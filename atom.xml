<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ins1mn1a</title>
  
  <subtitle>反方向的钟</subtitle>
  <link href="http://ins1mn1a.github.io/atom.xml" rel="self"/>
  
  <link href="http://ins1mn1a.github.io/"/>
  <updated>2022-02-18T14:39:57.368Z</updated>
  <id>http://ins1mn1a.github.io/</id>
  
  <author>
    <name>ins1mnia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://ins1mn1a.github.io/2022/02/18/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%AF%87%E8%AE%B2%E4%B9%89/"/>
    <id>http://ins1mn1a.github.io/2022/02/18/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E5%9F%BA%E7%A1%80%E7%AF%87%E8%AE%B2%E4%B9%89/</id>
    <published>2022-02-18T14:35:26.176Z</published>
    <updated>2022-02-18T14:39:57.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><blockquote><p><em><strong>基础篇要点：算法、数据结构、基础设计模式</strong></em></p></blockquote><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述二分查找算法</li><li>能够手写二分查找代码</li><li>能够解答一些变化后的考法</li></ul><p><strong>算法描述</strong></p><ol><li><p>前提：有已排序数组 A（假设已经做好）</p></li><li><p>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</p></li><li><p>获取中间索引 M = Floor((L+R) /2)</p></li><li><p>中间索引的值  A[M] 与待搜索的值 T 进行比较</p><p>① A[M] == T 表示找到，返回中间索引</p><p>② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p><p>③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p></li><li><p>当 L &gt; R 时，表示没有找到，应结束循环</p></li></ol><blockquote><p><em>更形象的描述请参考：binary_search.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = a.length - <span class="number">1</span>, m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &gt; t) &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = binarySearch(array, target);</span><br><span class="line">    System.out.println(idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决整数溢出问题</strong></p><p>当 l 和 r 都较大时，<code>l + r</code> 有可能超过整数范围，造成运算错误，解决方法有两种：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>还有一种是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>其它考法</strong></p><ol><li><p>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 </p></li><li><p>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</p></li><li><p>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</p></li></ol><p>对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：</p><p>$$n = log_2N = log_{10}N/log_{10}2$$</p><p>其中 n 为查找次数，N 为元素个数</p><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述冒泡排序算法</li><li>能够手写冒泡排序代码</li><li>了解一些冒泡排序的优化手段</li></ul><p><strong>算法描述</strong></p><ol><li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li><li>重复以上步骤，直到整个数组有序</li></ol><blockquote><p><em>更形象的描述请参考：bubble_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 一轮冒泡</span></span><br><span class="line">        <span class="keyword">boolean</span> swapped = <span class="keyword">false</span>; <span class="comment">// 是否发生了交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点1：每经过一轮冒泡，内层循环就可以减少一次</li><li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环</li></ul><p><strong>进一步优化</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble_v2</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>; <span class="comment">// 表示最后一次交换索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = last;</span><br><span class="line">        System.out.println(<span class="string">&quot;第轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可</li></ul><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述选择排序算法</li><li>能够比较选择排序与冒泡排序</li><li>理解非稳定排序与稳定排序</li></ul><p><strong>算法描述</strong></p><ol><li><p>将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><blockquote><p><em>更形象的描述请参考：selection_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// i 代表每轮选择最小元素要交换到的目标索引</span></span><br><span class="line">        <span class="keyword">int</span> s = i; <span class="comment">// 代表最小元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s] &gt; a[j]) &#123; <span class="comment">// j 元素比 s 元素还要小, 更新 s</span></span><br><span class="line">                s = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            swap(a, s, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点：为减少交换次数，每一轮可以先找最小的索引，在每轮最后再交换元素</li></ul><p><strong>与冒泡排序比较</strong></p><ol><li><p>二者平均时间复杂度都是 $O(n^2)$</p></li><li><p>选择排序一般要快于冒泡，因为其交换次数少</p></li><li><p>但如果集合有序度高，冒泡优于选择</p></li><li><p>冒泡属于稳定排序算法，而选择属于不稳定排序</p><ul><li>稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序</li><li>不稳定排序则反之</li></ul></li></ol><p><strong>稳定排序与不稳定排序</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=================不稳定================&quot;</span>);</span><br><span class="line">Card[] cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================稳定=================&quot;</span>);</span><br><span class="line">cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br></pre></td></tr></table></figure><p>都是先按照花色排序（♠♥♣♦），再按照数字排序（AKQJ…）</p><ul><li><p>不稳定排序算法按数字排序时，会打乱原本同值的花色顺序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♥2], [♠2]]</span><br></pre></td></tr></table></figure><p>原来 ♠2 在前 ♥2 在后，按数字再排后，他俩的位置变了</p></li><li><p>稳定排序算法按数字排序时，会保留原本同值的花色顺序，如下所示 ♠2 与 ♥2 的相对位置不变</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♠2], [♥2]]</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述插入排序算法</li><li>能够比较插入排序与选择排序</li></ul><p><strong>算法描述</strong></p><ol><li><p>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><blockquote><p><em>更形象的描述请参考：insertion_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改了代码与希尔排序一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[j - <span class="number">1</span>]) &#123; <span class="comment">// j-1 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = t;</span><br><span class="line">        System.out.println(Arrays.toString(a) + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与选择排序比较</strong></p><ol><li><p>二者平均时间复杂度都是 $O(n^2)$</p></li><li><p>大部分情况下，插入都略优于选择</p></li><li><p>有序集合插入的时间复杂度为 $O(n)$</p></li><li><p>插入属于稳定排序算法，而选择属于不稳定排序</p></li></ol><p><strong>提示</strong></p><blockquote><p><em>插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序</em></p></blockquote><h2 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述希尔排序算法</li></ul><p><strong>算法描述</strong></p><ol><li><p>首先选取一个间隙序列，如 (n/2，n/4 … 1)，n 为数组长度</p></li><li><p>每一轮将间隙相等的元素视为一组，对组内元素进行插入排序，目的有二</p><p>① 少量元素插入排序速度很快</p><p>② 让组内值较大的元素更快地移动到后方</p></li><li><p>当间隙逐渐减少，直至为 1 时，即可完成排序</p></li></ol><blockquote><p><em>更形象的描述请参考：shell_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap) &#123;</span><br><span class="line">                <span class="comment">// 每次与上一个间隙为 gap 的元素进行插入排序</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; a[j - gap]) &#123; <span class="comment">// j-gap 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                    a[j] = a[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = t;</span><br><span class="line">            System.out.println(Arrays.toString(a) + <span class="string">&quot; gap:&quot;</span> + gap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></li></ul><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述快速排序算法</li><li>掌握手写单边循环、双边循环代码之一</li><li>能够说明快排特点</li><li>了解洛穆托与霍尔两种分区方案的性能比较</li></ul><p><strong>算法描述</strong></p><ol><li>每一轮排序选择一个基准点（pivot）进行分区<ol><li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li><li>当分区完成时，基准点元素的位置就是其最终位置</li></ol></li><li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li><li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li></ol><blockquote><p><em>更形象的描述请参考：quick_sort.html</em></p></blockquote><p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p><ol><li><p>选择最右元素作为基准点元素</p></li><li><p>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换</p></li><li><p>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</p></li><li><p>最后基准点与 i 交换，i 即为分区位置</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = partition(a, l, h); <span class="comment">// p 索引值</span></span><br><span class="line">    quick(a, l, p - <span class="number">1</span>); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">    quick(a, p + <span class="number">1</span>, h); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pv = a[h]; <span class="comment">// 基准点元素</span></span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; h; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; pv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != h) &#123;</span><br><span class="line">        swap(a, h, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; i=&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 返回值代表了基准点元素所在的正确索引，用它确定下一轮分区的边界</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p><ol><li>选择最左元素作为基准点元素</li><li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li><li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li></ol><p>要点</p><ol><li><p>基准点在左边，并且要先 j 后 i</p></li><li><p>while( <strong>i</strong> **&lt; j** &amp;&amp; a[j] &gt; pv ) j– </p></li><li><p>while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] <strong>&lt;=</strong> pv ) i++</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = partition(a, l, h);</span><br><span class="line">    quick(a, l, p - <span class="number">1</span>);</span><br><span class="line">    quick(a, p + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pv = a[l];</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">int</span> j = h;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// j 从右找小的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pv) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 从左找大的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pv) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, l, j);</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; j=&quot;</span> + j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快排特点</strong></p><ol><li><p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$</p></li><li><p>数据量较大时，优势非常明显</p></li><li><p>属于不稳定排序</p></li></ol><p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p><ul><li>霍尔的移动次数平均来讲比洛穆托少3倍</li><li><a href="https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto">https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto</a></li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.sort.QuickSort3 演示了空穴法改进的双边快排，比较次数更少</li><li>day01.sort.QuickSortHoare 演示了霍尔分区的实现</li><li>day01.sort.LomutoVsHoare 对四种分区实现的移动次数比较</li></ul></blockquote><h2 id="7-ArrayList"><a href="#7-ArrayList" class="headerlink" title="7. ArrayList"></a>7. ArrayList</h2><p><strong>要求</strong></p><ul><li>掌握 ArrayList 扩容规则</li></ul><p><strong>扩容规则</strong></p><ol><li><p>ArrayList() 会使用长度为零的数组</p></li><li><p>ArrayList(int initialCapacity) 会使用指定容量的数组</p></li><li><p>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</p></li><li><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p></li><li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p></li></ol><p>其中第 4 点必须知道，其它几点视个人情况而定</p><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.TestArrayList</code> ，这里不再列出</li><li>要<strong>注意</strong>的是，示例中用反射方式来更直观地反映 ArrayList 的扩容特征，但从 JDK 9 由于模块化的影响，对反射做了较多限制，需要在运行测试代码时添加 VM 参数 <code>--add-opens java.base/java.util=ALL-UNNAMED</code> 方能运行通过，后面的例子都有相同问题</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.TestArrayList#arrayListGrowRule 演示了 add(Object) 方法的扩容规则，输入参数 n 代表打印多少次扩容后的数组长度</li></ul></blockquote><h2 id="8-Iterator"><a href="#8-Iterator" class="headerlink" title="8. Iterator"></a>8. Iterator</h2><p><strong>要求</strong></p><ul><li>掌握什么是 Fail-Fast、什么是 Fail-Safe</li></ul><p>Fail-Fast 与 Fail-Safe</p><ul><li><p>ArrayList 是 fail-fast 的典型代表，遍历的同时不能修改，尽快失败</p></li><li><p>CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离</p></li></ul><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.FailFastVsFailSafe</code>，这里不再列出</li></ul><h2 id="9-LinkedList"><a href="#9-LinkedList" class="headerlink" title="9. LinkedList"></a>9. LinkedList</h2><p><strong>要求</strong></p><ul><li>能够说清楚 LinkedList 对比 ArrayList 的区别，并重视纠正部分错误的认知</li></ul><p><strong>LinkedList</strong></p><ol><li>基于双向链表，无需连续内存</li><li>随机访问慢（要沿着链表遍历）</li><li>头尾插入删除性能高</li><li>占用内存多</li></ol><p><strong>ArrayList</strong></p><ol><li>基于数组，需要连续内存</li><li>随机访问快（指根据下标访问）</li><li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li><li>可以利用 cpu 缓存，局部性原理</li></ol><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.ArrayListVsLinkedList#randomAccess 对比随机访问性能</li><li>day01.list.ArrayListVsLinkedList#addMiddle 对比向中间插入性能</li><li>day01.list.ArrayListVsLinkedList#addFirst 对比头部插入性能</li><li>day01.list.ArrayListVsLinkedList#addLast 对比尾部插入性能</li><li>day01.list.ArrayListVsLinkedList#linkedListSize 打印一个 LinkedList 占用内存</li><li>day01.list.ArrayListVsLinkedList#arrayListSize 打印一个 ArrayList 占用内存</li></ul></blockquote><h2 id="10-HashMap"><a href="#10-HashMap" class="headerlink" title="10. HashMap"></a>10. HashMap</h2><p><strong>要求</strong></p><ul><li>掌握 HashMap 的基本数据结构</li><li>掌握树化</li><li>理解索引计算方法、二次 hash 的意义、容量对索引计算的影响</li><li>掌握 put 流程、扩容、扩容因子</li><li>理解并发使用 HashMap 可能导致的问题</li><li>理解 key 的设计</li></ul><h3 id="1）基本数据结构"><a href="#1）基本数据结构" class="headerlink" title="1）基本数据结构"></a>1）基本数据结构</h3><ul><li>1.7 数组 + 链表</li><li>1.8 数组 + （链表 | 红黑树）</li></ul><blockquote><p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar --add-exports java.base&#x2F;jdk.internal.misc&#x3D;ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure></blockquote><h3 id="2）树化与退化"><a href="#2）树化与退化" class="headerlink" title="2）树化与退化"></a>2）树化与退化</h3><p><strong>树化意义</strong></p><ul><li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li><li>hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li><li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li></ul><p><strong>树化规则</strong></p><ul><li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;=64，才会进行树化</li></ul><p><strong>退化规则</strong></p><ul><li>情况1：在扩容时如果拆分树时，树元素个数 &lt;= 6 则会退化链表</li><li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul><h3 id="3）索引计算"><a href="#3）索引计算" class="headerlink" title="3）索引计算"></a>3）索引计算</h3><p><strong>索引计算方法</strong></p><ul><li>首先，计算对象的 hashCode()</li><li>再进行调用 HashMap 的 hash() 方法进行二次哈希<ul><li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li></ul></li><li>最后 &amp; (capacity – 1) 得到索引</li></ul><p><strong>数组容量为何是 2 的 n 次幂</strong></p><ol><li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li><li>扩容时重新计算索引效率更高： hash &amp; oldCap == 0 的元素留在原来位置 ，否则新位置 = 旧位置 + oldCap</li></ol><p><strong>注意</strong></p><ul><li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li><li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li></ul><h3 id="4）put-与扩容"><a href="#4）put-与扩容" class="headerlink" title="4）put 与扩容"></a>4）put 与扩容</h3><p><strong>put 流程</strong></p><ol><li>HashMap 是懒惰创建数组的，首次使用才创建数组</li><li>计算索引（桶下标）</li><li>如果桶下标还没人占用，创建 Node 占位返回</li><li>如果桶下标已经有人占用<ol><li>已经是 TreeNode 走红黑树的添加或更新逻辑</li><li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li></ol></li><li>返回前检查容量是否超过阈值，一旦超过进行扩容</li></ol><p><strong>1.7 与 1.8 的区别</strong></p><ol><li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p></li><li><p>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</p></li><li><p>1.8 在扩容计算 Node 索引时，会优化</p></li></ol><p><strong>扩容（加载）因子为何默认是 0.75f</strong></p><ol><li>在空间占用与查询时间之间取得较好的权衡</li><li>大于这个值，空间节省了，但链表就会比较长影响性能</li><li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li></ol><h3 id="5）并发问题"><a href="#5）并发问题" class="headerlink" title="5）并发问题"></a>5）并发问题</h3><p><strong>扩容死链（1.7 会存在）</strong></p><p>1.7 源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li><li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li></ul><p><img src="/../../img/markdown_img/base_img/image-20210831084325075.png" alt="image-20210831084325075"></p><ul><li>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</li></ul><p><img src="/../../img/markdown_img/base_img/image-20210831084723383.png" alt="image-20210831084723383"></p><ul><li>第一次循环<ul><li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li><li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li><li>当循环结束是 e 会指向 next 也就是 b 节点</li></ul></li></ul><p><img src="/../../img/markdown_img/base_img/image-20210831084855348.png" alt="image-20210831084855348"></p><ul><li>第二次循环<ul><li>next 指向了节点 a</li><li>e 头插节点 b</li><li>当循环结束时，e 指向 next 也就是节点 a</li></ul></li></ul><p><img src="/../../img/markdown_img/base_img/image-20210831085329449.png" alt="image-20210831085329449"></p><ul><li>第三次循环<ul><li>next 指向了 null</li><li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li><li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li></ul></li></ul><p><img src="/../../img/markdown_img/base_img/image-20210831085543224.png" alt="image-20210831085543224"></p><p><strong>数据错乱（1.7，1.8 都会存在）</strong></p><ul><li>代码参考 <code>day01.map.HashMapMissData</code>，具体调试步骤参考视频</li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.map.HashMapDistribution 演示 map 中链表长度符合泊松分布</li><li>day01.map.DistributionAffectedByCapacity 演示容量及 hashCode 取值对分布的影响<ul><li>day01.map.DistributionAffectedByCapacity#hashtableGrowRule 演示了 Hashtable 的扩容规律</li><li>day01.sort.Utils#randomArray 如果 hashCode 足够随机，容量是否是 2 的 n 次幂影响不大</li><li>day01.sort.Utils#lowSameArray 如果 hashCode 低位一样的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>day01.sort.Utils#evenArray 如果 hashCode 偶数的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>由此得出对于容量是 2 的 n 次幂的设计来讲，二次 hash 非常重要</li></ul></li><li>day01.map.HashMapVsHashtable 演示了对于同样数量的单词字符串放入 HashMap 和 Hashtable 分布上的区别</li></ul></blockquote><h3 id="6）key-的设计"><a href="#6）key-的设计" class="headerlink" title="6）key 的设计"></a>6）key 的设计</h3><p><strong>key 的设计要求</strong></p><ol><li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li><li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li><li>key 的 hashCode 应该有良好的散列性</li></ol><p>如果 key 可变，例如修改了 age 会导致再次查询时查询不到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapMutableKey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Student, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        map.put(stu, <span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line"></span><br><span class="line">        stu.age = <span class="number">19</span>;</span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Student student = (Student) o;</span><br><span class="line">            <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String 对象的 hashCode() 设计</strong></p><ul><li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li><li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 </li><li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li><li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 <ul><li>即 $32 ∗h -h $</li><li>即 $2^5  ∗h -h$</li><li>即 $h≪5  -h$</li></ul></li></ul><h2 id="11-单例模式"><a href="#11-单例模式" class="headerlink" title="11. 单例模式"></a>11. 单例模式</h2><p><strong>要求</strong></p><ul><li>掌握五种单例模式的实现方式</li><li>理解为何 DCL 实现时要使用 volatile 修饰静态变量</li><li>了解 jdk 中用到单例的场景</li></ul><p><strong>饿汉式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;单例对象不能重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 INSTANCE = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法抛出异常是防止反射破坏单例</li><li><code>readResolve()</code> 是防止反序列化破坏单例</li></ul><p><strong>枚举饿汉式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举饿汉式能天然防止反射、反序列化破坏单例</li></ul><p><strong>懒汉式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Singleton3.class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实只有首次创建单例对象时才需要同步，但该代码实际上每次调用都会同步</li><li>因此有了下面的双检锁改进</li></ul><p><strong>双检锁懒汉式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 INSTANCE = <span class="keyword">null</span>; <span class="comment">// 可见性，有序性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为何必须加 volatile：</p><ul><li><code>INSTANCE = new Singleton4()</code> 不是原子的，分成 3 步：创建对象、调用构造、给静态变量赋值，其中后两步可能被指令重排序优化，变成先赋值、再调用构造</li><li>如果线程1 先执行了赋值，线程2 执行到第一个 <code>INSTANCE == null</code> 时发现 INSTANCE 已经不为 null，此时就会返回一个未完全构造的对象</li></ul><p><strong>内部类懒汉式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton5()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton5 INSTANCE = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>避免了双检锁的缺点</li></ul><p><strong>JDK 中单例的体现</strong></p><ul><li>Runtime 体现了饿汉式单例</li><li>Console 体现了双检锁懒汉式单例</li><li>Collections 中的 EmptyNavigableSet 内部类懒汉式单例</li><li>ReverseComparator.REVERSE_ORDER 内部类懒汉式单例</li><li>Comparators.NaturalOrderComparator.INSTANCE 枚举饿汉式单例</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;基础篇要点：算法、数据结构、基础设计模式&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ins1mn1a.github.io/2022/02/18/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E5%B9%B6%E5%8F%91%E7%AF%87%E8%AE%B2%E4%B9%89/"/>
    <id>http://ins1mn1a.github.io/2022/02/18/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E5%B9%B6%E5%8F%91%E7%AF%87%E8%AE%B2%E4%B9%89/</id>
    <published>2022-02-18T14:31:41.212Z</published>
    <updated>2022-02-18T14:33:32.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h1><h2 id="1-线程状态"><a href="#1-线程状态" class="headerlink" title="1. 线程状态"></a>1. 线程状态</h2><p><strong>要求</strong></p><ul><li>掌握 Java 线程六种状态</li><li>掌握 Java 线程状态转换</li><li>能理解五种状态与六种状态两种说法的区别</li></ul><p><strong>六种状态及转换</strong></p><p><img src="/../../img/markdown_img/juc_img/image-20210831090722658.png" alt="image-20210831090722658"></p><p>分别是</p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><blockquote><p><em><strong>其它情况（只需了解）</strong></em></p><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul></blockquote><p><strong>五种状态</strong></p><p>五种状态的说法来自于操作系统层面的划分</p><p><img src="/../../img/markdown_img/juc_img/image-20210831092652602.png" alt="image-20210831092652602"></p><ul><li>运行态：分到 cpu 时间，能真正执行线程内代码的</li><li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li><li>阻塞态：没资格分到 cpu 时间的<ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等</li></ul></li><li>新建与终结态：与 java 中同名状态类似，不再啰嗦</li></ul><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><p><strong>要求</strong></p><ul><li>掌握线程池的 7 大核心参数</li></ul><p><strong>七大参数</strong></p><ol><li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li><li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol></li></ol><p><img src="/../../img/markdown_img/juc_img/image-20210831093204388.png" alt="image-20210831093204388"></p><blockquote><p><em><strong>代码说明</strong></em></p><p>day02.TestThreadPoolExecutor 以较为形象的方式演示了线程池的核心组成</p></blockquote><h2 id="3-wait-vs-sleep"><a href="#3-wait-vs-sleep" class="headerlink" title="3. wait vs sleep"></a>3. wait vs sleep</h2><p><strong>要求</strong></p><ul><li>能够说出二者区别</li></ul><p><strong>一个共同点，三个不同点</strong></p><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><h2 id="4-lock-vs-synchronized"><a href="#4-lock-vs-synchronized" class="headerlink" title="4. lock vs synchronized"></a>4. lock vs synchronized</h2><p><strong>要求</strong></p><ul><li>掌握 lock 与 synchronized 的区别</li><li>理解 ReentrantLock 的公平、非公平锁</li><li>理解 ReentrantLock 中的条件变量</li></ul><p><strong>三个层面</strong></p><p>不同点</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><p><strong>公平锁</strong></p><ul><li>公平锁的公平体现<ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li></ul></li><li>公平锁会降低吞吐量，一般不用</li></ul><p><strong>条件变量</strong></p><ul><li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li><li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.TestReentrantLock 用较为形象的方式演示 ReentrantLock 的内部结构</li></ul></blockquote><h2 id="5-volatile"><a href="#5-volatile" class="headerlink" title="5. volatile"></a>5. volatile</h2><p><strong>要求</strong></p><ul><li>掌握线程安全要考虑的三个问题</li><li>掌握 volatile 能解决哪些问题</li></ul><p><strong>原子性</strong></p><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul><p><strong>可见性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul><p><strong>有序性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意：<ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.threadsafe.AddAndSubtract 演示原子性</li><li>day02.threadsafe.ForeverLoop 演示可见性<ul><li>注意：本例经实践检验是编译器优化导致的可见性问题</li></ul></li><li>day02.threadsafe.Reordering 演示有序性<ul><li>需要打成 jar 包后测试</li></ul></li><li>请同时参考视频讲解</li></ul></blockquote><h2 id="6-悲观锁-vs-乐观锁"><a href="#6-悲观锁-vs-乐观锁" class="headerlink" title="6. 悲观锁 vs 乐观锁"></a>6. 悲观锁 vs 乐观锁</h2><p><strong>要求</strong></p><ul><li>掌握悲观锁和乐观锁的区别</li></ul><p><strong>对比悲观锁与乐观锁</strong></p><ul><li><p>悲观锁的代表是 synchronized 和 Lock 锁</p><ul><li>其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】</li><li>线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li><li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li></ul></li><li><p>乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性</p><ul><li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】</li><li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li><li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数</li></ul></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.SyncVsCas 演示了分别使用乐观锁和悲观锁解决原子赋值</li><li>请同时参考视频讲解</li></ul></blockquote><h2 id="7-Hashtable-vs-ConcurrentHashMap"><a href="#7-Hashtable-vs-ConcurrentHashMap" class="headerlink" title="7. Hashtable vs ConcurrentHashMap"></a>7. Hashtable vs ConcurrentHashMap</h2><p><strong>要求</strong></p><ul><li>掌握 Hashtable 与 ConcurrentHashMap 的区别</li><li>掌握 ConcurrentHashMap 在不同版本的实现区别</li></ul><blockquote><p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar --add-exports java.base&#x2F;jdk.internal.misc&#x3D;ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure></blockquote><p><strong>Hashtable 对比 ConcurrentHashMap</strong></p><ul><li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li><li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li><li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li></ul><p><strong>ConcurrentHashMap 1.7</strong></p><ul><li>数据结构：<code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li><li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了</li><li>索引计算<ul><li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li><li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li></ul></li><li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍</li><li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li></ul><p><strong>ConcurrentHashMap 1.8</strong></p><ul><li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li><li>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容</li><li>扩容条件：Node 数组满 3/4 时就会扩容</li><li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode</li><li>扩容时并发 get<ul><li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li><li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</li><li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li></ul></li><li>扩容时并发 put<ul><li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li><li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li><li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li></ul></li><li>与 1.7 相比是懒惰初始化</li><li>capacity 代表预估的元素个数，capacity / factory 来计算出初始数组大小，需要贴近 $2^n$ </li><li>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3/4</li><li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li></ul><h2 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8. ThreadLocal"></a>8. ThreadLocal</h2><p><strong>要求</strong></p><ul><li>掌握 ThreadLocal 的作用与原理</li><li>掌握 ThreadLocal 的内存释放时机</li></ul><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li>初始容量 16，扩容因子 2/3，扩容容量翻倍</li><li>key 索引冲突后用开放寻址法解决冲突</li></ul><p><strong>弱引用 key</strong></p><p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p><ul><li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li></ul><p><strong>内存释放时机</strong></p><ul><li>被动 GC 释放 key<ul><li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li></ul></li><li>懒惰被动释放 value<ul><li>get key 时，发现是 null key，则释放其 value 内存</li><li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li></ul></li><li>主动 remove 释放 key，value<ul><li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li><li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发篇&quot;&gt;&lt;a href=&quot;#并发篇&quot; class=&quot;headerlink&quot; title=&quot;并发篇&quot;&gt;&lt;/a&gt;并发篇&lt;/h1&gt;&lt;h2 id=&quot;1-线程状态&quot;&gt;&lt;a href=&quot;#1-线程状态&quot; class=&quot;headerlink&quot; title=&quot;1. 线程状态&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ins1mn1a.github.io/2022/02/18/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87%E8%AE%B2%E4%B9%89/"/>
    <id>http://ins1mn1a.github.io/2022/02/18/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87%E8%AE%B2%E4%B9%89/</id>
    <published>2022-02-18T14:29:22.613Z</published>
    <updated>2022-02-18T14:31:26.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机篇"><a href="#虚拟机篇" class="headerlink" title="虚拟机篇"></a>虚拟机篇</h1><h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a>1. JVM 内存结构</h2><p><strong>要求</strong></p><ul><li>掌握 JVM 内存结构划分</li><li>尤其要知道方法区、永久代、元空间的关系</li></ul><p><strong>结合一段 java 代码的执行理解内存划分</strong></p><p><img src="/../../img/markdown_img/jvm_img/image-20210831165728217.png" alt="image-20210831165728217"></p><ul><li>执行 javac 命令编译源代码为字节码</li><li>执行 java 命令<ol><li>创建 JVM，调用类加载子系统加载 class，将类的信息存入<strong>方法区</strong></li><li>创建 main 线程，使用的内存区域是 <strong>JVM 虚拟机栈</strong>，开始执行 main 方法代码</li><li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li><li>需要创建对象，会使用<strong>堆</strong>内存来存储对象</li><li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li><li>调用方法时，方法内的局部变量、方法参数所使用的是  <strong>JVM 虚拟机栈</strong>中的栈帧内存</li><li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将字节码指令解释为机器码执行</li><li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当发生了线程切换，恢复时就可以从中断的位置继续</li><li>对于非 java 实现的方法调用，使用内存称为<strong>本地方法栈</strong>（见说明）</li><li>对于热点方法调用，或者频繁的循环代码，由 <strong>JIT 即时编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li></ol></li></ul><p>说明</p><ul><li>加粗字体代表了 JVM 虚拟机组件</li><li>对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</li></ul><p><strong>会发生内存溢出的区域</strong></p><ul><li>不会出现内存溢出的区域 – 程序计数器</li><li>出现 OutOfMemoryError 的情况<ul><li>堆内存耗尽 – 对象越来越多，又一直在使用，不能被垃圾回收</li><li>方法区内存耗尽 – 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li><li>虚拟机栈累积 – 每个线程最多会占用 1 M 内存，线程个数越来越多，而又长时间运行不销毁时</li></ul></li><li>出现 StackOverflowError 的区域<ul><li>JVM 虚拟机栈，原因有方法递归调用未正确结束、反序列化 json 时循环引用</li></ul></li></ul><p><strong>方法区、永久代、元空间</strong></p><ul><li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li><li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li><li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li></ul><p><img src="/../../img/markdown_img/jvm_img/image-20210831170457337.png" alt="image-20210831170457337"></p><p>从这张图学到三点</p><ul><li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li><li>X，Y 的类元信息是存储于元空间中，无法直接访问</li><li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li></ul><p><img src="/../../img/markdown_img/jvm_img/image-20210831170512418.png" alt="image-20210831170512418"></p><p>从这张图可以学到</p><ul><li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li><li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li></ul><h2 id="2-JVM-内存参数"><a href="#2-JVM-内存参数" class="headerlink" title="2. JVM 内存参数"></a>2. JVM 内存参数</h2><p><strong>要求</strong> </p><ul><li>熟悉常见的 JVM 参数，尤其和大小相关的</li></ul><p><strong>堆内存，按大小设置</strong></p><p><img src="/../../img/markdown_img/jvm_img/image-20210831173130717.png" alt="image-20210831173130717"></p><p>解释：</p><ul><li>-Xms 最小堆内存（包括新生代和老年代）</li><li>-Xmx 最大对内存（包括新生代和老年代）</li><li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li><li>-XX:NewSize 与 -XX:MaxNewSize 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li><li>-Xmn 设置新生代大小，相当于同时设置了 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等</li><li>保留是指，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。下同</li></ul><p><strong>堆内存，按比例设置</strong></p><p><img src="/../../img/markdown_img/jvm_img/image-20210831173045700.png" alt="image-20210831173045700"></p><p>解释：</p><ul><li>-XX:NewRatio=2:1 表示老年代占两份，新生代占一份</li><li>-XX:SurvivorRatio=4:1 表示新生代分成六份，伊甸园占四份，from 和 to 各占一份</li></ul><p><strong>元空间内存设置</strong></p><p><img src="/../../img/markdown_img/jvm_img/image-20210831173118634.png" alt="image-20210831173118634"></p><p>解释：</p><ul><li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li><li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li><li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li></ul><p>注意：</p><ul><li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li></ul><p><strong>代码缓存内存设置</strong></p><p><img src="/../../img/markdown_img/jvm_img/image-20210831173148816.png" alt="image-20210831173148816"></p><p>解释：</p><ul><li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li><li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）<ul><li>non-nmethods - JVM 自己用的代码</li><li>profiled nmethods - 部分优化的机器码</li><li>non-profiled nmethods - 完全优化的机器码</li></ul></li></ul><p><strong>线程内存设置</strong></p><p><img src="/../../img/markdown_img/jvm_img/image-20210831173155481.png" alt="image-20210831173155481"></p><blockquote><p><em><strong>官方参考文档</strong></em></p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></li></ul></blockquote><h2 id="3-JVM-垃圾回收"><a href="#3-JVM-垃圾回收" class="headerlink" title="3. JVM 垃圾回收"></a>3. JVM 垃圾回收</h2><p><strong>要求</strong></p><ul><li>掌握垃圾回收算法</li><li>掌握分代回收思想</li><li>理解三色标记及漏标处理</li><li>了解常见垃圾回收器</li></ul><p><strong>三种垃圾回收算法</strong></p><p>标记清除法</p><p><img src="/../../img/markdown_img/jvm_img/image-20210831211008162.png" alt="image-20210831211008162"></p><p>解释：</p><ol><li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li><li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li><li>清除阶段：释放未加标记的对象占用的内存</li></ol><p>要点：</p><ul><li>标记速度与存活对象线性关系</li><li>清除速度与内存大小线性关系</li><li>缺点是会产生内存碎片</li></ul><p>标记整理法</p><p><img src="/../../img/markdown_img/jvm_img/image-20210831211641241.png" alt="image-20210831211641241"></p><p>解释：</p><ol><li>前面的标记阶段、清理阶段与标记清除法类似</li><li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li></ol><p>特点：</p><ul><li><p>标记速度与存活对象线性关系</p></li><li><p>清除与整理速度与内存大小成线性关系</p></li><li><p>缺点是性能上较慢</p></li></ul><p>标记复制法</p><p><img src="/../../img/markdown_img/jvm_img/image-20210831212125813.png" alt="image-20210831212125813"></p><p>解释：</p><ol><li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li><li>标记阶段与前面的算法类似</li><li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li><li>复制完成后，交换 from 和 to 的位置即可</li></ol><p>特点：</p><ul><li>标记与复制速度与存活对象成线性关系</li><li>缺点是会占用成倍的空间</li></ul><p><strong>GC 与分代回收算法</strong></p><p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p><p>GC 要点：</p><ul><li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈。因为虚拟机栈中的内存是线程私有的，方法结束里面的变量就没用了，直接就可以回收了，随线程的生命周期是一样的</li><li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li><li>GC 具体的实现称为<strong>垃圾回收器</strong></li><li>GC 大都采用了<strong>分代回收思想</strong><ul><li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li><li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li></ul></li><li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></li></ul><p><strong>分代回收</strong></p><ol><li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210831213622704.png" alt="image-20210831213622704"></p><ol start="2"><li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210831213640110.png" alt="image-20210831213640110"></p><ol start="3"><li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210831213657861.png" alt="image-20210831213657861"></p><ol start="4"><li>将 from 和 to 交换位置</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210831213708776.png" alt="image-20210831213708776"></p><ol start="5"><li>经过一段时间后伊甸园的内存又出现不足</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210831213724858.png" alt="image-20210831213724858"></p><ol start="6"><li>标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210831213737669.png" alt="image-20210831213737669"></p><ol start="7"><li>将存活对象采用复制算法复制到 to 中</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210831213804315.png" alt="image-20210831213804315"></p><ol start="8"><li>复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210831213815371.png" alt="image-20210831213815371"></p><ol start="9"><li>将 from 和 to 交换位置</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210831213826017.png" alt="image-20210831213826017"></p><ol start="10"><li>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ol><p><strong>GC 规模</strong></p><ul><li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p></li><li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p></li><li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p></li></ul><p><strong>三色标记</strong></p><p>即用三种颜色记录对象的标记状态</p><ul><li>黑色 – 已标记</li><li>灰色 – 标记中</li><li>白色 – 还未标记</li></ul><ol><li>起始的三个对象还未处理完成，用灰色表示</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;" /><ol start="2"><li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;" /><ol start="3"><li>依次类推</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;" /><ol start="4"><li>沿着引用链都标记了一遍</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;" /><ol start="5"><li>最后为标记的白色对象，即为垃圾</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;" /><p><strong>并发漏标问题</strong></p><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p><ol><li>如图所示标记工作尚未完成</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;" /><ol start="2"><li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;" /><ol start="3"><li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;" /><ol start="4"><li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;" /><p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p><ol><li>Incremental Update 增量更新法，CMS 垃圾回收器采用<ul><li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li></ul></li><li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用<ul><li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li><li>新加对象会被记录</li><li>被删除引用关系的对象也被记录</li></ul></li></ol><p><strong>垃圾回收器 - Parallel GC</strong></p><ul><li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p></li><li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p></li><li><p><strong>注重吞吐量</strong></p></li></ul><p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p><ul><li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p><ul><li>并发标记时不需暂停用户线程</li><li>重新标记时仍需暂停用户线程</li></ul></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p></li><li><p><strong>注重响应时间</strong></p></li></ul><p><strong>垃圾回收器 - G1 GC</strong></p><ul><li><strong>响应时间与吞吐量兼顾</strong></li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>分成三个阶段：新生代回收、并发标记、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><strong>G1 回收阶段 - 新生代回收</strong></p><ol><li>初始时，所有区域都处于空闲状态</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222639754.png" alt="image-20210831222639754" style="zoom:50%;" /><ol start="2"><li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222653802.png" alt="image-20210831222653802" style="zoom:50%;" /><ol start="3"><li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222705814.png" alt="image-20210831222705814" style="zoom:50%;" /><ol start="4"><li>复制完成，将之前的伊甸园内存释放</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222724999.png" alt="image-20210831222724999" style="zoom:50%;" /><ol start="5"><li>随着时间流逝，伊甸园的内存又有不足</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222737928.png" alt="image-20210831222737928" style="zoom:50%;" /><ol start="6"><li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222752787.png" alt="image-20210831222752787" style="zoom:50%;" /><ol start="7"><li>释放伊甸园以及之前幸存区的内存</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222803281.png" alt="image-20210831222803281" style="zoom:50%;" /><p><strong>G1 回收阶段 - 并发标记与混合收集</strong></p><ol><li>当老年代占用内存超过阈值后，触发并发标记，这时无需暂停用户线程</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222813959.png" alt="image-20210831222813959" style="zoom:50%;" /><ol start="2"><li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222828104.png" alt="image-20210831222828104" style="zoom:50%;" /><ol start="3"><li>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222841096.png" alt="image-20210831222841096" style="zoom:50%;" /><ol start="4"><li>下图显示了老年代和幸存区晋升的存活对象的复制</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222859760.png" alt="image-20210831222859760" style="zoom:50%;" /><ol start="5"><li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li></ol><img src="../../img/markdown_img/jvm_img/image-20210831222919182.png" alt="image-20210831222919182" style="zoom:50%;" /><h2 id="4-内存溢出"><a href="#4-内存溢出" class="headerlink" title="4. 内存溢出"></a>4. 内存溢出</h2><p><strong>要求</strong></p><ul><li>能够说出几种典型的导致内存溢出的情况</li></ul><p><strong>典型情况</strong></p><ul><li>误用线程池导致的内存溢出<ul><li>参考 day03.TestOomThreadPool</li></ul></li><li>查询数据量太大导致的内存溢出<ul><li>参考 day03.TestOomTooManyObject</li></ul></li><li>动态生成类导致的内存溢出<ul><li>参考 day03.TestOomTooManyClass</li></ul></li></ul><h2 id="5-类加载"><a href="#5-类加载" class="headerlink" title="5. 类加载"></a>5. 类加载</h2><p><strong>要求</strong></p><ul><li>掌握类加载阶段</li><li>掌握类加载器</li><li>理解双亲委派机制</li></ul><p><strong>类加载过程的三个阶段</strong></p><ol><li><p>加载</p><ol><li><p>将类的字节码载入方法区，并创建类.class 对象</p></li><li><p>如果此类的父类没有加载，先加载父类</p></li><li><p>加载是懒惰执行</p></li></ol></li><li><p>链接</p><ol><li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li><li>准备 – 为 static 变量分配空间，设置默认值</li><li>解析 – 将常量池的符号引用解析为直接引用</li></ol></li><li><p>初始化</p><ol><li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li><li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li><li>初始化是懒惰执行</li></ol></li></ol><blockquote><p><em><strong>验证手段</strong></em></p><ul><li>使用 jps 查看进程号</li><li>使用 jhsdb 调试，执行命令 <code>jhsdb.exe hsdb</code> 打开它的图形界面<ul><li>Class Browser 可以查看当前 jvm 中加载了哪些类</li><li>控制台的 universe 命令查看堆内存范围</li><li>控制台的 g1regiondetails 命令查看 region 详情</li><li><code>scanoops 起始地址 结束地址 对象类型</code> 可以根据类型查找某个区间内的对象地址</li><li>控制台的 <code>inspect 地址</code> 指令能够查看这个地址对应的对象详情</li></ul></li><li>使用 javap 命令可以查看 class 字节码</li></ul></blockquote><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestLazy - 验证类的加载是懒惰的，用到时才触发类加载</li><li>day03.loader.TestFinal - 验证使用 final 修饰的变量不会触发类加载</li></ul></blockquote><p><strong>jdk 8 的类加载器</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>加载哪的类</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为 Bootstrap，显示为  null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为 Application</td></tr></tbody></table><p><strong>双亲委派机制</strong></p><p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p><ul><li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li><li>找不到这个类，则下级类加载器才有资格执行加载</li></ul><p>双亲委派的目的有两点</p><ol><li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p></li><li><p>让类的加载有优先次序，保证核心类优先加载</p></li></ol><p><strong>对双亲委派的误解</strong></p><p>下面面试题的回答是错误的</p><p><img src="/../../img/markdown_img/jvm_img/image-20210901110910016.png" alt="image-20210901110910016"></p><p>错在哪了？</p><ul><li><p>自己编写类加载器就能加载一个假冒的 java.lang.System 吗? 答案是不行。</p></li><li><p>假设你自己的类加载器用双亲委派，那么优先由启动类加载器加载真正的 java.lang.System，自然不会加载假冒的</p></li><li><p>假设你自己的类加载器不用双亲委派，那么你的类加载器加载假冒的 java.lang.System 时，它需要先加载父类 java.lang.Object，而你没有用委派，找不到 java.lang.Object 所以加载会失败</p></li><li><p><strong>以上也仅仅是假设</strong>。事实上操作你就会发现，自定义类加载器加载以 java. 打头的类时，会抛安全异常，在 jdk9 以上版本这些特殊包名都与模块进行了绑定，更连编译都过不了</p></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestJdk9ClassLoader - 演示类加载器与模块的绑定关系</li></ul></blockquote><h2 id="6-四种引用"><a href="#6-四种引用" class="headerlink" title="6. 四种引用"></a>6. 四种引用</h2><p><strong>要求</strong></p><ul><li>掌握四种引用</li></ul><p><strong>强引用</strong></p><ol><li><p>普通变量赋值即为强引用，如 A a = new A();</p></li><li><p>通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收</p></li></ol><img src="../../img/markdown_img/jvm_img/image-20210901111903574.png" alt="image-20210901111903574" style="zoom:80%;" /><p><strong>软引用（SoftReference）</strong></p><ol><li><p>例如：SoftReference a = new SoftReference(new A());</p></li><li><p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象</p></li><li><p>软引用自身需要配合引用队列来释放</p></li><li><p>典型例子是反射数据</p></li></ol><img src="../../img/markdown_img/jvm_img/image-20210901111957328.png" alt="image-20210901111957328" style="zoom:80%;" /><p><strong>弱引用（WeakReference）</strong></p><ol><li><p>例如：WeakReference a = new WeakReference(new A());</p></li><li><p>如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象</p></li><li><p>弱引用自身需要配合引用队列来释放</p></li><li><p>典型例子是 ThreadLocalMap 中的 Entry 对象</p></li></ol><img src="../../img/markdown_img/jvm_img/image-20210901112107707.png" alt="image-20210901112107707" style="zoom:80%;" /><p><strong>虚引用（PhantomReference）</strong></p><ol><li><p>例如： PhantomReference a = new PhantomReference(new A(), referenceQueue);</p></li><li><p>必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</p></li><li><p>典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存</p></li></ol><img src="../../img/markdown_img/jvm_img/image-20210901112157901.png" alt="image-20210901112157901" style="zoom:80%;" /><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestPhantomReference - 演示虚引用的基本用法</li><li>day03.reference.TestWeakReference - 模拟 ThreadLocalMap, 采用引用队列释放 entry 内存</li></ul></blockquote><h2 id="7-finalize"><a href="#7-finalize" class="headerlink" title="7. finalize"></a>7. finalize</h2><p><strong>要求</strong></p><ul><li>掌握 finalize 的工作原理与缺点</li></ul><p><strong>finalize</strong></p><ul><li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li><li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li></ul><p><strong>finalize 原理</strong></p><ol><li>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</li><li>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210901121032813.png" alt="image-20210901121032813"></p><ol start="3"><li>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</li><li>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</li><li>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</li></ol><p><img src="/../../img/markdown_img/jvm_img/image-20210901122228916.png" alt="image-20210901122228916"></p><ol start="6"><li>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</li></ol><p><strong>finalize 缺点</strong></p><ul><li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了</li><li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li><li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li><li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestFinalize - finalize 的测试代码</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚拟机篇&quot;&gt;&lt;a href=&quot;#虚拟机篇&quot; class=&quot;headerlink&quot; title=&quot;虚拟机篇&quot;&gt;&lt;/a&gt;虚拟机篇&lt;/h1&gt;&lt;h2 id=&quot;1-JVM-内存结构&quot;&gt;&lt;a href=&quot;#1-JVM-内存结构&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ins1mn1a.github.io/2022/02/18/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/"/>
    <id>http://ins1mn1a.github.io/2022/02/18/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/</id>
    <published>2022-02-18T14:25:02.517Z</published>
    <updated>2022-02-18T14:28:43.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM的4个部分"><a href="#JVM的4个部分" class="headerlink" title="JVM的4个部分"></a>JVM的4个部分</h3><p>JVM组件主要有4个部分：</p><ul><li>类加载子系统：加载class，将<strong>类的信息</strong>加载到<strong>方法区</strong></li><li>运行时数据区（内存）：分为堆、方法区、程序计数器、Java虚拟机栈、本地方法栈</li><li>执行引擎：解释器、JIT即时编译器、GC垃圾回收</li><li>本地方法接口：调用本地方法库</li></ul><h3 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h3><p>JVM内存划分</p><h3 id="Java代码执行过程"><a href="#Java代码执行过程" class="headerlink" title="Java代码执行过程"></a>Java代码执行过程</h3><p><strong>结合一段Java代码的执行理解内存划分</strong></p><p><img src="/../../img/markdown_img/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95.assets/image-20220217220809311.png" alt="image-20220217220809311"></p><ul><li>执行javac命令编译源代码为字节码</li><li>执行java命令<ol><li>创建JVM，调用类加载子系统<strong>加载class</strong>，将类的信息存入<strong>方法区</strong></li><li>创建main线程，使用的内存区域是<strong>JVM虚拟机栈</strong>，开始执行main方法代码</li><li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li><li>需要创建<strong>对象</strong>，会使用<strong>堆内存</strong>来存储对象</li><li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li><li>调用方法时，<strong>方法内的局部变量、方法参数</strong>所使用的是<strong>JVM虚拟机栈</strong>中的<strong>栈帧内存</strong></li><li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将<strong>字节码指令解释为机器码</strong>执行</li><li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当<strong>发生了线程切换</strong>，<strong>恢复</strong>时就可以从中断的位置继续</li><li>对于非Java实现的方法调用，使用内存称为<strong>本地方法栈</strong></li><li>对于<strong>热点方法调用</strong>，或者<strong>频繁的循环代码</strong>，由<strong>JIT即使编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li></ol></li></ul><p>说明</p><ul><li>对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</li></ul><p><strong>会发生内存溢出的区域</strong></p><ul><li>不会出现内存溢出的区域 - 程序计数器</li><li>出现OOM（OutOfMemoryError）的情况<ul><li><strong>堆内存耗尽</strong> — 对象越来越多，又一直在使用，不能被垃圾回收</li><li><strong>方法区内存耗尽</strong> — 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li><li><strong>虚拟机栈累积</strong> — 每个线程最多会占用1M内存，线程个数越来越多，而又长时间运行不销毁时</li></ul></li><li>出现 <strong>StackOverflowError</strong> 的区域<ul><li><strong>JVM虚拟机栈</strong>，原因有<strong>方法递归调用未正确结束</strong>，<strong>反序列化 json 时循环引用</strong></li></ul></li></ul><h3 id="一个对象的GC过程"><a href="#一个对象的GC过程" class="headerlink" title="一个对象的GC过程"></a>一个对象的GC过程</h3><p>就是分成3个代，老年代、永久代</p><h3 id="内存溢出OOM"><a href="#内存溢出OOM" class="headerlink" title="内存溢出OOM"></a>内存溢出OOM</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="讲一下HashMap"><a href="#讲一下HashMap" class="headerlink" title="讲一下HashMap"></a>讲一下HashMap</h3><p>底层实现，1.7是什么对吧数组+链表  1.8 到红黑树</p><p>讲一下扩容机制，put流程、转化为红黑树的条件，退化为链表的情况</p><p>再说1.7头插法带来的问题，1.8改为尾插法</p><p>并发死链问题、数据</p><h3 id="HashTable与HashMap区别"><a href="#HashTable与HashMap区别" class="headerlink" title="HashTable与HashMap区别"></a>HashTable与HashMap区别</h3><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="锁记录Lock-Record锁升级的一个过程"><a href="#锁记录Lock-Record锁升级的一个过程" class="headerlink" title="锁记录Lock Record锁升级的一个过程"></a><strong>锁记录Lock Record锁升级的一个过程</strong></h3><p>锁记录Lock Record锁升级的一个过程，不是说是跟synchronized可重入有关的。</p><p>可以讲又来一线程想要加锁，然后就cas什么什么，然后自然失败，失败了就会把</p><p><img src="/../../img/markdown_img/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95.assets/image-20220218155139756.png" alt="image-20220218155139756"></p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>底层就直接说从无锁到偏向锁到轻量级锁到重量级锁的过程</p><h3 id="synchronized作用在代码块和同步方法上的区别"><a href="#synchronized作用在代码块和同步方法上的区别" class="headerlink" title="synchronized作用在代码块和同步方法上的区别"></a>synchronized作用在代码块和同步方法上的区别</h3><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>说说CAS</p><p>CAS，可以说是<strong>乐观锁</strong>，但是实际上是<strong>不加锁</strong>的状态。<strong>CAS底层</strong>就是使用的一个<strong>lock指令</strong>。在<strong>CPU多核状态</strong>下，某个核<strong>执行到带lock的指令</strong>时，CPU会让<strong>总线锁住</strong>，当这个核把这个<strong>指令执行完毕</strong>，<strong>再开启总线</strong>。这个过程<strong>不会被线程的调度机制打断</strong>，保证了多线程对内存操作的准确性和原子性。在Java API层面一般就是一个<strong>compareAndSet</strong>方法，这个方法需要<strong>先获取当前线程知道的值</strong>，然后<strong>拿着这个值去和内存中的准确值比较</strong>，看是否相等，如果相等就可以把这个值进行一个原子的修改操作返回true，修改成功。否则就返回false，然后就需要一个while(true)的循环，一直重试，直到设置成功。这样就需要<strong>CAS和volatile一起使用，利用volatile的读写屏障来保证数据对于其他线程的可见性</strong></p><p><strong>CAS+volatile <strong>实现的是一个</strong>无锁并发</strong>，没有synchronized关键字，<strong>线程不会进入阻塞状态</strong>，<strong>没有线程上下文的切换的效率上的降低</strong>，但是 <strong>如果线程竞争激烈（写操作多）</strong>，线程很有可能会<strong>一直cas失败</strong>，一直<strong>重试</strong>，<strong>效率</strong>反而会<strong>降低</strong></p><h3 id="synchronized是不是可重入的"><a href="#synchronized是不是可重入的" class="headerlink" title="synchronized是不是可重入的"></a>synchronized是不是可重入的</h3><h3 id="ReentrantLock加锁流程"><a href="#ReentrantLock加锁流程" class="headerlink" title="ReentrantLock加锁流程"></a>ReentrantLock加锁流程</h3><h3 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h3><h3 id="为什么要用线程池来创建线程"><a href="#为什么要用线程池来创建线程" class="headerlink" title="为什么要用线程池来创建线程"></a>为什么要用线程池来创建线程</h3><h3 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h3><p>Executors创建4中线程池的缺点</p><p>一般要使用ThreadPoolExecutor创建线程池</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h2&gt;&lt;h3 id=&quot;JVM的4个部分&quot;&gt;&lt;a href=&quot;#JVM的4个部分&quot; class=&quot;headerlink&quot; title=&quot;JVM的4</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java 内存模型</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-02-09T15:01:55.449Z</published>
    <updated>2022-02-09T15:05:02.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p><strong>JMM</strong> 即 <strong>Java Memory Model</strong> ，它从Java层面定义了<strong>主存</strong>、<strong>工作内存</strong>抽象概念，底层对应着CPU 寄存器、缓存、硬件内存、CPU 指令优化等。JMM 体现在以下几个方面</p><ul><li><strong>原子性</strong> - 保证指令不会受 线程上下文切换的影响</li><li><strong>可见性</strong> - 保证指令不会受 cpu 缓存的影响 (JIT对热点代码的缓存优化)</li><li><strong>有序性</strong> - 保证指令不会受 cpu 指令并行优化的影响</li></ul><p><strong>Java内存模型</strong>描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。<br>在内存模型中，所有的变量都存储在主内存中。<strong>每个线程都有自己独立的工作内存</strong>，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)。</p><p><strong>JMM线程操作内存的两条基本的规定:</strong></p><ol><li>关于线程与主内存：线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写</li><li>关于线程间工作内存：不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要经过主内存来完成。</li></ol><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><code>在主线程中修改的静态变量的值，对应t线程来说是不可见的</code></p><p>这是因为t线程的run方法是个<code>while (run)</code>循环，JIT即使编译器会对t线程中的run变量进行缓存到本地工作内存，不去主存中取run的值，这样可以加快执行速度。也就是JVM达到一定阈值时，<code>while (run)</code>循环变成了<strong>热点代码</strong>， 所以一直访问的都是缓存到本地工作内存(局部)中的run。当主线程修改<strong>主存中的run变量</strong>的时候，t1线程一直访问的是自己缓存的, 所以不认为run已经改为false了。 所以一直运行并不会结束循环，我们为主存(成员变量)进行<strong>volatile</strong>修饰, 增加变量的可见性, 当主线程修改run为false, t1线程对run的值可见。这样就可以退出循环。</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120131625943.png" alt="image-20220120131625943"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (run)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;停止 t线程&quot;</span>);</span><br><span class="line">    run=<span class="keyword">false</span>;<span class="comment">// 没有volatile，事实上并不会退出t线程</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用<strong>volatile解决</strong>以外还可以使用<strong>synchronized解决</strong>问题</p><ul><li><strong>在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存，然后主内存中拷贝最新变量的副本到工作内存 ，执行完代码后，将更改后的共享变量的值刷新到主内存中，最后释放互斥锁。</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1s内,一直都在无限循环获取锁. 1s后主线程抢到锁,修改为false, 此时t1线程抢到锁对象,while循环也退出</span></span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!run)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当主线程获取到锁的时候, 就修改为false了</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            run = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul><li>前面例子体现的实际就是<code>可见性</code>，<strong>它保证的是在多个线程之间一个线程对 volatile 变量的修改对另一个线程可见</strong>， <strong>而不能保证原子性</strong>。volatile用在一个写线程，多个读线程的情况, 比较合适。 上例从字节码理解是这样的：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">putstatic run <span class="comment">// 线程 main 修改 run 为 false， 仅此一次</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run false </span></span><br></pre></td></tr></table></figure><ul><li>比较一下之前线程安全时的例子：两个线程一个 <strong>i++</strong> 一个 <strong>i–</strong> ，只能<strong>保证</strong>看到最新值(<strong>可见性</strong>)，<strong>不能</strong>解决<strong>指令交错(原子性)</strong></li></ul><p><strong>注意</strong> ：</p><ul><li><strong>synchronized</strong> 语句块既可以<strong>保证</strong>代码块的<strong>原子性</strong>，也同时<strong>保证</strong>代码块内变量的<strong>可见性</strong>。但缺点是 synchronized 是属于重量级操作，性能相对更低。</li><li> 如果在前面示例的死循环中加入 <strong>System.out.println()</strong> 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了</li><li>因为<strong>System.out.println() 方法里面有synchronized修饰</strong>。</li></ul><h2 id="volatile实现模式之两阶段终止"><a href="#volatile实现模式之两阶段终止" class="headerlink" title="volatile实现模式之两阶段终止"></a>volatile实现模式之两阶段终止</h2><ul><li>当我们在执行线程一时，想要终止线程二，这是就需要使用<code>interrupt方法</code>来优雅的停止线程二。这是之前的做法</li></ul><ul><li>使用volatile关键字来实现两阶段终止模式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是两个线程操作共享变量stop</span></span><br><span class="line">        Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        monitor.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;Monitor&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private boolean stop = false; // 不会停止程序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>; <span class="comment">// 会停止程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动监控器线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread monitor = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//开始不停的监控</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于停止监控器线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式之-Balking"><a href="#模式之-Balking" class="headerlink" title="模式之 Balking"></a>模式之 Balking</h2><ul><li>定义：<code>Balking （犹豫）模式</code>用在 <strong><code>一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</code>。有点类似于单例。</strong></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>JIT即时编译器的优化，可能会导致<strong>指令重排</strong>。为什么要优化? 因为CPU 支持多级指令流水线，例如支持同时执行 <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 的处理器，效率更快 </p><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120155001076.png" alt="image-20220120155001076"></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="指令重排序导致错误结果"><a href="#指令重排序导致错误结果" class="headerlink" title="指令重排序导致错误结果"></a>指令重排序导致错误结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span></span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line"> r.r1 = num + num;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> num = <span class="number">2</span>;</span><br><span class="line"> ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程1执行actor1方法, 线程2执行actor2方法</p><p>但是最终的结果还有可能让r.r1=0</p><ul><li><p>这样情况是在actor2方法进行了<strong>指令重排序</strong>，因为<code> num = 2;</code>和<code>ready = true;</code>互相之间看起来并没有影响，因此先执行<code>ready = true;</code>，这时候num=2还没执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重排序后</span></span><br><span class="line">ready = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//此时发生线程切换</span></span><br><span class="line">num = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>此时，发送线程上下文切换，<code>ready = true;</code>，线程1判断为true，就<code>r.r1=num+num</code>，最后r.r1=0;</p></li></ul><p>这种现象叫做指令重排，是JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现，可以使用jcstress工具进行测试。上面仅是从代码层面体现出了有序性问题，下面的 <strong>double-checked locking</strong> (双重检查锁)还会从java字节码的层面了解有序性的问题。</p><p><strong>指令重排序</strong>操作<strong>不会对</strong>存在<strong>数据依赖关系</strong>的操作进行<strong>重排序</strong>。比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p>重排序是为了优化性能，但是不管怎么重排序，<strong>单线程</strong>下程序的执行结果<strong>不会被改变</strong>。</p><p><strong>指令重排序 在 单线程模式下是一定会保证最终结果的正确性，</strong> 但是在多线程环境下，问题就出来了。</p><p><strong>解决方法</strong>：<code>volatile 修饰的变量，可以禁用指令重排</code></p><h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p><strong>volatile</strong> 的<strong>底层实现</strong>原理是<strong>内存屏障</strong>，<strong>Memory Barrier</strong>（Memory Fence）</p><p>对 volatile 变量的<strong>写指令</strong>后会加入<strong>写屏障</strong>。(保证写屏障之前的写操作, <strong>都能同步到主存中</strong>)</p><p>对 volatile 变量的<strong>读指令</strong>前会加入<strong>读屏障</strong>。(保证读屏障之后的读操作, <strong>都能读到主存的数据</strong>)</p><h3 id="volatile保证可见性原理"><a href="#volatile保证可见性原理" class="headerlink" title="volatile保证可见性原理"></a>volatile保证可见性原理</h3><ul><li><p><strong>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">     num = <span class="number">2</span>;</span><br><span class="line">     ready = <span class="keyword">true</span>; <span class="comment">// ready是被volatile修饰的 ，赋值带写屏障</span></span><br><span class="line">     <span class="comment">// 写屏障(在ready=true写指令之后加的, </span></span><br><span class="line">     <span class="comment">//在该屏障之前对共享变量的改动, 都同步到主存中，包括num)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 读屏障</span></span><br><span class="line"> <span class="comment">//  ready是被volatile修饰的 ，读取值带读屏障</span></span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;<span class="comment">// ready, 读取的就是主存中的新值</span></span><br><span class="line"> r.r1 = num + num; <span class="comment">// num, 读取的也是主存中的新值</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="volatile保证有序性原理"><a href="#volatile保证有序性原理" class="headerlink" title="volatile保证有序性原理"></a>volatile保证有序性原理</h3><ul><li><strong>写屏障</strong>会确保<strong>指令重排序</strong>时，<strong>不会将写屏障之前的代码排在写屏障之后</strong></li><li><strong>读屏障</strong>会确保<strong>指令重排序</strong>时，<strong>不会将读屏障之后的代码排在读屏障之前</strong></li></ul><h3 id="volatile不能解决指令交错-不能解决原子性-："><a href="#volatile不能解决指令交错-不能解决原子性-：" class="headerlink" title="volatile不能解决指令交错 (不能解决原子性)："></a>volatile不能解决<strong>指令交错</strong> (不能解决<strong>原子性</strong>)：</h3><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其它线程的读, 跑到它前面去</li><li><strong>有序性的保证也只是保证了本线程内相关代码不被重排序</strong>，并不能保证指令的交错</li><li>比如线程2先读到i，然后被切换成了线程1执行完后，线程2还是把i当做没更新的i值执行。可以使用<code>synchronized</code>来解决原子性</li></ul><h2 id="double-checked-locking-双重检查锁"><a href="#double-checked-locking-双重检查锁" class="headerlink" title="double-checked locking (双重检查锁)"></a>double-checked locking (双重检查锁)</h2><p>首先<strong>synchronized</strong>可以<strong>保证</strong>它的临界区的资源是<strong>原子性、可见性、有序性</strong>的, <strong>有序性的前提</strong>是, 在synchronized代码块中的共享变量, 不会在代码块外使用到, 否则<strong>有序性</strong>不能被保证, 只能使用<strong>volatile</strong>来保证有序性。<br>下面代码的第二个双重检查单例，就出现了这个问题(在synchronized外使用到了INSTANCE)，此时synchronized就不能防止指令重排，确保不了指令的有序性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最开始的单例模式是这样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      多线程同时调用getInstance(), 如果不加synchronized锁, 此时两个线程同时</span></span><br><span class="line"><span class="comment">      判断INSTANCE为空, 此时都会new Singleton(), 此时就破坏单例了.所以要加锁,</span></span><br><span class="line"><span class="comment">      防止多线程操作共享资源,造成的安全问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//INSTANCE没有加volatile</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是上面的<code>if(INSTANCE == null)</code>判断代码没有在同步代码块synchronized中，不能享有synchronized保证的原子性、可见性、以及有序性</strong>。所以可能会导致指令重排。</p><p>上述方法的字节码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span> <span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="comment">// ldc是获得类对象</span></span><br><span class="line">6: ldc #3 // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="comment">// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="comment">// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span></span><br><span class="line"><span class="comment">// 将类对象的引用地址存储了一份，是为了将来解锁用</span></span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line">11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="comment">// 新建一个实例</span></span><br><span class="line">17: new #3 // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="comment">// 复制了一个实例的引用</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="comment">// 通过这个复制的引用调用它的构造方法</span></span><br><span class="line">21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"><span class="comment">// 最开始的这个引用用来进行赋值操作</span></span><br><span class="line">24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line">37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><p>上述字节码最关键的地方在于17-&gt;24</p><ul><li><p><strong>正常情况</strong>先新建一个实例，然后复制实例的引用，再通过这个复制的引用调用它的构造方法，最后进行赋值操作赋值给instance。</p></li><li><p>但是JVM可能会优化这里的代码：<code>先执行 24(赋值)，再执行 21(构造方法)</code>。也就是先给instance赋值，这样instance并不为null，这个时候t2线程进入，第一个判断，<code> if(INSTANCE == null)</code>，ifnonnull，发现不为null，跳转到37行，最终获取到一个假的不为null的对象。</p></li><li><p>如果两个线程 t1，t2 按如下时间序列执行：</p></li></ul><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120171355261.png" alt="image-20220120171355261"></p><p>所以最终的问题</p><ul><li><code>INSTANCE = new Singleton();</code>操作不是一个<strong>原子操作</strong>, 它总共被分为4个指令，<code>21, 24两个指令</code>此时可能就会<strong>发生指令重排</strong>的问题。</li><li>此时又因为 <code>0: getstatic</code> 这行代码在 monitor 控制之外，也就是说第一次判断null的时候没有在synchronized控制下，其他线程可以来获取，判断instance的值</li><li>synchronized是可以保证变量的原子性、有序性和可见性，不会出现因为指令重排而产生错误，<strong>前提是</strong>：synchronized必须把这个变量完全的管理住。上面的问题就是因为第一次判空是没有被synchronized所管理到的。</li></ul><p>因此，解决方案就是加个volatile，<code>private static volatile Singleton INSTANCE = null</code>。加了<strong>volatile之后就会在putstatic加个写屏障，这样写屏障之前的指令就不会被重排序。</strong></p><p>读写 volatile 变量操作（即getstatic操作和putstatic操作）时会加入<strong>内存屏障</strong>，保证下面两点：</p><ul><li><strong>可见性</strong><br>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中<br>读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li><li><strong>有序性</strong><br>写屏障 会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后<br>读屏障 会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性<br>加上volatile之后, 保证了指令的有序性, 不会发生指令重排, 21就不会跑到24之后执行了</li></ul><p><strong>synchronized 既能保证原子性、可见性、有序性，其中有序性是在该共享变量完全被synchronized 所接管（包括共享变量的读写操作），上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。</strong></p><p><strong>对共享变量加volatile关键字可以保证可见性和有序性，但是不能保证<code>原子性</code>（即不能防止<code>指令交错</code>）。</strong></p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120172649628.png" alt="image-20220120172649628"></p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120172629908.png" alt="image-20220120172629908"></p><h2 id="Happens-before规则"><a href="#Happens-before规则" class="headerlink" title="Happens-before规则"></a>Happens-before规则</h2><p>happens-before规定了多共享变量的写操作对于其他线程的读操作的可见性。抛开以下规则，JVM并不能保证一个线程对共享变量的写操作对于其它线程对该共享变量的读可见。</p><h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>对于synchronized锁，会保证每次去主存中读取数据，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="volatile-变量"><a href="#volatile-变量" class="headerlink" title="volatile 变量"></a>volatile 变量</h3><ul><li><p>线程对volatile 变量的写，对接下来其它线程对该变量的读可见</p><p><strong>volatile修饰的变量, 通过<code>写屏障</code>, 共享到主存中, 其他线程通过<code>读屏障</code>, 读取主存的数据</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="start-前的写操作"><a href="#start-前的写操作" class="headerlink" title="start() 前的写操作"></a>start() 前的写操作</h3><ul><li><p>线程 start() 前对变量的写，对该线程开始后对该变量的读可见</p><p>线程还没启动时, 修改变量的值, 在启动线程后, 获取的变量值, 肯定是修改过的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">   System.out.println(x);</span><br><span class="line">  &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="t1-isAlive-或-t1-join-等待结束"><a href="#t1-isAlive-或-t1-join-等待结束" class="headerlink" title="t1.isAlive() 或 t1.join()等待结束"></a>t1.isAlive() 或 t1.join()等待结束</h3><ul><li><p>线程结束前 对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><p>主线程获取的x值, 是线程执行完对x的写操作之后的值。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure><h3 id="interrupt打断"><a href="#interrupt打断" class="headerlink" title="interrupt打断"></a>interrupt打断</h3><ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后, 对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(x); <span class="comment">// 10, 打断了, 读取的也是打断前修改的值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);<span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><ul><li>对变量默认值（0，false，null）的写，对其它线程对该变量的 读可见 (最基本)</li><li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</li><li>因为x加了volatile, 所以在volatile static int x 代码的上面添加了读屏障, 保证读到的x和y的变化是可见的(包括y, 只要是读屏障下面都OK); 通过传递性, t2线程对x,y的写操作, 都是可见的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">y = <span class="number">10</span>;</span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span> ).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">//x=20对t2可见，同时y=10 也对t2可见</span></span><br><span class="line">    system.out. print1n(x);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span> ).start();</span><br></pre></td></tr></table></figure><p><strong><code>volatile</code>主要用在<code>一个线程改,多个线程读时的来保证可见性</code>，和<code>double-checked locking模式中保证synchronized代码块外的共享变量的</code>指令重排序<code>问题</code></strong></p><h2 id="五种单例模式"><a href="#五种单例模式" class="headerlink" title="五种单例模式"></a><strong>五种单例模式</strong></h2><p>单例模式有<strong>饿汉式、懒汉式、枚举类(饿汉)、静态内部类</strong></p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：为什么<strong>类要加 final</strong></p><ul><li>防止子类继承后重写方法破坏单例</li></ul><p>问题2：如果实现了序列化接口，还要做什么来<strong>防止反序列化破坏单例</strong></p><ul><li>反序列化时候生成的对象可能会破坏单例，直接在类里加一个**public Object readResolve() {}**方法，可以让反序列化的时候调用这个方法返回单例的实例</li></ul><p>问题3：为什么<strong>构造方法设置为私有</strong>?</p><ul><li>避免其他类使用new生成新的实例，并不能防止反射创建新的实例，因为反射可以打破封装</li></ul><p>问题4：这样初始化是否能保证单例对象创建时的线程安全？</p><ul><li>可以保证，因为实例在<strong>类加载</strong>的时候就<strong>初始化</strong>，JVM会保证其线程安全性</li></ul><p>问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</p><ul><li>1.提供更好的<strong>封装性</strong>；2.提供<strong>泛型</strong>的支持</li></ul></blockquote><h3 id="饿汉式之枚举"><a href="#饿汉式之枚举" class="headerlink" title="饿汉式之枚举"></a>饿汉式之枚举</h3><p>饿汉式：因为枚举的变量，底层是通过public static final来修饰的，类加载就创建了，所以是饿汉式</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220122210404242.png" alt="image-20220122210404242"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：枚举单例是如何限制实例个数的</p><ul><li><strong>创建枚举类的时候就已经定义好了</strong>，每个枚举常量其实就是枚举类的一个静态成员变量</li></ul><p>问题2：枚举单例在创建时是否有并发问题</p><ul><li>没有并发问题，是线程安全的，因为枚举单例底层是一个静态成员变量，它是通过类加载器的加载而创建的，确保了线程安全</li></ul><p>问题3：枚举单例能否被反射破坏单例</p><ul><li><p><strong>反射无法破坏枚举单例</strong>, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">this</span>.clazz.getModifiers() &amp; <span class="number">16384</span>) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(“Cannot reflectively create <span class="class"><span class="keyword">enum</span> <span class="title">objects</span>”)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>问题4：枚举单例能否被反序列化破坏单例</p><ul><li><strong>反序列化不能破坏</strong>，枚举类默认也实现了序列号接口。但枚举类考虑到了这个问题，不会破坏单例。</li></ul><p>问题 5：枚举单例属于懒汉式还是饿汉式</p><ul><li>属于<strong>饿汉式</strong>, 静态成员变量, 通过类加载器的时候就加载了。</li></ul><p>问题 6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</p><ul><li>加构造方法，枚举也可以写构造方法，普通方法等</li></ul></blockquote><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点：</span></span><br><span class="line">    <span class="comment">// synchronized加载静态方法上，可以保证线程安全。缺点就是锁粒度大，效率低。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h3><p>DCL：double-check-locking</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：解释为什么要加 volatile</p><ul><li>因为在synchronized外部使用到了共享变量INSTANCE，可能存在一个线程先初始化了instance，但是别的线程没有从主存中获取instance，而是从工作内存中获取instance，仍然为空，volatile保证了可见性，保证读取变量的时候都从主存中去获取，这样就不会存在已经创建了实例，但读取到实例仍然为空的情况</li></ul><p>问题2：对比上面的懒汉式，说出这样做的意义</p><ul><li>增加了双重判断，如果存在了单例对象，别的线程再进来就无需加锁判断，<strong>提升效率</strong></li></ul><p>问题3：为什么还要加为空判断, 之前不是判断过了吗</p><ul><li>主要原因还是因为并发的时候产生线程不安全的问题</li><li>考虑这么一种情况：<ul><li>线程1第一次进入了synchronized代码，获取到了锁，判断到instance为null，然后就去创建实例</li><li>线程2此时已经进行了第一次判断为空，然后等待线程1释放锁。</li><li>如果不加判断，线程1创建完后释放锁，线程2进入同步代码块，此时没有了第二重为空判断，就会直接创建实例，此时就重复创建了实例，破坏了单例</li></ul></li></ul></blockquote><h3 id="懒汉式之静态内部类"><a href="#懒汉式之静态内部类" class="headerlink" title="懒汉式之静态内部类"></a>懒汉式之静态内部类</h3><p>通过静态内部类来创建单例，对外不可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：属于懒汉式还是饿汉式</p><ul><li>懒汉式，因为这是个静态内部类，类加载本身就是懒惰的，在没有用到这个类的时候，是不会进行类加载的，因此没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul><p>问题2：在创建时是否有并发问题</p><ul><li>没有并发问题，仍然是单例的。因为类加载是懒惰的，没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">原子性、可见性、volatile原理，读写屏障、单例设计，双重检查锁DCL</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/AQS%20ReentrantLock%E5%8E%9F%E7%90%86/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/AQS%20ReentrantLock%E5%8E%9F%E7%90%86/</id>
    <published>2022-02-09T14:53:07.569Z</published>
    <updated>2022-02-09T15:07:17.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h3><p>AQS全称<strong>AbstractQueueSynchronizer</strong>，抽象的队列的同步器，是JDK1.5提供的一套实现阻塞锁和一系列依赖FIFO等待队列的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类的实现都依赖于它，比如常用的ReentrantLock/ Semaphore/ CountDownLatch等。具体用法是通过<strong>继承AQS</strong>，<strong>实现</strong>其模板<strong>方法</strong>，来达到同步状态的管理。</p><h3 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h3><p>AQS在功能上可以分为</p><ul><li><strong>独占锁</strong>：每次只能有一个线程持有锁，比如ReentrantLock</li><li><strong>共享锁</strong>：允许多个线程同时获得锁，并发访问共享资源，比如ReentrantReadWriteLock中的读锁、CountDownLatch</li></ul><p>特点：</p><ul><li><p>用state属性来表示资源的状态（分独占模式和共享模型），子类需要定义如何维护这个状态，控制如何获取锁和释放锁，比如state为0就是没有线程持有锁，把state改为1就是有线程持有锁</p><ul><li>getState：获取state状态</li><li>setState：设置state状态</li><li>compareAndSetState：cas机制设置state状态，这里的cas只是原子性的来修改state的值，AQS仍然是一个阻塞式的，尝试设置失败后会进入阻塞的队列里去</li><li>独占模式是只有一个线程能访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li><p>提供了基于FIFO的等待队列，类似Monitor的EntryList</p></li><li><p>条件变量来实现等待，唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</p></li></ul><p>子类主要需要实现下面一些方法</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared：获取共享锁</li><li>tryReleaseShared：释放共享锁</li><li>isHeldExclusively：是否用于独占锁</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取锁的姿势</span></span><br><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁的姿势</span></span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承AQS自定义不可重入锁"><a href="#继承AQS自定义不可重入锁" class="headerlink" title="继承AQS自定义不可重入锁"></a>继承AQS自定义不可重入锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;TestAQS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            <span class="comment">// 不可重入锁</span></span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;locking...&quot;);</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占锁  同步器类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 确保原子性</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里不需要保证原子性, 因为是持锁者进行释放</span></span><br><span class="line">            <span class="comment">// 在setState(0)上面设置Owner为null, 防止指令重排序带来的问题</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// state是volatile修饰的, 在setState(0)前面的属性修改, 对于其他线程也是可见的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><p>ReentrantLock实现了Lock接口，同步内部还有一个自定义的抽象同步器Sync，Sync又包含了公平和非公平同步器，FairSync和NonfairSync都是ReentrantLock的static final 内部类，Sync是抽象的static 内部类继承自AQS</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129101733186.png" alt="image-20220129101733186"></p><h3 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h3><p>从构造方法来看，<strong>默认是非公平锁NonfairSync</strong>实现，NonfairSync继承了AQS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其lock方法调用的是同步器的lock方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看非公平同步器的lock方法，加锁流程就是现在cas机制原子性设置state值从0变为1，如果成功，就把独占锁Owner设置为当前线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有竞争时，Thread0进来加锁，把state变量为1，同时把独占锁Owner线程设置为Thread0</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129102122337.png" alt="image-20220129102122337"></p><p>第一个竞争出现时，假设已经有Thread0加锁成功，那么当前线程Thread1就<strong>加锁失败</strong>。</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129103843420.png" alt="image-20220129103843420"></p><p>加锁失败则进入AQS的acquire方法，会再一次尝试去获取锁，调用tryAcquire()，如果仍然获取失败，就尝试加入到等待队列里去，加入返回true就调用selfInterrupt把该线程打断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的addWaiter就是构造一个Node 双向链表队列</p><ol><li>下图中黄色三角表示该 Node 的<strong>waitStatus</strong>状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li><strong>第一次创建其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</strong></li></ol><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129104152327.png" alt="image-20220129104152327"></p><p>然后进入acquireQueued方法，这个方法内部是一个死for循环，获取当前线程关联节点的前驱节点p，<strong>如果p等于head，也就是说如果自己是紧邻着head（注意看图上的箭头，head指向的是node）</strong>，讲道理下一个就可以获得锁，那么Thread1就再一次的tryAcquire尝试去加锁；如果这次加锁成功了就把自己设置为Head节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果这次加锁失败或者p!=head，那么就应该在加锁失败后park住<strong>shouldParkAfterFailedAcquire</strong>，这个方法会将前驱节点即<strong>head</strong>的<strong>waitStatus</strong>修改为-1，**-1表示前面线程有责任唤醒后面的线程，也就是Thread1获取失败了，进入阻塞，把waitStatus设为-1 即将进入阻塞那么Thread0，就要有责任将Thread1唤醒<strong>，然后</strong>返回false**。</p><p>返回false后结束判断又进入for循环去尝试获取一次，假设<strong>又失败</strong>，那么又进入shouldParkAfterFailedAcquire方法，<strong>因为之前已经将waitStatus的值设置为-1了，这次肯定设置失败了，所以就返回了true</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">    * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>返回true后就进入<strong>parkAndCheckInterrupt</strong>方法，把当前线程park阻塞住</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129110313691.png" alt="image-20220129110313691"></p><p>假设有多个线程经历上述过程加锁失败，变成下图：</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129110452722.png" alt="image-20220129110452722"></p><h3 id="释放锁的流程"><a href="#释放锁的流程" class="headerlink" title="释放锁的流程"></a>释放锁的流程</h3><p>Thread0释放锁，进入tryRelease流程，将OwnerThread设置为null，state设置为0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后判断head是否为空，并且waitStatus==-1，进入unparkSuccessor方法，会找到离head最近的一个node(没取消的)，unpark唤醒。因此就是Thread1会被唤醒，然后Thread1继续执行acquireQueued方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Thread1加锁成功，设置</p><ol><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ol><p>如果有Thread4前来竞争，Thread1又加锁失败，Thread1再次进入acquireQueued流程，获取锁失败，重新进入park阻塞</p><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>以非公平锁NonfairSync的源码为例，NonfairSync在进行获取锁nonfairTryAcquire的时候，其实就是对state的值做一个判断，如果state的值为0，说明没线程加过锁；如果state的值不是0，说明已经有线程加过锁了，那就判断一下这个加锁的线程是不是当前线程，如果是当前线程那就<strong>把state的值再加1</strong>，<strong>表示当前线程又加了一次锁</strong></p><p>释放锁的时候相反，先让获取state的值，然后减去1，看看值是不是为0，为0才表示这个线程没有锁了，如果不为0，那就更新一下state的值就ok</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是Sync 继承过来的方法，实际上NonfairSync的tryAcquire里面也就是直接调用的这个nonfairTryAcquire方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 正常加锁流程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p>ReentrantLock默认是不可打断的，不可打断指的是，某个线程在尝试获取锁，然后获取锁失败了会进入parkAndCheckInterrupt()方法被park阻塞，这个时候是不可打断的。</p><h4 id="不可打断"><a href="#不可打断" class="headerlink" title="不可打断"></a>不可打断</h4><p>当在parkAndCheckInterrupt方法中park阻塞住，然后被打断后，会<strong>Thread.interrupted()清除打断标记</strong>，让下次park仍然可以阻塞。当被打断后，线程醒过来会接着执行return Thread.interrupted()，这个时候就会<strong>返回true</strong>，但同时会清除<strong>打断标记</strong>，也就是<strong>置为false</strong>，这样下次<strong>仍可以park</strong>阻塞住。</p><p>返回为true后，执行interrupted = true，然后<strong>又进入循环</strong>，看能否获取锁，不能获取又进入park阻塞。如果这次能获取锁了，interrupted = true，最后acquireQueued方法返回的就是interrupted=true。也就是说需要获取到锁之后，才能返回打断状态。</p><p>然后就从acquireQueued方法出来，<strong>也就是获取到锁之后进行一次selfInterrupt()，重新打断一次，如果是正常运行状态不是sleep中就不会抛打断异常</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        <span class="comment">// 被park阻塞的线程, 可以被别的线程调用它的interrupt方法打断该park阻塞</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted会返回是否被打断过，同时会清除打断标记; 下次park仍然可以阻塞</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)&amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>可打断则是在park方法被打断之后，执行完了parkAndCheckInterrupt方法，进入if内部，<strong>直接抛出异常，不会再次执行for循环</strong>，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入可打断的获取锁流程</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><p>与非公平锁的区别主要在tryAcquire方法里，公平锁并不会直接cas 去设置state的值，它会先去检查一下AQS队列中有不有前驱节点，也就是说还有不有线程在等待，如果有就退出if，获取锁失败，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">           <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(current);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                (<span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">            (s = h.next) == <span class="keyword">null</span> || <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">                                s.thread != Thread.currentThread()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>在AQS中ConditionObject是一个实现了Condition的公共内部类，每个条件变量其实就对应着一个ConditionObject，ConditionObject维护了一个等待队列</p><h4 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a>await流程</h4><p>下面是ConditionObject中的await方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>开始 Thread0 持有锁，conditionObject对象调用 await</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145922395.png" alt="image-20220129145922395"></p><p>进入 ConditionObject 的 addConditionWaiter方法，这个方法会将Thread0在ConditionObject 的等待队列中关联一个节点，首先创建新的Node状态为 -2(Node.CONDITION)，关联 Thread-0，加入等待队列尾部。</p><p>然后fullyRelease()，释放掉Thread0的所有锁，因为是可重入的</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145830741.png" alt="image-20220129145830741"></p><p>内部调用release(args)方法，unparkSuccessor(h)，唤醒AQS队列中的下一个节点，竞争锁</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145906453.png" alt="image-20220129145906453"></p><p>最后会进入await方法中的while循环，park阻塞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h4 id="signal流程"><a href="#signal流程" class="headerlink" title="signal流程"></a>signal流程</h4><p>下面是ConditionObject的<strong>signal</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>假设Thread1要来唤醒Thread0</p><p>首先判断Thread1是否持有独占锁if (!<strong>isHeldExclusively</strong>())，只有持有锁，才能去唤醒条件变量里的线程</p><p>然后<strong>每次都取条件变量中等待队列的第一个</strong><code>Node first = firstWaiter</code>，如果存在等待线程，就dosignal方法</p><p><strong>dosignal</strong> 先做些事后处理，判断是否还有下一个node，并且端口thread0的节点</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129151114179.png" alt="image-20220129151114179"></p><p>然后<strong>transferForSignal</strong>()，这个方法会将要唤醒Node加入到AQS的等待队列里去，并且将等待队列中最后一个node(即是图上的Thread3)的waitStatus修改为-1，因为要唤醒的node加入到它后面了</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129151221485.png" alt="image-20220129151221485"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">AbstractQueueSynchronizer，ReentrantLock实现原理，公平锁非公平锁实现原理，条件变量实现原理</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/CAS/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/CAS/</id>
    <published>2022-02-09T14:52:57.069Z</published>
    <updated>2022-02-09T15:07:44.859Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Java中 <strong>synchronized</strong> 和 <strong>ReentrantLock</strong> 等独占锁是 <strong>悲观锁</strong> 思想的实现</li><li>在Java中<strong>java.util.concurrent.atomic包下面的原子变量类</strong>是使用了乐观锁的一种实现方式 <strong><code>CAS</code></strong> 实现</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li>有如下需求，保证account.withdraw()取款方法的线程安全, 下面使用<code>synchronized</code>保证线程安全</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> AccountUnsafe(<span class="number">10000</span>));</span><br><span class="line">        Account.demo(<span class="keyword">new</span> AccountCas(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountUnsafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java8之后接口新特性, 可以添加默认方法、静态方法</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 1000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(thread -&gt; thread.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end - start) / <span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS解决"><a href="#CAS解决" class="headerlink" title="CAS解决"></a>CAS解决</h2><ul><li>上面的代码中使用synchronized加锁操作来保证线程安全，但是 **synchronized加锁操作太耗费资源 (线程上下文切换)**，我们还可以使用 <strong>无锁CAS</strong> 来解决此问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountCas</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用原子整数</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AccountCas</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//得到原子整数的值</span></span><br><span class="line"><span class="keyword">return</span> balance.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//获得修改前的值</span></span><br><span class="line"><span class="keyword">int</span> prev = balance.get();</span><br><span class="line"><span class="comment">//获得修改后的值</span></span><br><span class="line"><span class="keyword">int</span> next = prev - amount;</span><br><span class="line"><span class="comment">//比较并设置值</span></span><br><span class="line">            <span class="comment">//一个原子操作，比较并设置。会先去比较一下线程当前知道的值prev和主存中的balance</span></span><br><span class="line">            <span class="comment">//比较发现如果相等就设置balance的值为next，然后返回true，不相等就直接返回false</span></span><br><span class="line"><span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h2><p>使用原子操作CAS来保证线程访问共享资源的安全性，需要保证共享变量的可见性</p><h3 id="保证账户余额线程安全原理"><a href="#保证账户余额线程安全原理" class="headerlink" title="保证账户余额线程安全原理"></a>保证账户余额线程安全原理</h3><p><strong>compareAndSet</strong> 保证共享变量安全性：</p><ul><li>调用compareAndSet方法, 会先去比较一下线程当前知道的值prev和主存中的balance，比较发现如果相等就设置balance的值为next，然后返回true，不相等就直接返回false<br>如果不相同，表示其他线程也修改了balance值，此时就设置next值失败，然后进入while循环，重新获取balance.get()的值，计算出next值。并判断本次的prev和balnce的值是否相同</li></ul><p>其实 <strong>CAS</strong> 的底层是 <strong>lock cmpxchg 指令（X86 架构）</strong>，在单核 CPU 和多核 CPU 下都能够保证比较-交换的原子性。<br>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p><h3 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h3><p>在上面代码中的<strong>AtomicInteger</strong>类，内部的<strong>value</strong>属性使用了<strong>volatile</strong> 修饰。获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰，这样能保证线程对属性的修改对其他线程可见。(volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>使用<strong>CAS</strong>+重试无锁情况下，即使重试失败，<strong>线程</strong>始终在<strong>高速运行</strong>，没有停歇，而 <strong>synchronized</strong>会让线程在没有获得锁的时候，发生<strong>上下文切换</strong>，进入<strong>阻塞</strong>。</p><p>打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</p><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p><p>因此，CAS这种方式也比较依靠CPU核心数，如果CPU核心数不够，即使有再多的线程，线程分不到时间片，一样会阻塞住，一样会上下文切换，所以最好线程数不要大于CPU核心数。</p><h3 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，<strong>适用于线程数少、多核 CPU</strong> 的场景下。</p><p><strong>CAS</strong> 是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，那就再尝试一次。<br><strong>synchronized</strong>是基于<strong>悲观锁</strong>的思想：最悲观的估计，保证不让其它线程来修改共享变量，上了锁其他线程都不能操作，修改完了解开锁，其他线程才有机会。<br><strong>CAS 体现的是无锁并发、无阻塞并发</strong>，因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一，**但如果竞争激烈(写操作多)**，可以想到重试必然频繁发生，反而效率会受影响</p><h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p><strong>java.util.concurrent.atomic</strong>提供的是一些原子类，</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p>上面三个类提供的方法几乎相同，以 <strong>AtomicInteger</strong>为例。<br>通过观察源码可以发现AtomicInteger 内部是通过cas的来实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">    System.out.println(i.getAndIncrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">    System.out.println(i.incrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">    System.out.println(i.decrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">    System.out.println(i.getAndDecrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">    System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    <span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line">    <span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">    System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i.getAndAccumulate(10, (p, x) -&gt; p + x)</code>：函数式编程接口，(p, x) -&gt; p + x做为一个参数可以理解为实现了某一种方法，这种方式就是返回p+x的值</p><p><code>updateAndGet</code>方法的实现：实际上是相当于把匿名内部类简化了一下，以函数式的风格就可以调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    updateAndGet(i, <span class="keyword">new</span> IntUnaryOperator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(<span class="keyword">int</span> operand)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> operand / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i.get()); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateAndGet</span><span class="params">(AtomicInteger i, IntUnaryOperator operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = i.get(); <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">int</span> next = operator.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span> (i.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子引用-AtomicReference"><a href="#原子引用-AtomicReference" class="headerlink" title="原子引用 (AtomicReference)"></a>原子引用 (AtomicReference)</h2><p>原子引用保证引用类型的共享变量是线程安全的，刚才的是规定了数据类型比如为Integer</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicMarkableReference</code>：原子更新带有版本号的引用类型。用版本号一般是整型来标识是否被修改过，用来解决 ABA 问题。</li><li><code>AtomicStampedReference</code> 原子更新带有标记的引用类型。该类并不关心中途修改了多少次，只关心有没有修改过，所以只需要用一个 boolean 标记与引用关联起来，可以解决ABA 问题。</li></ul><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>ABA问题就是说在采用原子类型操作的时候，比如如果用上面的AtomicInteger，一个线程想把1改为3，但这个线程成功之前，线程2先把1改为了2，然后某个线程又把2改回了1，这时候想改为3的线程虽然也能改成功，因为它从主存中获取到的值仍然为1，但是实际上已经被其他线程修改过了，这就是ABA问题，简单点来说就是A修改到B后又修改回了A，但是其他线程并不知道修改过了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String pre = ref.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//把ref中的A改为C，也会修改成功，这就是ABA问题 仍然是true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C &quot;</span> + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 线程start后主线程sleep了，所以这个线程把A-&gt;B，并且能改成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 再将B-&gt;A，同样也能修改成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicStampedReference-版本号解决ABA问题"><a href="#AtomicStampedReference-版本号解决ABA问题" class="headerlink" title="AtomicStampedReference (版本号解决ABA问题)"></a>AtomicStampedReference (版本号解决ABA问题)</h3><p><strong>AtomicStampedReference</strong> 可以加一个版本号，来解决ABA问题，在构造的时候初始化一个版本号，如果有线程修改了就版本号加1，这样其他线程就能根据这个版本号来判断是否被修改过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String pre = ref.getReference();</span><br><span class="line">            <span class="comment">//获得版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp(); <span class="comment">// 此时的版本号还是第一次获取的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把ref中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C stamp &quot;</span> + stamp + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicMarkableReference-boolean解决ABA问题"><a href="#AtomicMarkableReference-boolean解决ABA问题" class="headerlink" title="AtomicMarkableReference (boolean解决ABA问题)"></a>AtomicMarkableReference (boolean解决ABA问题)</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; </p><p>A -&gt;C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，就可以使用<strong>AtomicMarkableReference</strong></p><h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><p><strong>原子数组用来保证数组内的元素的线程安全，使用原子的方式更新数组里的某个元素</strong></p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><p>下面<strong>不安全的示例</strong>中采用了函数式编程，可以理解为demo(…)方法里的参数，都是一种方法，在调用demo方法的时候实现好方法的内容，然后直接返回给参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo(</span><br><span class="line">                () -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">                array -&gt; array.length,</span><br><span class="line">                (array, index) -&gt; array[index]++,</span><br><span class="line">                array -&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment">     * 参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment">     * 参数3，自增方法，回传 array, index</span></span><br><span class="line"><span class="comment">     * 参数4，打印数组的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line">    <span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line">    <span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;void</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;T, Integer&gt; putConsumer, </span></span></span><br><span class="line"><span class="function"><span class="params">        Consumer&lt;T&gt; printConsumer)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        T array = arraySupplier.get();</span><br><span class="line">        <span class="keyword">int</span> length = lengthFun.apply(array);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建10个线程, 每个线程对数组作 10000 次操作</span></span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    putConsumer.accept(array, j % length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ts.forEach(t -&gt; t.start()); <span class="comment">// 启动所有线程</span></span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 等所有线程结束</span></span><br><span class="line"></span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安全的实现只需要用AtomicIntegerArray数组来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">        ()-&gt; <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>),</span><br><span class="line">        (array) -&gt; array.length(),</span><br><span class="line">        (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">        array -&gt; System.out.println(array)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><p><strong>保证多线程访问同一个对象的成员变量时，成员变量的线程安全性。</strong></p><ul><li>AtomicReferenceFieldUpdater：引用类型</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>注意：利用字段更新器，可以针对对象的某个域或者叫属性（Field）进行原子操作，但是<strong>属性需要被volatile 修饰</strong>，否则会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be <span class="keyword">volatile</span> type</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">// 获得原子更新器</span></span><br><span class="line">      <span class="comment">// 泛型</span></span><br><span class="line">      <span class="comment">// 参数1 newUpdater(类的字节码对象,被更新的属性的字节码对象,属性的名称)</span></span><br><span class="line">        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//最初为null，想要修改为&quot;张三&quot;</span></span><br><span class="line">        System.out.println(updater.compareAndSet(stu, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(updater.compareAndSet(stu, stu.name, <span class="string">&quot;王五&quot;</span>));</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子累加器-LongAddr"><a href="#原子累加器-LongAddr" class="headerlink" title="原子累加器 (LongAddr)"></a>原子累加器 (LongAddr)</h2><p>原子累加器是jdk8的新的几个类，它优化了原始原子整数的方法，能够得到更快的效率</p><ul><li>LongAddr</li><li>LongAccumulator</li><li>DoubleAddr</li><li>DoubleAccumulator</li></ul><p><strong>AtomicLong和LongAddr的性能比较</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----AtomicLong----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----LongAdder----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> LongAdder(), adder -&gt; adder.increment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">        T adder = adderSupplier.get();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                    action.accept(adder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(t -&gt; t.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start) / <span class="number">1000_000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LongAddr性能提升的原因"><a href="#LongAddr性能提升的原因" class="headerlink" title="LongAddr性能提升的原因"></a><strong>LongAddr性能提升的原因</strong></h3><ul><li>就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 失败的次数，从而提高性能。</li></ul><p>AtomicLong等都是在一个共享资源变量上进行竞争, while(true)循环进行CAS，性能没有LongAdder高</p><h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><ul><li><strong>Unsafe</strong> 对象提供了非常底层的操作内存和线程的方法，Unsafe 对象<strong>不能直接调用</strong>，<strong>只能</strong>通过<strong>反射</strong></li><li>可以发现AtomicInteger以及其他的原子类, 底层都会使用一个Unsafe的属性</li></ul><h3 id="使用Unsafe实现原子操作"><a href="#使用Unsafe实现原子操作" class="headerlink" title="使用Unsafe实现原子操作"></a>使用Unsafe实现原子操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射获得Unsafe对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Person对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获得其属性 name 的偏移量（相对于类的属性值的地址偏移量）</span></span><br><span class="line">        <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="keyword">long</span> ageOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过unsafe的CAS操作改变值</span></span><br><span class="line">        unsafe.compareAndSwapObject(person, nameOffset, <span class="keyword">null</span>, <span class="string">&quot;guizy&quot;</span>);</span><br><span class="line">        unsafe.compareAndSwapInt(person, ageOffset, <span class="number">0</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配合CAS操作，必须用volatile修饰</span></span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CAS，原子整数，原子引用，原子数组，累加器，Unsafe类</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/ReentrantLock/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/ReentrantLock/</id>
    <published>2022-02-09T14:20:56.592Z</published>
    <updated>2022-02-09T14:51:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><p>一个并发应用程序能及时执行的能力称为活跃性</p><ul><li>活跃性相关的一系列问题都可以用 ReentrantLock 进行解决。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br>如：线程1获取A对象锁, 线程2获取B对象锁; 此时线程1又想获取B对象锁, 线程2又想获取A对象锁; 它们都等着对象释放锁, 此时就称为死锁</p><h3 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h3><ol><li>互斥条件<br>在一段时间内，一种资源只能被一个进程所使用</li><li>请求和保持条件<br>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进阻塞状态，并且不释放自己已有的资源</li><li>不可抢占条件<br>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li><li>循环等待条件<br>发生死锁时，必然存在一个进程——资源的循环链</li></ol><h3 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h3><h4 id="JPS-JStack进程ID"><a href="#JPS-JStack进程ID" class="headerlink" title="JPS+JStack进程ID"></a>JPS+JStack进程ID</h4><p>首先JPS找到JVM进程，JStack +进程ID查看进程状态</p><h4 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h4><p>jconsole连接进程，检测死锁</p><h4 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h4><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li><li>当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。</li></ul><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁出现在两个线程互相改变对方的结束条件，谁也无法结束。</p><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><ul><li>某些线程因为优先级太低，导致一直无法获得资源的现象。</li></ul><ul><li>在使用顺序加锁时，可能会出现饥饿现象</li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock特点：</p><ul><li>可中断</li><li>可设置超时时间</li><li>可设置为公平锁</li><li>支持多个条件变量，根据不同条件加锁</li></ul><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//需要执行的代码</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//需要执行的代码</span></span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>ReentrantLock是可以中断的，调用reentrantLock. lockInterruptibly()，那么这个reentrantLock就是一个可打断的锁；如果这个锁没有竞争，那么它跟正常的lock方法是没有区别的。但是如果发生了竞争并且线程进入了阻塞队列，那么这个阻塞状态是可以被其他线程打断的。避免了一直阻塞。</p><ul><li><strong>synchronized</strong>是获得了锁以后，可以进行打断，<strong>打断正在运行的线程或者说打断在sleep，wait，join的线程</strong></li><li><strong>ReentrantLock</strong>的可<strong>打断</strong>的意思是没获得锁，前往阻塞队列，可以<strong>打断它的阻塞</strong>，<strong>避免一直获取不到锁而阻塞，可以用来避免死锁</strong>，**<code>防止死锁的思想还是避免一直等待</code>**</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//lockInterruptibly方法表示是可中断的</span></span><br><span class="line">            <span class="comment">// 也就是说reentrantLock还没获得锁，竞争后进入了阻塞队列，别的线程可以打断reentrantLock的阻塞</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有竞争这个方法跟lock()是一样的</span></span><br><span class="line">                <span class="comment">//如果有竞争进入阻塞队列，可以被其他线程打断</span></span><br><span class="line">                System.out.println(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">                reentrantLock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有获取锁，返回&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在t1线程获取到锁前先锁住</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打断t1&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">尝试获取锁</span><br><span class="line">打断t1</span><br><span class="line">没有获取锁，返回</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly (AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly( AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">at com.zc.reentrantlock.Test.lambda$main$<span class="number">0</span>(Test.java:<span class="number">22</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>如果是reentrantLock.lock()方法，则是不可打断的；会发现先尝试获取锁，获取不到，然后就阻塞，接下来主线程打断t1，但是没有打断成功，程序一直运行。</li></ul><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p><strong>锁超时</strong>是指用ReentrantLock的**tryLock()**方法上锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>tryLock()<strong>方法返回boolean值，会</strong>先判断能否成功获取锁</strong>，不能则返回false。</li><li>**tryLock(long timeout, TimeUnit unit)**表示在一定timeout时间内去尝试获取锁，在这时间段仍获取不到锁则返回false。同样这个方法同lockInterruptibly()方法一样，也是一个可打断的方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!reentrantLock.tryLock()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取不到锁，返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reentrantLock.lock();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trylock-解决哲学家就餐问题"><a href="#trylock-解决哲学家就餐问题" class="headerlink" title="trylock()解决哲学家就餐问题"></a>trylock()解决哲学家就餐问题</h3><p>哲学家在拿到左边的筷子的时候也就是左边筷子加锁，然后准备给右边筷子加锁，采用trylock()保证其不会一直占着左边的筷子不放，如果没能成功给右边筷子加锁，那么就会释放左边的筷子。</p><p>原来采用synchronized会产生死锁是因为synchronized给左边的的筷子加锁后，又想给右边筷子加锁，右边筷子加锁要是不成功，就不会继续往下执行，也就是不会释放左边筷子的锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哲学家就餐问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;PhilosopherEatingProblem.class&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhilosopherEatingProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Chopstick left;</span><br><span class="line">    <span class="keyword">final</span> Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//获得左手边筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//获得成功，获取右边筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承ReentrantLock, 让筷子类成为锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock<strong>默认</strong>是<strong>非公平锁</strong>，可以在<strong>构造方法</strong>的时候指定其为<strong>公平锁</strong>；</p><p>在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。一般不设置ReentrantLock为公平的, 会降低并发度。</p><p>Synchronized底层的Monitor锁就是不公平的, 和谁先进入阻塞队列是没有关系的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>公平锁可以解决饥饿问题，也就是说不会存在某个线程一直获取不到锁。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li>synchronized中也有条件变量，当条件不满足的时候，进入waitSet集合，但是它的waitSet只有一个</li><li>ReentrantLock可以有多个条件变量，也就是说可以有多个waitSet，不同条件的进入不同的waitSet等待，这样可以<strong>避免虚假唤醒</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">//条件变量一</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Condition condition1= lock.newCondition();</span><br><span class="line">   <span class="comment">//条件变量2</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Condition condition2= lock.newCondition();</span><br></pre></td></tr></table></figure><ul><li>condition.await()方法进入对应条件的waitSet</li><li>condition.signal()方法唤醒对应条件的waitSet中的一个线程</li><li>condition.signalAll()方法唤醒对应条件的waitSet中的所有线程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 等待烟的休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitCigaretteSet = lock.newCondition();</span><br><span class="line">    <span class="comment">// 等外卖的休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitTakeoutSet = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小南进入到等烟的休息室</span></span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;烟来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小女进入到等外卖的休息室</span></span><br><span class="line">                        waitTakeoutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送外卖的来咯~&quot;</span>);</span><br><span class="line">                hasTakeout = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等外卖的小女线程</span></span><br><span class="line">                waitTakeoutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送烟的来咯~&quot;</span>);</span><br><span class="line">                hasCigarette = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等烟的小南线程</span></span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="顺序打印"><a href="#顺序打印" class="headerlink" title="顺序打印"></a>顺序打印</h3><ul><li>要求两个线程先打印2，再打印1</li></ul><h4 id="wait-notify实现"><a href="#wait-notify实现" class="headerlink" title="wait-notify实现"></a>wait-notify实现</h4><p>设置一个标记变量，只有2还没打印，就wait，2打印完了，唤醒1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSeqPrint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> has2Printed=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!has2Printed) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)</span><br><span class="line">            &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">                has2Printed=<span class="keyword">true</span>;</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock的await-signal实现"><a href="#ReentrantLock的await-signal实现" class="headerlink" title="ReentrantLock的await/signal实现"></a>ReentrantLock的await/signal实现</h4><p>不满足条件去其条件变量中等待</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (!has2Printed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">        has2Printed=<span class="keyword">true</span>;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="LockSupport的park和unpark实现"><a href="#LockSupport的park和unpark实现" class="headerlink" title="LockSupport的park和unpark实现"></a>LockSupport的park和unpark实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();;</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><ul><li>要求线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。</li></ul><h4 id="wait-notify实现-1"><a href="#wait-notify实现-1" class="headerlink" title="wait-notify实现"></a>wait-notify实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;a线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;b线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;c线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出内容    等待标记    下一个标记</span></span><br><span class="line"><span class="comment">        a           1          2</span></span><br><span class="line"><span class="comment">        b           2          3</span></span><br><span class="line"><span class="comment">        c           3          1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, <span class="keyword">int</span> waitFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (waitFlag != <span class="keyword">this</span>.flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="keyword">this</span>.flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：abcabcabcabcabc</p><h4 id="condition-await-signal实现"><a href="#condition-await-signal实现" class="headerlink" title="condition.await/signal实现"></a>condition.await/signal实现</h4><p>设置3个条件变量，去各自的waitSet中等待，先让3个线程都阻塞，然后开始唤醒a，直接a唤醒b，b唤醒c</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAwaitSignal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a_condition = awaitSignal.newCondition();</span><br><span class="line">        Condition b_condition = awaitSignal.newCondition();</span><br><span class="line">        Condition c_condition = awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a_condition, b_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b_condition, c_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c_condition, a_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==========开始=========&quot;</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a_condition.signal();  <span class="comment">//首先唤醒a线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Condition condition, Condition next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.out.print(str);</span><br><span class="line">                    next.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LockSupport的park-unpark实现"><a href="#LockSupport的park-unpark实现" class="headerlink" title="LockSupport的park/unpark实现"></a>LockSupport的park/unpark实现</h4><p>先全部阻塞，然后唤醒a，接着a唤醒b，b唤醒c，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread a;</span><br><span class="line">    <span class="keyword">static</span> Thread b;</span><br><span class="line">    <span class="keyword">static</span> Thread c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark parkUnpark = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;a&quot;</span>, b);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;b&quot;</span>, c);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;c&quot;</span>, a);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h2><p><img src="/../../img/markdown_img/ReentrantLock.assets/image-20220118111830515.png" alt="image-20220118111830515"></p>]]></content>
    
    
    <summary type="html">ReentrantLock、条件变量Condition、LockSupport Park，unPark</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程的安全性问题</title>
    <link href="http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2022-01-17T10:35:35.045Z</published>
    <updated>2022-01-17T11:46:43.292Z</updated>
    
    <content type="html"><![CDATA[<ul><li>线程安全问题</li><li>synchronized保证线程安全</li><li>private或final的重要性</li><li>线程八锁问题分析</li><li>变量的线程安全分析</li></ul><h2 id="临界区与竞态条件"><a href="#临界区与竞态条件" class="headerlink" title="临界区与竞态条件"></a>临界区与竞态条件</h2><p>一个程序运行多线程本身是没有问题的，问题出现在多个线程共享资源(临界资源)的时候</p><p>多个线程同时对共享资源进行读操作本身也没有问题 - 对读操作没问题</p><p>问题出现在对对共享资源同时进行读写操作时就有问题了 - 同时读写操作有问题</p><p>先定义一个叫做临界区的概念：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为<strong>临界区</strong>; 共享资源也成为<strong>临界资源</strong></p><ul><li>多个线程在<code>临界区</code>执行，那么由于<strong>代码指令的执行不确定而导致的结果问题</strong>，称为<code>竞态条件</code></li></ul><p>为了避免临界区中的竞态条件发生，由多种手段可以达到</p><ul><li>阻塞式解决方案： synchronized , Lock (ReentrantLock)</li><li>非阻塞式解决方案： 原子变量 (CAS)</li></ul><p>使用synchronized来进行解决，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><p>注意: 虽然Java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码。同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</p><h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><ul><li>其实就是考察<code>synchronized 锁住的是哪个对象</code>, 如果锁住的是<code>同一对象</code>, 就不会出现<code>线程安全</code>问题</li></ul><h3 id="锁住同一个对象都是this，结果为：1-2或者2-1"><a href="#锁住同一个对象都是this，结果为：1-2或者2-1" class="headerlink" title="锁住同一个对象都是this，结果为：1,2或者2,1"></a>锁住同一个对象都是this，结果为：1,2或者2,1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1/2 或 2/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁住同一个对象都是this，结果为：1s后1-2-2-1s后1"><a href="#锁住同一个对象都是this，结果为：1s后1-2-2-1s后1" class="headerlink" title="锁住同一个对象都是this，结果为：1s后1,2 || 2,1s后1"></a>锁住同一个对象都是this，结果为：1s后1,2 || 2,1s后1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1s后1,2 || 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a，b锁住同一个对象都是this，c没有上锁。"><a href="#a，b锁住同一个对象都是this，c没有上锁。" class="headerlink" title="a，b锁住同一个对象都是this，c没有上锁。"></a>a，b锁住同一个对象都是this，c没有上锁。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会出现安全问题, 因为前两个线程, 执行run方法时, 都对相同的对象加锁;</span></span><br><span class="line"><span class="comment"> *              而第三个线程,调用的方法c, 并没有加锁, 所以它可以同前两个线程并行执行;</span></span><br><span class="line"><span class="comment"> *  打印结果顺序为: 分析: 因为线程3和线程1,2肯定是并行执行的, 所以有以下情况</span></span><br><span class="line"><span class="comment"> *               3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1</span></span><br><span class="line"><span class="comment"> *               至于 1,3,2的情况是不会发生的, 可以先调用到1,但需要sleep一秒.3肯定先执行了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                e1.a();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.c()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住对象this，b锁住对象this"><a href="#a锁住对象this，b锁住对象this" class="headerlink" title="a锁住对象this，b锁住对象this"></a>a锁住对象this，b锁住对象this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会出现安全问题, 线程1的锁对象为e1, 线程2的锁对象为e2. 所以他们会同一时刻执行1,2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是e2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住的是类-b锁住的是this"><a href="#a锁住的是类-b锁住的是this" class="headerlink" title="a锁住的是类, b锁住的是this"></a>a锁住的是类, b锁住的是this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是e2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-b锁住的是类-会发生互斥"><a href="#a-b锁住的是类-会发生互斥" class="headerlink" title="a,b锁住的是类, 会发生互斥"></a>a,b锁住的是类, 会发生互斥</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span></span><br><span class="line"><span class="comment"> *              结果: 2,1s后1 || 1s后1,2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住的是类-b锁住的是this-1"><a href="#a锁住的是类-b锁住的是this-1" class="headerlink" title="a锁住的是类, b锁住的是this"></a>a锁住的是类, b锁住的是this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是this,e2对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-b锁住的是类-会发生互斥-1"><a href="#a-b锁住的是类-会发生互斥-1" class="headerlink" title="a,b锁住的是类, 会发生互斥"></a>a,b锁住的是类, 会发生互斥</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1 || 1s后1,2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><h3 id="成员变量和静态变量的线程安全分析"><a href="#成员变量和静态变量的线程安全分析" class="headerlink" title="成员变量和静态变量的线程安全分析"></a>成员变量和静态变量的线程安全分析</h3><p>如果变量没有在线程间共享，那么变量是安全的<br>如果变量在线程间共享<br>如果只有读操作，则线程安全<br>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p><h3 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h3><p>局部变量【局部变量被初始化为基本数据类型】是安全的<br>但<strong>局部变量引用的对象</strong>则未必线程安全 （要看该对象是否被共享且被执行了读写操作）</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul><li>如果<code>局部变量引用的对象逃离方法的范围</code>，那么<code>要考虑线程安全问题</code>的，代码示例如下</li></ul><blockquote><p>循环创建了100个线程, 在线程体里面都调用了method1方法, 在method1方法中又循环调用了100次method2,method3方法，也即是arrayList 的add和remove；这里的arrayList 是多线程中共享的变量，因为都是unsafeTest，对于这个共享的变量，虽然arrayList 的操作是加了同步代码块的，但是arrayList.add()和arrayList.remove()并不能保证也是同步的，这样必然会出现线程安全问题，最后以异常的形式抛出。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeTest unsafeTest = <span class="keyword">new</span> UnsafeTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                unsafeTest.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;线程1&quot;</span> Exception in thread <span class="string">&quot;线程2&quot;</span> java.lang.ArrayIndexOutOfBoundsException: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>解决方法就是可以将arrayList作为局部变量，放在method1内部，这样arrayList就可以认为是一个线程私有的。局部变量存放在<strong>栈帧</strong>中, 栈帧又存放在<code>虚拟机栈</code>中, <strong>虚拟机栈是作为线程私有的;</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            method2(arrayList);</span><br><span class="line">            method3(arrayList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(List&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(List&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private-或-final的作用"><a href="#private-或-final的作用" class="headerlink" title="private 或 final的作用"></a><code>private</code> 或 <code>final</code>的作用</h3><p>使用这两个修饰符可以提高线程的安全性，private和final让子类不能重写父类的方法，当我们的方法如果是public，也即是上面的代码method2,method3都是public时，虽然上面代码不会出现线程安全问题，如果有一个子类继承了这个UnsafeTest类，然后又因为是public方法，就可以重写覆盖父类的方法，此时在子类中开多线程操作list对象，就有可能造成线程安全问题：子类和父类共享了list对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSafe threadSafe = <span class="keyword">new</span> ThreadSafeSubClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                threadSafe.method1(<span class="number">10</span>);</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见线程安全类-1"><a href="#常见线程安全类-1" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类 JUC</li></ul><p>这里说它们是线程安全的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong> , 也可以理解为 <strong>它们的每个方法是原子的</strong>，因为方法都被加上了synchronized</p><p>但注意它们的<code>多个方法的组合不是原子的</code>，所以可能<strong>会出现线程安全问题</strong></p>]]></content>
    
    
    <summary type="html">临界区与竞态条件、线程八锁问题</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-01-17T10:26:55.204Z</published>
    <updated>2022-01-17T10:33:15.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程、并行并发、同步异步概念"><a href="#线程与进程、并行并发、同步异步概念" class="headerlink" title="线程与进程、并行并发、同步异步概念"></a>线程与进程、并行并发、同步异步概念</h2><ul><li>线程创建</li><li>线程重要api，如start，run，sleep, join，interrupt等</li><li>线程状态</li><li>应用方面<ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li>原理方面<ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式的源码</li></ul></li><li><font color="green">模式方面</font><ul><li>两阶段终止</li></ul></li></ul><h2 id="进程与进程"><a href="#进程与进程" class="headerlink" title="进程与进程"></a>进程与进程</h2><p>进程: 资源分配的最小单位</p><p>进程是线程的容器, 一个进程中包含多个线程, 真正执行任务的是线程<br>线程: 资源调度的最小单位</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序由指令和数据组成，但是这些 指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令,管理内存,管理IO的<br>当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程<br>进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程之内可以分为多个线程。<br>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行<br>Java 中，线程作为资源的最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。</p><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集<br>进程拥有共享的资源，如内存空间等，供其内部的线程共享; 进程间通信较为复杂<br>同一台计算机的进程通信称为 IPC（Inter-process communication）<br>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP<br>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<br>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>并发: 在单核CPU下, 一定是并发执行的, 也就是在同一个时间段内一起执行. 实际还是串行执行, CPU的时间片切换非常快, 给人一种同时运行的感觉。</p><p>并行: 在多核CPU下, 能真正意义上实现并行执行, 在同一个时刻, 多个线程同时执行; 比如说2核cpu, 同时执行4个线程. 理论上同时可以有2个线程是并行执行的. 此时还是存在并发, 因为2个cpu也会同时切换不同的线程执行任务罢了</p><h3 id="并发-concurrent"><a href="#并发-concurrent" class="headerlink" title="并发 (concurrent)"></a>并发 (concurrent)</h3><p>微观串行, 宏观并行<br>在单核 cpu下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu 在线程间（时间片很短）的切换非常快，给人的感觉是同时运行的 。一般会将这种线程轮流使用 CPU的做法称为并发（concurrent）<br>将线程轮流使用cput称为并发(concurrent)</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p><h3 id="二者对比-1"><a href="#二者对比-1" class="headerlink" title="二者对比"></a>二者对比</h3><p>引用 Rob Pike 的一段描述：<br>并发（concurrent）: 是同一时间应对（dealing with）多件事情的能力<br>并行（parallel）: 是同一时间动手做（doing）多件事情的能力<br>例子</p><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发<br>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）<br>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是 并行</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>以调用方的角度讲</p><ul><li>如果需要等待结果返回才能继续运行的话就是同步</li><li>如果不需要等待就是异步</li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这5秒cpu什么都做不了，其它代码都得暂停</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>UI 程序中，开线程进行其他操作，避免阻塞 UI 线程</li></ul><h2 id="线程的创建-重点"><a href="#线程的创建-重点" class="headerlink" title="线程的创建 (重点)"></a>线程的创建 (重点)</h2><h3 id="创建一个线程（非主线程）"><a href="#创建一个线程（非主线程）" class="headerlink" title="创建一个线程（非主线程）"></a>创建一个线程（非主线程）</h3><h4 id="通过继承Thread创建线程"><a href="#通过继承Thread创建线程" class="headerlink" title="通过继承Thread创建线程"></a>通过继承Thread创建线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">myThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用继承方式的好处是，在run()方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread()方法；不好的地方是<strong>Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</strong></li></ul><h4 id="使用Runnable配合Thread-推荐"><a href="#使用Runnable配合Thread-推荐" class="headerlink" title="使用Runnable配合Thread (推荐)"></a>使用Runnable配合Thread (推荐)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread2</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;my runnable running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">      thread.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</li></ul><h5 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h5><ul><li><p>当一个接口带有**@FunctionalInterface**注解时，是可以使用lambda来简化操作的</p></li><li><p>所以方法二中的代码可以被简化为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="comment">//直接写方法体即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Thread-与-Runnable的关系"><a href="#Thread-与-Runnable的关系" class="headerlink" title="Thread 与 Runnable的关系"></a>Thread 与 Runnable的关系</h5><p>分析 Thread 的源码，查看与 Runnable 的关系，可以发现采用Runnable的方式最终new Thread的时候最终就是把实现Runnable作为Thread中的target成员，然后判断如果target不为null，就运行target的run()方法，也就是Runnable的run方法。</p><ul><li>继承Thread方式: 是把线程和任务合并在了一起</li><li>实现Runnable方式: 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h4 id="使用FutureTask与Thread结合"><a href="#使用FutureTask与Thread结合" class="headerlink" title="使用FutureTask与Thread结合"></a>使用FutureTask与Thread结合</h4><p>使用<strong>FutureTask可以用泛型指定线程的返回值类型</strong>（Runnable的run方法没有返回值），FutureTask实现了RunnableFuture，FutureRunable继承了Runnable接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread r1 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">r1.start();</span><br><span class="line"><span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseFutureTask</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">      FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCall());</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">      thread.start();</span><br><span class="line">      <span class="comment">// 获得线程运行后的返回值</span></span><br><span class="line">      System.out.println(futureTask.get());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用线程池来创建线程"><a href="#使用线程池来创建线程" class="headerlink" title="使用线程池来创建线程"></a>使用线程池来创建线程</h4><p>创建线程的方式四：使用线程池</p><p>好处：</p><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p></li></ol><ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？四种！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：创建多线程有几种方式？四种！"><a href="#面试题：创建多线程有几种方式？四种！" class="headerlink" title="面试题：创建多线程有几种方式？四种！"></a>面试题：创建多线程有几种方式？四种！</h4><p>总结</p><ul><li>使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</li><li>开发中一般使用线程池的方式</li></ul><h2 id="三、Linux-Windows命令查看进程和线程"><a href="#三、Linux-Windows命令查看进程和线程" class="headerlink" title="三、Linux Windows命令查看进程和线程"></a>三、Linux Windows命令查看进程和线程</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul><li>任务管理器查看进程和线程，杀死进程</li><li> <code>tasklist</code> 查看进程</li><li><code>taskkill /F /PID 进程号</code> 杀死进程</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><code>ps -fe </code>查看所有进程</li><li><code>ps -ft -p &lt;PID&gt;</code> 查看某个进程的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>pkill -9 &lt;PID&gt;</code> 杀死进程，-9代表一类操作，杀死进程</li><li><code>top</code> 查看进程信息</li><li><code>top -H -P &lt;PID&gt;</code> 查看某个进程PID的所有线程</li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><code>jps</code> 查看所有Java进程</li><li><code>jstack &lt;PID&gt;</code> 查看某个Java进程的所有线程状态</li><li><code>jconsole</code> 连接查看某个Java进程中线程的运行情况（Windows直接win+r 输入jconsole，图形界面）</li></ul><h2 id="线程运行原理-重点"><a href="#线程运行原理-重点" class="headerlink" title="线程运行原理 (重点)"></a>线程运行原理 (<code>重点</code>)</h2><h3 id="虚拟机栈与栈帧"><a href="#虚拟机栈与栈帧" class="headerlink" title="虚拟机栈与栈帧"></a>虚拟机栈与栈帧</h3><ul><li>虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法被执行</strong>的时候都会同时创建一个<strong>栈帧(stack frame)<strong>用于</strong>存储局部变量表</strong>、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。当Java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧(在栈顶)，<strong>对应着当前正在执行的那个方法</strong>。</li><li>每个线程都拥有自己的一个栈内存，里面对应着多个栈帧。可以用IDEA开启线程模式的调试功能。</li></ul><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101108334.png" alt="image-20220115101108334"></p><p>t1线程的多个栈帧：</p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115100910857.png" alt="image-20220115100910857"></p><p>主线程的多个栈帧：</p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101011097.png" alt="image-20220115101011097"></p><h3 id="线程上下文切换（Thread-Context-Switch"><a href="#线程上下文切换（Thread-Context-Switch" class="headerlink" title="线程上下文切换（Thread Context Switch)"></a>线程上下文切换（Thread Context Switch)</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程</p><ul><li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当Thread Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>线程的状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能，所以线程数也不能过多，如果线程数大于CPU核心数，可能并不会提升性能</li></ul><h3 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h3><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111642378.png" alt="image-20220115111642378"></p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111913619.png" alt="image-20220115111913619"></p><h4 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h4><h5 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h5><p>调用 sleep() 会让当前线程从 Running(运行状态) 进入 Timed Waiting 状态（阻塞）<br>其它线程可以使用interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 InterruptedException异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】<br>睡眠结束后的线程未必会立刻得到执行 (需要分配到cpu时间片)<br>建议用 TimeUnit 的 sleep() 代替 Thread 的 sleep()来获得更好的可读性</p><h5 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h5><p>调用 yield 会让当前线程从Running 进入 Runnable 就绪状态，然后调度执行其它线程</p><p>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</p><p>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>线程<code>优先级</code>会<code>提示（hint）调度器优先调度该线程</code>，但它仅仅是一个提示，调度器可以忽略它, 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><ul><li>在<code>主线程</code>中调用<code>t1.join</code>，则<code>主线程</code>会<code>等待t1线程执行完之后</code>再<code>继续执行</code></li></ul><h4 id="interrupt-方法详解"><a href="#interrupt-方法详解" class="headerlink" title="interrupt 方法详解"></a>interrupt 方法详解</h4><p>该方法用于打断 sleep，wait，join的线程, 在阻塞期间cpu不会分配给时间片</p><ul><li><p>如果一个线程在在运行中被打断，打断标记会被置为true</p></li><li><p>如果是打断因sleep wait join方法而被阻塞的线程，只是会抛出一个Interrupted 异常，以这个异常来表示线程被打断了，打断标记仍然是false</p></li></ul><p>sleep，wait，join的线程，这几个方法都会让线程进入阻塞状态，join方法底层就是用的wait方法，以 sleep 为例，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>); <span class="comment">// wait, join</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;iterrupt..&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.isInterrupted()); <span class="comment">// 如果是打断sleep,wait,join的线程, 即使打断了, 标记也为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sleep...</span><br><span class="line">iterrupt..</span><br><span class="line">打断标记为:<span class="keyword">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.zc.ThreadPrintDemo.lambda$main$<span class="number">0</span>(ThreadPrintDemo.java:<span class="number">14</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h5><ul><li>调用Interrupt方法去打断一个正在运行的线程，就好比是一个打断请求，只是把其打断标记记为True，实际上是不是要被打断由线程自己决定，线程并不会直接暂停。我们可以判断<code>Thread.currentThread().isInterrupted();</code>的值来手动停止线程</li><li>这样可以方便当线程被打断时做一些后续的操作，料理线程后事</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被打断了, 退出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;打断标记为: &quot;</span>+t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interrupt</span><br><span class="line">被打断了, 退出循环</span><br><span class="line">打断标记为: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="终止模式之两阶段终止模式-多线程设计模式"><a href="#终止模式之两阶段终止模式-多线程设计模式" class="headerlink" title="终止模式之两阶段终止模式(多线程设计模式)"></a>终止模式之两阶段终止模式(多线程设计模式)</h4><p>当我们在执行线程一时，想要终止线程二，这时就需要使用interrupt方法来优雅的停止线程二。</p><h5 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h5><ul><li><p>使用线程对象的stop()方法停止线程</p><p>stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p></li><li><p>使用System.exit(int)方法停止线程</p><p>目的仅是停止一个线程，但这种做法会让整个程序都停止</p></li></ul><p>如下所示：那么线程的isInterrupted()方法可以取得线程的打断标记</p><p>如果线程在睡眠sleep期间被打断，打断标记是不会变的，为false，但是sleep期间被打断会抛出异常，我们据此手动设置打断标记为true；<br>如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为true。处理好这两种情况那我们就可以放心地来料理后事啦！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">monitor.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">monitor.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置线控器线程，用于监控线程状态</span></span><br><span class="line">monitor = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//开始不停的监控</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">//判断当前线程是否被打断了</span></span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;处理后续任务&quot;</span>);</span><br><span class="line">                        <span class="comment">//终止线程执行</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;监控器运行中...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//线程休眠</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span></span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">monitor.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于停止监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//打断线程</span></span><br><span class="line">monitor.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sleep，yiled，wait，join-对比"><a href="#sleep，yiled，wait，join-对比" class="headerlink" title="sleep，yiled，wait，join 对比"></a>sleep，yiled，wait，join 对比</h4><ul><li>sleep，join，yield，interrupted是Thread类中的方法</li><li>wait/notify是object中的方法</li><li>sleep 不释放锁、释放cpu</li><li>join 释放锁、抢占cpu</li><li>yiled 不释放锁、释放cpu</li><li>wait 释放锁、释放cpu</li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>当Java进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，Java进程才会结束。但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</p><p>注意:</p><p>垃圾回收器线程就是一种守护线程<br>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会继续等待</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即Thread thread = new Thread();，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行</p><ul><li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li><p>阻塞状态<br>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】<br>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p><p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h3 id="Java-API层面"><a href="#Java-API层面" class="headerlink" title="Java API层面"></a>Java API层面</h3><p>根据<code>Thread.State 枚举，分为六种状态</code></p><ul><li><strong><code>新建状态</code>、<code>运行状态</code>(就绪状态, 运行中状态)、<code>阻塞状态</code>、<code>等待状态</code>、<code>定时等待状态</code>、<code>终止状态</code></strong></li></ul><ul><li><strong>NEW (新建状态)</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE (运行状态)</strong> 当调用了 start() 方法之后，注意，Java API 层面的<strong>RUNNABLE 状态</strong>涵盖了操作系统层面的 <strong>【就绪状态】、【运行中状态】和【阻塞状态】</strong>（由于 BIO 导致的线程阻塞，比如在读取文件时的操作系统层面的阻塞，也认为是运行状态，在 Java 里无法区分，仍然认为是可运行）</li><li><strong>BLOCKED (阻塞状态)</strong> ， <strong>WAITING (等待状态)</strong> ， <strong>TIMED_WAITING(定时等待状态)</strong> 都是 Java API 层面对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。</li><li><strong>TERMINATED (结束状态)</strong> 当线程代码运行结束</li></ul>]]></content>
    
    
    <summary type="html">线程的几种创建方式，线程设计原理，线程常用方法，多线程设计模式之两阶段终止模式</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized底层原理</title>
    <link href="http://ins1mn1a.github.io/2022/01/17/JUC/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/"/>
    <id>http://ins1mn1a.github.io/2022/01/17/JUC/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</id>
    <published>2022-01-17T10:26:55.173Z</published>
    <updated>2022-01-17T10:34:59.465Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Synchronized底层原理</li><li>Monitor 监视器、管程</li><li>轻量级锁</li><li>重量级锁</li><li>偏向锁</li></ul><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p><strong>对象头</strong>包含两部分：Mark Word和<strong>类型指针</strong> (Klass Word)</p><ol><li>Mark Word<ul><li>哈希值（HashCode），可以看作是堆中对象的地址</li><li>GC分代年龄（年龄计数器） (用于新生代from/to区晋升老年代的标准, 阈值为15)</li><li>锁状态标志 (用于JDK1.6对synchronized的优化 -&gt; 轻量级锁)</li><li>线程持有的锁</li><li>偏向线程ID (用于JDK1.6对synchronized的优化 -&gt; 偏向锁)</li><li>偏向时间戳</li></ul></li><li>类型指针<ul><li>确定该对象所属的类型。指向的其实是方法区中存放的类元信息<code>Class</code>字节码信息</li></ul></li></ol><p>说明：<strong>如果对象是数组，还需要记录数组的长度</strong></p><ul><li>以 <strong>32 位虚拟机</strong>为例,普通对象的对象头结构如下，其中的Klass Word为类型指针，指向方法区`对应的Class对象；</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230503852.png" alt="image-20220115230503852"></p><ul><li>数组对象</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230515921.png" alt="image-20220115230515921"></p><ul><li><strong>其中 Mark Word 结构为: 无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)</strong></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230553563.png" alt="image-20220115230553563"></p><ul><li>所以一个对象的结构如下：</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230631675.png" alt="image-20220115230631675"></p><h2 id="Monitor-原理-Synchronized底层实现-重量级锁"><a href="#Monitor-原理-Synchronized底层实现-重量级锁" class="headerlink" title="Monitor 原理 (Synchronized底层实现-重量级锁)"></a>Monitor 原理 (Synchronized底层实现-重量级锁)</h2><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p><strong>多线程同时访问临界区: 使用重量级锁</strong></p><ul><li>JDK6对Synchronized的优先状态：<code>偏向锁–&gt;轻量级锁–&gt;重量级锁</code></li></ul><p>每个Java对象都可以关联一个(操作系统的)<strong>Monitor</strong>。如果使用synchronized给对象上锁（<strong>重量级</strong>），该对象头的MarkWord中就被设置为指向Monitor对象的指针。</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115231347421.png" alt="image-20220115231347421"></p><p>上图是关联Monitor的原理图，可以理解为：</p><ul><li>Thread2最初执行到<strong>锁对象synchronized(obj)<strong>，会尝试让锁对象synchronized(obj)<strong>关联Monitor</strong>，如果</strong>关联成功</strong>，则将obj对象头的<strong>MarkWord</strong>字段<strong>指向Monitor的地址</strong>，同时将其后两位从<strong>00</strong>设置为10，<strong>Thread2</strong>会成为对应Monitor的<strong>Owner</strong>；</li><li>后续有<strong>Thread1</strong>也执行到了synchronized(obj)，会检查发现obj<strong>已经</strong>有了一个关联的monitor，其<strong>Owner为Thread2</strong>，然后Thread1也会同Monitor关联起来，只不过是<strong>和EntryList关联</strong>，会进入Monitor的EntryList<strong>阻塞（BLOCKED）</strong>起来，等待；</li><li>当<strong>Thread2执行完</strong>临界区代码后，Monitor的Owner就会空出来，此时就会<strong>通知EntryList阻塞队列</strong>的线程，这些线程经过<strong>竞争</strong>，得出新的<strong>Owner</strong>；</li><li>图中 WaitSet 中的线程是之前获得过锁，但条件不满足调用锁对象的wait方法进入 WAITING 状态的线程</li></ul><p><strong>注意：</strong></p><ul><li>synchronized 必须是进入同一个锁对象的 Monitor 才有上述的效果；也就要使用同一把锁</li><li>不加 synchronized的锁对象不会关联监视器，不遵从以上规则</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>它加锁就是依赖底层操作系统的 <code>mutex</code>相关指令实现, 所以会造成<code>用户态和内核态之间的切换</code>, 非常耗性能 !</p><ul><li>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗。</li></ul><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反编译的字节码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">stack&#x3D;2，locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">0: getstatic#2&#x2F;&#x2F; &lt;- lock引用( synchronized开始)</span><br><span class="line">3: dup</span><br><span class="line">4: astore_1&#x2F;&#x2F; lock引用-&gt; slot 1</span><br><span class="line">5: monitorenter&#x2F;&#x2F; 将lock对象Markword置为Monitor指针</span><br><span class="line">6: getstatic#3&#x2F;&#x2F; &lt;- i</span><br><span class="line">9: iconst_1&#x2F;&#x2F; 准备常数1</span><br><span class="line">10: iadd&#x2F;&#x2F; +1</span><br><span class="line">11: putstatic#3&#x2F;&#x2F; -&gt; i</span><br><span class="line">14: aload_1&#x2F;&#x2F; &lt;- lock引用</span><br><span class="line">15: monitorexit&#x2F;&#x2F; 将lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">16: goto24</span><br><span class="line">19: astore_2&#x2F;&#x2F; e -&gt; slot 2</span><br><span class="line">20: aload_1&#x2F;&#x2F; &lt;- lock引用</span><br><span class="line">21: monitorexit&#x2F;&#x2F; 将lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">22: aload_2&#x2F;&#x2F; &lt;- slot 2 (e)</span><br><span class="line">23: athrow&#x2F;&#x2F; throw e</span><br><span class="line">24: return</span><br><span class="line">    Exception table:</span><br><span class="line">        fromtotargettype</span><br><span class="line">            61619any</span><br><span class="line">            192219any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 6</span><br><span class="line">        line 10: 14</span><br><span class="line">        line 11: 24</span><br><span class="line">    LocalVariableTable:</span><br></pre></td></tr></table></figure><p>上面除了体现了正常执行的代码以外，还体现了异常情况。在16的时候goto到24。Exception table描述了异常的情况处理从19到22。</p><p>方法级别的 synchronized 不会在字节码指令中有所体现</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗。所以MarkWord对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁</p><p>轻量级锁用于优化重量级锁</p><p>通过<code>锁记录</code>的方式, 场景 : <strong>多个线程交替进入临界区</strong></p><ul><li><strong><code>轻量级锁的使用场景</code>: 如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用<code>轻量级锁来进行优化</code>。</strong></li></ul><ul><li>轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code> (jdk6对synchronized的优化)，假设有两个方法同步块，利用同一个对象加锁</li></ul><p>在method1加完锁的同时，调用了method2又会加锁synchronized(obj)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 B</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次执行到synchronized代码块时，都会在<code>栈帧中</code>创建<code>锁记录（Lock Record）对象</code>，锁记录内部最开始储存的是<code>lock record的地址 00</code>和<code>锁对象引用reference</code>。还有一个Object锁对象，锁对象头中存储的<strong>MarkWord</strong>（MarkWord包含了HashCode，分代年龄，偏向锁，加锁状态位），Klass Word表示是哪一类的对象。</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092015889.png" alt="image-20220116092015889"></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092231673.png" alt="image-20220116092231673"></p><ul><li>让锁记录中的<strong>Object reference</strong>指向<strong>锁对象地址</strong>，并且尝试用<strong>CAS(compare and swap)<strong>将栈帧中的</strong>锁记录的的地址</strong>(lock record 地址 00)替换Object对象的<strong>Mark Word</strong>，将Mark Word 的值存入锁记录原先存地址的地方(lock record地址 00)，这个交换是一个原子性的操作。这两个字段的后两位标识着一个状态，起到一个标志作用。01表示无锁，00表示轻量级锁，所以在交换成功后，Object存Mark Word的地方后两位就变成了00，就是一个轻量级锁的状态</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092637419.png" alt="image-20220116092637419"></p><p>如果cas<strong>替换成功</strong>，那么对象的对象头储存的就是锁记录的地址和状态00，表示由该线程给对象加锁</p><ul><li>线程中锁记录，记录了锁对象的锁状态标志；锁对象的对象头中存储了锁记录的地址和状态, 标志哪个线程获得了锁</li><li>此时栈帧中存储了对象的对象头中的锁状态标志,年龄计数器,哈希值等; 对象的对象头中就存储了栈帧中锁记录的地址和状态00, 这样的话对象就知道了是哪个线程锁住自己。</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116093326551.png" alt="image-20220116093326551"></p><p>如果cas<strong>替换失败</strong>，有两种情况 : ① 锁膨胀 ② 重入锁失败</p><p>1、如果是其它线程已经持有了该Object的轻量级锁（观察到Object对象头中已经存储了别的线程的锁记录地址 00,指向了其他线程），表示有竞争，将进入锁膨胀阶段</p><p>2、如果是自己的线程已经执行了synchronized进行加锁，那么再添加一条 Lock Record 作为重入锁的计数，同样按照正常的流程去cas交换，但这次交换肯定是失败的，发现这个锁是自己这个线程加的，其中记录锁地址的地方为null。（线程多次加锁, <strong>锁重入</strong>）</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116093748640.png" alt="image-20220116093748640"></p><p>在上面代码中,临界区中又调用了method2，method2中又进行了一次synchronized加锁操作， 此时就会在虚拟机栈中再开辟一个method2方法对应的栈帧(栈顶)， 该栈帧中又会存在一个独立的Lock Record，此时它发现对象的对象头中指向的就是自己线程中栈帧的锁记录; 加锁也就失败了。这种现象就叫做<strong>锁重入</strong>，线程中有多少个锁记录，就能表明该线程对这个对象加了几次锁 (锁重入计数)</p><ul><li><p>当<code>线程退出synchronized代码块</code>的时候，如果获取的是取值为 null 的锁记录，表示有<code>锁重入</code>，这时重置锁记录，表示重入计数减一</p></li><li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null；那么使用cas将Mark Word的值恢复给对象，将直接替换的内容还原。</p><ul><li>成功则解锁成功 (轻量级锁解锁成功)</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程 (Monitor流程)</li></ul></li></ul><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>锁膨胀就是当Thread0已经让某个对象加了轻量级锁，Thread0里的锁记录存着对象的MarkWord，锁对象obj的MarkWord又存着锁记录的地址，这个时候有一个Thread1也执行到了synchronized，也想对obj进行加锁，但是肯定是加锁失败的，Thread1发现锁对象的MarkWord里已经是00了，即已经是轻量级锁了。</p><ul><li><p><strong>因为轻量级锁没有阻塞队列的概念，因此会进入锁膨胀的过程，让锁成为一个重量级锁。</strong>这时Thread1就会为锁对象obj申请一个monitor，让obj的MarkWord执行monitor的地址，并且后两位为01表示重量级锁，monitor将Owner设为Thread0，Thread1则进入Monitor的EntryList阻塞起来</p></li><li><p>在<strong>Thread0执行完毕</strong>后，想要恢复锁记录的地址和MarkWord的时候，肯定会恢复失败，发现原来obj的MarkWord已经是<strong>01重量级锁</strong>了，即进行了<strong>锁膨胀</strong>，因此Thread0<strong>进入重量级锁的解锁流程</strong>，会根据<strong>obj的MarkWord</strong>（这时指向的是对象obj的Monitor）找到对应的monitor，将monitor的Owner设为空，<strong>唤醒EntryList</strong>中的<strong>Thread1</strong>。</p></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116100043133.png" alt="image-20220116100043133"></p><h2 id="自旋锁优化（优化重量级锁竞争）"><a href="#自旋锁优化（优化重量级锁竞争）" class="headerlink" title="自旋锁优化（优化重量级锁竞争）"></a>自旋锁优化（优化重量级锁竞争）</h2><ul><li>发生<strong>重量级锁竞争</strong>的时候，还可以使用<strong>自旋</strong>来进行优化 (不加入Monitor的阻塞队列EntryList中)，如果当前线程<strong>自旋成功</strong>（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以<strong>不用进行上下文切换</strong>(持锁线程执行完synchronized同步块后，释放锁，Owner为空，唤醒阻塞队列来竞争，胜出的线程得到cpu执行权的过程) 就获得了锁</li><li>优化的点: <strong>不用将线程加入到阻塞队列, 减少cpu切换</strong>。</li></ul><p><strong>自旋成功的情况：</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116101816612.png" alt="image-20220116101816612"></p><p><strong>自旋失败的情况：</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116101902140.png" alt="image-20220116101902140"></p><ul><li><p><strong>自旋会<code>占用 CPU 时间</code>，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势</strong>。</p></li><li><p>在 <code>Java 6 之后自旋锁是自适应</code>的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能。</p></li></ul><h2 id="偏向锁-biased-lock-用于优化轻量级锁重入"><a href="#偏向锁-biased-lock-用于优化轻量级锁重入" class="headerlink" title="偏向锁 (biased lock) (用于优化轻量级锁重入)"></a>偏向锁 (biased lock) (用于优化轻量级锁重入)</h2><ul><li>场景: 没有竞争的时候, 一个线程中多次使用synchronized需要重入加锁的情况; (只有一个线程进入临界区)</li></ul><p>在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭，将进入临界区的线程的ID, 直接设置给锁对象的Mark Word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了。</p><ul><li>在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行CAS替换操作，这是有点耗时。</li><li>那么java6开始引入了偏向锁，将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了</li><li><strong>升级为轻量级锁</strong>的情况 (会进行偏向锁撤销)：获取偏向锁的时候, 发现线程ID不是自己的, 此时通过<strong>CAS替换操作, 操作成功</strong>了, 此时该线程就获得了锁对象。( <strong>此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁</strong>)</li><li><strong>升级为重量级锁</strong>的情况 (会进行偏向锁撤销) : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过<strong>CAS替换操作, 操作失败</strong>了, 此时说明发生了锁竞争。( <strong>此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁</strong>)</li></ul><h2 id="偏向、轻量级、重量级锁关系"><a href="#偏向、轻量级、重量级锁关系" class="headerlink" title="偏向、轻量级、重量级锁关系"></a>偏向、轻量级、重量级锁关系</h2><p>最开始synchronized锁只有重量级锁，依赖操作系统的mutex指令，需要用户态和内核态切换，性能损耗明显。重量级锁需要用到monitor对象，而偏向锁则是MarkWord中记录线程的ID，如果某个线程发现Mark Word线程的ID是自己，就不需cas交换锁记录地址和MarkWord。如果不是发现对象的MarkWord中线程ID不是自己，此时就需要通过CAS替换操作，如果<strong>操作成功</strong>，就说明有<strong>多个线程访问临界区</strong>，但是是<strong>交替进行</strong>的，就<strong>撤销偏向锁</strong>，<strong>升级为轻量级锁</strong>，如果<strong>操作失败</strong>，就说明有<strong>多个线程方法临界区</strong>，并且存<strong>在锁竞争</strong>，就撤销偏向锁，<strong>升级为重量级锁</strong>。</p><p><strong>偏向锁</strong>是将锁对象<strong>MarkWord的线程ID</strong>和自己的线程<strong>ID比对</strong>，<strong>轻量级锁</strong>则是将MarkWord和Lock Record进行交换，采用<strong>CAS+自旋</strong>的方式判断是否存在竞争，然后加重量级锁，<strong>重量级锁</strong>则是采用<strong>Monitor</strong>，用<strong>阻塞队列</strong>的形式，将后续线程阻塞起来。</p><ol><li>只有一个线程进入临界区—&gt;偏向锁</li><li>多个线程交替进入临界区—&gt;轻量级锁</li><li>多个线程竞争进入临界区—&gt;重量级锁</li></ol><h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p><strong>64bit虚拟机</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116112754583.png" alt="image-20220116112754583"></p><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</li></ul><ul><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，最后2位为状态（00）</li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，最后2位为状态(10)</li></ul><p>如果开启了<strong>偏向锁</strong>（<strong>默认开启偏向锁</strong>），在创建对象时，对象的Mark Word后三位应该是101</p><p>但是偏向锁<strong>默认是有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态。如果想避免延迟，可以添加虚拟机参数来禁用延迟：</p><p><strong><code>-XX:BiasedLockingStartupDelay=0</code></strong></p><p>打印出101，这时它的hashcode、age都为0，表示它现在是一种<strong>可以偏向的状态</strong>，或者叫匿名偏向锁的状态，也就是说biased_lock位是1，可以偏向，要<strong>真正加锁</strong>还**需要加上synchronized(obj)**。</p><p>这加了synchronized(obj)之后，才是真正加了偏向锁的状态。</p><p>可以用org.openjdk.jol包打印信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">log.debug( classLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">synchronized</span> (d)&#123;</span><br><span class="line">log.debug( ClassLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">log.debug( classLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="撤销偏向锁-hashcode方法-了解"><a href="#撤销偏向锁-hashcode方法-了解" class="headerlink" title="撤销偏向锁-hashcode方法 (了解)"></a>撤销偏向锁-hashcode方法 (了解)</h3><ul><li>测试 <code>hashCode</code>：当<code>调用对象的hashcode方法</code>的时候就会<code>撤销这个对象的偏向锁</code>，<strong>因为使用偏向锁时没有位置存<code>hashcode</code>的值了</strong></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116115419509.png" alt="image-20220116115419509"></p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>在下面的代码中，b方法采用了synchronized，但可以发现它加的对象锁其实并没有启到作用。</p><p>JIT即时编译器会优化热点代码，JIT借助<strong>逃逸分析</strong>发现对象o不能逃离这个方法，对这样的对象加锁是没有意义的，因此JIT即时编译器会把synchronized优化掉，进行锁消除。</p><p>我们也可以在测试的时候加上JVM参数，让它不进行锁消除，<code>-XX:-EliminateLocks</code></p><p>字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，**<code>同步省略（锁消除）操作是在解释运行时发生的</code>**</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">            x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="wait、notify"><a href="#wait、notify" class="headerlink" title="wait、notify"></a>wait、notify</h2><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220117094637795.png" alt="image-20220117094637795"></p><p>Thread0线程<strong>获取到了对象Obj的锁</strong>，成为Monitor的Owner时候，发现自己执行synchronized代码块条件不满足，这时它就会调用**obj.wait()**方法，进入到Monitor的WaitSet集合，此时Thread0处于WAITING状态。</p><ul><li>处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。</li><li>但是有所区别：<ul><li>BLOCKED状态的线程是在竞争锁对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身的原因无法执行synchroized的临界区资源需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li><li><strong>BLOCKED线程</strong>会在<strong>Owner线程释放锁</strong>的时候被<strong>唤醒</strong></li><li><strong>WATITING线程</strong>会在Owner线程调用锁对象的<strong>notify</strong>或者<strong>notifyALL</strong>方法时唤醒，但唤醒后并不意味着立刻获得锁，仍需<strong>进入EntryList重新竞争</strong></li></ul></li></ul><h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><p>下面的三个方法都是Object中的方法; 通过锁对象来调用</p><p>**wait()**：让获得对象锁的线程到waitSet中一直等待</p><p>**wait(long n)**：当该等待线程没有被notify, 等待时间到了之后, 也会自动唤醒</p><p>**notify()**：让获得对象锁的线程, 使用锁对象调用notify去waitSet的等待线程中挑一个唤醒</p><p>**notifyAll()**：让获得对象锁的线程, 使用锁对象调用notifyAll去唤醒waitSet中所有的等待线程</p><p>它们都是线程之间进行协作的手段, 都属于Object对象的方法, 必须获得此对象的锁, 才能调用这些方法</p><p><strong>注：只有当对象被锁以后(成为Owner)，才能调用wait和notify方法</strong></p><p>拥有锁才能wait</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">LOCK.wait();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sleep-long-n-和-Wait-long-n-的区别"><a href="#Sleep-long-n-和-Wait-long-n-的区别" class="headerlink" title="Sleep(long n) 和 Wait(long n)的区别"></a>Sleep(long n) 和 Wait(long n)的区别</h3><ul><li><p>不同点</p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li><strong>Sleep</strong>在阻塞的时候<strong>不会释放锁</strong>，而<strong>Wait</strong>在阻塞的时候会<strong>释放锁</strong> (不释放锁的话, 其他线程就无法唤醒该线程了)</li><li>Sleep方法不需要与synchronized一起使用，而Wait方法需要与synchronized一起使用（wait/notify等方法, <strong>必须要使用对象锁来调用</strong>）</li></ul></li><li><p>相同点</p><ul><li>阻塞状态都为TIMED_WAITING (限时等待)</li></ul></li></ul><h3 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3><p>对象的WaitSet中有多个等待线程，而<strong>notify只能挑一个唤醒</strong>，并<strong>不能指定唤醒线程</strong>，所以有可能会出现<strong>虚假唤醒的状态</strong>。采用notifyAll会唤醒所有线程，但是这样会把其他条件可能仍然不满足的线程唤醒。对于那些线程来说也是一个虚假唤醒。</p><p>因此，那些线程必须得把<strong>If(条件)+wait的方法</strong>改为<strong>while(条件)+wait</strong>的方法，避免采用if判断语句被虚假唤醒后直接结束了，让其<strong>被虚假唤醒后</strong>发现仍然条件不满足，会<strong>继续调用wait方法</strong>再次等待。</p><h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><p>这是一种多线程设计模式，rpc框架的调用中就使用到了这种模式。</p><p>一个线程等待另一个线程的执行结果，一对一的情况，也就是一个生产者对应一个消费者。</p><p>线程2等待线程1执行完毕，线程1执行完后会改变它俩共享变量的状态，线程2据此来判断消费。同时还可以设置超时时间，线程2等到一定时间后就不再等待，退出while循环。</p><p>**join(long millis)**方法和future的原理都用到了这种模式</p><p>join方法设置了超时时间millis，判断是否isAlive()，如果线程还存活，就最多等待millis，<strong>注意每次循环等待时间为delay而不是millis</strong>，防止被虚假唤醒后，下次的等待时间仍然是millis，这显然不对</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多任务版的保护性暂停就需要把公共的锁对象GuardedObject，抽象出来到一个整体，比如一个邮箱，然后里面的每一个对应的信件GuardedObject就是一个锁。</strong></p><h2 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h2><p>这种生产者/消费者模式<strong>不需要一一对应</strong>，也就是说不需要一个生产者对应一个消费者，可以是多个生产者生产，只要生产了，消费者都能用。</p><p>左边三个生产者，生产了就put进中间的<strong>消息队列</strong>，消息队列存放生产者生产出的产品，那右边就一个消费者，只要消息队列里面有产品，那就可以消费。</p><p>这样生产者只关注自己能不能产生结果，消费者只关注自己能不能消费结果。</p><p>消息队列是有容量限制的，不能消费空数据，容量满也不能产生新数据。</p><p>RabbitMQ的原理也类似，但是MQ是实现进程之间的通信。</p><h2 id="park和unpark方法"><a href="#park和unpark方法" class="headerlink" title="park和unpark方法"></a>park和unpark方法</h2><ul><li>park和unpark是LockSupport的方法，可以<strong>指定线程</strong>唤醒。</li><li>park方法是让当前线程进入WAITING状态，unpark方法是让指定线程唤醒</li></ul><p><strong>但是unpark方法可以先执行，后再进行park</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Thread t1 start&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure><h3 id="park、unpark原理"><a href="#park、unpark原理" class="headerlink" title="park、unpark原理"></a>park、unpark原理</h3><p>每一个线程都有自己的<strong>Parker对象</strong>，由三部分组成：</p><ul><li>_counter：相当于一个信号量，只有0和1的状态</li><li>_cond：条件变量，相当于线程的阻塞队列</li><li>_mutex：互斥锁，关联一个 _cond</li></ul><h4 id="先调用park再调用unpark"><a href="#先调用park再调用unpark" class="headerlink" title="先调用park再调用unpark"></a>先调用park再调用unpark</h4><p>调用<strong>park</strong>方法：</p><ul><li><strong>线程t1</strong>，先<strong>调用park方法</strong>，检查_counter的值，发现为0，这时会获得一个互斥锁 _mutex，然后线程进入cond等待队列阻塞，同时还需要<strong>再设置counter为0</strong></li></ul><p>调用**unpark(t1)**方法：</p><ul><li><strong>设置counter为1</strong>，<strong>唤醒</strong>cond中的<strong>线程t1</strong>，t1恢复运行，设置counter为0</li></ul><h4 id="先调用unpark再调用park"><a href="#先调用unpark再调用park" class="headerlink" title="先调用unpark再调用park"></a>先调用unpark再调用park</h4><ul><li>设置counter为1，当前线程调用park方法，检查counter，无需阻塞继续运行，设置counter为0</li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2>]]></content>
    
    
    <summary type="html">Java对象MarkWord，偏向锁、轻量级锁、重量级锁、锁膨胀、</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ins1mn1a.github.io/2022/01/11/Bug%E4%B9%8B%E7%8E%8B/log4j%E7%9A%84mave%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>http://ins1mn1a.github.io/2022/01/11/Bug%E4%B9%8B%E7%8E%8B/log4j%E7%9A%84mave%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-11T14:18:59.692Z</published>
    <updated>2022-01-11T14:38:18.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ClassNotFoundException：org-apache-log4j-logger"><a href="#ClassNotFoundException：org-apache-log4j-logger" class="headerlink" title="ClassNotFoundException：org.apache.log4j.logger"></a>ClassNotFoundException：org.apache.log4j.logger</h3><p>最初的问题是报错ClassNotFoundException：org.apache.log4j.logger</p><p>说明在maven依赖中有某个依赖用到了org.apache.log4j.logger，而maven依赖中又没有引入log4j</p><p>我的项目中是有一个dubbo的依赖，排除了servlet-api防止依赖冲突，没有排除log4j，并且没有引入log4j</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dubbo.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，解决方法有两种</p><ol><li>直接把dubbo依赖中的log4j排除</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.dubbo.springboot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>不排除dubbo中的log4j，增加一个log4j依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="IllegalArgumentException-LoggerFactory-is-not-a-Logback-LoggerContext-but-Logback-is-on-the-classpath"><a href="#IllegalArgumentException-LoggerFactory-is-not-a-Logback-LoggerContext-but-Logback-is-on-the-classpath" class="headerlink" title="IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath."></a>IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath.</h3><p>完整报错信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;ASUS&#x2F;.m2&#x2F;repository&#x2F;org&#x2F;slf4j&#x2F;slf4j-log4j12&#x2F;1.7.30&#x2F;slf4j-log4j12-1.7.30.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;ASUS&#x2F;.m2&#x2F;repository&#x2F;ch&#x2F;qos&#x2F;logback&#x2F;logback-classic&#x2F;1.2.3&#x2F;logback-classic-1.2.3.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing implementation</span><br></pre></td></tr></table></figure><p>这个问题是因为slf4j的依赖冲突，spring-boot-starter正常打印日志是采用的logback，在引入了slf4j-log4j12的情况下会有两个绑定，</p><p>根据提示信息就可以发现，有两种解决方案：</p><ol><li>移除slf4j-log4j12</li><li>把spring-boot-starter-logging移除</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ClassNotFoundException：org-apache-log4j-logger&quot;&gt;&lt;a href=&quot;#ClassNotFoundException：org-apache-log4j-logger&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>经典排序算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.212Z</published>
    <updated>2022-01-09T02:55:46.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="部分排序算法"><a href="#部分排序算法" class="headerlink" title="部分排序算法"></a>部分排序算法</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆是一种数据结构，一种叫做完全二叉树的数据结构。</p><p>大顶堆：每个节点的值都大于或者等于它的左右子节点的值。</p><p>小顶堆：每个节点的值都小于或者等于它的左右子节点的值。</p><h3 id="最大堆的构建过程"><a href="#最大堆的构建过程" class="headerlink" title="最大堆的构建过程"></a>最大堆的构建过程</h3><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110195006939.png" alt="image-20211110195006939"></p><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110194953869.png" alt="image-20211110194953869"></p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ol><li>将待排序的序列构建成一棵树，然后最大堆化，形成一个大顶堆。这样，大顶堆的根结点一定是当前序列中最大的一个元素。</li><li>将根结点取出，将堆的最后一个元素换到根结点处，然后重新构建成一个大顶堆，同样使得最大的元素位于根结点。</li><li>重复步骤2，每次都能获得一个最大值，这样就排成了一个有序的序列。</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">&#123;</span><br><span class="line">l&lt;-LEFT(i)</span><br><span class="line"> r&lt;-RIGHT(i)</span><br><span class="line"><span class="keyword">if</span> l &lt;= heap-size[A] and A[l]&gt;A[i]</span><br><span class="line">then largest&lt;-l</span><br><span class="line"><span class="keyword">else</span> largest&lt;-i</span><br><span class="line"><span class="keyword">if</span> r &lt;= heap-size[A] and A[r]&gt;A[largest]</span><br><span class="line">then largest&lt;-r</span><br><span class="line"><span class="keyword">if</span> largest ≠ i</span><br><span class="line">then exchange A[i]&lt;-&gt;A[largest]</span><br><span class="line">MAX-HEAPIFY(A,largest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">&#123;</span><br><span class="line">heap-size[A] &lt;- length [A]</span><br><span class="line"> <span class="keyword">for</span> i &lt;- length[A]/<span class="number">2</span> downto <span class="number">1</span></span><br><span class="line"><span class="keyword">do</span> MAX-HEAPIFY(A,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HEAPSORT(A)</span><br><span class="line">&#123;</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line"><span class="keyword">for</span> i length[A] downto <span class="number">2</span></span><br><span class="line"><span class="keyword">do</span> exchange A[<span class="number">1</span>] A[i]</span><br><span class="line">heap-size[A]  heap-size[A]-<span class="number">1</span></span><br><span class="line">MAX-HEAPIFY(A,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>计数排序不基于比较，它只适用于待排序序列数值范围相差不大的情况下，否则，会造成大量的数组空间的浪费。</p><p>待排序序列A[1:n]，将辅助空间数组C[1:k]初始化为0，其中k为A[1:n]的最大取值，也可以直接设为n。对数组A的每一个数遍历一次，将数作为数组C[1:k]的的下标值，将对应值加1，这样，数组C[1:k]就记录了数组A[1:n]中每个数的出现次数，即A[i]的出现次数为C[ A[i] ]。然后，只需要对数组C遍历，每次遍历到C[i]用一个while循环，做C[i]–，直到C[i]=0。</p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110204919521.png" alt="image-20211110204919521"></p><p>插入排序    稳定</p><p>快速排序    不稳定    在位</p><p>归并排序    稳定        不在位</p><p>堆排序        不稳定    在位</p><p>计数排序    稳定        不在位</p><p>基数排序    稳定        不在位</p>]]></content>
    
    
    <summary type="html">包括堆排序，计数排序等</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.180Z</published>
    <updated>2022-01-09T02:55:07.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="回溯法的基本思想"><a href="#回溯法的基本思想" class="headerlink" title="回溯法的基本思想"></a>回溯法的基本思想</h2><p>回溯法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。</p><p>回溯法从开始结点（根结点）出发，以深度优先方式搜索整个解空间。这个开始结点成为活结点，同时也成为当前的扩展结点。在当前扩展结点处，搜索向纵深方向移至一个新结点，同时，也成为当前的扩展结点。</p><h2 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h2><p>当所给的问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间树称为子集树。</p><p>例如：n个物品的0-1背包问题所相应的解空间树是一棵子集树，这类子集树通常有2^n个叶结点，其结点总数为2^(n+1)-1。遍历子集树的算法需要Ω(2^n)计算时间。但是，回溯法我们一般可以通过一种剪枝策略对这棵树进行剪枝，从而减少遍历的时间。</p><p>用回溯法搜索子集树的一般算法可以描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        output(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=i;</span><br><span class="line">        <span class="keyword">if</span>(constraint(t)&amp;&amp;bound(t))</span><br><span class="line">            backtrack(t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h2><p>当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。</p><p>排列树通常有n!个叶结点，因此遍历需要Ω(n!)计算时间。同样，我们可以通过一种剪枝策略对这棵树进行剪枝，从而减少遍历的时间。</p><p>用回溯法搜索排列树的一般算法可以描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        output(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x[t],x[i]);</span><br><span class="line">        <span class="keyword">if</span>(constraint(t)&amp;&amp;bound(t))</span><br><span class="line">            backtrack(t+<span class="number">1</span>);</span><br><span class="line">        swap(x[t],x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P和NP问题"><a href="#P和NP问题" class="headerlink" title="P和NP问题"></a>P和NP问题</h1><p>如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。</p><p>NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。</p>]]></content>
    
    
    <summary type="html">回溯法，包括子集树和排列树</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.178Z</published>
    <updated>2022-01-09T02:54:32.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>二分搜索算法是分治法的一个典型策略。</p><p>给定已经排好序的n个元素a[0 : n-1]，现在要从中找出一个特定的元素x。</p><p>首先容易想到的是用顺序搜索方法，逐个比较a[0 : n-1]中元素，直到找到x或者搜索遍整个数组后确定x不在其中。这个方法没有很好地利用n个元素已经排好序这个条件，因此在最坏的情况下，顺序搜索方法需要O(n)次比较。</p><p>二分搜索方法充分利用了元素间的次序关系，采用分治策略，可以在最坏情况下用O(log n)时间找到元素x。</p><p>它的基本思想是：将这n个元素分成个数大致相同的两半，取a[n/2]与x进行比较，如果a[n/2]==x，则程序结束；如果x&lt;a[n/2]，只需要在a[0 : n/2]中再利用这种方法进行搜索；如果x&gt;a[n/2]，只需要在a[n/2 : n]中再利用这种方法进行搜索；</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==a[middle]) <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;a[middle]) right=middle-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left=middle+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易看出，每执行一次算法的while循环，待搜索的数组就将减少一半。因此，在最坏的情况下，while循环被执行O(log n)次。循环体内运算需要O(1)时间，因此整个算法在最坏的情况下时间复杂性为O(log n)。</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>合并排序算法是用分治策略实现对n个元素进行排序的算法。</p><p>其基本思想是：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并为所要求排好序的集合。下图可以很好的理解合并算法的分治思想。</p><blockquote><p>注：图源网络(dreamcatcher-cx)</p></blockquote><p><img src="/../../img/markdown_img/%E7%AE%97%E6%B3%95.assets/image-20211106093310191.png" alt="image-20211106093310191"></p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(a,left,mid-<span class="number">1</span>);</span><br><span class="line">        mergeSort(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(a,b,left,mid,right);<span class="comment">//合并到数组b</span></span><br><span class="line">        copy(a,b,left,right);<span class="comment">//复制回数组a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">                b[t++] = a[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b[t++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//左边剩余元素</span></span><br><span class="line">            b[t++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//右边剩余元素</span></span><br><span class="line">            b[t++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的merge方法，就是将一组一组子集合递归的合并到数组b。合并排序算法对n个元素进行排序，在最坏情况下所需的计算时间为T(n)满足：<strong>T(n)=2T(n/2)+O(n)  n&gt;1</strong></p><p>求解递归方程可知T(n)=O(n log n)。但是排序算法的时间下界为Ω(n log n)，故合并排序算法是渐进最优算法。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>快速排序算法是基于分治算法的另一个排序算法。</p><p>对于输入的子数组a[p : r]，按以下步骤进行排序：</p><ol><li>分解：以a[p]为基准元素将a[p : r]划分为3段a[p : q-1]，a[q]和a[q+1 : r]，并且让a[p : q-1]中的任何元素都小于等于a[q]，a[q+1 : r]中的任何元素都大于等于a[q]。通俗的来说就是，小于基准的放左边，大于基准的放右边。</li><li>递归求解：通过递归的调用快排算法，分别对a[p : q-1]，a[q+1 : r]两段递归调用算法。</li><li>合并：对于a[p : q-1]，a[q+1 : r]的排序是就地进行的，所以在a[p : q-1]，a[q+1 : r]排好序后不需要执行任何计算，原数组就排好序。</li></ol><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=partition(p,r);</span><br><span class="line">        qSort(p,q-<span class="number">1</span>);</span><br><span class="line">        qSort(q+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=p;</span><br><span class="line">    <span class="keyword">int</span> right=r;</span><br><span class="line">    <span class="keyword">int</span> x=a[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=x)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            a[left]=a[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;=x)</span><br><span class="line">            left--; </span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            a[right]=a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    a[left]=x;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的关键在于partition中以确定的基准元素a[p]进行划分。partition方法每次都以x=a[p]为基准，然后左边left和右边right移位，右边开始，如果a[right]比基准元素x大或者等于，那么right继续移位；如果a[right]&lt;x，那么则将当前的a[right]赋值到a[left]，因为left此时并未开始移位，未动，因此是就地排序。赋值完成后left就开始移动，同理。</p><p>快速排序最差情况划分过程产生的两个区域分别包含n-1个元素和1个元素，并且每一次都出现这种不对称的划分，则有T(n)=T(n-1)+O(n)；解得最坏情况下T(n)=O(n^2)；</p><p>快排最好和平均情况下的时间复杂度都是O(n log n)；</p><p>快速排序算法是不稳定的算法。</p><h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>元素选择的问题一般是：给定线性序列有n个元素，一个整数k，找到这n个元素中第k小的元素。</p><p>线性时间选择算法实际上是模仿快速排序算法设计出来的。其基本思想也是对输入数组进行递归划分。随机选择一个下标 i 作为基准 a[i]，将小于 a[i] 的放左边，大于 a[i] 的放在右边。j 为划分后左边有的元素个数，这样只需要比较k和j的大小，如果k &lt;= j，那么说明第k小的元素一定在基准左边，接下来就只需要对左半部分递归找第 k 小的元素即可；同理，如果<strong>k&gt;j</strong>，说明，第k小的元素在基准右边，那么就对右半部分递归找第<strong>k-j</strong>小的元素即可。</p><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomizedSelect</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=randomizedPartition(p,r);</span><br><span class="line">    <span class="keyword">int</span> j=i-p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=j)</span><br><span class="line">        <span class="keyword">return</span> randomizedSelect(p,i,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> randomizedSelect(i+<span class="number">1</span>,r,k-j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=random(p,r);</span><br><span class="line">    MyMath.swap(a,i,p);</span><br><span class="line">    <span class="keyword">return</span> partiton(p,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，最坏情况下randomizedSelect需要Ω(n^2)计算时间，这里的partition函数同快速排序算法的partition函数是一致的。由于随机划分算法randomizedPartition使用了随机数产生器random，它能随机的产生p和r之间的一个随机整数，因此，randomizedPartition产生的划分基准是随机的，在这个条件下，可以证明，算法randomizedSelect可以在O(n)平均时间内找出n个输入元素中第k小的数。</p><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>问题描述：</p><p>给定由n个整数(可负)组成的序列a1 ,a2 ,…,an，求该序列形如∑ak的子段和的最大值。当所有整数均为负整数时定义其最大子段和为0。 依此定义，所求的最优值为<img src="/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B../../img/markdown_img/%E7%AE%97%E6%B3%95.assets/image-20211106133058064.png" alt="image-20211106133058064"></p><p>例如,当(a1 ,a2 ,…,a6 ）= (-2, 11, -4, 13, -5, -2)时，最大子段和为 20 ( 11, -4, 13)。</p><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p>如果将所给的序列a[1 :  n]分为长度相同的两段a[1 : n/2]、a[n/2+1 : n]，分别求出这两段的最大子段和，则a[1 : n]的最大子段和分为三种情况：</p><ol><li>a[1 : n]的最大子段和同a[1 : n/2]的最大子段和相同。</li><li>a[1 : n]的最大子段和同a[n/2 : n]的最大子段和相同。</li><li>a[1 : n]的最大子段和等于位于a[1 : n/2]的子段和和位于a[n/2+1 : n]的子段和的和</li></ol><p>1和2的情况可以直接递归求得，第3种情况，a[n/2]和a[n/2+1]在最优子序列之中，我们只需要计算出左边a[1 : n/2]从n/2开始的最大子段和s1，右边a[ n/2+1 : n]从n/2+1开始的最大子段和，然后将两者相加s=s1+s2；s即为第3种情况的最优值。</p><h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubSum</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)</span><br><span class="line">        <span class="keyword">return</span> a[left]&gt;<span class="number">0</span>?a[left]:sum;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftSum=MaxSubSum(a,left,mid);</span><br><span class="line">        <span class="keyword">int</span> rightSum=MaxSubSum(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempS=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=left;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tempS+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(tempS&gt;s1)</span><br><span class="line">                s1=tempS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s2=<span class="number">0</span>;</span><br><span class="line">        tempS=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempS+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(tempS&gt;s2)</span><br><span class="line">                s2=tempS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回三者中最大的</span></span><br><span class="line">        <span class="keyword">return</span> max(leftSum,rightSum,s1+s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(n)=2T(n/2)+O(n)，因此时间复杂度为O(n log n)</p>]]></content>
    
    
    <summary type="html">分治法，包括二分搜索算法，合并排序，快排，线性时间选择，最大字段和</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.176Z</published>
    <updated>2022-01-09T02:53:37.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适用于动态规划法求解的问题，经分解得到的子问题往往不是相互独立的。在用分治法求解的时候，有些子问题被重复计算了许多次。如果能够保存已解决的子问题的答案，而在需要的时候再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间的算法。</p><p>动态规划算法适用于解最优化问题，通常可以按以下步骤设计的动态规划算法：</p><ol><li>找出最优解的性质，并刻画其结果特征。</li><li>递归地定义最优值。</li><li>以自底向上的方式计算出最优值。</li><li>根据计算最优值时得到的信息，构造最优解。</li></ol><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>先来看一下最大子段和用分治法思想的分析：</p><p>如果将所给的序列a[1 :  n]分为长度相同的两段a[1 : n/2]、a[n/2+1 : n]，分别求出这两段的最大子段和，则a[1 : n]的最大子段和分为三种情况：</p><ol><li>a[1 : n]的最大子段和同a[1 : n/2]的最大子段和相同。</li><li>a[1 : n]的最大子段和同a[n/2 : n]的最大子段和相同。</li><li>a[1 : n]的最大子段和等于位于a[1 : n/2]的子段和和位于a[n/2+1 : n]的子段和的和</li></ol><p>1和2的情况可以直接递归求得，第3种情况，a[n/2]和a[n/2+1]在最优子序列之中，我们只需要计算出左边a[1 : n/2]从n/2开始的最大子段和s1，右边a[ n/2+1 : n]从n/2+1开始的最大子段和，然后将两者相加s=s1+s2；s即为第3种情况的最优值。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>从上述分治法思想注意到，我们可以记b[ j ]为1 ~ j 中的最大子段和，其中j∈[1，n]；<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106135813232.png" alt="image-20211106135813232"></p><p>这样，那么所求的1 ~ n 中的最大子段和就为 i~j 的和可以表示为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106135834099.png" alt="image-20211106135834099"></p><p>意思就是，j从1到n，依次找到最大子段和。</p><p>由b[ j ]的定义易知，当b[ j-1 ]&gt;0 时b[ j ]= b[ j-1 ] +a[j]，否则 b[ j ]=a[ j ]。 由此可得计算b[j]的动态规划递归式：</p><p><strong>b[j] = max {b[j-1] +a[j], a[j] } ，1≤j ≤ n</strong></p><p>当前的最优解，就等于前一个最优解加上当前值和当前值中的较大者。</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106141924973.png" alt="image-20211106141924973"></p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">            b+=a[i];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            b=a[i];</span><br><span class="line">        <span class="keyword">if</span>(b&gt;sum)</span><br><span class="line">            sum=b;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><p>给定n个矩阵{A1，A2……An} ， 其中Ai与Ai+1可乘，i=1,2,3…n-1 。 如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。</p><p>考察这n个矩阵的连乘积     A1A2…An</p><p>由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。 </p><p>若一个矩阵连乘积的计算次序完全确定，也就是说该连乘积已完全加括号，则可以依此次序反复调用2个矩阵相乘的标准算法计算出矩阵连乘积。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>将矩阵连乘积 AiAi+1…Aj简记为A[i:j] ，这里i ≤ j  考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵 Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106143929876.png" alt="image-20211106143929876"></p><p>计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上 A[i:k]和A[k+1:j]相乘的计算量。</p><p><strong>最优解结构</strong>：</p><ul><li><p>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。 </p></li><li><p>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。</p></li></ul><p><strong>建立递归关系</strong>：</p><ol><li><p>设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]</p></li><li><p>当i=j时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n</p></li><li><p>当i&lt;j时，m[i , j]=m[i , k] + m[k+1 , j] + pi-1 * pk * pj ，这里Ai的维数为pi-1 * pi</p></li><li><p>递归的定义m[i , j]为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106144514820.png" alt="image-20211106144514820"></p><p>k的位置只有j-i种可能。</p></li></ol><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150225461.png" alt="image-20211106150225461"></p><p>计算的时候是斜着对角进行计算的，这样再计算下一轮的时候就可以用到前面已经求得的值。</p><p>计算过程：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150353882.png" alt="image-20211106150353882"></p><p>比如m[2] [5]就可以表示为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150243929.png" alt="image-20211106150243929"></p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matrixChain</span><span class="params">(<span class="keyword">int</span> []p,<span class="keyword">int</span> n,<span class="keyword">int</span> [][]m,<span class="keyword">int</span> [][]s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化对角线全为0 因为当i=j时，A[i:j]=Ai，因此，m[i,i]=0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) m[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">2</span>;r&lt;=n;r++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-r+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//这是把 m[i][j]分成i-&gt;i i+1-&gt;j的情形，m[i][i]=0</span></span><br><span class="line">            <span class="comment">//m[i , j]=m[i , k] + m[k+1 , j] + pi-1 * pk * pj</span></span><br><span class="line">            m[i][j]= m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="comment">//这里就是除了i-&gt;i i+1-&gt;j的情形以外的情况，要找到最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析： 算法matrixChain的主要计算量取决于算法中对r，i 和 k 的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n^3 )。因此算法的计算时间上界为O(n^3 )。算法所占用的空间显然为O(n^2 )。</p><h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><p>若给定序列X={x1 ,x2 ,…,xm}，则另一序列 Z={z1 ,z2 ,…,zk }，是X的子序列是指存在一个严格递增 下标序列{i1 ,i2 ,…,ik }使得对于所有j=1,2,…,k有：zj=xi。 例如，序列Z={B，C，D，B}是序列X={A，B，C，B， D，A，B}的子序列，相应的递增下标序列为{2，3，5， 7}。</p><p>给定2个序列X和Y，当另一序列Z既是X的子序列又是 Y的子序列时，称Z是序列X和Y的公共子序列。</p><p>给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，找 出X和Y的最长公共子序列。</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>设序列X={x1 ,x2 ,…,xm}和Y={y1 ,y2 ,…,yn }的最长公共子序列为 Z={z1 ,z2 ,…,zk } ，则</p><ul><li>若xm==yn，则zk=xm=yn。X与Y的最长公共子序列为{x1 ,x2 ,…,x(m-1)}，{y1 ,y2 ,…,y(n-1) }的最长公共子序列+xm</li><li>若xm!=yn且zk!=xm，则X与Y的最长公共子序列为{x1 ,x2 ,…,x(m-1)}，{y1 ,y2 ,…,yn }的最长公共子序列</li><li>若xm!=yn且zk!=yn，则X与Y的最长公共子序列为{x1 ,x2 ,…,xm}，{y1 ,y2 ,…,y(n-1) }的最长公共子序列</li></ul><p>由此可见，2个序列的最长公共子序列包含了这2个序列的前缀 的最长公共子序列。因此，最长公共子序列问题具有最优子结 构性质。</p><p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用c[i] [j]记录序列和的最长公共子序列的长度。其中，Xi={x1 ,x2 ,…,xi }；Yj={y1 ,y2 ,…,yj }。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时C[i] [j]=0。其它情况下，由最优子结构性质可建立递归关系如下：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106152638761.png" alt="image-20211106152638761"></p><p>Algorithms和alchemist：</p><p>i=0和j=0，则c[i] [j]为0；然后，首先X1  A 和Y1  A相同，那么就取左上方c[i-1] [j-1]+1 ；接下来，X1 A和Y2 L不同，则c[i] [j] 就等于左边c[i] [j-1] 和 上边 c[i-1] [j] 中的较大者。</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106155347486.png" alt="image-20211106155347486"></p><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LCSLength</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">char</span> []x,<span class="keyword">char</span> []y,<span class="keyword">int</span> [][]c,<span class="keyword">int</span> [][]b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//i=0或者j=0，空序列为最长公共子序列，因此c[i][j]=0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (x[i]==y[j]) </span><br><span class="line">            &#123; </span><br><span class="line">c[i][j]=c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>; </span><br><span class="line">                <span class="comment">//记录</span></span><br><span class="line">                b[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c[i-<span class="number">1</span>][j]&gt;=c[i][j-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i-<span class="number">1</span>][j];</span><br><span class="line">            b[i][j]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i][j-<span class="number">1</span>]; </span><br><span class="line">                b[i][j]=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造最长公共子序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LCS</span><span class="params">(<span class="keyword">int</span> i，<span class="keyword">int</span> j，<span class="keyword">char</span> []x，<span class="keyword">int</span> []b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i ==<span class="number">0</span> || j==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (b[i][j]== <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        LCS(i-<span class="number">1</span>，j-<span class="number">1</span>，x，b); </span><br><span class="line">        System.out.print(x[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b[i][j]== <span class="number">2</span>) </span><br><span class="line">        LCS(i-<span class="number">1</span>，j，x，b);</span><br><span class="line"><span class="keyword">else</span> LCS(i，j-<span class="number">1</span>，x，b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法LCSLength耗时O(m*n)，算法LCS的计算时间为O(m+n)。</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>设所给0-1背包问题的子问题<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106191015562.png" alt="image-20211106191015562"></p><p>的最优值为m[i] [j]，即m(i,j)是背包容量为j，可选择物品为i，i+1，…，n时0-1背包问题的最优值。</p><p>由0-1背包问题的最优子结构性质，可以建立如下计算m(i，j)的递归式：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106191335277.png" alt="image-20211106191335277"></p><p>递归式的意思就是：如果当前背包容量小于当前物品的重量，那么就是不能装下，这样就等于下一个到m(i+1 , j)。如果当前背包容量能大于当前物品的重量，那么就是能装下，这样就只需要比较装下该物品（如果选择装下该物品，那么前面物品的总价值就会被压缩，因为该物品占了重量所以要去找m(i+1 , j-wi)然后再加上刚装下物品的价值）或者不装该物品，哪一个得到的价值更大。</p><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> []v,<span class="keyword">int</span> []w,<span class="keyword">int</span> c,<span class="keyword">int</span> [][]m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=v.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">        m[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        m[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&gt;=c;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">                m[i][j]=max(m[i-<span class="number">1</span>][j],m[i-<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[i][j]=m[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用m[i] [j]=max(m[i-1] [j],m[i-1] [j-w[i]]+v[i]);同上方i+1意思是一样的，只不过初始化不同。</p><p>时间复杂度O(nc)；</p>]]></content>
    
    
    <summary type="html">算法之动态规划，包括最大字段和，矩阵连乘，最长公共子序列问题，01背包问题</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-09T02:45:48.174Z</published>
    <updated>2022-01-09T02:56:49.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优 解。如单源最短路经问题，最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p><h2 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h2><p>动态规划算法通常以自底向上的方式解各子问题，而 贪心算法则通常以自顶向下的方式进行，以迭代的方式 作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</p><h2 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h2><p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。</p><p>对于一个具体问题，要确定它是否具有贪心选择性质， 必须证明每一步所作的贪心选择最终导致问题的整体最优解。</p><h3 id="贪心选择性质证明"><a href="#贪心选择性质证明" class="headerlink" title="贪心选择性质证明"></a>贪心选择性质证明</h3><h4 id="货币系统"><a href="#货币系统" class="headerlink" title="货币系统"></a>货币系统</h4><p>设某种货币系统为(1, 5, 10, 25)四种币值（单位：元），要用最少的币数找出n元钱，问：能否用贪心算法进行求解，并证明。（不要求写算法）</p><p>贪心性质（最大面额优先选最多）证明：</p><p>对n&lt;=25的情况，易由穷举得证。</p><p>当n&gt;25时，设n=1<em>a1+5</em>a2+10<em>a3+25</em>a4</p><p>为了使a1+a2+a3+a4最小，易知：</p><p>a1&lt;5，若a1&gt;=5，可将5个1元兑换为1个5元，币数减少。</p><p>a2&lt;2，若a2&gt;=2，可将2个5元兑换为1个10元，币数减少。</p><p>当a2=0时，a3&lt;3，若a3&gt;=3，可将3个10元兑换为1个5元和1个25元，币数减少。</p><p>当a2&gt;0时，a3&lt;2，若a2&gt;=2，可将1个5元和2个10元兑换为1个25元，币数减少。</p><p>即，为了使a1+a2+a3+a4最小，所使用的1、5、10元币的币数的上限为：</p><p>a1=4, a2=0, a3=2 或 a1=4, a2=1, a3=1</p><p>则所使用的1、5、10元币的币值上限为：</p><p>4<em>1+0</em>5+2<em>10 = 24 或 4</em>1+1<em>5+1</em>10 = 19</p><p>均不超过25，因此，为了使a1+a2+a3+a4最小，应使a4达到最大。贪心选择性质得证。</p><p>最优子结构性质证明：</p><p>当a4的值确定后，为了使a1+a2+a3+a4达到最小，须使a1+a2+a3达到最小，仍为同型的最优问题。</p><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p>算法思想：先将所有物品按其单位重量的价值进行排序，然后，按照贪心策略，将尽可能多的单位重量价值最高的物品装入；若装入后，背包内的物品总重量未超过C，则选择单位重量价值次高的物品尽可能多地装入。依此策略一直进行下去，直到背包装满或物品装完为止。</p><p>贪心性质证明：</p><p>不失一般性，只要对第一个步骤进行证明即可。</p><p>设按以上方法第一个步骤装入地重量为w1’。（对单位价值最大的物品）</p><p>若存在一种装入方式，单位价值最大的物品装入数为w1‘’&lt;w1’ ，且得到了最优结果。</p><p>不妨设其他的物品被装入重量为w2’’,…,wn’’。</p><p>现对该方案作部分调整，将单位价值最高的物品的装入量改为w1’，而将由此产生的超重w1’-w1’’在后面的各物品上分摊（减少），这样的方案获得的价值必然超过原方案价值且不超重，与假设矛盾。故单位价值最大的物品的装入数必然为w1’ 。</p><h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><p>活动安排问题就是要在所给的活动集合中选出 最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。</p><p>设有n个活动的集合E={1,2,…,n}，其中每个活动都要 求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资 源的起始时间si和一个结束时间fi,且si&lt;fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>输入的活动以其完成时间的非减序排列， 算法每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。</p><h3 id="贪心选择性质-1"><a href="#贪心选择性质-1" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h3><p>假设有一个最大相容活动集，Ei1,Ei2,…,Eik**(**已按结束时间排序)<strong>，</strong>活动数为K。现在证明按照贪心策略一定可以找到同样数量的相容活动集。</p><p>假设i1&gt;1，则将活动Ei1换成E1后依然是相容的（因为E1更早结束）；</p><p>依次类推，只要不符合贪心策略，就可按贪心策略进行活动替换，得到数量相等的相容基。这说明按照贪心策略一定可以得到最大相容集。因此，按照以上贪心策略，进行局部最优选择，一定可以导致最终得到整体最优解。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>各活动的起始时间和结束时间存储于数组s和f中且按结束时间的非减序排列。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="keyword">int</span> n, T s[], T f[], bool A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A[<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (s[i]&gt;=f[j]) </span><br><span class="line"> &#123; </span><br><span class="line"> A[i]=<span class="keyword">true</span>; </span><br><span class="line"> j=i; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> A[i]=<span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法greedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。</p><h2 id="背包问题-1"><a href="#背包问题-1" class="headerlink" title="背包问题"></a>背包问题</h2><p>与0-1背包问题类似，所不同的是在选择物品i装入背包时，可以选择物品i的一部分，而不一定要全部装 入背包，1≤i≤n。 这2类问题都具有最优子结构性质，极为相似，但背 包问题可以用贪心算法求解，而0-1背包问题却不能用贪心算法求解。</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先计算每种物品单位重量的价值Vi/Wi，然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。 若将这种物品全部装入背包后，背包内的物品总重量未超过 C，则选择单位重量价值次高的物品并尽可能多地装入背包。 依此策略一直地进行下去，直到背包装满为止。</p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">float</span> M,<span class="keyword">float</span> v[],<span class="keyword">float</span> w[],<span class="keyword">float</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按照单位重量的价值从大到小排序</span></span><br><span class="line">    sort(n,v,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        x[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> c=M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&gt;c)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        x[i]=<span class="number">1</span>;</span><br><span class="line">        c-=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;n)</span><br><span class="line">        x[i]=c/w[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先计算每种物品单位重量的价值Vi/Wi，然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。 若将这种物品全部装入背包后，背包内的物品总重量未超过C，则选择单位重量价值次高的物品并尽可能多地装入背包。 依此策略一直地进行下去，直到背包装满为止。如果到最后装入某物品后背包内的物品总重量超过C，则选择将物品不全部装入，但占用背包剩余的全部容量。</p><p>对于0-1背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。事实上， 在考虑0-1背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。由此就导出许多互相重叠的子问题。这正是该问题可用动态规划算法-求解的另一重要特征。 </p><p>实际上也是如此，动态规划算法的确可以有效地解0- 1背包问题。</p>]]></content>
    
    
    <summary type="html">贪心算法，最优子结构性质、贪心选择性质证明，活动安排问题与背包问题</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SHA-1算法的Java实现</title>
    <link href="http://ins1mn1a.github.io/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/SHA-1/"/>
    <id>http://ins1mn1a.github.io/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/SHA-1/</id>
    <published>2022-01-05T13:37:14.246Z</published>
    <updated>2022-01-05T13:42:44.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>SHA-1把长度小于2^64次方的输入进行分组，512bit为一组。</p><p>采用Merkle提出的安全Hash模型</p><p><img src="/../../img/markdown_img/SHA-1.assets/image-20220104084936990.png" alt="image-20220104084936990"></p><h2 id="填充方案"><a href="#填充方案" class="headerlink" title="填充方案"></a>填充方案</h2><p>先在后面补一个1，然后补0一直到448bit，最后加上64bit的原始x长度的二进制表示</p><p>举例：</p><ol><li><p>原始消息为”abc”，则其bit序列为01100001 01100010 01100011</p></li><li><p>补位，最高位补1，其余补0，补位到448bit</p><ul><li>原始序列：01100001 01100010 01100011</li><li>补位序列：01100001 01100010 01100011 10000000 00000000 … 00000000 （共448bit）</li></ul></li><li><p>原始数据长度的二进制补位</p><ul><li><p>换为16进制：61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000</p></li><li><p>原始消息的长度为24，补位</p><p>61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000018 </p></li></ul></li></ol><p>至此填充完毕，|y|=|x|+1+(447-|x|)+|l|=512</p><h2 id="初始化缓冲区"><a href="#初始化缓冲区" class="headerlink" title="初始化缓冲区"></a>初始化缓冲区</h2><p>缓冲区由5个32位的寄存器（A,B,C,D,E）组成，用于保存160位的中间结果和最终结果</p><p>寄存器初始化为：</p><ul><li>A：67452301</li><li>B：EFCDAB89</li><li>C：98BADCFE</li><li>D：10325476</li><li>E：C3D2E1F0</li></ul><h2 id="主处理"><a href="#主处理" class="headerlink" title="主处理"></a>主处理</h2><p>主处理是SHA-1的核心，每次处理一个512bit分组，链接迭代处理所有L个分组数</p><p>压缩函数是主处理的核心，它由4层运算，每层20步迭代，共80步迭代组成，4层运算结构相同。</p><p>每轮的输入是当前512bit分组BLK和160bit缓冲区ABCDE的内容，并且每轮都对ABCDE的内容更新，而且每轮使用的逻辑函数f不相同，分为f1,f2,f3,f4</p><p>第四轮的输出与第一轮的输入相加得到压缩函数的输出</p><p><img src="/../../img/markdown_img/SHA-1.assets/image-20220104090917830.png" alt="image-20220104090917830"></p><p>&lt;&lt;s 表示32位的变量循环左移s位</p><p>Wt 表示从当前分组BLK导出的32位的字</p><p>Kt 表示加法常量，共使用4个不同的加法常量，每一层一个</p><p>ft 逻辑函数</p><h2 id="逻辑函数ft"><a href="#逻辑函数ft" class="headerlink" title="逻辑函数ft"></a>逻辑函数ft</h2><p>每一轮使用一个逻辑函数，共4个，其输入均为B,C,D(每个32位)，输出为一个32位的字。</p><ul><li>0 ≤ t ≤ 19    f1=ft(B,C,D) = (B ∧C) ∨((¬ B) ∧ D)</li><li>20 ≤ t ≤ 39 f2=ft(B,C,D) = B ⊕ C ⊕ D</li><li>40 ≤ t ≤ 59 f3=ft(B,C,D) = (B ∧ C) ∨(B ∧ D) ∨ (C∧D)</li><li>60≤ t ≤ 79 f4=ft(B,C,D) = B ⊕ C ⊕ D</li></ul><p>f2和f4都是线性函数</p><h2 id="加法常量Kt"><a href="#加法常量Kt" class="headerlink" title="加法常量Kt"></a>加法常量Kt</h2><p>每层使用一个加法常量，各轮使用的加法常量：</p><p>K1 0 ≤ t ≤ 19    5A827999</p><p>K2 20 ≤ t ≤ 39    6ED9EBA1</p><p>K3 40 ≤ t ≤ 59    8F1BBCDC</p><p>K4 60≤ t ≤ 79    CA62C1D6</p><p>压缩字Kt的作用范围太小，只影响输出A，不影响B,C,D,E。</p><h2 id="压缩字Wt"><a href="#压缩字Wt" class="headerlink" title="压缩字Wt"></a>压缩字Wt</h2><p>每步迭代都需要用到一个字，共有80个步，需要80个字。因此将输入BLK（512位，16个字）扩展成80个32位的字。消息M共16个字。</p><p>扩展过程：</p><ul><li>0 ≤ t ≤ 15 Wt=Mt</li><li>16 ≤ t ≤ 79 Wt=（Wt-16 ⊕ Wt-14 ⊕ Wt-8 ⊕ Wt-3）&lt;&lt;1</li></ul><p>压缩字的扩展函数为线性函数</p><p>Wt作用范围太小，只影响输出A，不影响B,C,D,E。</p><h2 id="主处理过程"><a href="#主处理过程" class="headerlink" title="主处理过程"></a>主处理过程</h2><h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h3><p>填充后的消息M，共16个字</p><p>61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000018 </p><p>对M扩展成80个字</p><p>Wt = S1(Wt-3 ⊕Wt-8 ⊕Wt-14 ⊕Wt-16) (16  ≤ t ≤ 79)</p><h3 id="初始化缓冲区-1"><a href="#初始化缓冲区-1" class="headerlink" title="初始化缓冲区"></a>初始化缓冲区</h3><p>初始化MD缓冲区{Hi}，160bit(5个32的寄存器)。</p><p>A=H0= 0x67452301 </p><p>B=H1 = 0xEFCDAB89 </p><p>C=H2= 0x98BADCFE </p><p>D=H3= 0x10325476 </p><p>E=H4= 0xC3D2E1F0</p><p>每轮的常数K为：  </p><p>Kt = 5A827999 ( 0 ≤ t ≤ 19) </p><p>Kt = 6ED9EBA1 (20 ≤ t ≤ 39) </p><p>Kt = 8F1BBCDC (40 ≤ t ≤ 59) </p><p>Kt = CA62C1D6 (60 ≤ t ≤ 79)</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ul><li><p>TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt</p></li><li><p>E = D ; D = C ; C = S30(B) ; B = A ; A = TEMP</p></li><li><p>H0 = H0 + A  H1 = H1 + B H2 = H2 + C  H3 = H3 + D H4 = H4 + E</p></li></ul>]]></content>
    
    
    <summary type="html">密码学Hash算法中的SHA-1实现，SHA-1把长度小于2^64次方bit的输入，转为固定长度160bit的消息摘要</summary>
    
    
    
    <category term="java小功能实现" scheme="http://ins1mn1a.github.io/categories/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="java小功能实现" scheme="http://ins1mn1a.github.io/tags/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java实现文件监控系统</title>
    <link href="http://ins1mn1a.github.io/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <id>http://ins1mn1a.github.io/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-05T13:36:07.619Z</published>
    <updated>2022-01-09T01:38:22.327Z</updated>
    
    <content type="html"><![CDATA[<p>用Java实现文件监控一般有三种方式，第一种是使用WatchService，但是WatchService只能监视当前目录下的文件和目录，不能监视子目录，如果需要监视，则需要遍历根目录下的所有目录，第二种就是利用commons-io监控，最后还可以用JNofiy实现，这里只使用了前两种</p><h2 id="WatchService实现文件监控"><a href="#WatchService实现文件监控" class="headerlink" title="WatchService实现文件监控"></a>WatchService实现文件监控</h2><p>WatchService是jdk7之后nio包中的新功能。可以看作是文件监控器，通过操作系统原生文件系统来运行。 针对单点多appkey的情况，可以注册开启多个监控器。 每个监控器可看作是后台线程，通过监控文件发出的信号来实现监控。</p><p>应用场景：可以监控配置文件的变化，修改配置文件内容即时生效，无需重启服务；监控磁盘文件的变化</p><p>WatchService监控目录文件操作的流程大致如下：</p><ol><li>获取WatchService</li><li>注册指定目录的监视器</li><li>开启线程，等等目录下的文件发生变化</li><li>对发送变化的文件进行记录</li></ol><h3 id="获取WatchService实例"><a href="#获取WatchService实例" class="headerlink" title="获取WatchService实例"></a>获取WatchService实例</h3><p>WatchService是对原生操作系统文件监视器的封装，因为不需要遍历文件所以整体效率上会高很多。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService = FileSystems.getDefault().newWatchService();</span><br></pre></td></tr></table></figure><p>FileSystems.getDefault().newWatchService();直接封装了WatchService的获取方法。</p><p>可以查看它的源码，getDefault()方法的返回值是一个FileSystem，FileSystem提供一个访问文件系统的接口，是对象访问文件系统中的文件和其他对象的工厂，进入getDefault()方法，看看它default了个啥。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileSystem <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultFileSystemHolder.defaultFileSystem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用了DefaultFileSystemHolder，DefaultFileSystemHolder是FileSystems中的一个静态内部类，而defaultFileSystem是DefaultFileSystemHolder的一个用static修饰的属性，然后调用了defaultFileSystem()方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> FileSystem defaultFileSystem = defaultFileSystem();</span><br></pre></td></tr></table></figure><p>defaultFileSystem方法里面用匿名内部类的形式返回了一个FileSystemProvider，它是文件系统的服务提供者类，用它可以获取由provider创建的一个FileSystem。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// returns default file system</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FileSystem <span class="title">defaultFileSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// load default provider</span></span><br><span class="line">    FileSystemProvider provider = AccessController</span><br><span class="line">        .doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;FileSystemProvider&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileSystemProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getDefaultProvider();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return file system</span></span><br><span class="line">    <span class="keyword">return</span> provider.getFileSystem(URI.create(<span class="string">&quot;file:///&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类中，获取了一个defaultProvider，WindowsFileSystemProvider，然后由这个provider获取了一个文件系统，WindowsFileSystemProvider中初始化文件系统。然后调用newWatchService方法就可以获取到WindowsWatchService对象了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WindowsFileSystem theFileSystem = <span class="keyword">new</span> WindowsFileSystem(<span class="keyword">this</span>, System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br></pre></td></tr></table></figure><p>实际上调用此方法后也就是WindowsWatchService的构造方法中，程序会新开一个线程，监视文件变化发出的信号，此时线程尚未就绪。Poller是WindowsWatchService中的一个内部类，WindowsWatchService也有一个poller属性，Poller继承了AbstractPoller，AbstractPoller是实现了Runnable接口，创建了一个守护线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread var1 = <span class="keyword">new</span> Thread(AbstractPoller.<span class="keyword">this</span>);</span><br><span class="line">            var1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            var1.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册目录监视器"><a href="#注册目录监视器" class="headerlink" title="注册目录监视器"></a>注册目录监视器</h3><p>注册监视器需要用到 Path 实例，该实例对应的必须是一个目录，不允许是一个文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要监视的文件目录</span></span><br><span class="line">        String strPath=<span class="string">&quot;D:/FileSystemMonitorTest&quot;</span>;</span><br><span class="line">        <span class="comment">//Path继承了Watchable接口，因此才可以通过Path类来对文件目录进行监听</span></span><br><span class="line">        Path path= Paths.get(strPath);</span><br><span class="line">        <span class="comment">//注册监控服务，监控新增、修改、删除事件，也可以只监控一个事件</span></span><br><span class="line">        path.register(watchService,StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br></pre></td></tr></table></figure><p>StandardWatchEventKinds是文件对应的操作事件，包括修改，创建，删除，它看起来像是枚举类型，但实际上并不是。WatchEvent.Kind<T>是一个接口，对应事件种类名和WatchEvent#context的类型，StdWatchEventKind是它的实现类，StdWatchEventKind<T>也是StandardWatchEventKinds中的内部静态类，StandardWatchEventKinds中的属性调用StdWatchEventKind的构造创建对应的观察事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> WatchEvent.Kind&lt;Path&gt; ENTRY_CREATE =</span><br><span class="line">    <span class="keyword">new</span> StdWatchEventKind&lt;Path&gt;(<span class="string">&quot;ENTRY_CREATE&quot;</span>, Path.class);</span><br></pre></td></tr></table></figure><h3 id="获取目录下的变化"><a href="#获取目录下的变化" class="headerlink" title="获取目录下的变化"></a>获取目录下的变化</h3><p>获取目录的变化需要使用 WatchService 的 take() 方法或 poll() 方法。</p><p>take() 是一个阻塞方法，会等待监视器发出的信号才返回。</p><p>poll() 是一个非阻塞方法，会立即返回当时监视器中是否有信号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    WatchKey watchKey = watchService.take();</span><br><span class="line">    <span class="comment">//轮询</span></span><br><span class="line">    List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">    <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">        System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">    &#125;</span><br><span class="line">    watchKey.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 WatchKey 对象，实际上是一个单例，和之前 path.register() 方法返回的实例是同一个。它只能保存某一时间点的文件变化信息。在AbstractPoller中可以看到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">awaitResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> var1 = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!<span class="keyword">this</span>.completed) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException var5) &#123;</span><br><span class="line">                        var1 = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (var1) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>pollEvents() 用于获取文件变化事件，只能获取一次，不能重复获取，类似队列的形式。</p><p>context() 返回触发该事件的那个文件或目录的路径(相对路径)</p><p>reset() 每次调用 WatchService 的 take() 或 poll() 方法时需要通过本方法重置。</p><h3 id="文件变化记录"><a href="#文件变化记录" class="headerlink" title="文件变化记录"></a>文件变化记录</h3><p>开启一个线程一直监控文件的变化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建监视服务类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService=FileSystems.getDefault().newWatchService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainMonitor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//需要监视的文件目录</span></span><br><span class="line">        String strPath=<span class="string">&quot;D:/FileSystemMonitorTest&quot;</span>;</span><br><span class="line">        <span class="comment">//Path继承了Watchable接口，因此才可以通过Path类来对文件目录进行监听</span></span><br><span class="line">        Path path= Paths.get(strPath);</span><br><span class="line">        <span class="comment">//注册监控服务，监控新增、修改、删除事件，也可以只监控一个事件</span></span><br><span class="line">        path.register(watchService,StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">        WatchServiceRunnable watchServiceRunnable = <span class="keyword">new</span> WatchServiceRunnable(watchService, strPath);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(watchServiceRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.FileMonitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchEvent;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchService;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控线程重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchServiceRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchServiceRunnable</span><span class="params">(WatchService watchService,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.watchService=watchService;</span><br><span class="line">        <span class="keyword">this</span>.path=path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                WatchKey watchKey = watchService.take();</span><br><span class="line">                <span class="comment">//轮询</span></span><br><span class="line">                List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">                <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">                    System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                            <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">                &#125;</span><br><span class="line">                watchKey.reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WatchService监控根目录以及子目录"><a href="#WatchService监控根目录以及子目录" class="headerlink" title="WatchService监控根目录以及子目录"></a>WatchService监控根目录以及子目录</h3><p>这样的话就需要遍历子目录，每个目录都注册一个监控事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历根目录及其子目录，全都注册监听服务</span></span><br><span class="line">LinkedList&lt;File&gt; fileLinkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加根目录到链表尾</span></span><br><span class="line">fileLinkedList.addLast(file);</span><br><span class="line"><span class="comment">//去除并且链表头的文件对象，查看其子目录下文件，能注册服务就注册WatchService</span></span><br><span class="line"><span class="keyword">while</span> (fileLinkedList.size()&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    File f=fileLinkedList.removeFirst();</span><br><span class="line">    File[] files1 = f.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file1 : files1) &#123;</span><br><span class="line">        <span class="comment">//如果是目录，则可以注册监听服务</span></span><br><span class="line">        <span class="keyword">if</span> (file1.isDirectory())&#123;</span><br><span class="line">            fileLinkedList.addLast(file1);</span><br><span class="line">            file1.toPath().register(watchService, StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                    StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在使用Junit测试的时候会遇到Junit测试多线程的限制，不能直接测试，可以看另一篇，Junit测试多线程的问题。</p><h2 id="Commons-IO实现文件监控"><a href="#Commons-IO实现文件监控" class="headerlink" title="Commons-IO实现文件监控"></a>Commons-IO实现文件监控</h2><p>Commons-IO是一个针对开发IO流功能的工具库，主要包括6个部分</p><ol><li>Utility classes：工具类，包括一些静态方法来执行常用任务</li><li>Input：输入，InputStream 和 Reader 实现</li><li>Output：输出，OutputStream 和 Writer 实现</li><li>Filters：过滤器，多种文件过滤器实现(定义了 IOFileFilter接口,同时继承了 FileFilter 和 FilenameFilter 接口)</li><li>Comparators： 比较器，用于文件比较的多种java.util.Comparatot实现</li><li>File Monitor： 文件监控</li></ol><p>使用Commons-IO来实现文件监控主要就是基于观察者模式，也叫发/布订阅模式。</p><p>主要的类有：</p><p>FileAlterationObserver：观察者，观察文件的变化</p><p>FileAlterationListener：文件变化的通知对象，监听器</p><p>FileAlterationListenerAdaptor：FileAlterationListener的实现类，里面方法都没仅仅有个方法体，没有具体的实现，我们一般需要继承FileAlterationListenerAdaptor，然后做具体的实现，比如监控到文件变化打印日志等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File system observer started checking event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> observer The file system observer (ignored)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileAlterationMonitor ：线程监控，实现了Runnable接口，可以以一个固定的时间间隔监听注册到观察者FileAlterationObserver的事件</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>首先由文件监控类FileAlterationMonitor中的线程不停的扫描文件观察器FileAlterationObserver</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> FileAlterationObserver observer : observers) &#123;</span><br><span class="line">            observer.checkAndNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(interval);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FileAlterationObserver中，有一个无参的checkAndNotify()方法，就是用来检查文件和它的子文件有没有变化。</p><p>在该方法中，首先将Observer的所有listener开启onStart方法，表示开始Observer开始检查事件了。然后调用checkAndNotify()的重载方法，根据文件的Comparators比较器，判断文件发生哪种变化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAndNotify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAndNotify</span><span class="params">(<span class="keyword">final</span> FileEntry parent, <span class="keyword">final</span> FileEntry[] previous, <span class="keyword">final</span> File[] files)</span></span></span><br><span class="line"><span class="function"><span class="title">doCreate</span><span class="params">(current[c])</span></span>;<span class="comment">//创建</span></span><br><span class="line">doMatch(entry, files[c]);<span class="comment">//修改</span></span><br><span class="line">doDelete(entry);<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><h3 id="自定义监听器FileAlterationListener"><a href="#自定义监听器FileAlterationListener" class="headerlink" title="自定义监听器FileAlterationListener"></a>自定义监听器FileAlterationListener</h3><p>通过实现FileAlterationListener或者说继承FileAlterationListenerAdaptor来自定义一个监听器，重写其中文件或者目录发生改变的方法，记录日志。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.commons_io_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationListenerAdaptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationObserver;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListener</span> <span class="keyword">extends</span> <span class="title">FileAlterationListenerAdaptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger=Logger.getLogger(FileListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;新建文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;修改文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;删除文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryCreate</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;新建目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryChange</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;修改目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryDelete</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;删除目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建监听器FileAlterationMonitor"><a href="#创建监听器FileAlterationMonitor" class="headerlink" title="创建监听器FileAlterationMonitor"></a>创建监听器FileAlterationMonitor</h3><p>首先给定一个需要监听的文件目录，配置一个观察者FileAlterationObserver，添加观察者的监听器，最后再new一个线程监控FileAlterationMonitor。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.commons_io_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.FileFilterUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.HiddenFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.IOFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationMonitor;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListenerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String dir=<span class="string">&quot;D:\\FileSystemMonitorTest&quot;</span>;</span><br><span class="line">    <span class="comment">//设置轮询间隔 1s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = TimeUnit.SECONDS.toMillis(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileAlterationMonitor <span class="title">getMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//装配过滤器</span></span><br><span class="line">        FileAlterationObserver observer = <span class="keyword">new</span> FileAlterationObserver(<span class="keyword">new</span> File(dir));</span><br><span class="line">        <span class="comment">//添加监听器</span></span><br><span class="line">        observer.addListener(<span class="keyword">new</span> FileListener());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileAlterationMonitor(interval,observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileMonitorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileAlterationMonitor monitor = <span class="keyword">new</span> FileListenerFactory().getMonitor();</span><br><span class="line">            monitor.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">采用jdk的WatchService和Commons-IO工具类库两种方法实现了对某文件目录下的文件监控，WatchService源码分析</summary>
    
    
    
    <category term="java小功能实现" scheme="http://ins1mn1a.github.io/categories/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="java小功能实现" scheme="http://ins1mn1a.github.io/tags/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Junit测试多线程的问题</title>
    <link href="http://ins1mn1a.github.io/2022/01/04/Bug%E4%B9%8B%E7%8E%8B/%E5%85%B3%E4%BA%8EJunit%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B5%8B%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://ins1mn1a.github.io/2022/01/04/Bug%E4%B9%8B%E7%8E%8B/%E5%85%B3%E4%BA%8EJunit%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B5%8B%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-01-04T11:15:54.233Z</published>
    <updated>2022-01-08T07:55:28.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Junit测试多线程的问题"><a href="#Junit测试多线程的问题" class="headerlink" title="Junit测试多线程的问题"></a>Junit测试多线程的问题</h1><p>今天在用写一个用WatchService做文件监控的时候使用Junit测试，实现Runnable接口，重写run方法，明明run方法里写的死循环，使用Junit一测试，啥都没干，自动给我执行完了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainMonitor mainMonitor = <span class="keyword">new</span> MainMonitor();</span><br><span class="line">        mainMonitor.monitor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控线程重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchServiceRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchServiceRunnable</span><span class="params">(WatchService watchService,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.watchService=watchService;</span><br><span class="line">        <span class="keyword">this</span>.path=path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                WatchKey watchKey = watchService.take();</span><br><span class="line">                List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">                <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">                    System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                            <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">                &#125;</span><br><span class="line">                watchKey.reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我直接重新写一个for循环，打印数字，也不能正常输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">                Thread.currentThread().setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在输出&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整了半天，发现Junit并不能直接测试多线程。Junit单元测试当主线程执行完毕时，主线程会关闭，并且关闭子线程。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>使用join()等待子线程执行完毕</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    thread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainMonitor mainMonitor = <span class="keyword">new</span> MainMonitor();</span><br><span class="line">        mainMonitor.monitor();</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>还可以使用CountDownLatch类</li></ol><p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Junit测试多线程</summary>
    
    
    
    <category term="bug" scheme="http://ins1mn1a.github.io/categories/bug/"/>
    
    
    <category term="Bug" scheme="http://ins1mn1a.github.io/tags/Bug/"/>
    
  </entry>
  
</feed>
