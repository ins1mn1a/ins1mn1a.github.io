<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ins1mn1a</title>
  
  <subtitle>反方向的钟</subtitle>
  <link href="http://ins1mn1a.github.io/atom.xml" rel="self"/>
  
  <link href="http://ins1mn1a.github.io/"/>
  <updated>2021-12-17T12:52:42.081Z</updated>
  <id>http://ins1mn1a.github.io/</id>
  
  <author>
    <name>ins1mnia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 缓存穿透击穿与雪崩</title>
    <link href="http://ins1mn1a.github.io/2021/12/17/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9/"/>
    <id>http://ins1mn1a.github.io/2021/12/17/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9/</id>
    <published>2021-12-17T12:31:22.721Z</published>
    <updated>2021-12-17T12:52:42.081Z</updated>
    
    <content type="html"><![CDATA[<p>在生产环境中，会因为很多的原因造成访问请求绕过了缓存，都需要访问数据库持久层，虽然对Redis缓存服务器不会造成影响，但是数据库的负载就会增大，使缓存的作用降低</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p><strong>缓存穿透</strong>是指查询一个<strong>数据库一定不存在的数据</strong>。</p><p>正常的使用缓存流程大致是：数据查询先到缓存中查找key，发现key不存在或者已经过期，再对数据库进行查询，并把查询到的对象，数据存到缓存中。但是如果数据库为空，则不放进缓存。</p><p>缓存穿透：一个数据缓存中不存在，导致请求的数据走数据库，就会使得后端存储负载加大，然而数据库中也不存在。这种情况下如果有攻击者故意多次请求一个不存在的主键id（比如负数id），而这个负数id在数据库根本就没有，就有可能搞垮整个数据库，甚至使整个服务瘫痪。</p><p>造成缓存穿透的基本原因有两个。</p><ul><li>自身业务代码或者数据出现问题（例如：set 和 get 的key不一致）</li><li>一些恶意攻击、爬虫等造成大量空命中（爬取线上商城商品数据，超大循环递增商品的ID）</li></ul><h1 id="缓存穿透解决方案"><a href="#缓存穿透解决方案" class="headerlink" title="缓存穿透解决方案"></a>缓存穿透解决方案</h1><h2 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h2><p>缓存空对象是指：在持久层没有命中的情况下，仍然将数据进行缓存。把key的value设置为null，并设置过期时间。</p><h4 id="缓存空对象带来的问题"><a href="#缓存空对象带来的问题" class="headerlink" title="缓存空对象带来的问题"></a>缓存空对象带来的问题</h4><ol><li>缓存空对象设置key的value为空，但是仍然是占用了内存空间的，对空值做缓存，缓存中还需要去保存这个空值的key，消耗内存空间。因此我们要对这种空值设置一个过期时间，让一定时间过后自动过期。</li><li>缓存空对象可能带来缓存和数据库的数据有一段时间窗口内的不一致，可能会对业务造成影响。比如设置过期时间为1分钟，如果此时数据库又添加了这个数据，那么这段时间就会出现缓存和数据库的数据不一致。此时，可以利用消息系统或者其他方式清除缓存中的空对象。</li></ol><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><blockquote><p>布隆过滤器参照知乎[@YoungChen][<a href="https://zhuanlan.zhihu.com/p/43263751]%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E8%AE%B2%E5%BE%97%E9%9D%9E%E5%B8%B8%E6%B8%85%E6%A5%9A">https://zhuanlan.zhihu.com/p/43263751]的文章，讲得非常清楚</a></p></blockquote><p>布隆过滤器（Bloom Filter）本质是其实是一种概率型数据结构。它可以高效的查询和插入，但是不能删除。可以<strong>用来判断某个数一定不存在或者可能存在</strong>。</p><p>跟传统的list、set、map相比，因为布隆过滤器本质存的是二进制比特位，且不存key，所以它占用的空间更小。跟HashMap相比，HashMap可以根据特定的key查询到对应的value值，并且判断key是否存在的时间复杂度也很低O(1)。但是，HashMap既需要存key，还需要存value值，存储容量比较高，并且考虑到HashMap的负载因子，HashMap一般情况下会有空间的浪费的。数据一旦过高，用HashMap占用的空间可就太高的。</p><p>布隆过滤器的虽然占用的空间小，但是它不确定的判断某个key一定存在，只能说概率。</p><ul><li>实现原理</li></ul><p>布隆过滤器就是一个bit向量或者说bit数组。</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122091819486.png" alt="image-20211122091819486"></p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122091912029.png" alt="image-20211122091912029"></p><p>我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122092135911.png" alt="image-20211122092135911"></p><p>4这个bit位被“baidu”和“tencent”两都置1，因为4这个bit位是被覆盖了的。那么我们现在想查询一个值是否存在，假设这个值通过哈希函数映射到了1，5，7三个bit位上。发现5这个bit位上的值是0，那么就说明这个值一定是不存在的。如果它存在，则它的映射到的所有bit位都必须为1。</p><p>现在我们要查询”baidu”是否存在。通过哈希函数我们得到三个bit位1,4,7。我们发现这三个bit上全都是1，尽管如此，我们仍然不能说”baidu”这个值必然是存在的，因为不要忘记了4这个bit位，”tencent”也存为1过。那么或许有个数，它根本就没进来存过，却意外的被其他的key一起把这个数的bit位全置为1了，所以布隆过滤器不能认定一个key一定存在。</p><ul><li>哈希函数的个数选择和布隆过滤器的长度选择</li></ul><p>如果哈希函数的个数选择太少了，bit位的覆盖率就会变高，误报率就会变高。</p><p>如果哈希函数的个数选择太多了，每个bit位置1的速度就会加快，并且每次的哈希函数计算就是一个消耗资源的行为，布隆过滤器的效率就会降低。</p><p>如果布隆过滤器的长度设置太小了，那么每个bit位置1的速度也会加快，误报率同样会增加。</p><p>如果布隆过滤器的长度设置太大了，那么就意味着更多的空间。</p><p>对于哈希函数的个数和布隆过滤器的长度选择有一个公式：</p><p>m：布隆过滤器的长度    k：哈希函数的个数    n：插入元素的个数    p：误报率</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122093555700.png" alt="image-20211122093555700"></p><h2 id="Redis缓存穿透的布隆过滤器的解决方案"><a href="#Redis缓存穿透的布隆过滤器的解决方案" class="headerlink" title="Redis缓存穿透的布隆过滤器的解决方案"></a>Redis缓存穿透的布隆过滤器的解决方案</h2><p>根据上述布隆过滤器的描述，那么我们可以很好的将Redis的缓存穿透和布隆过滤器联系起来。</p><p>一个请求先去Redis缓存中去请求数据，缓存中并不存在，接着我们让这个请求进入布隆过滤器，去判断这个值是否存在，如果存在则再让这个请求进入到数据库中去查询。</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122095540985.png" alt="image-20211122095540985"></p><p>布隆过滤器的特性就是占用的空间相对较小，并且查询速度相比数据库也比较快，能支撑的QPS更高，可以很好的保护数据库。</p><p>分布式环境下，数据放到内存中来处理， 属于local cache 问题；如果想要保持一致性，可以通过数据变更时，群发MQ消息的方式让应用服务器实例更新。这个方案在数据变更频次很低而访接口QPS极高时，可以尝试。否则，当有实例 bloom filter数据未更新时， 在未更新这个间隔内，用户请求路由到不同实例，就会出现一下能查到，一下查不到奇怪现象。 如果数据变更频次很低时，也可以考虑把bloom fliter 数据写到配置中心里，让配置中心把数据推送到应用实例上。</p><h2 id="两种解决方案的对比"><a href="#两种解决方案的对比" class="headerlink" title="两种解决方案的对比"></a>两种解决方案的对比</h2><table><thead><tr><th>解决缓存穿透</th><th>适用场景</th><th>维护成本</th></tr></thead><tbody><tr><td>缓存空对象</td><td>数据命中不高<br />数据变更频次高</td><td>代码维护简单<br />需要过多的缓存空间来存key和null值<br />数据不一致</td></tr><tr><td>布隆过滤器</td><td>数据命中不高<br />数据变更频次低</td><td>代码维护复杂<br />缓存空间占用少</td></tr></tbody></table><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿是指一个热点key，并发量特别的大，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就击穿缓存，直接请求走数据库。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>设置热点数据过期时间</p><p>让过期时间更加均匀一点或者永不过期，这样就解决了热点key过期后的问题。当然这也会带来一些空间的问题。</p></li><li><p>加互斥锁</p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此需要等待。这种方式将高并发的压力转到分布式锁上，因此对分布式锁的考验很大。这样就会导致高并发场景下的性能降低。</p></li></ul><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是指：缓存不可用Redis宕机或者说大批缓存集体失效，大量的请求同时达到数据库，造成数据库系统雪崩。</p><p>产生雪崩的原因之一，比如马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122100233282.png" alt="image-20211122100233282"></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>针对缓存不可用这种情况可以提高缓存层的可用性，比如设计成分布式，Redis集群，配置哨兵模式和cluster实现。</li><li>服务降级（限流降级）：关闭一些服务，保证主要的服务可用。</li><li>数据预热：在正式部署之前，先把可能的数据先预访问一遍，这样部分可能大量访问的数据就会加载到缓存中，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀。</li></ul>]]></content>
    
    
    <summary type="html">Redis存穿透击穿与雪崩以及解决方式</summary>
    
    
    
    <category term="Redis" scheme="http://ins1mn1a.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://ins1mn1a.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化及优化方式</title>
    <link href="http://ins1mn1a.github.io/2021/12/17/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>http://ins1mn1a.github.io/2021/12/17/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</id>
    <published>2021-12-17T12:28:06.258Z</published>
    <updated>2021-12-17T12:52:42.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>因为Redis是内存数据库，一旦宕机，数据就会丢失，所有需要一种持久化的操作，将内存中的数据写到磁盘上保存。Redis本身提供了两种数据持久化方式：RDB和AOF。这两种方式各有其优点和缺点。</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>Redis默认的持久化方案就是RDB。RDB就是把数据以快照的形式保存到磁盘上。快照就类似于VMware上虚拟机快照的意思，把当前时刻状态记录下来。</p><p>RDB持久化是指在指定的时间间隔内，将内存中的数据集快照写入磁盘中。这样方式是将内存中的数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。</p><h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>save命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB持久化完成。这样对于内存比较大的服务器，会造成较长时间的阻塞，所以不太建议使用。</p><p>具体流程如下：</p><p><img src="/../../img/markdown_img/Redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211121091823127.png" alt="image-20211121091823127"></p><p>执行完成后如果存在旧的RDB文件，就会把旧的RDB文件替换成新的RDB文件。客户端数据太大的时候，这种方式显然不可取。</p><h3 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h3><p>bgsave命令Redis会在后台异步进行快照操作，同时Redis还可以响应客户端的请求。</p><p>具体操作是Redis主进程会执行fork操作创建一个子进程，然后RDB持久化过程由子进程负责，完成后自动结束。这样，尽管也会阻塞，但是阻塞只发生在fork阶段，基本上Redis内部所有的RDB操作都是bgsave命令。</p><p>具体流程如下：</p><p><img src="/../../img/markdown_img/Redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211121092857471.png" alt="image-20211121092857471"></p><h3 id="配置文件自动触发"><a href="#配置文件自动触发" class="headerlink" title="配置文件自动触发"></a>配置文件自动触发</h3><p>自动触发模式是需要我们在配置文件redis.conf中完成的。</p><p>配置save，这里的save 3600 1的意思是：如果3600秒内，至少有1个key值变化，就进行持久化。</p><p>在redis.conf配置文件中有配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># You can set these explicitly by uncommenting the three following lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># save 3600 1</span></span><br><span class="line"><span class="comment"># save 300 100</span></span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes<span class="comment"># 默认yes 当启用RDB且最后一次bgsave失败了，Redis是否停止接收数据</span></span><br><span class="line">rdbcompression yes<span class="comment"># 默认yes，存到磁盘的快照，可以设置是否进行压缩存储</span></span><br><span class="line">rdbchecksum yes<span class="comment"># 默认yes，存储快照后让redis进行数据校验，这样做会增加大约10%性能消耗</span></span><br><span class="line">dbfilename dump.rdb<span class="comment"># 快照文件名</span></span><br><span class="line">dir ./<span class="comment"># 快照文件存放路径</span></span><br></pre></td></tr></table></figure><h3 id="save与bgsave的比较"><a href="#save与bgsave的比较" class="headerlink" title="save与bgsave的比较"></a>save与bgsave的比较</h3><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞</td><td>是</td><td>是（仅在fork期间阻塞）</td></tr><tr><td>复杂度</td><td>O（n）</td><td>O（n）</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>fork，消耗额外内存</td></tr></tbody></table><p>除了上述三种方式，以下情况也会生成RDB文件：</p><ul><li>主从的全量复制时，主机会生成RDB文件。</li><li>Redis中的debug reload提供debug级别的重启，不清空内存的一种重启，这种方式也会触发RDB文件的生成。</li><li>执行shutdown时，会触发RDB文件的生成。</li><li>执行flushall命令，也会生成dump.rdb文件，但此时里面是空的。</li></ul><h2 id="RDB的优点和缺点"><a href="#RDB的优点和缺点" class="headerlink" title="RDB的优点和缺点"></a>RDB的优点和缺点</h2><p>优点</p><ul><li>RDB文件是全量备份，适合用于进行备份和数据恢复</li><li>生成RDB文件的时候，Redis主进程会fork( )一个子进程来处理所有保存的工作，主进程不需要进行任何磁盘IO操作</li><li>RDB在加载RDB恢复数据比AOF方式快</li></ul><p>缺点</p><ul><li>RDB是全量备份比较耗时，存储的是内存数据的二进制序列化形式，存储上非常紧凑。写RDB文件还是会消耗大量IO性能。</li><li>当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有主进程的内存数据，父进程如果在此时进行数据的修改，子进程并不知情，所有在持久化期间修改的数据不会被保存，如果此时宕机，就有可能丢失数据。即并不支持数据持久化的实时性。</li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>RDB的全量备份有些耗时，所以提出了另外一种持久化方式AOF。此外，AOF还可以解决数据持久化的实时性。</p><p>默认关闭AOF模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><h2 id="持久化原理"><a href="#持久化原理" class="headerlink" title="持久化原理"></a>持久化原理</h2><p>AOF的持久化方式工作机制很简单，Redis将收到的每一个写命令都通过write函数追加到aof文件中。</p><p>随着aof文件越来越大，需要定期对aof文件进行重写，达到压缩的目的。</p><h2 id="文件重写原理"><a href="#文件重写原理" class="headerlink" title="文件重写原理"></a>文件重写原理</h2><ol><li><p>AOF的方式每次写命令都追加到aof文件中，这样aof文件会变得越来越大。为了压缩aof的持久化文件，Redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时fork出一条新进程来将文件重写。</p></li><li><p>重写后的aof文件为什么可以变小</p><p>a). 进程内已经超时的数据不再写入文件。</p><p>b). 旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a111、set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</p><p>c). 多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢 出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。</p></li></ol><p>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据内容用命令的方式重写一个新的aof文件。</p><p>重写后的aof文件更小，可以被Redis更快的加载。</p><h3 id="触发方式-1"><a href="#触发方式-1" class="headerlink" title="触发方式"></a>触发方式</h3><h4 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h4><p>通过Redis的命令bgrewriteaof手动触发</p><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p><p>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。</p><p>auto-aof-rewrite-percentage：代表当前AOF文件空间 （aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb<span class="comment"># 表示运行AOF重写时文件最小体积，默认为64MB。</span></span><br></pre></td></tr></table></figure><p>自动触发时机 = aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（aof_current_size - aof_base_size）/ aof_base_size&gt;=auto-aof-rewritepercentage</p><p>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</p><h2 id="触发方式-2"><a href="#触发方式-2" class="headerlink" title="触发方式"></a>触发方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If unsure, use &quot;everysec&quot;.</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure><ul><li><p>always Redis的每条写命令都写入到系统aof_buffer缓冲区，然后fsync同步到磁盘。每次发送数据变更会被立即记录到磁盘，<strong>性能较差，IO开销比较大</strong>。但是数据完整性比较好。</p></li><li><p>everysec 过程与always相同，每秒记录一次，如果一秒内宕机，则会有数据丢失。</p></li><li><p>no 从不记录。</p></li></ul><h2 id="AOF的优点和缺点"><a href="#AOF的优点和缺点" class="headerlink" title="AOF的优点和缺点"></a>AOF的优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>AOF可以更好的保存数据不丢失，一般AOF每隔一秒，通过一个后台线程执行一次fsync操作，最多丢失1s的数据。</li><li>AOF日志文件过大的时候，出现后台重写操作，不会影响客户端的读写。</li><li>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如如果不小心flushall清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令删除，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</li><li>AOF开启后，支持的写QPS（每秒查询率）会比RDB支持的写QPS低，因为AOP一般会配置成每秒fsync一次日志文件，每秒一次fsync，性能也还是很高的</li></ul><h1 id="RDB和AOF比较"><a href="#RDB和AOF比较" class="headerlink" title="RDB和AOF比较"></a>RDB和AOF比较</h1><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>没有实时持久化</td><td>根据策略不同决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table><h1 id="Redis启动数据加载的流程"><a href="#Redis启动数据加载的流程" class="headerlink" title="Redis启动数据加载的流程"></a>Redis启动数据加载的流程</h1><ol><li>AOF持久化开启并且存在AOF文件，优先加载AOF文件。</li><li>AOF持久化关闭或者AOF文件不存在，加载RDB文件。</li><li>AOF/RDB加载成功后，Redis启动成功。</li><li>AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</li></ol><h1 id="Redis持久化的优化方式"><a href="#Redis持久化的优化方式" class="headerlink" title="Redis持久化的优化方式"></a>Redis持久化的优化方式</h1><p>可以看到不管是RDB的快照，还是AOP的重写，都需要fork一个进程，这会对Redis造成阻塞。因此为了不影响Redis主进程的响应，我们需要尽可能的降低阻塞。即是<strong>减少fork操作的阻塞。</strong></p><ol><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例的最大可用内存maxmemory，fork耗时跟内存量成正比。</li><li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败。vm.overcommit_memory=1。默认值为0，会使Linux在内存分配时，发现不够内存不足时，不会进行分配，进而造成fork阻塞。</li><li>降低fork频率。放宽AOF自动触发时机，避免不必要的全量复制。</li></ol>]]></content>
    
    
    <summary type="html">Redis持久化aof、rdb</summary>
    
    
    
    <category term="Redis" scheme="http://ins1mn1a.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://ins1mn1a.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity+Jwt整合</title>
    <link href="http://ins1mn1a.github.io/2021/12/17/SpringSecurity/SpringSecurity+Jwt%E6%95%B4%E5%90%88/"/>
    <id>http://ins1mn1a.github.io/2021/12/17/SpringSecurity/SpringSecurity+Jwt%E6%95%B4%E5%90%88/</id>
    <published>2021-12-17T12:15:04.707Z</published>
    <updated>2021-12-17T12:35:55.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="常见的认证机制"><a href="#常见的认证机制" class="headerlink" title="常见的认证机制"></a>常见的认证机制</h3><h4 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h4><p>　HTTP Basic Auth简单点说就是每次请求API时都提供用户的username和password。简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth。</p><h4 id="Cookie-Auth"><a href="#Cookie-Auth" class="headerlink" title="Cookie Auth"></a>Cookie Auth</h4><p>​    Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。     </p><p><img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image64.png"></p><h4 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h4><p>　OAuth（开放授权,Open Authorization）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。</p><p>　OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。</p><p>下面是OAuth2.0的流程：</p><p> <img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image65.png"></p><p>　这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。</p><p>缺点：过重。</p><h4 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h4><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li><p>客户端使用用户名跟密码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p></li><li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p></li></ol><p> <img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image66.png"></p><p>比第一种方式更安全，比第二种方式更节约服务器资源，比第三种方式更加轻量。</p><p>具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）：</p><ol><li><p>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</p></li><li><p>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</p></li><li><p>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</p></li><li><p>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</p></li><li><p>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 10等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p></li><li><p>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</p></li><li><p>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多.</p></li><li><p>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</p></li><li><p>基于标准化：你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</p></li></ol><h2 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h2><h4 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h4><p>　JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。</p><p>官网：  <a href="https://jwt.io/">https://jwt.io/</a></p><p>标准：  <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a></p><p>JWT令牌的优点：</p><ol><li><p>jwt基于json，非常方便解析。</p></li><li><p>可以在令牌中自定义丰富的内容，易扩展。</p></li><li><p>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</p></li><li><p>资源服务使用JWT可不依赖认证服务即可完成授权。</p></li></ol><p>缺点：</p><ol><li>JWT令牌较长，占存储空间比较大。</li></ol><h4 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h4><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p><h5 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h5><p>头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法（如HMAC SHA256或RSA）等。这也可以被表示成一个JSON对象。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>typ</code>：是类型。</p></li><li><p><code>alg</code>：签名的算法，这里使用的算法是HS256算法</p></li></ul><p>我们对头部的json字符串进行BASE64编码（网上有很多在线编码的网站），编码后的字符串如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  </span><br></pre></td></tr></table></figure><p>　<code>Base64</code>是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 <code>BASE64Encoder </code>和 <code>BASE64Decoder</code>，用它们可以非常方便的完成基于 BASE64 的编码和解码。</p><h5 id="负载-Payload"><a href="#负载-Payload" class="headerlink" title="负载(Payload)"></a>负载(Payload)</h5><p>第二部分是负载，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：</p><ul><li>标准中注册的声明（建议但不强制使用）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iss: jwt签发者</span><br><span class="line">sub: jwt所面向的用户</span><br><span class="line">aud: 接收jwt的一方</span><br><span class="line">exp: jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">nbf: 定义在什么时间之前，该jwt都是不可用的.</span><br><span class="line">iat: jwt的签发时间</span><br><span class="line">jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</span><br></pre></td></tr></table></figure><ul><li>公共的声明</li></ul><p>　公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><ul><li>私有的声明</li></ul><p>　私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>　这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>sub</code>是标准的声明，<code>name</code>是自定义的声明（公共的或私有的）</p><p>然后将其进行base64编码，得到Jwt的第二部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbWVzIiwiYWRtaW4iOnRydWV9  </span><br></pre></td></tr></table></figure><p>提示：声明中不要放一些敏感信息。</p><h5 id="签证、签名（signature）"><a href="#签证、签名（signature）" class="headerlink" title="签证、签名（signature）"></a>签证、签名（signature）</h5><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ol><li><p>header (base64后的)</p></li><li><p>payload (base64后的)</p></li><li><p>secret（盐，一定要保密）</p></li></ol><p>　这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI</span><br></pre></td></tr></table></figure><p>将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR9cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI  </span><br></pre></td></tr></table></figure><p>注意：<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以自我签发<code>jwt</code>了。</p><h3 id="JJWT简介"><a href="#JJWT简介" class="headerlink" title="JJWT简介"></a>JJWT简介</h3><h4 id="什么是JJWT"><a href="#什么是JJWT" class="headerlink" title="什么是JJWT"></a>什么是JJWT</h4><p>　JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</p><p>规范官网：<a href="https://jwt.io/">https://jwt.io/</a></p><h2 id="SpringSecurity整合JWT"><a href="#SpringSecurity整合JWT" class="headerlink" title="SpringSecurity整合JWT"></a>SpringSecurity整合JWT</h2><p>SpringSecurity整合JWT最终达到的效果：</p><p>当用户首次登录的时候，输入用户名和密码走正常的登录逻辑，到数据库中根据用户名找到用户的密码信息，然后比对密码是否匹配。若匹配，先将这个用户存入Security的安全上下文holder中，然后利用<strong>JWT工具类</strong>生成一个token，返回给客户端。</p><p>接下来，用户每次请求，都需要在请求头header中携带一个token，这个token首先会进入我们<strong>自定义的Jwt登录认证过滤器</strong>，从请求头中获取token，利用<strong>Jwt工具类</strong>解析token，如果能获取到用户名，则用户认证成功，执行下一个过滤器。否则用<strong>自定义的拒绝访问类</strong>返回权限不足，或者直接用<strong>自定义的认证失败类</strong>返回token失效或者请先登录。</p><h3 id="Application-properties配置"><a href="#Application-properties配置" class="headerlink" title="Application.properties配置"></a>Application.properties配置</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">springsecurityforjwt</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="comment"># Jwt盐</span></span><br><span class="line"><span class="meta">jwt.secret</span>=<span class="string">******</span></span><br><span class="line"><span class="comment"># 请求头的key value为token</span></span><br><span class="line"><span class="meta">jwt.tokenHeader</span>=<span class="string">Authorization</span></span><br><span class="line"><span class="comment"># 过期时间7天</span></span><br><span class="line"><span class="meta">jwt.expiration</span>=<span class="string">604800</span></span><br><span class="line"><span class="comment"># token的头部</span></span><br><span class="line"><span class="meta">jwt.tokenHead</span>=<span class="string">Bearer</span></span><br><span class="line"><span class="comment"># 配置freemarker视图的位置</span></span><br><span class="line"><span class="meta">spring.freemarker.template-loader-path</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="comment"># 配置freemarker后缀</span></span><br><span class="line"><span class="meta">spring.freemarker.suffix</span>=<span class="string">.ftl</span></span><br><span class="line"><span class="meta">spring.freemarker.charset</span>=<span class="string">utf-8</span></span><br></pre></td></tr></table></figure><h3 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.springsecurityforjwt.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_USERNAME=<span class="string">&quot;sub&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_CREATED=<span class="string">&quot;created&quot;</span>;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHead;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expiration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTokenHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tokenHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expiration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims claims</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateToken</span><span class="params">(Map&lt;String,Object&gt; claims)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户信息生成token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从token中获取负载</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> claims</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Claims <span class="title">getClaimsFromToken</span><span class="params">(String token)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Claims claims = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secret)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;JWT格式验证失败:&#123;&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从token中获取登录用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsernameFromToken</span><span class="params">(String token)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String username;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            username = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> expiration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">generateExpirationDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(System.currentTimeMillis()+expiration*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证token是否还有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     *客户端传入的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDetails 从数据库中查询出来的用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateToken</span><span class="params">(String token, UserDetails userDetails)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String username = getUsernameFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断token是否已经失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTokenExpired</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date expiredDate = getExpiredDateFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> expiredDate.before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从token中获取过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getExpiredDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClaimsFromToken(token).getExpiration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当原来的token没过期时是可以刷新的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldToken 带tokenHead的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">refreshHeadToken</span><span class="params">(String oldToken)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(oldToken))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = oldToken.substring(tokenHead.length());</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//token校验不通过</span></span><br><span class="line">        Claims claims = getClaimsFromToken(token);</span><br><span class="line">        <span class="keyword">if</span>(claims==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果token已经过期，不支持刷新</span></span><br><span class="line">        <span class="keyword">if</span>(isTokenExpired(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">return</span> generateToken(claims);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jwt登录认证过滤器JwtAuthenticationFilter"><a href="#Jwt登录认证过滤器JwtAuthenticationFilter" class="headerlink" title="Jwt登录认证过滤器JwtAuthenticationFilter"></a>Jwt登录认证过滤器JwtAuthenticationFilter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHead;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String authHeader=request.getHeader(tokenHeader);</span><br><span class="line">        System.out.println(authHeader);</span><br><span class="line">        <span class="comment">//存在token</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>!=authHeader&amp;&amp;authHeader.startsWith(tokenHead))</span><br><span class="line">        &#123;</span><br><span class="line">            String authToken=authHeader.substring(tokenHead.length());</span><br><span class="line">            System.out.println(authToken);</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            System.out.println(<span class="string">&quot;token中解析到的用户名为：&quot;</span>+username);</span><br><span class="line">            <span class="comment">//token存在但是未登录</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span>!=username&amp;&amp;<span class="keyword">null</span>==SecurityContextHolder.getContext().getAuthentication())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//登录</span></span><br><span class="line">                User user = userService.findUserByUsername(username);</span><br><span class="line">                System.out.println(user);</span><br><span class="line">                <span class="comment">//判断token是否有效</span></span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken,user))</span><br><span class="line">                &#123;</span><br><span class="line">                    UsernamePasswordAuthenticationToken authenticationToken=</span><br><span class="line">                            <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    authenticationToken.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝方法异常RestfulAccessDeniedHandler"><a href="#拒绝方法异常RestfulAccessDeniedHandler" class="headerlink" title="拒绝方法异常RestfulAccessDeniedHandler"></a>拒绝方法异常RestfulAccessDeniedHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean error = RespBean.error(<span class="string">&quot;权限不足，联系管理员!&quot;</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));</span><br><span class="line">        error.setCode(<span class="number">403</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="认证失败异常RestfulAuthorizationEntryPoint"><a href="#认证失败异常RestfulAuthorizationEntryPoint" class="headerlink" title="认证失败异常RestfulAuthorizationEntryPoint"></a>认证失败异常RestfulAuthorizationEntryPoint</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当未登录或者token失效时访问接口自定义的返回结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAuthorizationEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean bean = RespBean.error(<span class="string">&quot;请先登录!&quot;</span>);</span><br><span class="line">        bean.setCode(<span class="number">401</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(bean));</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringSecurity安全配置类"><a href="#SpringSecurity安全配置类" class="headerlink" title="SpringSecurity安全配置类"></a>SpringSecurity安全配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationFilter jwtAuthenticationFilter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestfulAccessDeniedHandler restfulAccessDeniedHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestfulAuthorizationEntryPoint restfulAuthorizationEntryPoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/toLogin&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/static/**&quot;</span>,<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/static/**&quot;</span>,<span class="string">&quot;wabjars/**&quot;</span>,<span class="string">&quot;swagger-resources/**&quot;</span>,<span class="string">&quot;/v2/api-doc/**&quot;</span>).permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//开启跨域访问</span></span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//使用jwt，禁用csrf保护</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//关闭session存储</span></span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .headers().cacheControl();</span><br><span class="line">            <span class="comment">//配置自定义过滤器 添加jwt登录授权过滤器</span></span><br><span class="line">            <span class="comment">//在过滤器UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line">            http.addFilterBefore(jwtAuthenticationFilter,UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">            <span class="comment">//添加自定义未授权未登录结果返回</span></span><br><span class="line">            http.exceptionHandling()</span><br><span class="line">                    .accessDeniedHandler(restfulAccessDeniedHandler)</span><br><span class="line">                    .authenticationEntryPoint(restfulAuthorizationEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenUtil <span class="title">tokenUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenUtil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">login</span><span class="params">(User user, HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.login(user,request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserInfo</span><span class="params">(Principal principal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==principal)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String username = principal.getName();</span><br><span class="line">        User user = userService.findUserByUsername(username);</span><br><span class="line">        user.setPassword(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service实现类"><a href="#Service实现类" class="headerlink" title="Service实现类"></a>Service实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserByUsername&quot;</span>);</span><br><span class="line">        User user = userMapper.findUserByUsername(username);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">login</span><span class="params">(User user, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//登录</span></span><br><span class="line">        User userDetails = userMapper.findUserByUsername(user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">&quot;登录用户为：&quot;</span>+user);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==userDetails||passwordEncoder.matches(user.getPassword(),userDetails.getPassword()))</span><br><span class="line">            <span class="keyword">return</span> RespBean.error(<span class="string">&quot;用户名或者密码不正确&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!userDetails.isEnabled())</span><br><span class="line">            <span class="keyword">return</span> RespBean.error(<span class="string">&quot;账户被禁止使用，请联系管理员&quot;</span>);</span><br><span class="line">        <span class="comment">//更新security登录用户对象</span></span><br><span class="line">        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken=</span><br><span class="line">                <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails,<span class="keyword">null</span>,userDetails.getAuthorities());</span><br><span class="line">        String token=jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">        map.put(<span class="string">&quot;tokenHead&quot;</span>,jwtTokenUtil.getTokenHead());</span><br><span class="line">        <span class="keyword">return</span> RespBean.success(<span class="string">&quot;登录成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Postman测试"><a href="#Postman测试" class="headerlink" title="Postman测试"></a>Postman测试</h3><p>用户首次进行访问登录接口，携带username和password以post方式进行提交。服务器端返回一个token。</p><p>因为后端采用的PostMapping所以注意提交方式。</p><p><img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image-20211202195719521.png" alt="image-20211202195719521"></p><p>用户访问后端其他接口，需要在请求头中加上token。</p><p>因为后端采用的GetMapping所以注意提交方式。</p><p><img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image-20211202200021002.png" alt="image-20211202200021002"></p>]]></content>
    
    
    <summary type="html">SpringSecurity+Jwt的整合</summary>
    
    
    
    <category term="SpringSecurity" scheme="http://ins1mn1a.github.io/categories/SpringSecurity/"/>
    
    
    <category term="SpringSecurity" scheme="http://ins1mn1a.github.io/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity</title>
    <link href="http://ins1mn1a.github.io/2021/12/17/SpringSecurity/SpringSecurity/"/>
    <id>http://ins1mn1a.github.io/2021/12/17/SpringSecurity/SpringSecurity/</id>
    <published>2021-12-17T12:15:04.704Z</published>
    <updated>2021-12-17T12:36:07.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p><img src="/../../img/markdown_img/SpringSecurity.assets/Snipaste_2020-03-04_19-34-27.png"></p><h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><h3 id="SpringSecurity简介"><a href="#SpringSecurity简介" class="headerlink" title="SpringSecurity简介"></a>SpringSecurity简介</h3><h4 id="安全框架概述"><a href="#安全框架概述" class="headerlink" title="安全框架概述"></a>安全框架概述</h4><p>　什么是安全框架？ 解决系统安全问题的框架。如果没有安全框架，我们需要手动处理每个资源的访问控制，非常麻烦。使用安全框架，我们可以通过配置的方式实现对资源的访问限制。</p><h4 id="常用安全框架"><a href="#常用安全框架" class="headerlink" title="常用安全框架"></a>常用安全框架</h4><ul><li><p>Spring Security：Spring家族一员。是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了<code>Spring IoC</code>，<code>DI（控制反转Inversion of Control,DI:Dependency Injection 依赖注入）</code>和<code>AOP（面向切面编程）</code>功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p></li><li><p>Apache Shiro：一个功能强大且易于使用的Java安全框架,提供了认证,授权,加密,和会话管理。</p></li></ul><h4 id="Spring-Security简介"><a href="#Spring-Security简介" class="headerlink" title="Spring Security简介"></a>Spring Security简介</h4><p><strong>概述</strong></p><p>　Spring Security是一个高度自定义的安全框架。利用 Spring IoC/DI和AOP功能，为系统提供了声明式安全访问控制功能，减少了为系统安全而编写大量重复代码的工作。使用 Spring Secruity 的原因有很多，但大部分都是发现了 javaEE的 Servlet 规范或 EJB 规范中的安全功能缺乏典型企业应用场景。同时认识到他们在 WAR 或 EAR 级别无法移植。因此如果你更换服务器环境，还有大量工作去重新配置你的应用程序。使用 Spring Security解决了这些问题，也为你提供许多其他有用的、可定制的安全功能。正如你可能知道的两个应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两点也是 Spring Security 重要核心功能。“认证”，是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统），通俗点说就是系统认为用户是否能登录。“授权”指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情。</p><p><strong>历史</strong></p><p>　Spring Security 以“The Acegi Secutity System for Spring”的名字始于2003年年底。其前身为 acegi 项目。起因是 Spring 开发者邮件列表中一个问题，有人提问是否考虑提供一个基于 Spring 的安全实现。限制于时间问题，开发出了一个简单的安全实现，但是并没有深入研究。几周后，Spring 社区中其他成员同样询问了安全问题，代码提供给了这些人。2004 年 1 月份已经有 20 人左右使用这个项目。随着更多人的加入，在 2004 年 3 月左右在 sourceforge 中建立了一个项目。在最开始并没有认证模块，所有的认证功能都是依赖容器完成的，而 acegi 则注重授权。但是随着更多人的使用，基于容器的认证就显现出了不足。acegi 中也加入了认证功能。大约 1 年后 acegi 成为 Spring子项目。在 2006 年 5 月发布了 acegi 1.0.0 版本。2007 年底 acegi 更名为Spring Security。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yjxxt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springsecurity-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>springsecurity-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--spring security 组件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--web 组件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- test 组件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h4><p>login.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h4><p>　导入spring-boot-starter-security 启动器后，Spring Security 已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。</p><p>​         <img src="/../../img/markdown_img/SpringSecurity.assets/image1.png">             </p><p>默认的 username 为 user，password 打印在控制台中。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image2.png"></p><p>在浏览器中输入账号和密码后会显示 login.html 页面内容。</p><h3 id="UserDetailsService详解"><a href="#UserDetailsService详解" class="headerlink" title="UserDetailsService详解"></a>UserDetailsService详解</h3><p>　当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口定义如下：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image3.png"></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回值 UserDetails 是一个接口，定义如下</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image4.png"></p><p>要想返回 <code>UserDetails </code>的实例就只能返回接口的实现类。SpringSecurity 中提供了如下的实例。对于我们只需要使用里面的 <code>User </code>类即可。注意 User 的全限定路径是：</p><p><code>org.springframework.security.core.userdetails.User</code>此处经常和系统中自己开发的 User 类弄混。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image5.png"></p><p>在 User 类中提供了很多方法和属性。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image6.png"></p><p>其中构造方法有两个，调用其中任何一个都可以实例化</p><p><code>UserDetails </code>实现类 <code>User </code>类的实例。而三个参数的构造方法实际上也是调用 7 个参数的构造方法。</p><ul><li><p><code>username</code>:用户名</p></li><li><p><code>password</code>:密码</p></li><li><p><code>authorities</code>：用户具有的权限。此处不允许为 null</p></li></ul><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image7.png"></p><p>　此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。Spring Security 会根据 User 中的 <code>password</code>和客户端传递过来的 <code>password </code>进行比较。如果相同则表示认证通过，如果不相同表示认证失败。</p><p>　<code>authorities </code>里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现 403。通常都是通过<code>AuthorityUtils.commaSeparatedStringToAuthorityList(“”)</code> 来创建<code>authorities</code> 集合对象的。参数是一个字符串，多个权限使用逗号分隔。</p><h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><p>方法参数表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫 <code>username</code>，否则无法接收。</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>　<code>UsernameNotFoundException </code>用户名没有发现异常。在<code>loadUserByUsername</code>中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出<code>UsernameNotFoundException</code>，系统就知道用户名没有查询到。</p><h3 id="PasswordEncoder-密码解析器详解"><a href="#PasswordEncoder-密码解析器详解" class="headerlink" title="PasswordEncoder 密码解析器详解"></a>PasswordEncoder 密码解析器详解</h3><p>　Spring Security 要求容器中必须有<code>PasswordEncoder</code>实例。所以当自定义登录逻辑时要求必须给容器注入<code>PaswordEncoder</code>的bean对象。</p><h4 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h4><ul><li><p><code>encode()</code>：把参数按照特定的解析规则进行解析。</p></li><li><p><code>matches()</code> ：验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。</p></li><li><p><code>upgradeEncoding()</code>：如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回 false。默认返回 false。</p></li></ul><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image8.png"></p><h4 id="内置解析器介绍"><a href="#内置解析器介绍" class="headerlink" title="内置解析器介绍"></a>内置解析器介绍</h4><p>在 Spring Security 中内置了很多解析器。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image9.png"></p><h4 id="BCryptPasswordEncoder-简介"><a href="#BCryptPasswordEncoder-简介" class="headerlink" title="BCryptPasswordEncoder 简介"></a>BCryptPasswordEncoder 简介</h4><p>　BCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，平时多使用这个解析器。</p><p>　BCryptPasswordEncoder 是对 <code>bcrypt </code>强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度，默认 10.</p><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p>新建测试方法BCryptPasswordEncoder 用法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//创建解析器</span></span><br><span class="line">      PasswordEncoder pw = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">      <span class="comment">//对密码加密</span></span><br><span class="line">      String encode = pw.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      System.out.println(encode);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断原字符和加密后内容是否匹配</span></span><br><span class="line">      <span class="keyword">boolean</span> matches = pw.matches(<span class="string">&quot;1234&quot;</span>, encode);</span><br><span class="line">      System.out.println(<span class="string">&quot;===================&quot;</span>+matches);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义登录逻辑"><a href="#自定义登录逻辑" class="headerlink" title="自定义登录逻辑"></a>自定义登录逻辑</h3><p>　当 进 行 自 定 义 登 录 逻 辑 时 需 要 用 到 之 前 讲 解 的<code>UserDetailsService </code>和 <code>PasswordEncoder</code>。但是 Spring Security 要求：当进行自定义登录逻辑时容器内必须有 <code>PasswordEncoder </code>实例。所以不能直接 new 对象。</p><h4 id="编写配置类"><a href="#编写配置类" class="headerlink" title="编写配置类"></a>编写配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">getPw</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义逻辑"><a href="#自定义逻辑" class="headerlink" title="自定义逻辑"></a>自定义逻辑</h4><p>在 Spring Security 中实现 UserDetailService 就表示为用户详情服务。在这个类中编写用户认证逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> PasswordEncoder pw;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">      <span class="comment">//1.查询数据库判断用户名是否存在，如果不存在抛出UsernameNotFoundException异常</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="string">&quot;admin&quot;</span>.equals(username))&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//2.把查询出来的密码（注册时已经加密过）进行解析，或直接把密码放入构造方法中</span></span><br><span class="line">      String password = pw.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,normal&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h4><p>重启项目后，在浏览器中输入账号：admin，密码：123。后可以正确进入到 login.html 页面。</p><h3 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h3><p>　虽然 Spring Security 给我们提供了登录页面，但是对于实际项目中，大多喜欢使用自己的登录页面。所以 Spring Security 中不仅仅提供了登录页面，还支持用户自定义登录页面。实现过程也比较简单，只需要修改配置类即可。</p><h4 id="编写登录页面"><a href="#编写登录页面" class="headerlink" title="编写登录页面"></a>编写登录页面</h4><p>login.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改配置类"><a href="#修改配置类" class="headerlink" title="修改配置类"></a>修改配置类</h4><p>修改配置类中主要是设置哪个页面是登录页面。配置类需要继承WebSecurityConfigurerAdapter,并重写 configure 方法。</p><ul><li><p><code>successForwardUrl()</code>：登录成功后跳转地址</p></li><li><p><code>loginPage()</code> ：登录页面</p></li><li><p><code>loginProcessingUrl </code>：登录页面表单提交地址，此地址可以不真实存在。</p></li><li><p><code>antMatchers()</code>：匹配内容</p></li><li><p><code>permitAll()</code>：允许</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//表单提交</span></span><br><span class="line">      http.formLogin()</span><br><span class="line">            <span class="comment">//自定义登录页面</span></span><br><span class="line">            .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">            <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">            .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      http.authorizeRequests()</span><br><span class="line">            <span class="comment">//login.html不需要被认证</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/login.html&quot;</span>).permitAll()</span><br><span class="line">            <span class="comment">//所有请求都必须被认证，必须登录后被访问</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭csrf防护</span></span><br><span class="line">      http.csrf().disable();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">getPw</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写控制器"><a href="#编写控制器" class="headerlink" title="编写控制器"></a>编写控制器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">   <span class="comment">//该方法不执行</span></span><br><span class="line">   <span class="comment">// @RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="comment">// public String login()&#123;</span></span><br><span class="line">   <span class="comment">//     System.out.println(&quot;登录方法&quot;);</span></span><br><span class="line">   <span class="comment">//     return &quot;main.html&quot;;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 成功后跳转页面</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/toMain&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="认证过程其他常用配置"><a href="#认证过程其他常用配置" class="headerlink" title="认证过程其他常用配置"></a>认证过程其他常用配置</h3><h4 id="失败跳转"><a href="#失败跳转" class="headerlink" title="失败跳转"></a>失败跳转</h4><p>表单处理中成功会跳转到一个地址，失败也可以跳转到一个地址。</p><h5 id="编写页面error-html"><a href="#编写页面error-html" class="headerlink" title="编写页面error.html"></a>编写页面error.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">操作失败，请重新登录 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>= <span class="string">&quot;/login.html&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改表单配置"><a href="#修改表单配置" class="headerlink" title="修改表单配置"></a>修改表单配置</h5><p>　在配置方法中表单认证部分添加<code> failureForwardUrl()</code>方法，表示登录失败跳转的 url。此处依然是 POST 请求，所以跳转到可以接收 POST请求的控制器/error中。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表单提交</span></span><br><span class="line">http.formLogin()</span><br><span class="line">      <span class="comment">//自定义登录页面</span></span><br><span class="line">      .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">      <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">      .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">      <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">      .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>)</span><br><span class="line">      <span class="comment">//登录失败后跳转页面，POST请求</span></span><br><span class="line">      .failureForwardUrl(<span class="string">&quot;/toError&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="添加控制器的方法"><a href="#添加控制器的方法" class="headerlink" title="添加控制器的方法"></a>添加控制器的方法</h5><p>　在控制器类中添加控制器方法，方法映射路径/error。此处要注意：由于是 POST 请求访问/error。所以如果返回值直接转发到 error.html 中，即使有效果，控制台也会报警告，提示 error.html 不支持 POST 访问方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 失败后跳转页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toError&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toError</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/error.html&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置error-html不需要认证"><a href="#设置error-html不需要认证" class="headerlink" title="设置error.html不需要认证"></a>设置error.html不需要认证</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">      <span class="comment">//login.html不需要被认证</span></span><br><span class="line">      .antMatchers(<span class="string">&quot;/login.html&quot;</span>).permitAll()</span><br><span class="line">      <span class="comment">//error.html不需要被认证</span></span><br><span class="line">      .antMatchers(<span class="string">&quot;/error.html&quot;</span>).permitAll()</span><br><span class="line">      <span class="comment">//所有请求都必须被认证，必须登录后被访问</span></span><br><span class="line">      .anyRequest().authenticated();</span><br></pre></td></tr></table></figure><h4 id="设置请求账户和密码的参数名"><a href="#设置请求账户和密码的参数名" class="headerlink" title="设置请求账户和密码的参数名"></a>设置请求账户和密码的参数名</h4><h5 id="源码简介"><a href="#源码简介" class="headerlink" title="源码简介"></a>源码简介</h5><p>当进行登录时会执行 UsernamePasswordAuthenticationFilter 过滤器。</p><ul><li><p><code>usernamePasrameter</code>：账户参数名</p></li><li><p><code>passwordParameter</code>：密码参数名</p></li><li><p><code>postOnly=true</code>：默认情况下只允许POST请求。</p></li></ul><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image10.png"></p><h5 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表单提交</span></span><br><span class="line">http.formLogin()</span><br><span class="line">      <span class="comment">//自定义登录页面</span></span><br><span class="line">      .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">      <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">      .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">      <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">      .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>)</span><br><span class="line">      <span class="comment">//登录失败后跳转页面，POST请求</span></span><br><span class="line">      .failureForwardUrl(<span class="string">&quot;/toError&quot;</span>)</span><br><span class="line">      .usernameParameter(<span class="string">&quot;myusername&quot;</span>)</span><br><span class="line">      .passwordParameter(<span class="string">&quot;mypassword&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="修改login-html"><a href="#修改login-html" class="headerlink" title="修改login.html"></a>修改login.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myusername&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mypassword&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义登录成功处理器"><a href="#自定义登录成功处理器" class="headerlink" title="自定义登录成功处理器"></a>自定义登录成功处理器</h4><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>　使用successForwardUrl()时表示成功后转发请求到地址。内部是通过 <code>successHandler()</code>方法进行控制成功后交给哪个类进行处理</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image11.png"></p><p>　ForwardAuthenticationSuccessHandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image12.png"></p><p>当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>自定义类</strong></p><p>新建类 com.yjxxt.handler.MyAuthenticationSuccessHandler 编写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyAuthenticationSuccessHandler</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.url = url;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      <span class="comment">//Principal 主体，存放了登录用户的信息</span></span><br><span class="line">      User user = (User) authentication.getPrincipal();</span><br><span class="line">      System.out.println(user.getUsername());</span><br><span class="line">      <span class="comment">//输出null</span></span><br><span class="line">      System.out.println(user.getPassword());</span><br><span class="line">      System.out.println(user.getAuthorities());</span><br><span class="line">      response.sendRedirect(url);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改配置项</strong></p><p>使用 successHandler()方法设置成功后交给哪个对象进行处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表单提交</span></span><br><span class="line">http.formLogin()</span><br><span class="line">      <span class="comment">//自定义登录页面</span></span><br><span class="line">      .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">      <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">      .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">      <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">      <span class="comment">// .successForwardUrl(&quot;/toMain&quot;)</span></span><br><span class="line">      <span class="comment">//和successForwardUrl不能共存</span></span><br><span class="line">      .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler(<span class="string">&quot;http://www.baidu.com&quot;</span>))</span><br><span class="line">      <span class="comment">//登录失败后跳转页面，POST请求</span></span><br><span class="line">      .failureForwardUrl(<span class="string">&quot;/toError&quot;</span>)</span><br><span class="line">      .usernameParameter(<span class="string">&quot;myusername&quot;</span>)</span><br><span class="line">      .passwordParameter(<span class="string">&quot;mypassword&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="自定义登录失败处理器"><a href="#自定义登录失败处理器" class="headerlink" title="自定义登录失败处理器"></a>自定义登录失败处理器</h4><h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>failureForwardUrl()内部调用的是<code> failureHandler()</code>方法</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image13.png"></p><p>ForwardAuthenticationFailureHandler 中也是一个请求转发，并在request 作用域中设置 <code>SPRING_SECURITY_LAST_EXCEPTION </code>的 key，内容为异常对象。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image14.png"></p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>新建控制器</strong></p><p>新建 com.yjxxt.handler.MyForwardAuthenticationFailureHandler 实现AuthenticationFailureHandler。在方法中添加重定向语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyForwardAuthenticationFailureHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyForwardAuthenticationFailureHandler</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.url = url;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      response.sendRedirect(url);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改配置类</strong></p><p>修改配置类中表单登录部分。设置失败时交给失败处理器进行操作。<code>failureForwardUrl </code>和 <code>failureHandler </code>不可共存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表单提交</span></span><br><span class="line">http.formLogin()</span><br><span class="line">      <span class="comment">//自定义登录页面</span></span><br><span class="line">      .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">      <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">      .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">      <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">      <span class="comment">// .successForwardUrl(&quot;/toMain&quot;)</span></span><br><span class="line">      <span class="comment">//和successForwardUrl不能共存</span></span><br><span class="line">      .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler(<span class="string">&quot;http://www.baidu.com&quot;</span>))</span><br><span class="line">      <span class="comment">//登录失败后跳转页面，POST请求</span></span><br><span class="line">      <span class="comment">// .failureForwardUrl(&quot;/toError&quot;)</span></span><br><span class="line">      .failureHandler(<span class="keyword">new</span> MyForwardAuthenticationFailureHandler(<span class="string">&quot;/error.html&quot;</span>))</span><br><span class="line">      .usernameParameter(<span class="string">&quot;myusername&quot;</span>)</span><br><span class="line">      .passwordParameter(<span class="string">&quot;mypassword&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="访问控制url匹配"><a href="#访问控制url匹配" class="headerlink" title="访问控制url匹配"></a>访问控制url匹配</h3><p>　在前面讲解了认证中所有常用配置，主要是对<code> http.formLogin()</code>进行操作。而在配置类中 <code>http.authorizeRequests()</code>主要是对url进行控制，也就是我们所说的授权（访问控制）。<code>http.authorizeRequests()</code>也支持连缀写法，总体公式为：</p><ul><li>url 匹配规则.权限控制方法</li></ul><p>　通过上面的公式可以有很多 url 匹配规则和很多权限控制方法。这些内容进行各种组合就形成了Spring Security中的授权。</p><p>　在所有匹配规则中取所有规则的交集。配置顺序影响了之后授权效果，越是具体的应该放在前面，越是笼统的应该放到后面。</p><h4 id="anyRequest"><a href="#anyRequest" class="headerlink" title="anyRequest()"></a>anyRequest()</h4><p>　在之前认证过程中我们就已经使用过 anyRequest()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.anyRequest().authenticated();  </span><br></pre></td></tr></table></figure><h4 id="antMatcher"><a href="#antMatcher" class="headerlink" title="antMatcher()"></a>antMatcher()</h4><p>方法定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> C <span class="title">antMatchers</span><span class="params">(String... antPatterns)</span>  </span></span><br></pre></td></tr></table></figure><p>参数是不定向参数，每个参数是一个 ant 表达式，用于匹配 URL规则。</p><p>规则如下：</p><ul><li><p><code>?</code>： 匹配一个字符</p></li><li><p><code>*</code>：匹配 0 个或多个字符</p></li><li><p><code>**</code> ：匹配 0 个或多个目录</p></li></ul><p>在实际项目中经常需要放行所有静态资源，下面演示放行 js 文件夹下所有脚本文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/js/**&quot;</span>,<span class="string">&quot;/css/**&quot;</span>).permitAll()  </span><br></pre></td></tr></table></figure><p>还有一种配置方式是只要是.js 文件都放行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/**/*.js&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><h4 id="regexMatchers"><a href="#regexMatchers" class="headerlink" title="regexMatchers()"></a>regexMatchers()</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>　使用正则表达式进行匹配。和 <code>antMatchers()</code>主要的区别就是参数，<code>antMatchers()</code>参数是 ant 表达式，<code>regexMatchers()</code>参数是正则表达式。</p><p>　演示所有以.js 结尾的文件都被放行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.regexMatchers( <span class="string">&quot;.+[.]js&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><h5 id="两个参数时使用方式"><a href="#两个参数时使用方式" class="headerlink" title="两个参数时使用方式"></a>两个参数时使用方式</h5><p>　无论是<code> antMatchers()</code>还是<code> regexMatchers()</code>都具有两个参数的方法，其中第一个参数都是 <code>HttpMethod</code>，表示请求方式，当设置了<code>HttpMethod </code>后表示只有设定的特定的请求方式才执行对应的权限设置。</p><p>枚举类型 <code>HttpMethod </code>内置属性如下：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image15.png"></p><h4 id="mvcMatchers"><a href="#mvcMatchers" class="headerlink" title="mvcMatchers()"></a>mvcMatchers()</h4><p>　mvcMatchers()适用于配置了 servletPath 的情况。</p><p>　<code>servletPath </code>就是所有的 URL 的统一前缀。在 SpringBoot 整合SpringMVC 的项目中可以在 application.properties 中添加下面内容设置 <code>ServletPath</code></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.servlet.path</span>=<span class="string">/yjxxt</span></span><br></pre></td></tr></table></figure><p>　在 Spring Security 的配置类中配置<code>.servletPath()</code>是 mvcMatchers()返回值特有的方法，antMatchers()和 regexMatchers()没有这个方法。在<code> servletPath()</code>中配置了<code>servletPath </code>后，mvcMatchers()直接写 SpringMVC 中@RequestMapping()中设置的路径即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.mvcMatchers(<span class="string">&quot;/demo&quot;</span>).servletPath(<span class="string">&quot;/yjxxt&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><p>　如果不习惯使用 mvcMatchers()也可以使用 antMatchers()，下面代码和上面代码是等效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/yjxxt/demo&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><h3 id="内置访问控制方法"><a href="#内置访问控制方法" class="headerlink" title="内置访问控制方法"></a>内置访问控制方法</h3><p>　Spring Security 匹配了 URL 后调用了<code> permitAll()</code>表示不需要认证，随意访问。在 Spring Security 中提供了多种内置控制。</p><h4 id="permitAll"><a href="#permitAll" class="headerlink" title="permitAll()"></a>permitAll()</h4><p>permitAll()表示所匹配的 URL 任何人都允许访问。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image16.png"></p><h4 id="authenticated"><a href="#authenticated" class="headerlink" title="authenticated()"></a>authenticated()</h4><p>authenticated()表示所匹配的 URL 都需要被认证才能访问。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image17.png"></p><h4 id="anonymous"><a href="#anonymous" class="headerlink" title="anonymous()"></a>anonymous()</h4><p>anonymous()表示可以匿名访问匹配的URL。和permitAll()效果类似，只是设置为 anonymous()的 url 会执行 filter 链中</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image18.png"></p><h4 id="denyAll"><a href="#denyAll" class="headerlink" title="denyAll()"></a>denyAll()</h4><p>denyAll()表示所匹配的 URL 都不允许被访问。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image19.png"></p><h4 id="rememberMe"><a href="#rememberMe" class="headerlink" title="rememberMe()"></a>rememberMe()</h4><p>被“remember me”的用户允许访问</p><p>  <img src="/../../img/markdown_img/SpringSecurity.assets/image20.png"></p><h4 id="fullyAuthenticated"><a href="#fullyAuthenticated" class="headerlink" title="fullyAuthenticated()"></a>fullyAuthenticated()</h4><p>如果用户不是被 remember me 的，才可以访问。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image21.png"></p><h3 id="角色权限判断"><a href="#角色权限判断" class="headerlink" title="角色权限判断"></a>角色权限判断</h3><p>　除了之前讲解的内置权限控制。Spring Security 中还支持很多其他权限控制。这些方法一般都用于用户已经被认证后，判断用户是否具有特定的要求。</p><h4 id="hasAuthority-String"><a href="#hasAuthority-String" class="headerlink" title="hasAuthority(String)"></a>hasAuthority(String)</h4><p>　判断用户是否具有特定的权限，用户的权限是在自定义登录逻辑中创建 User 对象时指定的。下图中 admin和normal 就是用户的权限。admin和normal 严格区分大小写。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image22.png"></p><p>在配置类中通过 hasAuthority(“admin”)设置具有 admin 权限时才能访问。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/main1.html&quot;</span>).hasAuthority(<span class="string">&quot;admin&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="hasAnyAuthority-String-…"><a href="#hasAnyAuthority-String-…" class="headerlink" title="hasAnyAuthority(String …)"></a>hasAnyAuthority(String …)</h4><p>如果用户具备给定权限中某一个，就允许访问。</p><p>下面代码中由于大小写和用户的权限不相同，所以用户无权访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/main1.html&quot;</span>).hasAnyAuthority(<span class="string">&quot;adMin&quot;</span>,<span class="string">&quot;admiN&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="hasRole-String"><a href="#hasRole-String" class="headerlink" title="hasRole(String)"></a>hasRole(String)</h4><p>如果用户具备给定角色就允许访问。否则出现 403。</p><p>参数取值来源于自定义登录逻辑 <code>UserDetailsService </code>实现类中创建 User 对象时给 User 赋予的授权。</p><p>　在给用户赋予角色时角色需要以：<code>ROLE_开头</code>，后面添加角色名称。例如：ROLE_abc 其中 abc 是角色名，ROLE_是固定的字符开头。</p><p>使用 hasRole()时参数也只写 abc 即可。否则启动报错。</p><p>给用户赋予角色：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image23.png"></p><p>　在配置类中直接写 abc 即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/main1.html&quot;</span>).hasRole(<span class="string">&quot;abc&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="hasAnyRole-String-…"><a href="#hasAnyRole-String-…" class="headerlink" title="hasAnyRole(String …)"></a>hasAnyRole(String …)</h4><p>如果用户具备给定角色的任意一个，就允许被访问</p><h4 id="hasIpAddress-String"><a href="#hasIpAddress-String" class="headerlink" title="hasIpAddress(String)"></a>hasIpAddress(String)</h4><p>如果请求是指定的 IP 就运行访问。</p><p>可以通过 <code>request.getRemoteAddr()</code>获取 ip 地址。</p><p>需要注意的是在本机进行测试时 localhost 和 127.0.0.1 输出的 ip地址是不一样的。</p><p>当浏览器中通过 localhost 进行访问时控制台打印的内容：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image24.png"></p><p>当浏览器中通过 127.0.0.1 访问时控制台打印的内容：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image25.png"></p><p>当浏览器中通过具体 ip 进行访问时控制台打印内容：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image26.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/main1.html&quot;</span>).hasIpAddress(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="自定义403处理方案"><a href="#自定义403处理方案" class="headerlink" title="自定义403处理方案"></a>自定义403处理方案</h3><p>使用 Spring Security 时经常会看见 403（无权限），默认情况下显示的效果如下：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image27.png"></p><p>而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。Spring Security 支持自定义权限受限。</p><h4 id="新建类"><a href="#新建类" class="headerlink" title="新建类"></a>新建类</h4><p>新建类实现 AccessDeniedHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.access.AccessDeniedException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.access.AccessDeniedHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">      response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line">      out.write(<span class="string">&quot;&#123;\&quot;status\&quot;:\&quot;error\&quot;,\&quot;msg\&quot;:\&quot;权限不足，请联系管理员！\&quot;&#125;&quot;</span>);</span><br><span class="line">      out.flush();</span><br><span class="line">      out.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改配置类-1"><a href="#修改配置类-1" class="headerlink" title="修改配置类"></a>修改配置类</h4><p>配置类中重点添加异常处理器。设置访问受限后交给哪个对象进行处理。</p><p>myAccessDeniedHandler 是在配置类中进行自动注入的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常处理</span></span><br><span class="line">http.exceptionHandling()</span><br><span class="line">      .accessDeniedHandler(myAccessDeniedHandler);</span><br></pre></td></tr></table></figure><h3 id="基于表达式的访问控制"><a href="#基于表达式的访问控制" class="headerlink" title="基于表达式的访问控制"></a>基于表达式的访问控制</h3><h4 id="access-方法使用"><a href="#access-方法使用" class="headerlink" title="access()方法使用"></a>access()方法使用</h4><p>之前学习的登录用户权限判断实际上底层实现都是调用access(表达式)</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image28.png"></p><p>可以通过<code> access()</code>实现和之前学习的权限控制完成相同的功能。</p><p>以 hasRole 和 和 permitAll 举例</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image29.png"></p><h4 id="使用自定义方法"><a href="#使用自定义方法" class="headerlink" title="使用自定义方法"></a>使用自定义方法</h4><p>虽然这里面已经包含了很多的表达式(方法)但是在实际项目中很有可能出现需要自己自定义逻辑的情况。</p><p>判断登录用户是否具有访问当前 URL 权限。</p><h5 id="新建接口及实现类"><a href="#新建接口及实现类" class="headerlink" title="新建接口及实现类"></a>新建接口及实现类</h5><p>MyService.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(HttpServletRequest request, Authentication authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyServiceImpl.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecuritydemo.service.MyService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceImpl</span> <span class="keyword">implements</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(HttpServletRequest request, Authentication authentication)</span> </span>&#123;</span><br><span class="line">      Object obj = authentication.getPrincipal();</span><br><span class="line">      <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UserDetails)&#123;</span><br><span class="line">         UserDetails userDetails = (UserDetails) obj;</span><br><span class="line">         Collection&lt;? extends GrantedAuthority&gt; authorities = userDetails.getAuthorities();</span><br><span class="line">         <span class="keyword">return</span> authorities.contains(<span class="keyword">new</span> SimpleGrantedAuthority(request.getRequestURI()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改配置类-2"><a href="#修改配置类-2" class="headerlink" title="修改配置类"></a>修改配置类</h5><p>在 access 中通过@bean的id名.方法(参数)的形式进行调用配置类中修改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//url拦截</span></span><br><span class="line">http.authorizeRequests()</span><br><span class="line">      <span class="comment">//login.html不需要被认证</span></span><br><span class="line">      <span class="comment">// .antMatchers(&quot;/login.html&quot;).permitAll()</span></span><br><span class="line">      .antMatchers(<span class="string">&quot;/login.html&quot;</span>).access(<span class="string">&quot;permitAll&quot;</span>)</span><br><span class="line">      <span class="comment">// .antMatchers(&quot;/main.html&quot;).hasRole(&quot;abc&quot;)</span></span><br><span class="line">      .antMatchers(<span class="string">&quot;/main.html&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>)</span><br><span class="line">      .anyRequest().access(<span class="string">&quot;@myServiceImpl.hasPermission(request,authentication)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="基于注解的访问控制"><a href="#基于注解的访问控制" class="headerlink" title="基于注解的访问控制"></a>基于注解的访问控制</h3><p>在 Spring Security 中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过<code>@EnableGlobalMethodSecurity </code>进行开启后使用。</p><p>如果设置的条件允许，程序正常执行。如果不允许会报 500</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image30.png"></p><p>这些注解可以写到 Service 接口或方法上，也可以写到 Controller或 Controller 的方法上。通常情况下都是写在控制器方法上的，控制接口URL是否允许被访问。</p><h4 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h4><p>@Secured 是专门用于判断是否具有角色的。能写在方法或类上。参数要以 ROLE_开头。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image31.png"></p><h5 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h5><p>在 启 动 类 ( 也 可 以 在 配 置 类 等 能 够 扫 描 的 类 上 ) 上 添 加<code>@EnableGlobalMethodSecurity(securedEnabled = true)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringsecurityDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(SpringsecurityDemoApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在控制器方法上添加-Secured-注解"><a href="#在控制器方法上添加-Secured-注解" class="headerlink" title="在控制器方法上添加@Secured 注解"></a>在控制器方法上添加@Secured 注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成功后跳转页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Secured(&quot;ROLE_abc&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toMain&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">//表单提交</span></span><br><span class="line">   http.formLogin()</span><br><span class="line">         <span class="comment">//自定义登录页面</span></span><br><span class="line">         .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">         <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">         .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">         <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">         .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>)</span><br><span class="line">         </span><br><span class="line">   <span class="comment">//url拦截</span></span><br><span class="line">   http.authorizeRequests()</span><br><span class="line">         <span class="comment">//login.html不需要被认证</span></span><br><span class="line">         .antMatchers(<span class="string">&quot;/login.html&quot;</span>).permitAll()</span><br><span class="line">         <span class="comment">//所有请求都必须被认证，必须登录后被访问</span></span><br><span class="line">         .anyRequest().authenticated();</span><br><span class="line">   <span class="comment">//关闭csrf防护</span></span><br><span class="line">   http.csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PreAuthorize-PostAuthorize"><a href="#PreAuthorize-PostAuthorize" class="headerlink" title="@PreAuthorize/@PostAuthorize"></a>@PreAuthorize/@PostAuthorize</h4><p>@PreAuthorize 和@PostAuthorize 都是方法或类级别注解。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image32.png"></p><ul><li><p><code>@PreAuthorize </code>表示访问方法或类在执行之前先判断权限，大多情况下都是使用这个注解，注解的参数和access()方法参数取值相同，都是权限表达式。</p></li><li><p><code>@PostAuthorize</code> 表示方法或类执行结束后判断权限，此注解很少被使用到。</p></li></ul><h5 id="开启注解-1"><a href="#开启注解-1" class="headerlink" title="开启注解"></a>开启注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringsecurityDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(SpringsecurityDemoApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="添加-PreAuthorize"><a href="#添加-PreAuthorize" class="headerlink" title="添加@PreAuthorize"></a>添加@PreAuthorize</h5><p>在控制器方法上添加@PreAuthorize，参数可以是任何 access()支持的表达式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成功后跳转页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ROLE_abc&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toMain&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RememberMe功能实现"><a href="#RememberMe功能实现" class="headerlink" title="RememberMe功能实现"></a>RememberMe功能实现</h3><p>　Spring Security 中 Remember Me 为“记住我”功能，用户只需要在登录时添加 remember-me复选框，取值为true。Spring Security 会自动把用户信息存储到数据源中，以后就可以不登录进行访问</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>　Spring Security 实 现 Remember Me 功 能 时 底 层 实 现 依 赖Spring-JDBC，所以需要导入 Spring-JDBC。以后多使用 MyBatis 框架而很少直接导入 spring-jdbc，所以此处导入 mybatis 启动器同时还需要添加 MySQL 驱动</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mysql 数据库依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><p>在 application.properties 中配置数据源。请确保数据库中已经存在shop数据库</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.driver-class-name</span>= <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>= <span class="string">jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>= <span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>= <span class="string">root</span></span><br></pre></td></tr></table></figure><h4 id="编写配置"><a href="#编写配置" class="headerlink" title="编写配置"></a>编写配置</h4><p>RememberMeConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RememberMeConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">getPersistentTokenRepository</span><span class="params">()</span></span>&#123;</span><br><span class="line">      JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">      jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">      <span class="comment">//自动建表，第一次启动时需要，第二次启动时注释掉</span></span><br><span class="line">      jdbcTokenRepository.setCreateTableOnStartup(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改SecurityConfig-java"><a href="#修改SecurityConfig-java" class="headerlink" title="修改SecurityConfig.java"></a>修改SecurityConfig.java</h4><p>在SecurityConfig中添加RememberMeConfig和UserDetailsService实现类对象，并自动注入。</p><p>在 configure 中添加下面配置内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.rememberMe()</span><br><span class="line">      <span class="comment">//登录逻辑交给哪个对象</span></span><br><span class="line">      .userDetailsService(userService)</span><br><span class="line">      <span class="comment">// 持久层对象</span></span><br><span class="line">      .tokenRepository(persistentTokenRepository);</span><br></pre></td></tr></table></figure><h4 id="在客户端页面添加复选框"><a href="#在客户端页面添加复选框" class="headerlink" title="在客户端页面添加复选框"></a>在客户端页面添加复选框</h4><p>在客户端登录页面中添加 remember-me 的复选框，只要用户勾选了复选框下次就不需要进行登录了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="有效时间"><a href="#有效时间" class="headerlink" title="有效时间"></a>有效时间</h4><p>默认情况下重启项目后登录状态失效了。但是可以通过设置状态有效时间，即使项目重新启动下次也可以正常登录。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.rememberMe()</span><br><span class="line">      <span class="comment">//失效时间，单位秒</span></span><br><span class="line">      .tokenValiditySeconds(<span class="number">120</span>)</span><br><span class="line">      <span class="comment">//登录逻辑交给哪个对象</span></span><br><span class="line">      .userDetailsService(userService)</span><br><span class="line">      <span class="comment">// 持久层对象</span></span><br><span class="line">      .tokenRepository(persistentTokenRepository);</span><br></pre></td></tr></table></figure><h3 id="Thymeleaf中SpringSecurity的使用"><a href="#Thymeleaf中SpringSecurity的使用" class="headerlink" title="Thymeleaf中SpringSecurity的使用"></a>Thymeleaf中SpringSecurity的使用</h3><p>　Spring Security 可以在一些视图技术中进行控制显示效果。例如：<code>JSP </code>或 <code>Thymeleaf</code>。在非前后端分离且使用 Spring Boot 的项目中多使用 <code>Thymeleaf </code>作为视图展示技术。</p><p>　Thymeleaf 对 Spring Security 的 支 持 都 放 在<code>thymeleaf-extras-springsecurityX </code>中，目前最新版本为 5。所以需要在项目中添加此 jar 包的依赖和 thymeleaf 的依赖。。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--thymeleaf springsecurity5 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--thymeleaf依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 html 页面中引入 thymeleaf 命名空间和 security 命名空间</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h4><p>可以在html页面中通过<code>sec:authentication=&quot;&quot;</code>获取</p><p><code>UsernamePasswordAuthenticationToken</code>中所有 <code>getXXX </code>的内容，包含父类中的 <code>getXXX </code>的内容。</p><p>根据源码得出下面属性：</p><ul><li><p><code>name</code>：登录账号名称</p></li><li><p><code>principal</code>：登录主体，在自定义登录逻辑中是 UserDetails</p></li><li><p><code>credentials</code>：凭证</p></li><li><p><code>authorities</code>：权限和角色</p></li><li><p><code>details</code>：实际上是 <code>WebAuthenticationDetails </code>的实例。可以获取<code>remoteAddress</code>(客户端 ip)和 <code>sessionId</code>(当前 sessionId)</p></li></ul><h5 id="新建demo-html"><a href="#新建demo-html" class="headerlink" title="新建demo.html"></a>新建demo.html</h5><p>在项目 resources 中新建 templates 文件夹，在 templates 中新建demo.html 页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    登录账号:<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    登录账号:<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;principal.username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    凭证：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;credentials&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    权限和角色：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;authorities&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    客户端地址：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;details.remoteAddress&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    sessionId：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;details.sessionId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h5><p>thymeleaf 页面需要控制转发，在控制器类中编写下面方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="权限判断"><a href="#权限判断" class="headerlink" title="权限判断"></a>权限判断</h4><h5 id="设置用户角色和权限"><a href="#设置用户角色和权限" class="headerlink" title="设置用户角色和权限"></a>设置用户角色和权限</h5><p>设定用户具有 admin，/insert，/delete 权限 ROLE_abc 角色。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,ROLE_abc,/insert,/delete&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="控制页面显示效果"><a href="#控制页面显示效果" class="headerlink" title="控制页面显示效果"></a>控制页面显示效果</h5><p>在页面中根据用户权限和角色判断页面中显示的内容</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">通过权限判断：</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasAuthority(&#x27;/insert&#x27;)&quot;</span>&gt;</span>新增<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasAuthority(&#x27;/delete&#x27;)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasAuthority(&#x27;/update&#x27;)&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasAuthority(&#x27;/select&#x27;)&quot;</span>&gt;</span>查看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">通过角色判断：</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>&gt;</span>新增<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>&gt;</span>查看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><p>用户只需要向 Spring Security 项目中发送<code>/logout </code>退出请求即可。</p><h4 id="退出登录-1"><a href="#退出登录-1" class="headerlink" title="退出登录"></a>退出登录</h4><p>实现退出非常简单，只要在页面中添加<code>/logout</code> 的超链接即可。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了实现更好的效果，通常添加退出的配置。默认的退出 url 为<code>/logout</code>，退出成功后跳转到<code>/login?logout</code></p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image33.png"></p><p>如果不希望使用默认值，可以通过下面的方法进行修改。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.logout()</span><br><span class="line">      .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">      .logoutSuccessUrl(<span class="string">&quot;/login.html&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="logout其他常用配置源码解读"><a href="#logout其他常用配置源码解读" class="headerlink" title="logout其他常用配置源码解读"></a>logout其他常用配置源码解读</h4><h5 id="addLogoutHandler-LogoutHandler"><a href="#addLogoutHandler-LogoutHandler" class="headerlink" title="addLogoutHandler(LogoutHandler)"></a>addLogoutHandler(LogoutHandler)</h5><p>默认是 contextLogoutHandler</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image34.png"></p><p> 默认实例内容</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image35.png"></p><h5 id="clearAuthentication-boolean"><a href="#clearAuthentication-boolean" class="headerlink" title="clearAuthentication(boolean)"></a>clearAuthentication(boolean)</h5><p>是否清除认证状态，默认为 true</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image36.png"></p><h5 id="invalidateHttpSession-boolean"><a href="#invalidateHttpSession-boolean" class="headerlink" title="invalidateHttpSession(boolean)"></a>invalidateHttpSession(boolean)</h5><p>是否销毁 HttpSession 对象，默认为 true</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image37.png"></p><h5 id="logoutSuccessHandler-LogoutSuccessHandler"><a href="#logoutSuccessHandler-LogoutSuccessHandler" class="headerlink" title="logoutSuccessHandler(LogoutSuccessHandler)"></a>logoutSuccessHandler(LogoutSuccessHandler)</h5><p>退出成功处理器</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image38.png"></p><p>　也可以自己进行定义退出成功处理器。只要实现了<code>LogoutSuccessHandler </code>接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。</p><h3 id="SpringSecurity中的CSRF"><a href="#SpringSecurity中的CSRF" class="headerlink" title="SpringSecurity中的CSRF"></a>SpringSecurity中的CSRF</h3><p>　从刚开始学习Spring Security时，在配置类中一直存在这样一行代码：<code>http.csrf().disable();</code>如果没有这行代码导致用户无法被认证。这行代码的含义是：关闭 csrf 防护。</p><h4 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h4><p>　CSRF（Cross-site request forgery）跨站请求伪造，也被称为“OneClick Attack” 或者 Session Riding。通过伪造用户请求访问受信任站点的非法请求访问。</p><p>　跨域：只要网络协议，ip 地址，端口中任何一个不相同就是跨域请求。</p><p>　客户端与服务进行交互时，由于 http 协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份的。在跨域的情况下，session id 可能被第三方恶意劫持，通过这个 session id 向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。</p><h4 id="2、Spring-Security中的CSRF"><a href="#2、Spring-Security中的CSRF" class="headerlink" title="2、Spring Security中的CSRF"></a>2、Spring Security中的CSRF</h4><p>　从 Spring Security4开始CSRF防护默认开启。默认会拦截请求。进行CSRF处理。CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为<code>_csrf</code>值为token(token 在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。</p><h5 id="2-1、编写控制器方法"><a href="#2-1、编写控制器方法" class="headerlink" title="2.1、编写控制器方法"></a>2.1、编写控制器方法</h5><p>编写控制器方法，跳转到 templates 中 login.html 页面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showLogin&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2、新建login.html</p><p>红色部分是必须存在的否则无法正常登录。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;_csrf&#125;&quot;</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改配置类-3"><a href="#修改配置类-3" class="headerlink" title="修改配置类"></a>修改配置类</h5><p>在配置类中注释掉 CSRF 防护失效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭csrf防护</span></span><br><span class="line"><span class="comment">// http.csrf().disable();</span></span><br></pre></td></tr></table></figure><h2 id="Oauth2认证"><a href="#Oauth2认证" class="headerlink" title="Oauth2认证"></a>Oauth2认证</h2><h3 id="Oauth2简介"><a href="#Oauth2简介" class="headerlink" title="Oauth2简介"></a>Oauth2简介</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>　第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间要遵循一定的接口协议。</p><p>　OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。</p><p>　Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。</p><p>参考：<a href="https://baike.baidu.com/item/oAuth/7153134?fr=aladdin">https://baike.baidu.com/item/oAuth/7153134?fr=aladdin</a></p><p>Oauth 协议：<a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p>下边分析一个Oauth2认证的例子，网站使用微信认证的过程：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image39.png"></p><ol><li>用户进入网站的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。</li></ol><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image40.png"></p><p>点击“微信”出现一个二维码，此时用户扫描二维码，开始给网站授权。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image41.png"></p><ol start="2"><li>资源拥有者同意给客户端授权</li></ol><p>　资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到网站。</p><ol start="3"><li>客户端获取到授权码，请求认证服务器申请令牌</li></ol><p>　此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。</p><ol start="4"><li>认证服务器向客户端响应令牌</li></ol><p>　认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。</p><ol start="5"><li>客户端请求资源服务器的资源</li></ol><p>　客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。</p><ol start="6"><li>资源服务器返回受保护资源</li></ol><p>　资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。</p><p>注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。</p><p>Oauth2.0认证流程如下：</p><p>引自Oauth2.0协议rfc6749 <a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image42.png"></p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><strong>客户端</strong></p><p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。</p><p><strong>资源拥有者</strong></p><p>通常为用户，也可以是应用程序，即该资源的拥有者。</p><p><strong>授权服务器（也称认证服务器）</strong></p><p>用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。</p><p><strong>资源服务器</strong></p><p>存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。</p><h4 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h4><ul><li><code>客户凭证(client Credentials)</code>：客户端的clientId和密码用于认证客户</li><li><code>令牌(tokens)</code>：授权服务器在接收到客户请求后，颁发的访问令牌</li><li><code>作用域(scopes)</code>：客户请求访问令牌时，由资源拥有者额外指定的细分权限(permission)</li></ul><h4 id="令牌类型"><a href="#令牌类型" class="headerlink" title="令牌类型"></a>令牌类型</h4><ul><li><p><code>授权码</code>：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌</p></li><li><p><code>访问令牌</code>：用于代表一个用户或服务直接去访问受保护的资源</p></li><li><p><code>刷新令牌</code>：用于去授权服务器获取一个刷新访问令牌</p></li><li><p><code>BearerToken</code>：不管谁拿到Token都可以访问资源，类似现金</p></li><li><p><code>Proof of Possession(PoP) Token</code>：可以校验client是否对Token有明确的拥有权</p></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>优点</strong>：</p><p>​     更安全，客户端不接触用户密码，服务器端更易集中保护</p><p>​     广泛传播并被持续采用</p><p>​     短寿命和封装的token</p><p>​     资源服务器和授权服务器解耦</p><p>​     集中式授权，简化客户端</p><p>​     HTTP/JSON友好，易于请求和传递token</p><p>​     考虑多种客户端架构场景</p><p>​     客户可以具有不同的信任级别</p><p><strong>缺点</strong>：</p><p>​     协议框架太宽泛，造成各种实现的兼容性和互操作性差</p><p>​     不是一个认证协议，本身并不能告诉你任何用户信息。</p><h3 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h3><h4 id="授权码模式（Authorization-Code）"><a href="#授权码模式（Authorization-Code）" class="headerlink" title="授权码模式（Authorization Code）"></a>授权码模式（Authorization Code）</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image43.jpeg"></p><h4 id="简化授权模式（Implicit）"><a href="#简化授权模式（Implicit）" class="headerlink" title="简化授权模式（Implicit）"></a>简化授权模式（Implicit）</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image44.png"></p><h4 id="密码模式（Resource-Owner-PasswordCredentials）"><a href="#密码模式（Resource-Owner-PasswordCredentials）" class="headerlink" title="密码模式（Resource Owner PasswordCredentials）"></a>密码模式（Resource Owner PasswordCredentials）</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image45.png"></p><h4 id="客户端模式（Client-Credentials）"><a href="#客户端模式（Client-Credentials）" class="headerlink" title="客户端模式（Client Credentials）"></a>客户端模式（Client Credentials）</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image46.png"></p><h4 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image47.jpeg"></p><h2 id="Spring-Security-Oauth2"><a href="#Spring-Security-Oauth2" class="headerlink" title="Spring Security Oauth2"></a>Spring Security Oauth2</h2><h3 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h3><p><img src="/../../img/markdown_img/SpringSecurity.assets/image48.png"></p><ul><li><p><code>Authorize Endpoint</code>：授权端点，进行授权</p></li><li><p><code>Token Endpoint</code>：令牌端点，经过授权拿到对应的Token</p></li><li><p><code>Introspection Endpoint</code>：校验端点，校验Token的合法性</p></li><li><p><code>Revocation Endpoint</code>：撤销端点，撤销授权</p></li></ul><h3 id="Spring-Security-Oauth2架构"><a href="#Spring-Security-Oauth2架构" class="headerlink" title="Spring Security Oauth2架构"></a>Spring Security Oauth2架构</h3><p><img src="/../../img/markdown_img/SpringSecurity.assets/image49.png"></p><p>流程：</p><ol><li><p>用户访问,此时没有Token。Oauth2RestTemplate会报错，这个报错信息会被Oauth2ClientContextFilter捕获并重定向到认证服务器</p></li><li><p>认证服务器通过Authorization Endpoint进行授权，并通过AuthorizationServerTokenServices生成授权码并返回给客户端</p></li><li><p>客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端</p></li><li><p>客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用ResourceServerTokenServices进行校验。校验通过可以获取资源。</p></li></ol><h3 id="Spring-Security-Oauth2授权码模式"><a href="#Spring-Security-Oauth2授权码模式" class="headerlink" title="Spring Security Oauth2授权码模式"></a>Spring Security Oauth2授权码模式</h3><h4 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h4><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image50.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image51.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image52.png"></p><h4 id="2、添加依赖"><a href="#2、添加依赖" class="headerlink" title="2、添加依赖"></a>2、添加依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yjxxt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springsecurityoauth2demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>springsecurityoauth2demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、编写实体类"><a href="#3、编写实体类" class="headerlink" title="3、编写实体类"></a>3、编写实体类</h4><p>User.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password, List&lt;GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、编写Service"><a href="#4、编写Service" class="headerlink" title="4、编写Service"></a>4、编写Service</h4><p>UserService.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">      String password = passwordEncoder.encode(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5、编写Controller"><a href="#5、编写Controller" class="headerlink" title="5、编写Controller"></a>5、编写Controller</h4><p>UserController.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getCurrentUser&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> authentication.getPrincipal();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、编写配置类"><a href="#6、编写配置类" class="headerlink" title="6、编写配置类"></a>6、编写配置类</h4><p>SecurityConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      http.csrf()</span><br><span class="line">            .disable()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/oauth/**&quot;</span>, <span class="string">&quot;/login/**&quot;</span>, <span class="string">&quot;/logout/**&quot;</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AuthorizationServerConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResourceServerConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .requestMatchers()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/**&quot;</span>);<span class="comment">//配置需要保护的资源路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h4><h5 id="获取授权码"><a href="#获取授权码" class="headerlink" title="获取授权码"></a>获取授权码</h5><p><a href="http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=http://www.baidu.com&amp;scope=all">http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=http://www.baidu.com&amp;scope=all</a> </p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image53.png"></p><p>输入账户密码</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image54.png"></p><p>点击授权获取授权码</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image55.png"></p><h5 id="根据授权码获取令牌（POST请求）"><a href="#根据授权码获取令牌（POST请求）" class="headerlink" title="根据授权码获取令牌（POST请求）"></a>根据授权码获取令牌（POST请求）</h5><p><img src="/../../img/markdown_img/SpringSecurity.assets/image56.png"></p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image57.png"></p><ul><li><p><code>grant_type</code>：授权类型，填写authorization_code，表示授权码模式</p></li><li><p><code>code</code>：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。</p></li><li><p><code>client_id</code>:客户端标识</p></li><li><p><code>redirect_uri</code>：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。</p></li><li><p><code>scope</code>:授权范围。</p></li></ul><p>认证失败服务端返回 401 Unauthorized</p><p>注意：此时无法请求到令牌，访问服务器会报错</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image58.png"></p><h5 id="根据token去资源服务器拿资源"><a href="#根据token去资源服务器拿资源" class="headerlink" title="根据token去资源服务器拿资源"></a>根据token去资源服务器拿资源</h5><p><img src="/../../img/markdown_img/SpringSecurity.assets/image59.png"></p><p>如果修改token就会报错</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image60.png"></p><h3 id="Spring-Security-Oauth2-密码模式"><a href="#Spring-Security-Oauth2-密码模式" class="headerlink" title="Spring Security Oauth2 密码模式"></a>Spring Security Oauth2 密码模式</h3><p>在上面的代码中进行适当的修改即可</p><p>SecurityConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      http.csrf()</span><br><span class="line">            .disable()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/oauth/**&quot;</span>, <span class="string">&quot;/login/**&quot;</span>, <span class="string">&quot;/logout/**&quot;</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AuthorizationServerConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image56.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image61.png"></p><h3 id="在Redis中存储token"><a href="#在Redis中存储token" class="headerlink" title="在Redis中存储token"></a>在Redis中存储token</h3><p>之前的代码我们将token直接存在内存中，这在生产环境中是不合理的，下面我们将其改造成存储在Redis中</p><h4 id="添加依赖及配置"><a href="#添加依赖及配置" class="headerlink" title="添加依赖及配置"></a>添加依赖及配置</h4><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- commons-pool2 对象池依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis配置</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.10.100</span></span><br></pre></td></tr></table></figure><h4 id="编写Redis配置类"><a href="#编写Redis配置类" class="headerlink" title="编写Redis配置类"></a>编写Redis配置类</h4><p>RedisConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TokenStore <span class="title">redisTokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RedisTokenStore(redisConnectionFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在认证服务器配置中指定令牌的存储策略为Redis"><a href="#在认证服务器配置中指定令牌的存储策略为Redis" class="headerlink" title="在认证服务器配置中指定令牌的存储策略为Redis"></a>在认证服务器配置中指定令牌的存储策略为Redis</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;redisTokenStore&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService)</span><br><span class="line">                .tokenStore(tokenStore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>使用密码模式请求token</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image62.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image63.png"></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="常见的认证机制"><a href="#常见的认证机制" class="headerlink" title="常见的认证机制"></a>常见的认证机制</h3><h4 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h4><p>　HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth。</p><h4 id="Cookie-Auth"><a href="#Cookie-Auth" class="headerlink" title="Cookie Auth"></a>Cookie Auth</h4><p>　Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。       </p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image64.png">                   </p><h4 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h4><p>　OAuth（开放授权,Open Authorization）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。</p><p>　OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。</p><p>下面是OAuth2.0的流程：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image65.png"></p><p>　这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。</p><p>缺点：过重。</p><h4 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h4><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li><p>客户端使用用户名跟密码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p></li><li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p></li></ol><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image66.png"></p><p>比第一种方式更安全，比第二种方式更节约服务器资源，比第三种方式更加轻量。</p><p>具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）：</p><ol><li><p>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</p></li><li><p>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</p></li><li><p>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</p></li><li><p>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</p></li><li><p>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 10等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p></li><li><p>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</p></li><li><p>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多.</p></li><li><p>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</p></li><li><p>基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</p></li></ol><h3 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h3><h4 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h4><p>　JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。</p><p>官网：  <a href="https://jwt.io/">https://jwt.io/</a></p><p>标准：  <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a></p><p>JWT令牌的优点：</p><ol><li><p>jwt基于json，非常方便解析。</p></li><li><p>可以在令牌中自定义丰富的内容，易扩展。</p></li><li><p>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</p></li><li><p>资源服务使用JWT可不依赖认证服务即可完成授权。</p></li></ol><p>缺点：</p><ol><li>JWT令牌较长，占存储空间比较大。</li></ol><h4 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h4><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p><h5 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h5><p>头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法（如HMAC SHA256或RSA）等。这也可以被表示成一个JSON对象。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>typ</code>：是类型。</p></li><li><p><code>alg</code>：签名的算法，这里使用的算法是HS256算法</p></li></ul><p>我们对头部的json字符串进行BASE64编码（网上有很多在线编码的网站），编码后的字符串如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  </span><br></pre></td></tr></table></figure><p>　<code>Base64</code>是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 <code>BASE64Encoder </code>和 <code>BASE64Decoder</code>，用它们可以非常方便的完成基于 BASE64 的编码和解码。</p><h5 id="负载-Payload"><a href="#负载-Payload" class="headerlink" title="负载(Payload)"></a>负载(Payload)</h5><p>第二部分是负载，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：</p><ul><li>标准中注册的声明（建议但不强制使用）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iss: jwt签发者</span><br><span class="line">sub: jwt所面向的用户</span><br><span class="line">aud: 接收jwt的一方</span><br><span class="line">exp: jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">nbf: 定义在什么时间之前，该jwt都是不可用的.</span><br><span class="line">iat: jwt的签发时间</span><br><span class="line">jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</span><br></pre></td></tr></table></figure><ul><li>公共的声明</li></ul><p>　公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><ul><li>私有的声明</li></ul><p>　私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>　这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>sub</code>是标准的声明，<code>name</code>是自定义的声明（公共的或私有的）</p><p>然后将其进行base64编码，得到Jwt的第二部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbWVzIiwiYWRtaW4iOnRydWV9  </span><br></pre></td></tr></table></figure><p>提示：声明中不要放一些敏感信息。</p><h5 id="签证、签名（signature）"><a href="#签证、签名（signature）" class="headerlink" title="签证、签名（signature）"></a>签证、签名（signature）</h5><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ol><li><p>header (base64后的)</p></li><li><p>payload (base64后的)</p></li><li><p>secret（盐，一定要保密）</p></li></ol><p>　这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI</span><br></pre></td></tr></table></figure><p>将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR9cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI  </span><br></pre></td></tr></table></figure><p>注意：<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以自我签发<code>jwt</code>了。</p><h3 id="JJWT简介"><a href="#JJWT简介" class="headerlink" title="JJWT简介"></a>JJWT简介</h3><h4 id="什么是JJWT"><a href="#什么是JJWT" class="headerlink" title="什么是JJWT"></a>什么是JJWT</h4><p>　JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</p><p>规范官网：<a href="https://jwt.io/">https://jwt.io/</a></p><h4 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h4><h5 id="token的创建"><a href="#token的创建" class="headerlink" title="token的创建"></a>token的创建</h5><p>创建SpringBoot工程，引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yjxxt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jwtdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>jwtdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--JWT依赖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 创建测试类JwtTest，用于生成token：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.jwtdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.impl.Base64Codec;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建token</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreatToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建一个JwtBuilder对象</span></span><br><span class="line">      JwtBuilder jwtBuilder = Jwts.builder()</span><br><span class="line">            <span class="comment">//声明的标识&#123;&quot;jti&quot;:&quot;888&quot;&#125;</span></span><br><span class="line">            .setId(<span class="string">&quot;888&quot;</span>)</span><br><span class="line">            <span class="comment">//主体，用户&#123;&quot;sub&quot;:&quot;Rose&quot;&#125;</span></span><br><span class="line">            .setSubject(<span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">            <span class="comment">//创建日期&#123;&quot;ita&quot;:&quot;yjxxtxx&quot;&#125;</span></span><br><span class="line">            .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">            <span class="comment">//签名手段，参数1：算法，参数2：盐</span></span><br><span class="line">            .signWith(SignatureAlgorithm.HS256,<span class="string">&quot;yjxxt&quot;</span>);</span><br><span class="line">      <span class="comment">//获取jwt的token</span></span><br><span class="line">      String token = jwtBuilder.compact();</span><br><span class="line">      System.out.println(token);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//三部分的base64解密</span></span><br><span class="line">      System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">      String[] split = token.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">      System.out.println(Base64Codec.BASE64.decodeToString(split[<span class="number">0</span>]));</span><br><span class="line">      System.out.println(Base64Codec.BASE64.decodeToString(split[<span class="number">1</span>]));</span><br><span class="line">      <span class="comment">//无法解密</span></span><br><span class="line">      System.out.println(Base64Codec.BASE64.decodeToString(split[<span class="number">2</span>]));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image67.png"></p><p>再次运行，会发现每次运行的结果是不一样的，因为我们的载荷中包含了时间</p><h5 id="token的验证解析"><a href="#token的验证解析" class="headerlink" title="token的验证解析"></a>token的验证解析</h5><p>　我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParseToken</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//token</span></span><br><span class="line">   String token = <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE0MjUyfQ&quot;</span> +</span><br><span class="line">         <span class="string">&quot;.-FYFMHyfTcGzq900f_Drfdsges0ge2UjaWvPW9gCDto&quot;</span>;</span><br><span class="line">   <span class="comment">//解析token获取负载中的声明对象</span></span><br><span class="line">   Claims claims = Jwts.parser()</span><br><span class="line">         .setSigningKey(<span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         .parseClaimsJws(token)</span><br><span class="line">         .getBody();</span><br><span class="line">   <span class="comment">//打印声明的属性</span></span><br><span class="line">   System.out.println(<span class="string">&quot;id:&quot;</span>+claims.getId());</span><br><span class="line">   System.out.println(<span class="string">&quot;subject:&quot;</span>+claims.getSubject());</span><br><span class="line">   System.out.println(<span class="string">&quot;issuedAt:&quot;</span>+claims.getIssuedAt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token</p><h5 id="token过期校验"><a href="#token过期校验" class="headerlink" title="token过期校验"></a>token过期校验</h5><p>　有很多时候，我们并不希望签发的token是永久生效的（上节的token是永久的），所以我们可以为token添加一个过期时间。原因：从服务器发出的token，服务器自己并不做记录，就存在一个弊端就是，服务端无法主动控制某token的立刻失效。</p><p>测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreatTokenHasExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//当前系统时间的长整型</span></span><br><span class="line">   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">//过期时间，这里是1分钟后的时间长整型</span></span><br><span class="line">   <span class="keyword">long</span> exp = now + <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">   <span class="comment">//创建一个JwtBuilder对象</span></span><br><span class="line">   JwtBuilder jwtBuilder = Jwts.builder()</span><br><span class="line">         <span class="comment">//声明的标识&#123;&quot;jti&quot;:&quot;888&quot;&#125;</span></span><br><span class="line">         .setId(<span class="string">&quot;888&quot;</span>)</span><br><span class="line">         <span class="comment">//主体，用户&#123;&quot;sub&quot;:&quot;Rose&quot;&#125;</span></span><br><span class="line">         .setSubject(<span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">         <span class="comment">//创建日期&#123;&quot;ita&quot;:&quot;yjxxtxx&quot;&#125;</span></span><br><span class="line">         .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">         <span class="comment">//签名手段，参数1：算法，参数2：盐</span></span><br><span class="line">         .signWith(SignatureAlgorithm.HS256, <span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         <span class="comment">//设置过期时间</span></span><br><span class="line">         .setExpiration(<span class="keyword">new</span> Date(exp));</span><br><span class="line">   <span class="comment">//获取jwt的token</span></span><br><span class="line">   String token = jwtBuilder.compact();</span><br><span class="line">   System.out.println(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParseTokenHasExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//token</span></span><br><span class="line">   String token = <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9&quot;</span> +</span><br><span class="line">         <span class="string">&quot;.eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE1MDYyLCJleHAiOjE1Nzg4MTUxMjIsInJvbGVzIjoiYWRtaW4iLCJsb2dvIjoic2hzeHQuanBnIn0.hKog0RsZ9_6II_R8kUCp0HLAouUAYXAJVbz3xtLTUh4&quot;</span>;</span><br><span class="line">   <span class="comment">//解析token获取负载中的声明对象</span></span><br><span class="line">   Claims claims = Jwts.parser()</span><br><span class="line">         .setSigningKey(<span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         .parseClaimsJws(token)</span><br><span class="line">         .getBody();</span><br><span class="line">   <span class="comment">//打印声明的属性</span></span><br><span class="line">   System.out.println(<span class="string">&quot;id:&quot;</span> + claims.getId());</span><br><span class="line">   System.out.println(<span class="string">&quot;subject:&quot;</span> + claims.getSubject());</span><br><span class="line">   System.out.println(<span class="string">&quot;issuedAt:&quot;</span> + claims.getIssuedAt());</span><br><span class="line">   DateFormat sf =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;签发时间:&quot;</span>+sf.format(claims.getIssuedAt()));</span><br><span class="line">   System.out.println(<span class="string">&quot;过期时间:&quot;</span>+sf.format(claims.getExpiration()));</span><br><span class="line">   System.out.println(<span class="string">&quot;当前时间:&quot;</span>+sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：当未过期时可以正常读取，当过期时会引发io.jsonwebtoken.ExpiredJwtException异常。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image68.png"></p><h5 id="自定义claims"><a href="#自定义claims" class="headerlink" title="自定义claims"></a>自定义claims</h5><p>我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角色）可以定义自定义claims </p><p>测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreatTokenByClaims</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//当前系统时间的长整型</span></span><br><span class="line">   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">//过期时间，这里是1分钟后的时间长整型</span></span><br><span class="line">   <span class="keyword">long</span> exp = now + <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">   <span class="comment">//创建一个JwtBuilder对象</span></span><br><span class="line">   JwtBuilder jwtBuilder = Jwts.builder()</span><br><span class="line">         <span class="comment">//声明的标识&#123;&quot;jti&quot;:&quot;888&quot;&#125;</span></span><br><span class="line">         .setId(<span class="string">&quot;888&quot;</span>)</span><br><span class="line">         <span class="comment">//主体，用户&#123;&quot;sub&quot;:&quot;Rose&quot;&#125;</span></span><br><span class="line">         .setSubject(<span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">         <span class="comment">//创建日期&#123;&quot;ita&quot;:&quot;yjxxtxx&quot;&#125;</span></span><br><span class="line">         .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">         <span class="comment">//签名手段，参数1：算法，参数2：盐</span></span><br><span class="line">         .signWith(SignatureAlgorithm.HS256, <span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         <span class="comment">//设置过期时间</span></span><br><span class="line">         .setExpiration(<span class="keyword">new</span> Date(exp))</span><br><span class="line">         <span class="comment">//直接传入map</span></span><br><span class="line">         <span class="comment">// .addClaims(map)</span></span><br><span class="line">         .claim(<span class="string">&quot;roles&quot;</span>,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">         .claim(<span class="string">&quot;logo&quot;</span>,<span class="string">&quot;yjxxt.jpg&quot;</span>);</span><br><span class="line">   <span class="comment">//获取jwt的token</span></span><br><span class="line">   String token = jwtBuilder.compact();</span><br><span class="line">   System.out.println(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParseTokenByClaims</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//token</span></span><br><span class="line">   String token = <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9&quot;</span> +</span><br><span class="line">         <span class="string">&quot;.eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE1MDYyLCJleHAiOjE1Nzg4MTUxMjIsInJvbGVzIjoiYWRtaW4iLCJsb2dvIjoic2hzeHQuanBnIn0.hKog0RsZ9_6II_R8kUCp0HLAouUAYXAJVbz3xtLTUh4&quot;</span>;</span><br><span class="line">   <span class="comment">//解析token获取负载中的声明对象</span></span><br><span class="line">   Claims claims = Jwts.parser()</span><br><span class="line">         .setSigningKey(<span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         .parseClaimsJws(token)</span><br><span class="line">         .getBody();</span><br><span class="line">   <span class="comment">//打印声明的属性</span></span><br><span class="line">   System.out.println(<span class="string">&quot;id:&quot;</span> + claims.getId());</span><br><span class="line">   System.out.println(<span class="string">&quot;subject:&quot;</span> + claims.getSubject());</span><br><span class="line">   System.out.println(<span class="string">&quot;issuedAt:&quot;</span> + claims.getIssuedAt());</span><br><span class="line">   DateFormat sf =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;签发时间:&quot;</span>+sf.format(claims.getIssuedAt()));</span><br><span class="line">   System.out.println(<span class="string">&quot;过期时间:&quot;</span>+sf.format(claims.getExpiration()));</span><br><span class="line">   System.out.println(<span class="string">&quot;当前时间:&quot;</span>+sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">&quot;roles:&quot;</span>+claims.get(<span class="string">&quot;roles&quot;</span>));</span><br><span class="line">   System.out.println(<span class="string">&quot;logo:&quot;</span>+claims.get(<span class="string">&quot;logo&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Security-Oauth2-整合JWT"><a href="#Spring-Security-Oauth2-整合JWT" class="headerlink" title="Spring Security Oauth2 整合JWT"></a>Spring Security Oauth2 整合JWT</h2><h3 id="整合JWT"><a href="#整合JWT" class="headerlink" title="整合JWT"></a>整合JWT</h3><p>我们拿之前Spring Security Oauth2的完整代码进行修改</p><p>添加配置文件JwtTokenStoreConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtTokenStore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenStoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TokenStore <span class="title">jwtTokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      JwtAccessTokenConverter accessTokenConverter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">      <span class="comment">//配置JWT使用的秘钥</span></span><br><span class="line">      accessTokenConverter.setSigningKey(<span class="string">&quot;test_key&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> accessTokenConverter;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在认证服务器配置中指定令牌的存储策略为JWT</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;jwtTokenStore&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService)</span><br><span class="line">                <span class="comment">//配置存储令牌策略</span></span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用密码模式测试：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image69.png"></p><p>发现获取到的令牌已经变成了JWT令牌，将access_token拿到<a href="https://jwt.io/">https://jwt.io/</a> 网站上去解析下可以获得其中内容。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image70.png"></p><h3 id="扩展JWT中存储的内容"><a href="#扩展JWT中存储的内容" class="headerlink" title="扩展JWT中存储的内容"></a>扩展JWT中存储的内容</h3><p>　有时候我们需要扩展JWT中存储的内容，这里我们在JWT中扩展一个<code>key为enhance，value为enhance info</code>的数据。</p><p>继承TokenEnhancer实现一个JWT内容增强器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.common.OAuth2AccessToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.OAuth2Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenEnhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JWT内容增强器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenEnhancer</span> <span class="keyword">implements</span> <span class="title">TokenEnhancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> OAuth2AccessToken <span class="title">enhance</span><span class="params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">      Map&lt;String,Object&gt; info = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      info.put(<span class="string">&quot;enhance&quot;</span>,<span class="string">&quot;enhance info&quot;</span>);</span><br><span class="line">      ((DefaultOAuth2AccessToken)accessToken).setAdditionalInformation(info);</span><br><span class="line">      <span class="keyword">return</span> accessToken;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个JwtTokenEnhancer实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtTokenStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Jwt存储token的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenStoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TokenStore <span class="title">jwtTokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      JwtAccessTokenConverter accessTokenConverter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">      <span class="comment">//配置JWT使用的秘钥</span></span><br><span class="line">      accessTokenConverter.setSigningKey(<span class="string">&quot;test_key&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> accessTokenConverter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JwtTokenEnhancer <span class="title">jwtTokenEnhancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenEnhancer();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在认证服务器配置中配置JWT的内容增强器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.component.JwtTokenEnhancer;</span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenEnhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenEnhancerChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 授权服务器配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;jwtTokenStore&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenEnhancer jwtTokenEnhancer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        TokenEnhancerChain enhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        List&lt;TokenEnhancer&gt; delegates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//配置JWT的内容增强器</span></span><br><span class="line">        delegates.add(jwtTokenEnhancer);</span><br><span class="line">        delegates.add(jwtAccessTokenConverter);</span><br><span class="line">        enhancerChain.setTokenEnhancers(delegates);</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService)</span><br><span class="line">                <span class="comment">//配置存储令牌策略</span></span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter)</span><br><span class="line">                .tokenEnhancer(enhancerChain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行项目后使用密码模式来获取令牌，之后对令牌进行解析，发现已经包含扩展的内容。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image71.png"></p><h3 id="Java中解析JWT中的内容"><a href="#Java中解析JWT中的内容" class="headerlink" title="Java中解析JWT中的内容"></a>Java中解析JWT中的内容</h3><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jwt 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改UserController类，使用jjwt工具类来解析Authorization头中存储的JWT内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getCurrentUser&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">      String header = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      String token = header.substring(header.indexOf(<span class="string">&quot;bearer&quot;</span>) + <span class="number">7</span>);</span><br><span class="line">      <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">            .setSigningKey(<span class="string">&quot;test_key&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            .parseClaimsJws(token)</span><br><span class="line">            .getBody();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将令牌放入Authorization头中，访问如下地址获取信息：</p><p><a href="http://localhost:8080/user/getCurrentUser">http://localhost:8080/user/getCurrentUser</a></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image72.png"></p><h3 id="刷新令牌-1"><a href="#刷新令牌-1" class="headerlink" title="刷新令牌"></a>刷新令牌</h3><p>　在Spring Cloud Security 中使用oauth2时，如果令牌失效了，可以使用刷新令牌通过refresh_token的授权模式再次获取access_token。</p><p>只需修改认证服务器的配置，添加refresh_token的授权模式即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            <span class="comment">//配置client_id</span></span><br><span class="line">            .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">            <span class="comment">//配置client-secret</span></span><br><span class="line">            .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">            <span class="comment">//配置访问token的有效期</span></span><br><span class="line">            .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">            <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">            .refreshTokenValiditySeconds(<span class="number">86400</span>)</span><br><span class="line">            <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">            .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">            <span class="comment">//配置申请的权限范围</span></span><br><span class="line">            .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">            <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">            .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用刷新令牌模式来获取新的令牌，访问如下地址：</p><p><a href="http://localhost:8080/oauth/token">http://localhost:8080/oauth/token</a></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image73.png"></p><h2 id="Spring-Security-Oauth2-整合单点登录（SSO）"><a href="#Spring-Security-Oauth2-整合单点登录（SSO）" class="headerlink" title="Spring Security Oauth2 整合单点登录（SSO）"></a>Spring Security Oauth2 整合单点登录（SSO）</h2><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><p><img src="/../../img/markdown_img/SpringSecurity.assets/image74.png"></p><p>   <img src="/../../img/markdown_img/SpringSecurity.assets/image75.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image76.png"></p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yjxxt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oauth2client01demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>oauth2client01demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>application.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment">#防止Cookie冲突，冲突会导致登录验证不通过</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.name</span>=<span class="string">OAUTH2-CLIENT-SESSIONID01</span></span><br><span class="line"><span class="comment">#授权服务器地址</span></span><br><span class="line"><span class="meta">oauth2-server-url</span>: <span class="string">http://localhost:8080</span></span><br><span class="line"><span class="comment">#与授权服务器对应的配置</span></span><br><span class="line"><span class="meta">security.oauth2.client.client-id</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">security.oauth2.client.client-secret</span>=<span class="string">112233</span></span><br><span class="line"><span class="meta">security.oauth2.client.user-authorization-uri</span>=<span class="string">$&#123;oauth2-server-url&#125;/oauth/authorize</span></span><br><span class="line"><span class="meta">security.oauth2.client.access-token-uri</span>=<span class="string">$&#123;oauth2-server-url&#125;/oauth/token</span></span><br><span class="line"><span class="meta">security.oauth2.resource.jwt.key-uri</span>=<span class="string">$&#123;oauth2-server-url&#125;/oauth/token_key</span></span><br></pre></td></tr></table></figure><h3 id="在启动类上添加-EnableOAuth2Sso注解来启用单点登录功能"><a href="#在启动类上添加-EnableOAuth2Sso注解来启用单点登录功能" class="headerlink" title="在启动类上添加@EnableOAuth2Sso注解来启用单点登录功能"></a>在启动类上添加@EnableOAuth2Sso注解来启用单点登录功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.oauth2client01demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableOAuth2Sso</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Oauth2client01demoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(Oauth2client01demoApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加接口用于获取当前登录用户信息"><a href="#添加接口用于获取当前登录用户信息" class="headerlink" title="添加接口用于获取当前登录用户信息"></a>添加接口用于获取当前登录用户信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.oauth2client01demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getCurrentUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> authentication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改认证服务器配置"><a href="#修改认证服务器配置" class="headerlink" title="修改认证服务器配置"></a>修改认证服务器配置</h3><p>修改授权服务器中的AuthorizationServerConfig类，将绑定的跳转路径为</p><p><a href="http://localhost:8081/login%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%8E%B7%E5%8F%96%E7%A7%98%E9%92%A5%E6%97%B6%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">http://localhost:8081/login，并添加获取秘钥时的身份认证</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            <span class="comment">//配置client_id</span></span><br><span class="line">            .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">            <span class="comment">//配置client-secret</span></span><br><span class="line">            .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">            <span class="comment">//配置访问token的有效期</span></span><br><span class="line">            .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">            <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">            .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">            <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">            <span class="comment">// .redirectUris(&quot;http://www.baidu.com&quot;)</span></span><br><span class="line">            <span class="comment">//单点登录时配置</span></span><br><span class="line">            .redirectUris(<span class="string">&quot;http://localhost:8081/login&quot;</span>)</span><br><span class="line">            <span class="comment">//配置申请的权限范围</span></span><br><span class="line">            .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">            <span class="comment">//自动授权配置</span></span><br><span class="line">            .autoApprove(<span class="keyword">true</span>) </span><br><span class="line">            <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">            .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取密钥需要身份认证，使用单点登录时必须配置</span></span><br><span class="line">    security.tokenKeyAccess(<span class="string">&quot;isAuthenticated()&quot;</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动授权服务和客户端服务；</p><p>访问客户端需要授权的接口<a href="http://localhost:8081/user/getCurrentUser">http://localhost:8081/user/getCurrentUser</a></p><p>会跳转到授权服务的登录界面；</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image77.png"></p><p>授权后会跳转到原来需要权限的接口地址，展示登录用户信息；</p><p><img src="/../../img/markdown_img/SpringSecurity.assets%5Cimage78.png"></p>]]></content>
    
    
    <summary type="html">SpringSecurity</summary>
    
    
    
    <category term="SpringSecurity" scheme="http://ins1mn1a.github.io/categories/SpringSecurity/"/>
    
    
    <category term="SpringSecurity" scheme="http://ins1mn1a.github.io/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从哨兵脑裂</title>
    <link href="http://ins1mn1a.github.io/2021/12/16/redis/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/"/>
    <id>http://ins1mn1a.github.io/2021/12/16/redis/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-16T01:31:22.853Z</published>
    <updated>2021-12-17T12:52:42.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><p>读和写以及备份操作都是在一台Redis服务器上进行的，那么随着项目访问量的增加，对Redis服务器的操作也越加频繁，虽然Redis读写速度都很快，但是一定程度上也会造成一定的延时，那么为了解决访问量大的问题（大概有80%的请求都是读请求），通常会采取的一种方式是主从架构Master/Slave，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机Slave 节点。</p><p>主从复制之后，<strong>主服务器用来处理写请求，而从服务器只能用于读，不能写</strong>。最简单一主二从的方式，也可以采用一主多从的或者级联结构，Redis主从复制又可以分为全量复制和增量复制。</p><p>主从复制一主多从：</p><ul><li><p>这样的问题就是，如果Master服务器宕机了，那么两个从服务器便没有了主人一样，这时候我们只能去重新启动master，或者说在剩下的从服务器中选一个作为主服务器，然后进行将剩下的从服务器手动的连接到新master，这样就显得并不智能。显然，这非常的麻烦，大型的项目从服务器可能会有很多。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121200823820.png" alt="image-20211121200823820"></p></li></ul><p>主从复制链路形式：</p><ul><li>这种模式也有上述的问题，Master6379宕机之后，Slave6380并不会摇身一变成为matser，它仍然是一个salve。</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121194755383.png" alt="image-20211121194755383"></p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。</p><ul><li>从服务器连接主服务器，发送sync命令；</li><li>主服务器接收到sync命令，开始执行bgsave命令生成rdb文件，并使用缓冲区记录此后执行的所有写命令</li><li>主服务器bgsave命令执行完成后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照</li><li>主服务器快照发送完毕后开始向服务器发送缓冲区中的写命令</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令</li></ul><p>至此，从服务器数据初始化的所有操作完成，从服务器此时可以接收来自用户的读请求，但是不能写。</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>Redis<strong>增量复制</strong>是指<strong>Slave初始化后开始正常工作时，主服务器发生的写操作同步到从服务器的过程。</strong></p><p>增量复制的过程主要是<strong>主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行写命令</strong>。</p><h1 id="主从复制模拟"><a href="#主从复制模拟" class="headerlink" title="主从复制模拟"></a>主从复制模拟</h1><p>这里用3个不同的端口，生成3个redis服务器，并且准备用6379端口设置为主机，6380和6381设置为从机。</p><p>主从复制，配置从节点不配置主节点</p><h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><ol><li>拷贝redis.conf文件</li></ol><p>这里拷贝3份配置文件redis.conf，1一个主，2个从</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121190849226.png" alt="image-20211121190849226"></p><ol start="2"><li><p>修改配置文件</p><ul><li>redis.conf中的端口号</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185306902.png" alt="image-20211121185306902"></p><ul><li>daemonize 设置为yes</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185315718.png" alt="image-20211121185315718"></p><ul><li>进程id pid</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185322334.png" alt="image-20211121185322334"></p><ul><li>日志</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185331341.png" alt="image-20211121185331341"></p><ul><li>dump.rdb</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185345459.png" alt="image-20211121185345459"></p><ul><li>如果redis设置了密码，那么需要在从机上设置主机的密码</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185439977.png" alt="image-20211121185439977"></p></li><li><p>分别启动三个端口的redis-server和redis-cli</p></li><li><p>将端口6380、6381设置为6379的从机</p><ul><li><p><code>slave ip port</code>设置为Ip+port主机的从机</p></li><li><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191420316.png"></p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191440436-16374932859391.png" alt="image-20211121191440436"></p></li><li><p><code>info replication</code>查看当6380和6381服务器的状态</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191544255.png" alt="image-20211121191544255"></p></li><li><p>6379主机查看服务器状态</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191650650.png" alt="image-20211121191650650"></p></li></ul></li></ol><p>我们上述的配置是通过命令配置的，如果在配置文件中进行配置，那么则是永久的配置。</p><p>配置文件中进行的配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置主服务器IP 端口</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment"># redis设置了密码的话 还需要配置主服务器的密码</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure><p>这种命令配置的主从，当主机关闭后，重启，它仍然会是两个从机的主机，从机依旧可以直接获取到主机写的信息！如果我们将主机关闭后，让从机比如6380成为。但是，当从机关闭，重启，这个从机就不再是之前它master的slave了，现在重启后，它自己就是一个master，跟之前的master就没关系了。</p><p>如果Master宕机了，如果要让slave中的一个成为master，在哨兵模式没有设置的情况下，执行命令<code>slaveof no one</code>，那么这个结点就成为了master，然后其他的slave就可以再手动连接到新手动设置的master了。</p><h3 id="链路形式"><a href="#链路形式" class="headerlink" title="链路形式"></a>链路形式</h3><p>这里将6379作为master，然后6380连接到6381上。</p><p>现在将6379master断掉，然后在6381上info replication，发现它并不会成为master。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121195727429.png" alt="image-20211121195727429"></p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121195757090.png" alt="image-20211121195757090"></p><p>主从模式没办法对master进行自动的更新。因此引入了哨兵模式Sentinel。</p><p>从master到slave的复制是异步的，所以可能有部分数据还没复制到slave，master宕机，由此数据就部分丢失了，这就是<strong>Redis异步复制导致的数据丢失问题。</strong></p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>上面的模式，如果Master宕机了那么就类似群龙无首一样，多个slave中没有一个站出来自动充当master，如果我们手动选择就太繁琐了，引入的哨兵模式就可以解决这种问题。</p><h3 id="哨兵模式的作用"><a href="#哨兵模式的作用" class="headerlink" title="哨兵模式的作用"></a>哨兵模式的作用</h3><ol><li><strong>监控(Monitoring):</strong> 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</li><li><strong>提醒(Notification):</strong> 当被监控的某个Redis节点出现问题时， 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>主节点故障转移(Automatic failover)<strong>：当</strong>一个Master不能正常工作</strong>时，哨兵(sentinel) 会开始<strong>一次自动故障迁移操作</strong>。从节点晋升到主节点并维护后续正确的主从关系；</li></ol><h3 id="哨兵进程的工作方式"><a href="#哨兵进程的工作方式" class="headerlink" title="哨兵进程的工作方式"></a>哨兵进程的工作方式</h3><p>Sentinel（哨兵）是Redis的高可用性解决方案：由一个或者多个哨兵实例组成的哨兵系统来监视多个服务器的运行状态。</p><p>当一个master主服务器宕机的时候，如果有一个哨兵检测到这个主机处于下线状态，这时候这个主机被认为是<strong>主观下线</strong>（SDOWN），然后当一定数量的哨兵都检测到这个主服务器下线时，这个主机被认为<strong>客观下线</strong>（ODOWN），并在确定主服务器进入<strong>客观下线</strong>的状态之后，哨兵自动投票选举从服务器中的一个成为主服务器，剩下的所有从服务器都会自动的连接到这个新选取出来的主服务器。</p><ol><li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。</li><li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态。</li><li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）。</li><li>在一般情况下， 每个Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li><li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li></ol><h3 id="哨兵模式模拟"><a href="#哨兵模式模拟" class="headerlink" title="哨兵模式模拟"></a>哨兵模式模拟</h3><h4 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h4><p>新建一个哨兵模式配置文件<code>sentinel.conf</code>，这里设置同意主节点真的挂掉的哨兵数量为1。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 同意主节点真的挂掉的哨兵数量</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6381 1</span><br></pre></td></tr></table></figure><h4 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h4><p><code>redis-sentinel sentinel.conf</code>启动哨兵</p><p>第一次启动哨兵：Next failover delay: I will not start a failover before Sun Nov 21 20:50:55 2021</p><p>这是因为在redis主从服务器中设置了密码，但是哨兵配置文件中并没有配置密码，所有没有成功启动哨兵模式。</p><p>重新配置如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 同意主节点真的挂掉的哨兵数量</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6381 1</span><br><span class="line">sentinel auth-pass myredis password <span class="comment"># 密码配置</span></span><br></pre></td></tr></table></figure><p>重新启动哨兵模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># redis-sentinel myredisconfig/sentinel.conf</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.176 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.176 <span class="comment"># Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=8175, just started</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.176 <span class="comment"># Configuration loaded</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.177 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">8175:X 21 Nov 2021 21:26:49.177 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.6 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 8175</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">          `-._        _.-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span></span><br><span class="line"></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.177 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># Sentinel ID is 16cbd6e88092909d2f92476c149045138facc8f1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># +monitor master myredis 127.0.0.1 6381 quorum 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.180 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:26:49.181 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动成功，可以看到6381端口下有两个slave：</p><p>+slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381；</p><p>+slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381；</p><p>现在我们将主节点6381断掉，验证哨兵模式是否会重新选举主服务器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8175:X 21 Nov 2021 21:26:49.177 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># Sentinel ID is 16cbd6e88092909d2f92476c149045138facc8f1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># +monitor master myredis 127.0.0.1 6381 quorum 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.180 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:26:49.181 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +sdown master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +odown master myredis 127.0.0.1 6381 #quorum 1/1</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +new-epoch 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +try-failover master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.869 <span class="comment"># +vote-for-leader 16cbd6e88092909d2f92476c149045138facc8f1 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.869 <span class="comment"># +elected-leader master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.869 <span class="comment"># +failover-state-select-slave master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.931 <span class="comment"># +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.931 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:55.991 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:56.291 <span class="comment"># +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:56.291 <span class="comment"># +failover-state-reconf-slaves master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:56.345 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.273 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.273 * +slave-reconf-done slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 <span class="comment"># +failover-end master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 <span class="comment"># +switch-master myredis 127.0.0.1 6381 127.0.0.1 6380</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6380</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6380</span><br><span class="line">8175:X 21 Nov 2021 21:28:27.369 <span class="comment"># +sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6380</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这里+表示进入，-表示退出</span><br><span class="line">+sdown就表示实例进入主观下线状态</span><br><span class="line"></span><br><span class="line">-sdown表示实例退出主观下线状态</span><br><span class="line"></span><br><span class="line">+odown表示实例进入客观下线状态</span><br><span class="line"></span><br><span class="line">-odown表示实例退出客观下线状态</span><br><span class="line"></span><br><span class="line">+swtich-master表示主服务器地址发生变化</span><br></pre></td></tr></table></figure><p>可以看到，确实是重新选举了一个master：+switch-master myredis 127.0.0.1 6381 127.0.0.1 6380；</p><p>现在6380成为了一个master，然后我们去查看6380的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line">Error: Server closed the connection</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment"># 角色从slave变为master</span></span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6379,state=online,offset=5126,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4f3894e2484b0ed7c7cf3ddb62805a4cd865e726</span><br><span class="line">master_replid2:c2a5af21553f6f3996fdfd68742d9a667960d9e5</span><br><span class="line">master_repl_offset:5126</span><br><span class="line">second_repl_offset:2408</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:5126</span><br></pre></td></tr></table></figure><p>可以看到现在6380的角色成为了master。</p><p>查看6379的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">Error: Server closed the connection</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6380<span class="comment"># 主节点从6381变为了6380</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:5390</span><br><span class="line">slave_repl_offset:5390</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4f3894e2484b0ed7c7cf3ddb62805a4cd865e726</span><br><span class="line">master_replid2:c2a5af21553f6f3996fdfd68742d9a667960d9e5</span><br><span class="line">master_repl_offset:5390</span><br><span class="line">second_repl_offset:2408</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:5376</span><br></pre></td></tr></table></figure><h3 id="哨兵配置文件"><a href="#哨兵配置文件" class="headerlink" title="哨兵配置文件"></a>哨兵配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">  sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line"> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h3><p>当只有一个哨兵的时候，如果这个哨兵一不小心崩掉了，那么我们的主从模式就没有哨兵了，就无法完成自动选举主节点的功能了。所以我们可以给哨兵也做一个集群。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121214930557.png" alt="image-20211121214930557"></p><p>根据端口不同配置多份哨兵的配置文件，然后启动redis-master，redis-slaves，哨兵。</p><h1 id="异步数据丢失"><a href="#异步数据丢失" class="headerlink" title="异步数据丢失"></a>异步数据丢失</h1><p>因为Redis从master到slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，由此数据就部分丢失了，这就是<strong>Redis异步复制导致的数据丢失问题。</strong></p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211123224114132.png" alt="image-20211123224114132"></p><h1 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h1><p>Redis的一个master因为网络的波动，与其他slave失去了连接，但是master实际上还是在正常的运行。哨兵们就认为这个master挂掉了，于是哨兵就会选举出一个新的master。这个时候集群里就有两个master了，这就是<strong>脑裂。</strong></p><p>尽管这个时候某个slave已经被选举成为了master，但是可能客户端client还没来得及从旧的master切换到新的master，仍在继续写数据，就可能造成这仍向旧master写的部分数据丢失。</p><p>然后当原本的master携带数据重新连接回来的时候，哨兵让原master执行slaveof命令，和新master进行全量复制，当从服务器收到master的快照文件后丢弃所有旧数据，原master数据被清空，重新向新master复制数据。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211123224138254.png" alt="image-20211123224138254"></p><h1 id="脑裂以及异步数据丢失解决方案"><a href="#脑裂以及异步数据丢失解决方案" class="headerlink" title="脑裂以及异步数据丢失解决方案"></a>脑裂以及异步数据丢失解决方案</h1><p>Redis提供以下配置：</p><ul><li><p>min-slaves-to-write M</p><p>配置了master能进行数据同步的最少slave数量。</p></li><li><p>min-slaves-max-lag N</p><p>配置了master，slave进行数据复制时，slave给master发送ACK消息的最大延迟。</p></li></ul><p>我们可以把min-slaves-to-write和min-slaves-max-lag结合起来使用，分别设置一定阈值。</p><p>比如这里配置后要求：一个master至少要有M个slave，并且slave和master进行数据复制时的ACK消息不能超过N秒，否则，master就不能再接收client的请求。</p>]]></content>
    
    
    <summary type="html">Redis主从复制、哨兵模式、脑裂</summary>
    
    
    
    <category term="Redis" scheme="http://ins1mn1a.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://ins1mn1a.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity过滤器原理</title>
    <link href="http://ins1mn1a.github.io/2021/01/23/SpringSecurity/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://ins1mn1a.github.io/2021/01/23/SpringSecurity/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/</id>
    <published>2021-01-23T08:07:02.517Z</published>
    <updated>2021-12-17T12:52:37.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringSecurity原理"><a href="#SpringSecurity原理" class="headerlink" title="SpringSecurity原理"></a>SpringSecurity原理</h1><h2 id="主要过滤器链"><a href="#主要过滤器链" class="headerlink" title="主要过滤器链"></a>主要过滤器链</h2><p>SpringSecurity的功能主要是由一系列的过滤器链相互配合完成的。验证一个过滤器之后放行到下一个过滤器链，然后到最后。</p><p><img src="/../../img/markdown_img/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.assets/image-20211202145237010.png" alt="image-20211202145237010"></p><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p><img src="/../../img/markdown_img/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.assets/d359fe34bc7860c11a1b6e50bfd0e086.png" alt="img"></p><h3 id="过滤器作用"><a href="#过滤器作用" class="headerlink" title="过滤器作用"></a>过滤器作用</h3><ol><li><p>SecurityContextPersistenceFilter：会在每次请求处理之前从配置好的SecurityContextRepository中获取SecurityContext安全上下文信息，然后加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓库”中，然后将SecurityContextHolder中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</p></li><li><p>DefaultLoginPageGeneratingFilter：如果没有配置自定义登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p></li><li><p>BasicAuthenticationFilter：检测和处理http basic认证。</p></li><li><p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自/login的表单action。从表单中获取用户名和密码时，默认使用的表单name属性值为username和password，这俩个值也可以通过usernameParameter和passwordParameter在配置中自定义。</p><p>这个过滤器在表单提交登录请求之时会起作用。那么假设现在采用SpringSecurity整合Jwt，那么我需要配置一个Jwt登录认证类（继承BasicAuthenticationFilter或者继承OncePerRequestFilter都可以，因为BasicAuthenticationFilter继承了OncePerRequestFilter），重写过滤器方法。Jwt的token认证登录是需要在<strong>在采用用户名密码登录认证之前</strong>，所以在配置Jwt登录认证类的时候需要在UsernamePasswordAuthenticationFilter之前添加过滤器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置自定义过滤器 添加jwt登录授权过滤器</span></span><br><span class="line"><span class="comment">//在过滤器UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line">http.addFilterBefore(jwtAuthenticationFilter,UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure></li><li><p>RequestCacheAwareFilter：用来处理请求的缓存。</p></li><li><p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。</p></li><li><p>AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在则为其提供一个匿名Authentication。</p></li><li><p>SessionManagementFilter：管理Session的过滤器</p></li><li><p>ExceptionTranslationFilter：捕获来自过滤器链的所有异常，并进行处理。但是只处理两类异常：AccessDeniedException和AuthenticationException 异常，其他的异常会继续抛出。</p><p>如果捕获到的AuthenticationException，那么将会使用其对应的AuthenticationEntryPoint的commence()方法处理。在处理之前，ExceptionTranslationFilter先使用RequestCache将当前的HTTPServletRequest的信息保存起来，方便用户登录成功后可以跳转到之前的页面。</p><p>可以自定义AuthenticationException的处理方法。需要实现AuthenticationEntryPoint接口，然后重写commence()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当未登录或者token失效时访问接口自定义的返回结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAuthorizationEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean bean = RespBean.error(<span class="string">&quot;请先登录!&quot;</span>);</span><br><span class="line">        bean.setCode(<span class="number">401</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(bean));</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果捕获的AuthenticationDeniedException，那么将会根据当前访问的用户是否已经登录认证做不同的处理，如果未登录，则会使用关联的AuthenticationEntryPoint的commence()方法进行处理，否则将使用关联的AccessDeniedHandler的handle()方法进行处理。</p><p>可以进行自定义AuthenticationDeniedException的处理方法。需要实现AccessDeniedHandler接口，然后重写handle()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean error = RespBean.error(<span class="string">&quot;权限不足，联系管理员!&quot;</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));</span><br><span class="line">        error.setCode(<span class="number">403</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FilterSecurityInterceptor：可以看做过滤器链的出口</p></li><li><p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p></li></ol><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>SecurityContext对象是安全上下文信息，包括当前使用系统的用户的信息。每个用户都会有它的安全上下文对象，所以把每一个用户的SecurityContext保存到SecurityContextHolder中。</p><p>SecurityContextHolder存储SecurityContext的方式根据应用场景不同也有区别：</p><p>（1）单机系统，即应用从开启到关闭的整个生命周期只有一个用户在使用。由于整个应用只需要保存一个SecurityContext（安全上下文即可）</p><p>（2）多用户系统，比如典型的Web系统，整个生命周期可能同时有多个用户在使用。这时候应用需要保存多个SecurityContext（安全上下文），需要利用ThreadLocal进行保存，每个线程都可以利用ThreadLocal获取其自己的SecurityContext，及安全上下文。ThreadLocal内部会用数组来存储多个对象的。原理是，ThreadLocal会为每个线程开辟一个存储区域，来存储相应的对象。</p><p>Authentication：用户信息的表示</p><p>在SecurityContextHolder中存储了当前与系统交互的用户的信息。Spring Security使用一个Authentication 对象来表示这些信息。</p><p>Authentication 主要包含了：</p><ul><li>用户权限集合</li><li>用户证书（密码）</li><li>细节（Details）</li><li>Principal（就是这个用户的账户信息）</li></ul><p>在自定义登录认证过滤器的时候，记得需要把用户的信息（Authentication ）保存到SecurityContextHolder中，以便后续用户的正常使用。比如我在做和Jwt认证的整合的时候，继承OncePerRequestFilter，重写doFilterInternal方法，认证完token之后，就需要把用户的信息存入安全上下文Holder中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UsernamePasswordAuthenticationToken authenticationToken</span><br><span class="line">    =<span class="keyword">new</span> UsernamePasswordAuthenticationToken(user,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">authenticationToken.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource()</span><br><span class="line">                               .buildDetails(request));</span><br><span class="line"></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br></pre></td></tr></table></figure><p>关于SecurityContextHolder大概就这样，有一些关于SecurityContextHolder具体的源码的细节可以参考一篇博客：</p><p><a href="https://www.cnblogs.com/longfurcat/p/9417912.html">https://www.cnblogs.com/longfurcat/p/9417912.html</a></p>]]></content>
    
    
    <summary type="html">SpringSecurity过滤器，安全上下文</summary>
    
    
    
    <category term="SpringSecurity" scheme="http://ins1mn1a.github.io/categories/SpringSecurity/"/>
    
    
    <category term="SpringSecurity" scheme="http://ins1mn1a.github.io/tags/SpringSecurity/"/>
    
  </entry>
  
</feed>
