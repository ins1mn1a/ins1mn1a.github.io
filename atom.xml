<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ins1mn1a</title>
  
  <subtitle>反方向的钟</subtitle>
  <link href="http://ins1mn1a.github.io/atom.xml" rel="self"/>
  
  <link href="http://ins1mn1a.github.io/"/>
  <updated>2022-07-27T14:58:44.257Z</updated>
  <id>http://ins1mn1a.github.io/</id>
  
  <author>
    <name>ins1mnia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://ins1mn1a.github.io/2022/07/27/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://ins1mn1a.github.io/2022/07/27/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-07-27T14:57:22.561Z</published>
    <updated>2022-07-27T14:58:44.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><ul><li><p>示例 1：</p><p>输入：target = 7, nums = [2,3,1,2,4,3]</p><p>输出：2</p><p>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p></li></ul><p><strong>滑动窗口：</strong></p><ul><li>要找到 和 大于 target 的最小 连续 子数组，那就从左开始扩大窗口 right++，直到窗口内的和 &gt;= target。这个时候就可以缩小窗口了，因为当前就意味着 &gt;= target 的数组找到了，从 left 到 right，但它不是最小的子数组，可能 left+1 到 right 还是 &gt;= target，所以就缩小窗口，更新 最小值 和 窗口内的和</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口解决</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left =<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> windowSum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">while</span> (right &lt; nums.length)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 扩大窗口</span></span><br><span class="line">           windowSum += nums[right];</span><br><span class="line">           right++;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 不能这个时候 记录最小值，窗口还没缩小呢，这个时候都是当前轮次的最大值</span></span><br><span class="line">           <span class="comment">// res = Math.min(res,right - left);</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 缩小窗口</span></span><br><span class="line">           <span class="keyword">while</span> (windowSum &gt;= target)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 窗口缩小 后， 才是最小值</span></span><br><span class="line">               res = Math.min(res,right - left);</span><br><span class="line">               windowSum -= nums[left];</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res==Integer.MAX_VALUE ? <span class="number">0</span>:res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="乘积小于-K-的子数组"><a href="#乘积小于-K-的子数组" class="headerlink" title="乘积小于 K 的子数组"></a>乘积小于 K 的子数组</h2><p><strong>剑指 Offer II 009. 乘积小于 K 的子数组</strong></p><p>给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。</p><ul><li><p>示例 1:</p><p>输入: nums = [10,5,2,6], k = 100</p><p>输出: 8</p><p>解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</p></li><li><p>示例 2:</p><p>输入: nums = [1,2,3], k = 0</p><p>输出: 0</p></li></ul><p>同样滑动窗口，关键是什么时候缩小窗口？当window 内的乘积 &gt;= k 的时候缩小窗口？这个时候缩小窗口，怎么去记录结果值呢，怎么去记录这个窗口内这些乘积小于k 的子数组？在缩小窗口的时候 res++，肯定不行，这样就窗口只会缩小一次，也只记录一次，记录也不全。</p><p>考虑 <strong>当 window 内的成绩&lt;k</strong> 的时候，那么 <strong>window 内的每一个数，都将是&lt;k的</strong>。那么这个时候，我们每次直接记录在window内有多少数就可以，res += right - left + 1。</p><p>所以我们在 window 内的乘积 &gt;= k 的时候缩小窗口，但是不记录 res，窗口缩小完后，记录窗口里多少个数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> window=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 扩大窗口</span></span><br><span class="line">            window *= nums[right];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 没有这个left &lt;= right 下面 nums[left]会越界</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; window &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                window = window / nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 窗口内的乘积 &lt; k，则窗口内的每一个数都小于 k</span></span><br><span class="line">            res += right - left + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里扩大窗口，不用在上面记录一次 right</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="几道滑动窗口总结"><a href="#几道滑动窗口总结" class="headerlink" title="几道滑动窗口总结"></a>几道滑动窗口总结</h2><p><strong>剑指offer2 14 —&gt; 17</strong></p><p>下面的 need 是一个 hashmap，包含了 一个字符串中的 所有字符以及出现次数</p><p>14：判断 一个字符串s2 中 包不包含 另外一个字符串 s1的全排列之一</p><p>​    <strong>s1 = “ab” s2 = “eidbaooo”</strong> —&gt; <strong>true</strong>    ba 是 s1=”ab” 的全排列之一</p><ul><li><p><strong>扩大窗口</strong></p><ul><li>扩大窗口，很明显需要 <strong>根据need 去更新 window</strong>，看这个字符 是不是 在need 之中，如果在，显然就要 put 到window中</li><li>此外，<strong>valid</strong> 来表示有效字符的个数，如果这个字符在窗口中的出现次数和要找的次数相同，显然还要更新 **valid++**，这样后面缩小的时候 就可以 <strong>根据valid 直接返回结果 true</strong></li></ul></li><li><p><strong>缩小窗口</strong></p><ul><li><p><strong>缩小窗口时机</strong>：right - left == s1.length，当移动了 s1的长度，说明就有可能 有 s2 包含 s1 的全排列了</p></li><li><p>缩小窗口，那么根据<strong>与扩大窗口的对称性</strong>，显然 要 <strong>根据 need 去更新 window</strong>，看这个字符 是不是 在need 之中，如果在，显然就要 <strong>把 window中这个字符的出现次数 减去 1</strong></p></li><li><p>根据<strong>与扩大窗口的对称性</strong>，把当前left 字符移出，也就<strong>还要 更新 valid</strong>，如果这个字符在窗口中的出现次数和要找的次数相同，显然 缩小窗口后，就不相同了，那么就要 valid–</p></li><li><p><strong>valid == need.size</strong>，因为 我们 找到的 有效字符 包含了 need 中的所有字符，那么显然就 可以 直接返回结果了</p></li></ul></li></ul><p>15：要找到 s 中包含 p中全排列的 所有下标，14 只是要找到一个即可，并且返回true 或者 false，而15 则是要找到 所有的，并且 以数组的形式 返回所有下标值</p><p>​    <strong>s = “cbaebabacd”, p = “abc”</strong> —&gt; <strong>[0,6]</strong></p><ul><li><p><strong>扩大窗口</strong></p><ul><li>扩大窗口，很明显需要 <strong>根据need 去更新 window</strong>，看这个字符 是不是 在need 之中，如果在，显然就要 put 到window中</li><li>此外，<strong>valid</strong> 来表示有效字符的个数，如果这个字符在窗口中的出现次数和要找的次数相同，显然还要更新 <strong>valid++<strong>，当 <strong>后面 判断 valid==need.size</strong>，就</strong>说明找到了包含全部字符的子串</strong>，就可以 把 left 下标，添加到 结果数组中</li></ul></li><li><p><strong>缩小窗口</strong></p><ul><li><strong>缩小窗口时机</strong>：right - left == p.length，当移动了 p的长度，说明就有可能 有 s 包含 p 的全排列了。<strong>能够去掉s中重复的原因( s=cbba p=abc)：</strong> 只要 已经匹配的字符 == P的长度了，那么就可以去判断 这个字符内是不是它的异位词了，这样 如果 在left…right 这个串里 如果有 p 的重复字符，那么就意味着 right - left == p.length 时，必然 不是异位词，因为重复字符多占用了 多个空间，所以会提早==p.length，也自然就不会认为重复字符 cbba 是 abc的异位了</li><li><strong>valid==need.size</strong>，就<strong>说明找到了包含全部字符的子串</strong>，就可以 把 left 下标，添加到 结果数组中</li><li>根据 <strong>与扩大窗口的对称性</strong>，<strong>更新 window</strong></li><li>根据 <strong>与扩大窗口的对称性</strong>，<strong>更新 valid</strong></li></ul></li><li><p><strong>更新返回结果</strong></p><ul><li><strong>valid==need.size</strong>，就<strong>说明找到了包含全部字符的子串</strong>，就可以 把 left 下标，添加到 结果数组中，这个时候更新结果，但是 <strong>显然 要在 窗口 正式缩小前 判断 然后 更新</strong>，窗口缩小后 valid 需要更新的</li></ul></li></ul><p>16：无重复的最长子串，给一个 字符串s ，要找到 s 中 无重复的最长子串</p><p>​    <strong>s = “pwwkew”</strong> —&gt; <strong>wke</strong>    无重复最长子串为 wke，而不是 pwke，pwke 是子序列</p><ul><li><p><strong>窗口改变</strong></p><p><strong>这题不再需要 need 这个hashmap了，因为只有涉及到一个字符串，并且只要在 一个字符串中找到无重复的最长子串就OK</strong></p></li><li><p><strong>扩大窗口</strong></p><ul><li>窗口扩大，更新 window，就把 这个字符直接放到window里去，更新其出现次数</li></ul></li><li><p><strong>窗口缩小</strong></p><ul><li><strong>缩小时机</strong>：<strong>window.get(c) &gt; 1</strong>  要找到 无重复的最长子串，当窗口里面<strong>出现重复的字符</strong>的时候，显然，就要去 更新 无重复最长的子串结果 res 了 ，所以当 出现字符重复的时候，就应该去缩小窗口了</li><li>缩小窗口，<strong>更新 window</strong> 中字符的出现次数</li></ul></li><li><p><strong>更新返回值</strong></p><ul><li><strong>缩小完窗口后，整个窗口内，就是无重复的子串了</strong>，这样就可以去<strong>更新 最长无重复子串 res</strong>了，<code>res = Math.max(res,right - left);</code></li><li>就算没有重复，没有缩小窗口的流程，自然也是 无重复的子串，那么正好 一样 记录结果</li></ul></li></ul><p>17：最小覆盖子串，要在 s 中找到 包含 t 中所有字符的 最小子串，t 可能包含重复字符</p><p>​    <strong>s = “ADOBECODEBANC”, t = “ABC”</strong> —&gt; <strong>BANC</strong></p><ul><li><p><strong>扩大窗口</strong></p><ul><li>窗口扩大，更新 window，同样的，如果 need 中包含这个字符，那么就把 窗口中的字符出现次数+1</li><li>窗口扩大，更新 valid，当某个字符完全出现（即出现次数也相同）的时候，就valid++</li></ul></li><li><p>缩小窗口</p><ul><li><strong>缩小时机</strong>：<strong>valid==need.size</strong> 当 window 内包含 need 中所有的字符的时候（此外字符出现次数也要相同），就可以缩小窗口了</li><li><strong>此处记录返回值</strong></li><li>更新valid，判断如果 窗口中的字符出现次数 和 need 中的相同的话，那么窗口一缩小，valid要–；</li><li>缩小窗口，更新 window，同样如果 need 中包含这个字符，那就把这个window中的字符出现次数-1</li></ul></li><li><p><strong>更新返回值</strong></p><ul><li><p>当窗口缩小的时候，也就是s 的子串 s[left…right] 包含 t的所有字符的时候，因为要返回的是子串，所以我们要记录下来 最小的子串长度，同时记录子串的起始索引，最后 返回 s.subString()即可</p></li><li><p><strong>更新时机</strong></p><p>知道要更新什么了，什么时候更新呢，显然是在 每次缩小 之前更新，每次的缩小都代表的着是一个结果子串，那么这个时候 我们记录 最小值的同时记录下起始索引也就是 left 即可。</p></li></ul></li></ul><h2 id="字符串中的变位词"><a href="#字符串中的变位词" class="headerlink" title="字符串中的变位词"></a>字符串中的变位词</h2><p><a href="https://leetcode.cn/problems/MPnaiL/">剑指 Offer II 014. 字符串中的变位词</a></p><p><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></p><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的某个变位词。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的 子串 。</p><ul><li><p>示例 1：</p><p>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”)</p></li><li><p>示例 2：</p><p>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length();</span><br><span class="line">        <span class="keyword">int</span> n = s2.length();</span><br><span class="line">        <span class="comment">// 窗口中字符以及出现次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存 s1 中 字符出现的次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1.toCharArray()) &#123;</span><br><span class="line">            need.put(c,need.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 扩大窗口</span></span><br><span class="line">            <span class="keyword">char</span> c = s2.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 数据更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(c))</span><br><span class="line">            &#123;</span><br><span class="line">                window.put(c,window.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 出现次数相等，则 valid++</span></span><br><span class="line">                <span class="keyword">if</span> (window.get(c).equals(need.get(c)))</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            <span class="comment">// 当移动了 s1 的长度，说明就可能 有 s2 包含 s1的排列了</span></span><br><span class="line">            <span class="comment">// 这个时候 就可以缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (right - left == m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 出现了合适的子串，可以 退出了</span></span><br><span class="line">                <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">char</span> d = s2.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 移除 s2[left]，要更新map 需要 更新的数据 包括: 窗口内字符的出现次数 和 valid</span></span><br><span class="line">                <span class="comment">// 要移除的 d 包含在need里面，那就要把 window 里的出现次数减去1</span></span><br><span class="line">                <span class="comment">// 其次，要先 判断 是不是有效字符，如果是，valid也要--</span></span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(d))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果 完全包含 d 这个有效字符</span></span><br><span class="line">                    <span class="keyword">if</span> (need.get(d).equals(window.get(d)))</span><br><span class="line">                        valid--;</span><br><span class="line">                    window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="字符串中的所有变位词"><a href="#字符串中的所有变位词" class="headerlink" title="字符串中的所有变位词"></a>字符串中的所有变位词</h2><p><a href="https://leetcode.cn/problems/VabMRr/">剑指 Offer II 015. 字符串中的所有变位词</a></p><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>变位词 指字母相同，但排列不同的字符串。</p><ul><li><p>示例 1：</p><p>输入: s = “cbaebabacd”, p = “abc”<br>输出: [0,6]</p><p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的变位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的变位词。</p></li><li><p>示例 2：</p><p>输入: s = “abab”, p = “ab”<br>输出: [0,1,2]</p><p>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的变位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的变位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的变位词。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 窗口中字符以及出现次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存 p 中 字符出现的次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">            need.put(c,need.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> valid=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// s = &quot;cbba ebabacd&quot;, p = &quot;abc&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (right&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 扩大窗口</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(c))</span><br><span class="line">            &#123;</span><br><span class="line">                window.put(c,window.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 出现次数ok</span></span><br><span class="line">                <span class="keyword">if</span> (need.get(c).equals(window.get(c)))</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            <span class="comment">// 只要 已经匹配的字符 == P的长度了，那么就可以去判断 这个字符内是不是它的异位词了，</span></span><br><span class="line">            <span class="comment">// 这样 如果 在left...right 这个串里 如果有 p 的重复字符，那么就意味着 right - left == p.length 时，</span></span><br><span class="line">            <span class="comment">// 必然 不是异位词，因为重复字符多占用了 多个空间，所以会提早==p.length，也自然就不会认为重复字符 cbba 是 abc的异位了</span></span><br><span class="line">            <span class="keyword">while</span> (right-left &gt;= p.length())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (valid == need.size())</span><br><span class="line">                    res.add(left);</span><br><span class="line">                <span class="keyword">char</span> d = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(d))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (need.get(d).equals(window.get(d)))</span><br><span class="line">                        valid--;</span><br><span class="line">                    window.put(d,window.get(d)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><a href="https://leetcode.cn/problems/wtcaE1/">剑指 Offer II 016. 不含重复字符的最长子字符串</a></p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><ul><li><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></li><li><p>示例 2:</p><p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></li><li><p>示例 3:</p></li><li><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><pre><code> 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 扩大窗口</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 更新数据 window</span></span><br><span class="line"></span><br><span class="line">            window.put(c,window.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 缩小窗口，当 字符出现次数 &gt; 1 也就是重复出现的的时候，就需要更新res值，找到最大的无重复子串</span></span><br><span class="line">            <span class="keyword">while</span> (window.get(c) &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                <span class="keyword">char</span> d = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                window.put(d,window.get(d)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            res = Math.max(res,right - left);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></p><p><a href="https://leetcode.cn/problems/M1oyTv/">剑指 Offer II 017. 含有所有字符的最短字符串</a></p><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><ul><li><p>示例 1：</p><p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”</p></li><li><p>示例 2：</p><p>输入：s = “a”, t = “a”<br>输出：”a”</p></li><li><p>示例 3:</p><p>输入: s = “a”, t = “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存 需要找的字符 即 t 中字符 及其出现次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            need.put(c,need.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录最后 的长度 和 起始位置</span></span><br><span class="line">        <span class="keyword">int</span> minLen=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valid=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 扩大窗口</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(c))</span><br><span class="line">            &#123;</span><br><span class="line">                window.put(c,window.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (need.get(c).equals(window.get(c)))</span><br><span class="line">                    valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (valid == need.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 这里更新最小覆盖子串</span></span><br><span class="line">                <span class="keyword">if</span> (right-left &lt; minLen)</span><br><span class="line">                &#123;</span><br><span class="line">                    minLen = right-left;</span><br><span class="line">                    start=left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> d = s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(d))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(d).equals(need.get(d)))</span><br><span class="line">                        valid--;</span><br><span class="line">                    window.put(d,window.get(d)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span>:s.substring(start,start+minLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">滑动窗口算法，滑动窗口总结，最小覆盖子串，无重复最长子串，变位词</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch</title>
    <link href="http://ins1mn1a.github.io/2022/07/27/ElasticSearch/ElasticSearch/"/>
    <id>http://ins1mn1a.github.io/2022/07/27/ElasticSearch/ElasticSearch/</id>
    <published>2022-07-27T14:48:59.392Z</published>
    <updated>2022-07-27T14:53:20.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES-概述"><a href="#ES-概述" class="headerlink" title="ES 概述"></a>ES 概述</h1><p>The Elastic Stack, 包括 Elasticsearch、 Kibana、 Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化。</p><p>Elaticsearch，简称为 ES， ES 是一个开源的高扩展的分布式全文搜索引擎， 是整个 ElasticStack 技术栈的核心。</p><p>它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理 PB 级别的数据。</p><p><strong>ES</strong> 是使用 <strong>Java 编写</strong>的一种开源搜索引擎，它在<strong>内部使用 Lucene 做索引与搜索</strong>，通过对 <strong>Lucene</strong> 的<strong>封装</strong>，隐藏了 Lucene 的复杂性，取而代之的提供一套简单一致的 <strong>RESTful API</strong>。</p><h3 id="ElasticSearch-安装"><a href="#ElasticSearch-安装" class="headerlink" title="ElasticSearch 安装"></a>ElasticSearch 安装</h3><p>直接在 Windows 下安装 ES，下载安装包 ES 7.8，解压即可，然后运行 elasticsearch.bat</p><p>访问 localhost:9200</p><p><strong>9300 端口</strong>为 Elasticsearch <strong>集群间</strong>组件的<strong>通信端口</strong>， <strong>9200 端口</strong>为浏览器访问的 <strong>http协议 RESTful 端口</strong>。</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220725141643870.png" alt="image-20220725141643870"></p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>首先先理解正排索引。正排索引是一般的常规索引，是从表行映射到关键字列表的常规（正向）索引，倒排索引则将关键字映射到它们各自的行。</p><p>可以看navicat 的文档 [ <a href="http://www.navicat.com.cn/company/aboutus/blog/416-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B.html">http://www.navicat.com.cn/company/aboutus/blog/416-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B.html</a> ]，有倒排索引的简介</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220725145754662.png" alt="image-20220725145754662"></p><p>像下面 description 这样的文本，很适合建立倒排索引，就跟上面一样，每个单词对应有自己的行。每个单词都直接指向相关行。</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220725145929941.png" alt="image-20220725145929941"></p><p>Elasticsearch 是<strong>面向文档型数据库</strong>，一条数据在这里就是一个文档。 我们可以将 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220725150218418.png" alt="image-20220725150218418"></p><p>这里 Types 的概念已经被逐渐弱化， Elasticsearch 6.X 中，一个 index 下已经只能包含一个type， Elasticsearch 7.X 中, Type 的概念已经被删除了。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="HTTP-索引创建"><a href="#HTTP-索引创建" class="headerlink" title="HTTP 索引创建"></a>HTTP 索引创建</h4><p>对比关系型数据库，创建索引就类似于创建数据库</p><p>在Postman中，向 ES 发起 Put 请求，localhost:9200/shopping，服务器返回响应</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;shards_acknowledged&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;shopping&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台日志： [shopping] creating index, cause [api], templates [], shards [1]/[1], mappings []</p><p>如果重复创建相同索引，会返回错误信息</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;resource_already_exists_exception&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;index [shopping/f27eP8FlRRahLL5pwATr-g] already exists&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;f27eP8FlRRahLL5pwATr-g&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;shopping&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;resource_already_exists_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;index [shopping/f27eP8FlRRahLL5pwATr-g] already exists&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;f27eP8FlRRahLL5pwATr-g&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;shopping&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引查询-amp-删除"><a href="#索引查询-amp-删除" class="headerlink" title="索引查询 &amp; 删除"></a>索引查询 &amp; 删除</h4><p>向 ES 服务器发 GET 请求 ： <a href="http://127.0.0.1:9200/_cat/indices?v">http://127.0.0.1:9200/_cat/indices?v</a></p><p>_cat 表示查看的意思，indices 表示索引，这个请求代表 查看 ES 中所有的索引，服务器响应如下：</p><p><strong>health</strong> <strong>status</strong> <strong>index</strong>    <strong>uuid</strong>                   <strong>pri</strong> <strong>rep</strong> <strong>docs.count</strong> <strong>docs.deleted</strong> <strong>store.size</strong> <strong>pri.store.size</strong><br>yellow open   shopping f27eP8FlRRahLL5pwATr-g   1   1          0            0       208b           208b</p><p>每个字段的意义如下：<br><strong>health</strong>：当前<strong>服务器健康状态</strong>： <strong>green (集群完整)</strong>  <strong>yellow(单点正常、集群不完整)</strong>  <strong>red(单点不正常)</strong><br><strong>status</strong>：索引打开、关闭状态<br><strong>index</strong>：索引名<br><strong>uuid</strong>：索引统一编号<br><strong>pri</strong>：主分片数量<br><strong>rep</strong>：副本数量<br><strong>docs.count</strong>：可用文档数量<br><strong>docs.deleted</strong>：文档删除状态（逻辑删除）<br><strong>store.size</strong>：主分片和副分片整体占空间大小<br><strong>pri.store.size</strong>：主分片占空间大小</p><p><strong>查询单个索引</strong>：localhost:9200/shopping</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;shopping&quot;</span>: &#123;<span class="comment">//索引名</span></span><br><span class="line">        <span class="attr">&quot;aliases&quot;</span>: &#123;&#125;,<span class="comment">//别名</span></span><br><span class="line">        <span class="attr">&quot;mappings&quot;</span>: &#123;&#125;,<span class="comment">//映射</span></span><br><span class="line">        <span class="attr">&quot;settings&quot;</span>: &#123;<span class="comment">//设置</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span>: &#123;<span class="comment">//设置-索引</span></span><br><span class="line">                <span class="attr">&quot;creation_date&quot;</span>: <span class="string">&quot;1658732651930&quot;</span>,<span class="comment">//设置-索引-创建时间</span></span><br><span class="line">                <span class="attr">&quot;number_of_shards&quot;</span>: <span class="string">&quot;1&quot;</span>,<span class="comment">//设置-索引-主分片数量</span></span><br><span class="line">                <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="string">&quot;1&quot;</span>,<span class="comment">//设置-索引-副本数量</span></span><br><span class="line">                <span class="attr">&quot;uuid&quot;</span>: <span class="string">&quot;f27eP8FlRRahLL5pwATr-g&quot;</span>,<span class="comment">// 设置-索引-索引编号</span></span><br><span class="line">                <span class="attr">&quot;version&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;created&quot;</span>: <span class="string">&quot;7080099&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;provided_name&quot;</span>: <span class="string">&quot;shopping&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除索引：localhost:9200/shopping</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;acknowledged&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文档创建（Put-amp-Post）"><a href="#文档创建（Put-amp-Post）" class="headerlink" title="文档创建（Put &amp; Post）"></a>文档创建（Put &amp; Post）</h4><p>索引已经创建好了，接下来我们来创建文档，并添加数据。这里的文档可以类比为关系型数据库中的表数据，添加的数据格式为 JSON 格式</p><p>我们向服务器发送 <strong>POST 请求</strong>：<a href="http://localhost:9200/shopping/_doc">http://localhost:9200/shopping/_doc</a></p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220725151951850.png" alt="image-20220725151951850"></p><p>返回结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,<span class="comment">//索引</span></span><br><span class="line">    <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,<span class="comment">//类型-文档</span></span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;_Iw5NIIBG-b_YnjtLKNM&quot;</span>,<span class="comment">// 唯一标识，随机生成</span></span><br><span class="line">    <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,<span class="comment">//版本，每post一次，自增1</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;created&quot;</span>,<span class="comment">//结果，created 表示创建成功</span></span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,<span class="comment">//分片 - 总数</span></span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,<span class="comment">// 分片-成功</span></span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 POST 请求中，没有自定义唯一标识（ <strong>_id</strong> ），默认情况 ES 会自动生成一个，如果要自定义唯一表示，需要在创建时指定：<a href="http://localhost:9200/shopping/_doc/1">http://localhost:9200/shopping/_doc/1</a></p><p>这种情况下，如果 自定义了唯一标识，我们也可以用 PUT 请求代替 POST 请求，如果没有自定义 _id，还使用 PUT 请求的情况下，会返回错误</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Incorrect HTTP method for uri [/shopping/_doc] and method [PUT], allowed: [POST]&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">405</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_version&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询-主键查询-amp-全查询"><a href="#查询-主键查询-amp-全查询" class="headerlink" title="查询 主键查询 &amp; 全查询"></a>查询 主键查询 &amp; 全查询</h4><p><strong>查看文档</strong> 时，<strong>需要指明文档的唯一性标识</strong>，类似于 MySQL 中数据的主键查询</p><p>向 ES 服务器发 GET 请求 ： <a href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1</a> </p><p>返回：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_version&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;price&quot;</span>: <span class="number">3900.00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果请求查询到不存在的 <strong>_id</strong> ： <a href="http://localhost:9200/shopping/_doc/100">http://localhost:9200/shopping/_doc/100</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;found&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查看索引下所有数据</strong>，向 ES 服务器发 GET 请求 <a href="http://localhost:9200/shopping/_search">http://localhost:9200/shopping/_search</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">52</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;-4w3NIIBG-b_YnjtN6P1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;\n    query IntrospectionQuery &#123;\n      __schema &#123;\n        queryType &#123; name &#125;\n        mutationType &#123; name &#125;\n        subscriptionType &#123; name &#125;\n        types &#123;\n          ...FullType\n        &#125;\n        directives &#123;\n          name\n          description\n          locations\n          args &#123;\n            ...InputValue\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n\n    fragment FullType on __Type &#123;\n      kind\n      name\n      description\n      fields(includeDeprecated: true) &#123;\n        name\n        description\n        args &#123;\n          ...InputValue\n        &#125;\n        type &#123;\n          ...TypeRef\n        &#125;\n        isDeprecated\n        deprecationReason\n      &#125;\n      inputFields &#123;\n        ...InputValue\n      &#125;\n      interfaces &#123;\n        ...TypeRef\n      &#125;\n      enumValues(includeDeprecated: true) &#123;\n        name\n        description\n        isDeprecated\n        deprecationReason\n      &#125;\n      possibleTypes &#123;\n        ...TypeRef\n      &#125;\n    &#125;\n\n    fragment InputValue on __InputValue &#123;\n      name\n      description\n      type &#123; ...TypeRef &#125;\n      defaultValue\n    &#125;\n\n    fragment TypeRef on __Type &#123;\n      kind\n      name\n      ofType &#123;\n        kind\n        name\n        ofType &#123;\n          kind\n          name\n          ofType &#123;\n            kind\n            name\n            ofType &#123;\n              kind\n              name\n              ofType &#123;\n                kind\n                name\n                ofType &#123;\n                  kind\n                  name\n                  ofType &#123;\n                    kind\n                    name\n                  &#125;\n                &#125;\n              &#125;\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;_Iw5NIIBG-b_YnjtLKNM&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">3900.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">3900.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全量修改-amp-局部修改-amp-删除"><a href="#全量修改-amp-局部修改-amp-删除" class="headerlink" title="全量修改 &amp; 局部修改 &amp; 删除"></a>全量修改 &amp; 局部修改 &amp; 删除</h4><p> <strong>全量修改</strong></p><p>和新增文档一样，输入相同的 URL 地址请求，如果请求体变化，会将原有的数据内容覆盖</p><p>在 Postman 中，向 ES 服务器发 POST 请求 ： <a href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1</a></p><p>请求体JSON内容为:</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220725153522674.png" alt="image-20220725153522674"></p><p>响应：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_version&quot;</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;updated&quot;</span>,<span class="comment">// updated 表示数据的更新</span></span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部修改</strong><br>修改数据时，也可以只修改某一给条数据的局部信息</p><p>向 ES 服务器发 POST 请求 ： <a href="http://127.0.0.1:9200/shopping/_update/1">http://127.0.0.1:9200/shopping/_update/1</a></p><p>请求体JSON内容为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;title&quot;</span>:<span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line"><span class="attr">&quot;category&quot;</span>:<span class="string">&quot;小米&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Get 查看内容， <a href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_version&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span>: <span class="number">9</span>,</span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;found&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;price&quot;</span>: <span class="number">1999.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>删除一个文档不会立即从磁盘上移除，它只是被标记成已删除（逻辑删除）。</p><p>向 ES 服务器发 DELETE 请求 ： <a href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1</a></p><p>返回结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;_version&quot;</span>: <span class="number">9</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: <span class="string">&quot;deleted&quot;</span>, <span class="comment">// 删除成功</span></span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;_seq_no&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;_primary_term&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件查询-amp-分页查询-amp-查询排序"><a href="#条件查询-amp-分页查询-amp-查询排序" class="headerlink" title="条件查询 &amp; 分页查询 &amp; 查询排序"></a>条件查询 &amp; 分页查询 &amp; 查询排序</h4><p><strong>条件查询</strong></p><ol><li><strong>URL 带参查询</strong>：查询 shopping 索引下的 category=小米  <a href="http://127.0.0.1:9200/shopping/_search?q=category:%E5%B0%8F%E7%B1%B3">http://127.0.0.1:9200/shopping/_search?q=category:小米</a></li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">51</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="number">1.9616582</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;_Iw5NIIBG-b_YnjtLKNM&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.9616582</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">3900.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>JSON 请求体查询，还是 GET 请求  <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E5%B8%A6%E6%9C%89%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E7%9A%84%E8%AF%B7%E6%B1%82%E4%BD%93">http://127.0.0.1:9200/shopping/_search，带有查询参数的请求体</a></li></ol><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220725155936851.png" alt="image-20220725155936851"></p><p>因此，查找所有文档内容，也可以这样，在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;match_all&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询指定字段：</strong></p><p>如果 <strong>只想查询指定字段</strong>，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;match_all&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;_source&quot;</span>:[<span class="string">&quot;title&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分页查询：</strong></p><p>向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;match_all&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="attr">&quot;from&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询排序：</strong></p><p>附带如下 JSON</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;match_all&quot;</span>:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;sort&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;price&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;order&quot;</span>:<span class="string">&quot;desc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多条件查询-amp-范围查询"><a href="#多条件查询-amp-范围查询" class="headerlink" title="多条件查询 &amp; 范围查询"></a>多条件查询 &amp; 范围查询</h4><p><strong>多条件查询</strong></p><p><strong>查询 种类 = 小米 且 价格 = 3999元</strong></p><p>发起 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><p>ES bool 查询：</p><p><strong>must</strong> ：相当于 and</p><p><strong>must not</strong>： 相当于 not in</p><p><strong>should</strong> ：相当于 or，只要符合其中一个条件就返回</p><p><strong>filter</strong>：条件过滤查询，过滤条件<strong>范围</strong>用<strong>range</strong>表示，gt表示大于、lt表示小于、gte表示大于等于、lte表示小于等于</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;must&quot;</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;match&quot;</span>:&#123;</span><br><span class="line">                        <span class="attr">&quot;category&quot;</span>:<span class="string">&quot;小米&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    <span class="attr">&quot;match&quot;</span>:&#123;</span><br><span class="line">                        <span class="attr">&quot;price&quot;</span>:<span class="number">3900.00</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询 ( 种类 = 小米 or 种类 = 华为 ) and 价格 &gt; 2000</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;bool&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;should&quot;</span>:[&#123;</span><br><span class="line"><span class="attr">&quot;match&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;category&quot;</span>:<span class="string">&quot;小米&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line"><span class="attr">&quot;match&quot;</span>:&#123;</span><br><span class="line"><span class="attr">&quot;category&quot;</span>:<span class="string">&quot;华为&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;],</span><br><span class="line">            <span class="attr">&quot;filter&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;range&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;price&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;gt&quot;</span>:<span class="number">2000</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="模糊查询-amp-完全匹配"><a href="#模糊查询-amp-完全匹配" class="headerlink" title="模糊查询 &amp; 完全匹配"></a>模糊查询 &amp; 完全匹配</h4><p><strong>全文检索</strong>：类似搜索引擎的功能</p><p><strong>match 查询</strong>，会先对搜索词进行<strong>分词</strong>，然后查出相关的内容，比如 “小oppo”，根据已经有的doc它会去查询出 “小米” 与 “oppo”</p><p>如下JSON体，将查询出 种类为 小米 和 oppo 的</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;category&quot;</span>:<span class="string">&quot;小oppo&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="number">1.1727304</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.1727304</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;oppo手机&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;oppo&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">2999.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;_Iw5NIIBG-b_YnjtLKNM&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">0.9066489</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">3900.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>match_phrase 查询：</strong>要完全匹配，match_phrase与slop一起用，能保证分词间的邻近关系，slop参数表示match_phrase查询词条能够<strong>相隔多远</strong>时仍然将文档视为匹配，默认是0。为0时 必须相邻才能被检索出来。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;match_phrase&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;category&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;query&quot;</span>:<span class="string">&quot;小米&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;slop&quot;</span>:<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="number">1.3862942</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;_Iw5NIIBG-b_YnjtLKNM&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.3862942</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">3900.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">0.7092669</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机8&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小大米&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">2999.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><p>聚合允许使用者对 es 文档进行统计分析，类似与关系型数据库中的 group by，当然还有很多其他的聚合，例如取最大值max、平均值avg等等。</p><p><strong>要对所有手机价格求平均值</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;price_avg&quot;</span>:&#123; <span class="comment">// 名称，随意取</span></span><br><span class="line">            <span class="attr">&quot;avg&quot;</span>:&#123; <span class="comment">// 求平均</span></span><br><span class="line">                <span class="attr">&quot;field&quot;</span>:<span class="string">&quot;price&quot;</span> <span class="comment">// 属性 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询结果</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">28</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;_Iw5NIIBG-b_YnjtLKNM&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">3900.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;华为手机&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;华为&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">1999.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;oppo手机&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;oppo&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">2999.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;shopping&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机8&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;小大米&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;images&quot;</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;price&quot;</span>: <span class="number">2999.00</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;price_avg&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">2974.25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面把查到的原始数据也带上了，如果只想要平均值，可以加个 <code>size=0</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;price_avg&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;avg&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span>:<span class="string">&quot;price&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询结果</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;aggregations&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;price_avg&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">2974.25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><p>映射 mapping，创建数据库表需要设置字段名称，类型，长度，约束等；索引库也一样，需要知道这个类型下有哪些字段，每个字段有哪些约束信息，这就叫做映射(mapping)。</p><p>创建一个索引： put <a href="http://127.0.0.1:9200/user">http://127.0.0.1:9200/user</a></p><p>创建映射：PUT <a href="http://127.0.0.1:9200/user/_mapping">http://127.0.0.1:9200/user/_mapping</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;字段名称&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;字段类型&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;store&quot;</span>:<span class="string">&quot;是否存储&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;索引方式、是否分析，指定index=false，体现为该字段是否可被查询，默认为true，表示可以。&quot;</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用如下 JSON 体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;sex&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;tel&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询映射 GET <a href="http://127.0.0.1:9200/user/_mapping">http://127.0.0.1:9200/user/_mapping</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;sex&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;tel&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加数据  PUT <a href="http://127.0.0.1:9200/user/_create/1001">http://127.0.0.1:9200/user/_create/1001</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>:<span class="string">&quot;小米&quot;</span>,</span><br><span class="line"><span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;男的&quot;</span>,</span><br><span class="line"><span class="attr">&quot;tel&quot;</span>:<span class="string">&quot;1111&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询</strong></p><ol><li>因为我们的 “tel” field 在创建映射的时候设置的 index=false，所以是不可查询的，当我们查询的时候就会报错</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;tel&quot;</span>:<span class="string">&quot;11&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;query_shard_exception&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;failed to create query: Cannot search on field [tel] since it is not indexed.&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;MTvdDbhzQbmF_9Y21_aQOQ&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;user&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;search_phase_execution_exception&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;all shards failed&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;phase&quot;</span>: <span class="string">&quot;query&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;grouped&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;failed_shards&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;shard&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;node&quot;</span>: <span class="string">&quot;XZ6IS9mES2G6zU-jIe8wPQ&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;reason&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;query_shard_exception&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;failed to create query: Cannot search on field [tel] since it is not indexed.&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;index_uuid&quot;</span>: <span class="string">&quot;MTvdDbhzQbmF_9Y21_aQOQ&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;caused_by&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;illegal_argument_exception&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;Cannot search on field [tel] since it is not indexed.&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当我们的 properties 中 type 设置为keyword的时候，做查询 只能全部匹配才能查询得到。像 “sex” = “男的” 才能查到数据，如果是 “sex”=”男”，是查不到数据的</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;男&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查不到数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keyword 要完全匹配 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;男的&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询到数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;took&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;skipped&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;total&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;max_score&quot;</span>: <span class="number">0.2876821</span>,</span><br><span class="line">        <span class="attr">&quot;hits&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;1001&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;_score&quot;</span>: <span class="number">0.2876821</span>,</span><br><span class="line">                <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;sex&quot;</span>: <span class="string">&quot;男的&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;tel&quot;</span>: <span class="string">&quot;1111&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ES-API"><a href="#ES-API" class="headerlink" title="ES API"></a>ES API</h2><h2 id="ES-进阶"><a href="#ES-进阶" class="headerlink" title="ES 进阶"></a>ES 进阶</h2><h3 id="Lucnne"><a href="#Lucnne" class="headerlink" title="Lucnne"></a>Lucnne</h3><p>非结构化数据的处理依赖全文搜索，而目前市场上开放源代码的最好全文检索引擎工具包就属于 Apache 的 Lucene了。</p><p>Lucene 只是一个工具包，它不是一个完整的全文检索引擎。Lucene 的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎</p><p>Solr 和 Elasticsearch 都是比较成熟的全文搜索引擎，能完成的功能和性能也基本一样。</p><p>但是 ES 本身就具有分布式的特性和易安装使用的特点，而 Solr 的分布式需要借助第三方来实现，例如通过使用 ZooKeeper 来达到分布式协调管理。</p><p>不管是 Solr 还是 Elasticsearch 底层都是依赖于 Lucene，而 Lucene 能实现全文搜索主要是因为它实现了倒排索引的查询结构。</p><h3 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>假如现有三份数据文档，文档的内容如下分别是：</p><ul><li>Java is the best programming language.</li><li>PHP is the best programming language.</li><li>Javascript is the best programming language.</li></ul><p>为了创建倒排索引，我们通过<strong>分词器</strong>将每个文档的内容域拆分成单独的词（我们称它为<strong>词条</strong>或 <strong>Term</strong>），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220726134914548.png" alt="image-20220726134914548"></p><p>这种结构由文档中所有不重复词的列表构成，对于其中每个词都有一个文档列表与之关联。</p><p>这种由<strong>属性值</strong>来<strong>确定记录的位置</strong>的结构就是<strong>倒排索引</strong>。带有倒排索引的文件我们称为倒排文件。</p><p>我们将上面的内容转换为图的形式来说明倒排索引的结构信息，如下图所示：</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/640.png" alt="image-20220726135053669"></p><ul><li><strong>词条（Term）</strong>：就是分词之后的词，索引里面最小的存储和查询单元，对于英文来说是一个单词，对于中文来说一般指分词后的一个词。</li><li><strong>词典（Term Dictionary）：</strong> 或字典，是词条 Term 的集合。<strong>搜索引擎的通常索引单位是单词</strong>，<strong>单词词典</strong>是由文档集合中出现过的所有<strong>单词</strong>构成的字符串<strong>集合</strong>，单词词典内每条<strong>索引项记载单词本身的一些信息</strong>以及<strong>指向“倒排列表”的指针</strong>。</li><li><strong>倒排表（Post list）：</strong> 一个文档通常由多个词组成，倒排表<strong>记录</strong>的是<strong>某个词在哪些文档里出现过</strong>以及<strong>出现的位置</strong>。<strong>每条记录</strong>称为<strong>一个倒排项</strong>（Posting）。<strong>倒排表记录</strong>的不单是<strong>文档编号</strong>，还<strong>存储了词频</strong>等信息。</li><li><strong>倒排文件（Inverted File）：</strong> <strong>所有单词的倒排列表</strong>往往顺序地存储在磁盘的某个文件里，这个文件被称之为<strong>倒排文件</strong>，倒排文件是<strong>存储倒排索引</strong>的<strong>物理文件</strong>。</li></ul><p>倒排索引主要由两个部分组成：</p><ul><li>词典</li><li>倒排文件</li></ul><h3 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引 Index"></a>索引 Index</h3><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220725175020638.png" alt="image-20220725175020638"></p><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除（CRUD）的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</p><p>能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。</p><h3 id="类型-Type"><a href="#类型-Type" class="headerlink" title="类型 Type"></a>类型 Type</h3><p>在一个索引中，你可以定义一种或多种类型。</p><p>一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由自己决定。通常，会为具<br>有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化。参考上图，Type 对应 Row，在 ES 中采用倒排索引，MySQL 一行是一个数据，所以 Row 就可以理解为一行就是相当于MySQL的索引</p><p>在 5.x 之前版本 支持多个 type，在6.x 只能有一种，在7.x 不支持自定义 type，默认类型为 _doc</p><h3 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档 Document"></a>文档 Document</h3><p>一个文档，就是一个可以被索引的基础信息单元，也就是一条数据</p><h3 id="字段Field"><a href="#字段Field" class="headerlink" title="字段Field"></a>字段Field</h3><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。</p><h3 id="映射Mapping"><a href="#映射Mapping" class="headerlink" title="映射Mapping"></a>映射Mapping</h3><p><strong>mapping 映射</strong> 是处理数据的方式和<strong>规则</strong>方面做一些<strong>限制</strong>，如：某个字段的<strong>数据类型</strong>、<strong>默认值</strong>、分析器、<strong>是否被索引</strong>等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p><h3 id="分片-Shards"><a href="#分片-Shards" class="headerlink" title="分片 Shards"></a>分片 Shards</h3><p>一个<strong>索引</strong>可以<strong>存储超出单个节点硬件限制</strong>的大量<strong>数据</strong>。比如，一个具有 10 亿文档数据的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。 或者单个节点处理搜索请求，响应太慢。为了解决这个问题，<strong>Elasticsearch 提供了将索引划分成多份的能力，每一份就称之为分片。</strong>当你创建一个索引的时候，你可以<strong>指定</strong>你想要的<strong>分片的数量</strong>。<strong>每个分片</strong>本身也是一个<strong>功能完善并且独立的“索引”</strong>，这个“索引”可以被放置<strong>到集群</strong>中的<strong>任何节点</strong>上。</p><p>一个 <strong>Lucene 索引</strong> 我们在 Elasticsearch 称作 <strong>分片</strong> 。 <strong>一个 Elasticsearch 索引 是分片的集合</strong>。 当 Elasticsearch 在索引中搜索的时候， <strong>发送查询</strong>到<strong>每一个</strong>属于<strong>索引的分片</strong>（Lucene 索引），然后<strong>合并每个分片的结果</strong>到一个<strong>全局的结果集</strong>。</p><p>类似于 MySQL 的分库分表，只不过 MySQL 分库分表需要借助第三方组件而 ES 内部自身实现了此功能。</p><p>一个多分片的索引中写入数据的时候，要通过路由来确定具体写入到哪一个分片中，因此在创建索引的时候需要指定分片的数量，并且分片的数量一旦确定就不能修改</p><p>分片的数量和下面的副本数量都是可以通过创建索引时的 Settings 来配置，ES 默认为一个索引创建5个<strong>主分片</strong>，并且<strong>为每个分片都创建一个副本</strong>。</p><p>ES 通过分片的功能使得索引在规模上和性能上都得到提升，每个分片都是 Lucene 中的一个索引文件，每个分片必须有一个主分片和零到多个副本。</p><p>下图给这个索引 3个主分片，每个主分片 1个副本</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220726141940019.png" alt="image-20220726141940019"></p><h3 id="副本-Replicas"><a href="#副本-Replicas" class="headerlink" title="副本 Replicas"></a>副本 Replicas</h3><p>每个索引可以被分为多个分片。此外，每个索引可以被复制多次。一旦复制了，每个索引就有了主分片和复制分片。分片，片上是不同的数据，副本是每个分片的副本。</p><p>ES 禁止同一个分片的主分片和副本分片在同一个节点上，所以如果是一个节点的集群是不能有副本的，并且副本分片数的最大值是 N-1（其中 N 为节点数）。</p><p>对<strong>文档的新建、索引和删除请求都是写操作</strong>，必须在<strong>主分片上面完成</strong>之后才能被<strong>复制</strong>到相关的<strong>副本分片</strong>。</p><p><strong>ES</strong> 为了提高写入的能力这个过程是<strong>并发写</strong>的，同时为了<strong>解决并发写的过程中数据冲突的问题</strong>，ES 通过<strong>乐观锁的方式控制</strong>，每个文档都有一个**<code> _version</code>** （版本）号，当<strong>文档被修改时版本号递增</strong>。</p><p>一旦所有的副本分片都报告写成功才会向协调节点（就是 客户端访问到的那个节点）报告成功，协调节点向客户端报告成功。</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220726152625525.png" alt="image-20220726152625525"></p><p>假设这时节点 Node1 服务宕机了或者网络不可用了，那么主节点上主分片 S0 也就不可用了。</p><p>幸运的是还存在另外两个节点能正常工作，这时 ES 会重新选举新的主节点，而且这两个节点上存在我们所需要的 S0 的所有数据。</p><p>我们会将 S0 的副本分片提升为主分片，这个提升主分片的过程是瞬间发生的。此时集群的状态将会为  Yellow。</p><p>为什么我们<strong>集群状态是 Yellow</strong> 而不是 Green 呢？虽然我们拥有所有的 2 个主分片，但是同时设置了每个主分片需要对应两份副本分片，而<strong>此时只存在一份副本分片</strong>。所以集群不能为 Green 的状态。</p><p>如果我们重新启动 Node1 ，集群可以将缺失的副本分片再次进行分配，那么集群的状态又将恢复到原来的正常状态。</p><p>如果 Node1 依然拥有着之前的分片，它将尝试去重用它们，只不过这时 Node1 节点上的分片不再是主分片而是副本分片了，如果期间有更改的数据只需要从主分片上复制修改的数据文件即可。</p><p><strong>集群健康状态</strong>： <strong>green (集群完整)</strong>  <strong>yellow(单点正常、集群不完整)</strong>  <strong>red(单点不正常)</strong></p><p><strong>小结：</strong></p><ul><li>将<strong>数据分片</strong>是为了<strong>提高可处理数据的容量和易于进行水平扩展</strong>，为<strong>分片做副本</strong>是为了<strong>提高集群的稳定性</strong>和提高<strong>并发量</strong>。</li><li><strong>副本</strong>是乘法，<strong>越多消耗越大</strong>，但也越保险。分片是除法，<strong>分片越多</strong>，<strong>单分片数据</strong>就<strong>越少</strong>也越分散。</li><li><strong>副本越多</strong>，集群的<strong>可用性就越高</strong>，但是由于每个分片都相当于一个 Lucene 的索引文件，会<strong>占用一定的文件句柄、内存及 CPU</strong>。并且<strong>分片间的数据同步也会占用一定的网络带宽</strong>，所以索引的分片数和副本数也不是越多越好。</li></ul><h3 id="集群健康状态"><a href="#集群健康状态" class="headerlink" title="集群健康状态"></a>集群健康状态</h3><ul><li>绿色：集群健康完好，一切功能齐全正常，所有分片和副本都可以正常工作。</li><li>黄色：预警状态，所有主分片功能正常，但<strong>至少有一个副本是不能正常工作的</strong>。此时集群是可以正常工作的，但是高可用性在某种程度上会受影响。</li><li>红色：<strong>集群不可正常使用</strong>。某个或某些分片及其副本异常不可用，这时集群的查询操作还能执行，但是返回的结果会不准确。对于分配到这个分片的写入请求将会报错，最终会导致数据的丢失。</li></ul><h3 id="分配-Allocation"><a href="#分配-Allocation" class="headerlink" title="分配 Allocation"></a><strong>分配 Allocation</strong></h3><p>将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含<strong>主从分片复制数据</strong>的过程。这个过程是由 master 节点完成的。</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220725184817229.png" alt="image-20220725184817229"></p><p>一个运行中的 Elasticsearch 实例称为一个节点，而集群是由一个或者多个拥有相同<br>cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p><p>当一个节点被选举成为主节点时， 它将负责管理集群范围内的所有变更，例如增加、删除<strong>索引</strong>，或者增加、删除节点等。 而<strong>主节点并不需要涉及</strong>到<strong>文档级别</strong>的<strong>变更和搜索等操作</strong>，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。</p><p>作为用户，我们可以将请求发送到集群中的任何节点 ，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>ES 集群不需要依赖第三方协调管理组件比如Zzookeeper，自身就实现了集群的管理功能</p><p>ES集群有一个或者多个 Elasticsearch 节点组成，每个节点配置相同的 cluster.name 即可加入集群，默认值为 “elasticsearch”。</p><p>一个 Elasticsearch 服务启动实例就是一个节点(Node)。节点通过 node.name 设置节点名称，如果不设置则在启动时给节点分片一个随机通用唯一标识符作为名称。</p><p>单节点集群：</p><p>我们给 索引 users 分配3个主分片，每个主分片 1 个副本</p><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220726141940019.png" alt="image-20220726141940019"></p><p>这样，集群现在是单节点集群。3个主分片都被分片在一个 node，但是 3个副本 因为是单节点，所以并没有处在正常状态</p><h3 id="发现机制"><a href="#发现机制" class="headerlink" title="发现机制"></a>发现机制</h3><p>ES 内部是如何通过一个相同的设置 cluster.name 就能将不同的节点连接到同一个集群的？答案是 Zen Discovery。</p><p><strong>Zen Discovery</strong> 是 ES 内置的<strong>默认发现模块</strong>，职责是<strong>发现集群中的其他节点</strong>，以及<strong>Master 节点选举</strong>。</p><p>Zen Discovery 提供单播和基于文件的发现，并且可以扩展为通过插件支持云环境和其他形式的发现。</p><p>Zen Discovery 与其他模块集成，例如，节点之间的所有通信都使用 Transport 模块完成。节点使用发现机制通过 Ping 的方式查找其他节点。</p><p><strong>默认配置为 单播模式</strong> 的目的是 <strong>防止节点无意中加入集群</strong>。只有在一台机器上运行的节点才会自动组成集群</p><p>如果集群的节点运行在不同的机器上，<strong>使用单播</strong>，你可以<strong>为 Elasticsearch</strong> 提供一些它应该去尝试连接的<strong>节点列表</strong>。当 一个节点<strong>联系到单播列表中的成员</strong>，它就会获得整个集群的状态，然后联系 Master，加入集群。</p><p>这也意味着，单播列表不需要保存集群的所有节点，只需要一部分，一个新节点联系上列表中的某个节点并且说上话就可以了</p><p>如果你使用 Master 候选节点作为单播列表，你只要列出三个就可以了。这个配置在 elasticsearch.yml 文件中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">discovery.zen.ping.unicast.hosts: [&quot;host1&quot;, &quot;host2:port&quot;]  </span><br></pre></td></tr></table></figure><p><strong>节点启动后先 Ping</strong> ，如果 <strong><code>discovery.zen.ping.unicast.hosts</code> 有设置，则 Ping 设置中的 Host(单播列表)</strong> ，否则尝试 ping localhost 的几个端口。</p><p><strong>Elasticsearch</strong> <strong>支持同一个主机启动多个节点</strong>，Ping 的 Response 会包含该节点的基本信息以及该节点认为的 Master 节点。</p><h3 id="节点角色"><a href="#节点角色" class="headerlink" title="节点角色"></a>节点角色</h3><p>每个节点既可以是候选主节点也可以是数据节点，通过在配置文件 ../config/elasticsearch.yml 中设置即可，默认都为 true。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">node.master</span>: <span class="string">true  //是否候选主节点  </span></span><br><span class="line"><span class="meta">node.data</span>: <span class="string">true    //是否数据节点  </span></span><br></pre></td></tr></table></figure><p><strong>数据节点</strong>负责<strong>数据的存储和相关的操作</strong>，例如对数据进行增、删、改、查和聚合等操作，所以数据节点（Data 节点）对机器配置要求比较高，对 CPU、内存和 I/O 的消耗很大。</p><p>通常随着集群的扩大，需要增加更多的数据节点来提高性能和可用性。</p><p><strong>候选主节点</strong>可以被<strong>选举为主节点（Master 节点）</strong>，集群中<strong>只有候选主节点</strong>才有<strong>选举权和被选举权</strong>，其他节点不参与选举的工作。</p><p><strong>主节点</strong>负责<strong>创建索引、删除索引</strong>、跟踪哪些节点是<strong>集群</strong>的一部分，并决定哪些<strong>分片分配</strong>给相关的节点、追踪集群中节点的状态等，稳定的主节点对集群的健康是非常重要的。</p><p>一个节点<strong>既可以是候选主节点也可以是数据节点</strong>，但是由于数据节点对 CPU、内存核 I/O 消耗都很大。所以如果某个节点既是数据节点又是主节点，那么可能会对主节点产生影响从而对整个集群的状态产生影响。因此<strong>为了提高集群的健康性</strong>，我们应该<strong>对 Elasticsearch 集群中的节点做好角色上的划分和隔离</strong>。可以使用几个<strong>配置较低的机器群</strong>作为<strong>候选主节点群</strong>。</p><p>主节点和其他节点之间通过 Ping 的方式互检查，<strong>主节点负责 Ping 所有其他节点</strong>，判断是否有节点已经挂掉。<strong>其他节点也通过 Ping 的方式判断主节点是否处于可用状态</strong>。</p><p>虽然对节点做了角色区分，但是<strong>用户的请求可以发往任何一个节点</strong>，并<strong>由该节点负责分发请求</strong>、<strong>收集结果</strong>等操作，而不需要主节点转发。这种节点可称之为<strong>协调节点</strong>，协调节点是不需要指定和配置的，集群中的任何节点都可以充当协调节点的角色。</p><h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><ul><li>ES 的Master 选举是ZenDiscovery 模块负责的，主要包含 Ping （通过 Ping 这个 RPC 发现彼此，查找其他节点）和 Unicast （单播模块，包含一个单播列表，联系上列表中某个节点，就可以获取整个集群的状态）两部分</li><li>对所有可以选取成功 Master （<strong>候选Master</strong>） 的节点 (<strong>node.master:true</strong>) 根据节点<strong>的 nodeId 的字典排序</strong>，选取第一个节点</li><li>但是有一个限制条件，才会开始选举，在配置文件中 elasticsearch.yml 设置的值 **<code>discovery.zen.minimum_master_nodes</code>**，确保候选主节点数达标，如果节点数达不到最小值的限制，会一直等到节点数足够才开始选举</li><li><strong><code>discovery.zen.minimum_master_nodes</code></strong> 也是解决 <strong>脑裂问题</strong> 的配置</li></ul><p>由于它支持任意数目的集群（ 1- N ），所以不能像 Zookeeper 那样限制节点必须是奇数，也就无法用投票的机制来选主，而是通过一个规则。</p><p>只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致的。</p><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>如果由于网络或其他原因导致集群中选举出多个 Master 节点，使得数据更新时出现不一致，这种现象称之为脑裂，即集群中不同的节点对于 Master 的选择出现了分歧，出现了多个 Master 竞争。</p><p>“脑裂”问题可能有以下几个原因造成：</p><ul><li><strong>网络问题：</strong> 集群间的网络延迟导致<strong>一些节点访问不到 Master</strong>，认为 Master 挂掉了从而<strong>选举出新</strong>的 Master，并对 Master 上的分片和副本标红，分配新的主分片。</li><li><strong>节点负载：</strong> <strong>主节点的角色既为 Master 又为 Data</strong>，<strong>访问量较大</strong>时可能会导致 <strong>ES 停止响应</strong>（假死状态）造成大面积延迟，此时<strong>其他节点得不到主节点的响应</strong>认为主节点挂掉了，会重新选取主节点。</li><li><strong>内存回收：</strong> <strong>主节点的角色既为 Master 又为 Data</strong>，<strong>当 Data 节点上的 ES 进程占用的内存较大</strong>，引发 <strong>JVM 的大规模内存回收</strong>，造成 <strong>ES 进程失去响应</strong>。</li></ul><p>为了避免脑裂现象的发生，我们可以从原因着手通过以下几个方面来做出优化措施：</p><ol><li><p><strong>适当调大响应时间，减少误判。</strong> 通过参数 discovery.zen.ping_timeout <strong>设置节点状态的响应时间</strong>，<strong>默认</strong>为 <strong>3s</strong>，可以适当调大。如果 Master 在这个时间内没有应答就认为 master 挂掉了，时间调大，可以一定程度上减少因为网络延迟等误判</p></li><li><p><strong>选举触发。</strong> 我们需要在候选集群中的节点的配置文件中设置参数 <code>discovery.zen.munimum_master_nodes</code> 的值。这个参数表示在<strong>选举主节点时</strong>需要<strong>参与选举的候选主节点的节点数</strong>，默认值是 1。也就是说，如果大于这个值，才会开始选举流程。这样做既能防止脑裂现象的发生，也能最大限度地提升集群的高可用性，因为只要不少于 <code>discovery.zen.munimum_master_nodes</code> 个候选节点存活，选举工作就能正常进行。当小于这个值的时候，无法触发选举行为，集群无法使用，不会造成分片混乱的情况。</p><p>官方建议取值**(<code>master_eligibel_nodes2)+1</code><strong>，其中 <strong><code>master_eligibel_nodes</code></strong> 为</strong>候选主节点的个数**。</p></li><li><p><strong>角色分离</strong>：候选主节点和数据节点进行角色分离，这样可以减轻主节点的负担，防止主节点的假死状态发生，减少对主节点“已死”的误判。</p></li></ol><h2 id="ES-原理"><a href="#ES-原理" class="headerlink" title="ES 原理"></a>ES 原理</h2><h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>下面介绍了在 ES 内部索引的写处理流程，这个流程是在 ES 的内存中执行的，数据被分配到特定的分片和副本上之后，最终是存储到磁盘上的，这样在断电的时候就不会丢失数据。</p><p>具体的存储路径可在配置文件 <code>../config/elasticsearch.yml </code>中进行设置，默认存储在安装目录的 Data 文件夹下。</p><p>建议不要使用默认值，因为若 ES 进行了升级，则有可能导致数据全部丢失：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">path.data</span>: <span class="string">/path/to/data  //索引数据  </span></span><br><span class="line"><span class="meta">path.logs</span>: <span class="string">/path/to/logs  //日志记录  </span></span><br></pre></td></tr></table></figure><h4 id="分段存储"><a href="#分段存储" class="headerlink" title="分段存储"></a>分段存储</h4><p>索引文档以段的形式存储在磁盘上，何为段？索引文档被拆分为多个子文件，则每个子文件叫作段，每一个段本身都是一个倒排索引，并且<strong>段具有不变性</strong>，<strong>一旦索引的数据被写入硬盘，就不可再修改</strong>。</p><p>段在被写入磁盘后会生成一个<strong>提交点</strong>，<strong>提交点</strong>是一个用来<strong>记录所有提交后段信息</strong>的文件。一旦<strong>提交点生成</strong>，就说明这个段<strong>只有读的权限</strong>，<strong>写的权限丢失</strong>。相反，当段在内存中的时候，就只有写的权限，而不具备读的权限，意味着不能被检索。</p><p>索引文件<strong>分段</strong>存储并且<strong>不可修改</strong>，那么新增、删除、更新的如何处理的：</p><ul><li>新增：新增文档，那就新增一个段</li><li>删除：段具有不变性，不可再修改。所以也只是逻辑上的删除。如果要删除当前文档，不会把这个文档从当前段中移除，而是新增一个 .del 文件，.del 文件中标记被删除文档的段信息，在查询文档的时候，返回结果之前根据 .del 文件 从结果集中排除，然后再返回结果</li><li>更新：更新也不能对段更新。更新就相当于新增和删除，我们先把旧的文档在 .del 中标记删除，然后把要更新的文档内容写到新增一个段</li></ul><p><strong>分段存储不可变性</strong>的<strong>优点</strong>：</p><ul><li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题</li><li>一旦索引被读入内核的文件系统缓存，便会留在那里，因为其不变性。只有文件系统缓存中还有足够的空间，大部分请求都可以直接请求内存，而不会命中磁盘。这提供了很大的性能提升</li><li>其它缓存(像 <strong>Filter 缓存</strong>)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li><li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和需要被缓存到内存的索引的使用量。</li></ul><p>段的不可变性，导致它的缺点也很明显：</p><ul><li>对旧数据进行删除不会立即删除，而是在 .del 文件中标记。那么<strong>旧数据会一直存在</strong>，只能等到<strong>段更新</strong>时才会<strong>被删除</strong>，这样会造成<strong>大量资源浪费</strong></li><li>如果某条数据<strong>频繁更新</strong>，那么就频繁<strong>新增</strong>段内容，<strong>标记到 .del</strong> 旧文档内容段信息，<strong>空间浪费</strong></li><li>每次新增数据时都需要新增一个段来存储数据。当段的量太多时，对服务器的资源例如文件句柄的消耗会非常大</li><li>在查询的结果中包含所有的结果集，需要<strong>排除被标记删除的旧数据</strong>，这<strong>增加了查询的负担</strong></li></ul><h4 id="延迟写策略"><a href="#延迟写策略" class="headerlink" title="延迟写策略"></a><strong>延迟写策略</strong></h4><h3 id="写索引原理"><a href="#写索引原理" class="headerlink" title="写索引原理"></a>写索引原理</h3><p>下图描述了 3 个节点的集群，共拥有 12 个分片，其中有 4 个主分片（S0、S1、S2、S3）和 8 个副本分片（R0、R1、R2、R3），每个主分片对应两个副本分片，节点 1 是主节点（Master 节点）负责整个集群的状态。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4hVH3IUycaXbZib5Koq8WmfkWlicAKhpDrg6zPH4k9Ozy6jRovxHNt4lMTnO6wCTujV93SSb5YdqAOg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="image-20220726171046484"></p><p>写索引是只能写在主分片上，然后同步到副本分片。这里有四个主分片，一条数据 ES 是根据特定的路由规则来写到特定的分片上。由以下公式决定：</p><p><strong><code>shard = hash(routing) % number_of_primary_shards </code></strong></p><p><strong>routing</strong> 是一个可变值，默认是文档的<code> _id</code> ，也可以设置成一个自定义的值。</p><p><strong>number_of_primary_shards</strong>  主分片的数量</p><p><strong>把 routing 进行 hash 运算之后 对 主分片数量进行求余 = 写入主分片的位置</strong></p><p>这里的路由跟 主分片的数量 有关，所以 我们在创建索引的时候 就确定好主分片的数量，并且 不能再改变这个值了，因为 这个值一旦改变了，那么之前的路由就无效了，找不到了</p><p><strong>流程：</strong></p><ol><li><p>在一个写请求被发送到某个节点后，该节点即为前面说过的协调节点，协调节点会根据路由公式计算出需要写到哪个分片上，再将请求转发到该分片的主分片节点上。</p></li><li><p>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 Memory Buffer 到 Filesystem Cache 的过程就叫做 refresh；</p></li><li><p>当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失， ES 是通过 translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystemcache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；</p></li><li><p>在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</p></li><li><p>flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</p></li></ol><p><img src="/../../img/markdown_img/ElasticSearch.assets/image-20220726171636435.png" alt="image-20220726171636435"></p><p>假如此时数据通过路由计算公式取余后得到的值是 <code>shard=hash(routing)%4=0</code>。</p><p>则具体流程如下：</p><ul><li>客户端向 ES1 节点（协调节点）发送写请求，通过路由计算公式得到值为 0，则当前数据应被写到主分片 S0 上。</li><li>ES1 节点将请求转发到 S0 主分片所在的节点 ES3，ES3 接受请求并写入到磁盘。</li><li>并发将数据复制到两个副本分片 R0 上，其中通过乐观并发控制数据的冲突。一旦所有的副本分片都报告成功，则节点 ES3 将向协调节点报告成功，协调节点向客户端报告成功。</li></ul>]]></content>
    
    
    <summary type="html">Elasticsearch，Elasticsearch基本操作，倒排索引，分片，副本，集群，选举，写索引流程</summary>
    
    
    
    <category term="Elasticsearch" scheme="http://ins1mn1a.github.io/categories/Elasticsearch/"/>
    
    
    <category term="Elasticsearch" scheme="http://ins1mn1a.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://ins1mn1a.github.io/2022/07/27/Kafka/Kafka/"/>
    <id>http://ins1mn1a.github.io/2022/07/27/Kafka/Kafka/</id>
    <published>2022-07-27T14:46:17.266Z</published>
    <updated>2022-07-27T14:55:47.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka介绍"><a href="#Kafka介绍" class="headerlink" title="Kafka介绍"></a>Kafka介绍</h2><p>Kafka是最初由Linkedin公司开发，是一个<strong>分布式</strong>、<strong>支持分区</strong>的（<strong>partition</strong>）、<strong>多副本</strong>的 （<strong>replica</strong>），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理 大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、 Storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于 2010 年贡献给了Apache基金会并成为顶级开源项目。</p><h3 id="Kafka使用场景"><a href="#Kafka使用场景" class="headerlink" title="Kafka使用场景"></a>Kafka使用场景</h3><p><strong>日志收集：</strong>可以用kafka收集各种服务的日志，通过Kafka以统一接口服务的方式 开放给各种consumer，比如 Hadoop，Hbase，Solr等。</p><p><strong>消息系统</strong>：Kafka可以同消息队列一样，用于解耦，不用关系消息怎么消费，只需要放到队列里去就可以了。</p><p><strong>用户活动跟踪（埋点）</strong>：当用户在浏览网页的同时，可以记录用户的行为，比如浏览网页，点赞，搜索等行为，这些信息可以发布到Kafka的各个Topic中，然后订阅者 订阅topic去做对应监控分析，或者到Hadoop等。</p><h3 id="Kafka基本概念"><a href="#Kafka基本概念" class="headerlink" title="Kafka基本概念"></a>Kafka基本概念</h3><p><strong>Broker：</strong>一个Broker也就是一个Kafka，多个Broker可以构建成Kafka集群</p><p><strong>Producer：</strong>消息生产者，向Broker发送消息的客户端</p><p><strong>Consumer：</strong>消息消费者，从Broker读取数据的客户端</p><p><strong>Topic：</strong>topic是消息的分类，可以有多个topic，Producer发送的每条消息都必须要有一个topic，可以理解为队列</p><p><strong>ConsumerGroup：</strong>消费者组，每一个Consumer属于一个ConsumerGroup，<strong>一条消息可以被不同的ConsumerGroup消费，但是一个ConsumerGroup中只能有一个Consumer消费该消息</strong></p><p><strong>Partition</strong>：分区，每个topic可以分为多个partition</p><p><strong>Leader：</strong>每个分区都会有 1 个leader，leader负责处理读写操作</p><p><strong>Follower：</strong>每个分区除了 1 个leader外，还有多个 follower 副本，follower只用于leader发生故障，follower会被重新选举为leader</p><h3 id="Kafka架构图"><a href="#Kafka架构图" class="headerlink" title="Kafka架构图"></a>Kafka架构图</h3><p>下面是Kafka架构图</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220705110316426.png" alt="image-20220705110316426"></p><h2 id="Kafka基本使用"><a href="#Kafka基本使用" class="headerlink" title="Kafka基本使用"></a>Kafka基本使用</h2><p>在安装Kafka之前，需要安装JDK，Zookeeper，Kafka在2.8版本以后就可以不使用Zookeeper了</p><h3 id="Kafka搭建"><a href="#Kafka搭建" class="headerlink" title="Kafka搭建"></a>Kafka搭建</h3><p>已安装好ZK3.7.0，在阿里云的镜像上下载Kafka2.13_3.2.0，2.13代表Scala的版本2.13,3.2.0是kafka的版本</p><p>Kafka安装到/usr/local/kafka的目录下，然后修改kafka的配置文件。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#broker.id属性在kafka集群中必须要是唯一</span></span><br><span class="line"><span class="meta">broker.id</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#kafka部署的机器ip和提供服务的端口号</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://192.168.73.138:9092</span></span><br><span class="line"><span class="comment">#kafka的消息存储文件</span></span><br><span class="line"><span class="meta">log.dir</span>=<span class="string">/usr/local/data/kafka-logs</span></span><br><span class="line"><span class="comment">#kafka连接zookeeper的地址</span></span><br><span class="line"><span class="meta">zookeeper.connect</span>= <span class="string">192.168.73.137:2181</span></span><br></pre></td></tr></table></figure><p>先启动Zookeeper，然后启动Kafka</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./kafka-server-start.sh -daemon ../config/server.properties</span><br></pre></td></tr></table></figure><p>然后连接到Zookeeper客户端  ./zkCli.sh -server 192.168.73.137:2181</p><p>查看 /brokers/ids目录下有不有 broker.id=0 的broker</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220704231503309.png" alt="image-20220704231503309"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>server.properties 配置文件：</p><table><thead><tr><th>Property</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>broker.id</td><td>0</td><td>每个broker都可以⽤⼀个唯⼀的⾮负整数id进⾏标识；</td></tr><tr><td>log.dirs</td><td>/tmp/kafka-logs</td><td>kafka存放数据的路径。这个路径并不是唯⼀的，可以是多个，路径之间只需要使⽤逗号分隔即可；每当创建新partition时，都会选择在包含最少partitions的路径下进行。</td></tr><tr><td>listeners</td><td>PLAINTEXT://192.168.73.137:9092</td><td>server接受客户端连接的端⼝，ip配置kafka本机ip即可</td></tr><tr><td>zookeeper.connect</td><td>localhost:2181</td><td>zooKeeper连接字符串的格式为：hostname:port，此处hostname和port分别是ZooKeeper集群中某个节点的host和port；zookeeper如果是集群，连接⽅式为hostname1:port1, hostname2:port2,hostname3:port3</td></tr><tr><td>log.retention.hours</td><td>168</td><td>每个⽇志⽂件删除之前保存的时间。默认数据保存时间对所有topic都⼀样。</td></tr><tr><td>num.partitions</td><td>1</td><td>创建topic的默认分区数</td></tr><tr><td>default.replication.factor</td><td>1</td><td>⾃动创建topic的默认副本数量，建议设置为⼤于等于2</td></tr><tr><td>min.insync.replicas</td><td>1</td><td>当producer设置acks为-1时，min.insync.replicas指定replicas的最⼩数⽬（必须确认每⼀个repica的写数据都是成功的），如果这个数⽬没有达到，producer发送消息会产⽣异常</td></tr><tr><td>delete.topic.enable</td><td>false</td><td>是否允许删除主题</td></tr></tbody></table><h3 id="创建-topic"><a href="#创建-topic" class="headerlink" title="创建 topic"></a>创建 topic</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在3.2版本使用这个命令会报错 zookeeper is not a recogined option，新版Kafka可以脱离zookeeper了，kafka版本太高了</span></span><br><span class="line">./kafka-topics.sh --create --zookeeper 172.16.253.35:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure><p>创建主题</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单机Kafka可以不用指定分区</span></span><br><span class="line">./kafka-topics.sh --create --bootstrap-server 192.168.73.137:9092 --topic first_test_topic --partition 1 --replication-factor 1</span><br><span class="line"><span class="comment"># 查询所有主题</span></span><br><span class="line">./kafka-topics.sh --bootstrap-server 192.168.73.137:9092 --list</span><br><span class="line"><span class="comment"># 查询Kafka的指定主题</span></span><br><span class="line">./kafka-topics.sh --bootstrap-server 192.168.73.137:9092 --describe first_test_topic</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@192 bin]<span class="comment"># ./kafka-console-producer.sh --bootstrap-server 192.168.73.137:9092 --topic first_test_topic</span></span><br><span class="line">OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, <span class="keyword">then</span> you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N</span><br><span class="line">&gt;hello</span><br></pre></td></tr></table></figure><p><img src="/../../img/markdown_img/kafka.assets/image-20220705114403700.png" alt="image-20220705114403700"></p><h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>这个时候，我们上面生产者已经生产了一条 hello 消息，这个时候我们再去消费</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认是消费最新的消息，是从历史消息中最后一条消息的偏移量+1开始消费的，也就是这个Consumer启动后，接收到的第一条消息</span></span><br><span class="line"><span class="comment"># 因此，上面的 hello 是消费不到的</span></span><br><span class="line">[root@192 bin]<span class="comment"># ./kafka-console-consumer.sh --bootstrap-server 192.168.73.137:9092 --topic first_test_topic</span></span><br><span class="line">OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, <span class="keyword">then</span> you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N</span><br></pre></td></tr></table></figure><p><img src="/../../img/markdown_img/kafka.assets/image-20220705114717746.png" alt="image-20220705114717746"></p><p>这时候，生产者再发送一条消息，消费者这里就可以消费到了</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220705114753416.png" alt="image-20220705114753416"></p><p>还有一种模式，可以直接 <strong>从头开始 消费</strong>，这样，历史的消息记录，也可以消费得到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@192 bin]<span class="comment"># ./kafka-console-consumer.sh --bootstrap-server 192.168.73.137:9092 --topic first_test_topic --from-beginning</span></span><br><span class="line">OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, <span class="keyword">then</span> you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N</span><br><span class="line">hello</span><br><span class="line">kafka</span><br></pre></td></tr></table></figure><p><img src="/../../img/markdown_img/kafka.assets/image-20220705114824630.png" alt="image-20220705114824630"></p><h3 id="单播消息"><a href="#单播消息" class="headerlink" title="单播消息"></a>单播消息</h3><p>单播消息：一个消费组里 只会有一个消费者能消费到某一个topic中的消息。于是可以创建多个消费者，这些消费者在同一个消费组中。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server 192.168.73.137:9092 --consumer-property group.id=testGroup --topic first_test_topic</span><br></pre></td></tr></table></figure><h3 id="多播消息"><a href="#多播消息" class="headerlink" title="多播消息"></a>多播消息</h3><p>在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。kafka实现多播，只需要让不同的消费者处于不同的消费组即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server 192.168.73.137:9092 --consumer-property group.id=testGroup1 --topic first_test_topic</span><br><span class="line"></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server 192.168.73.137:9092 --consumer-property group.id=testGroup2 --topic first_test_topic</span><br></pre></td></tr></table></figure><h3 id="查看消费组"><a href="#查看消费组" class="headerlink" title="查看消费组"></a>查看消费组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前主题下有哪些消费组</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server 192.168.73.137:9092 --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看消费组中的具体信息：比如当前偏移量、最后一条消息的偏移量、堆积的消息数量</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server 192.168.73.137:9092 --describe --group testGroup</span><br></pre></td></tr></table></figure><h2 id="Kafka集群搭建"><a href="#Kafka集群搭建" class="headerlink" title="Kafka集群搭建"></a>Kafka集群搭建</h2><p>这里采用三台虚拟机</p><ol><li><p>先搭建好 Zookeeper 集群</p></li><li><p>进行配置文件目录，修改配置文件<code>server.properties</code></p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每个broker的id是唯一的</span></span><br><span class="line">broker.id=0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定监听的地址和端口号，IP是内网IP</span></span><br><span class="line">listeners=PLAINTEXT://192.168.73.137:9092</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定监听的地址和端口号，IP是外网IP</span></span><br><span class="line"><span class="meta">#</span><span class="bash">advertised.listeners=PLAINTEXT://your.host.name:9092</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定数据日志目录</span></span><br><span class="line">log.dirs=/usr/local/kafka/logs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定zk的连接地址</span></span><br><span class="line">zookeeper.connect=192.168.73.137:2181,192.168.73.136:2181,192.168.73.135:2181</span><br></pre></td></tr></table></figure><ol start="3"><li>启动Kafka集群</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 kafka]# ./bin/kafka-server-start.sh -daemon config/server.properties </span><br><span class="line">[root@192 kafka]# netstat -lntp | grep 9092</span><br><span class="line">tcp6       0      0 192.168.73.137:9092     :::*                    LISTEN      19603/java</span><br></pre></td></tr></table></figure><ol start="4"><li>到Zookeeper集群下查看所有的broker</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /brokers/ids</span><br><span class="line">[0, 1, 2]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] </span><br></pre></td></tr></table></figure><p>修改分区数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 bin]# ./kafka-topics.sh --bootstrap-server 192.168.73.137:9092 --alter --topic first_test_topic --partitions 3</span><br><span class="line">OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N</span><br><span class="line">[root@192 bin]# ./kafka-topics.sh --bootstrap-server 192.168.73.137:9092 --describe --topic first_test_topic</span><br><span class="line">OpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N</span><br><span class="line">Topic: first_test_topicTopicId: vi8l4UdNR8ydP9o0bhCYYAPartitionCount: 3ReplicationFactor: 1Configs: segment.bytes=1073741824</span><br><span class="line">Topic: first_test_topicPartition: 0Leader: 0Replicas: 0Isr: 0</span><br><span class="line">Topic: first_test_topicPartition: 1Leader: 1Replicas: 1Isr: 1</span><br><span class="line">Topic: first_test_topicPartition: 2Leader: 2Replicas: 2Isr: 2</span><br></pre></td></tr></table></figure><h2 id="Kafka生产者"><a href="#Kafka生产者" class="headerlink" title="Kafka生产者"></a>Kafka生产者</h2><h3 id="生产者原理"><a href="#生产者原理" class="headerlink" title="生产者原理"></a>生产者原理</h3><p>Kafka在消息发送的过程中，涉及到两个线程——<strong>main</strong> 线程和 <strong>sender</strong> 线程。在 main 线程中创建一个了<strong>缓冲区 记录累加器 RecordAccumulator</strong>，里面有多个双端队列，<strong>一个分区对应一个双端队列</strong>。main 线程将消息发送给 RecordAccumulator，sender 线程不断从 RecordAccumulator 中拉取消息发送到 Kafka Broker。</p><ol><li>Kafka生产者将生产的消息封装成一个 <strong>ProducerRecord</strong> 向Kafka中某个topic发送消息</li><li>首先 发送的消息 会经过一个 <strong>拦截器Interceptor</strong>，可以对 消息进行一些额外的封装</li><li>发送的消息 首先要通过 <strong>序列化器</strong> 进行 序列化，以便在网络中传输</li><li>发送的消息 接下来通过 <strong>分区器</strong> 指定该消息应该到哪一个分区，一个分区对应一个双端队列，如果消息指定了分区，那就不用分区器划分了</li><li>分好区的消息并不是立即发送，而是放入了RecordAccumulator（默认大小是32M），然后多个消息会被分个一个<strong>批次（batch）</strong>，默认一个批次是 <strong>16K</strong>。</li><li>Sender 线程启动后会去缓冲区中获取可以发送的批次。只有数据累积到<strong>batch.size</strong>之后，Sender才会发送数据，默认就是 <strong>16K</strong>。如果数据迟迟未到达batch.size，Sender等待 <strong>linger.ms</strong> 时间，然后就会直接发送消息。<strong>默认 linger.ms 是 0ms</strong>，表示没有延迟，因此会立即发送。生产环境中这两个参数都需要调整。</li><li>Sender发送时，以分区节点作为Key，也就是 broker1，broker2为 key，请求为value进行发送，形成一个请求。</li><li>请求在从 Sender线程发往Kafka之前还会保存到 <strong>InFlightRequests</strong> 中，主要作用就是<strong>缓存已经发出去还是还没有收到应答的请求</strong>。</li><li>请求发送到某个 Broker中，如果第一个请求发送到Broker1，broker1没有即使应答，就允许继续发送到第二个请求，如果一直到<strong>第5个请求</strong>都<strong>没有应答</strong>，<strong>后续</strong>的请求也<strong>不允许再发送</strong>了。</li><li>在InFlightRequests 通过配置参数去限制的这个请求的最大次数，也就是每个连接（也就是客户端与 Node 之间的连接）最多缓存的请求数。这个配置参数为 <strong>max.in.flight.requests.per.connection</strong>，<strong>默认值为5</strong>，即每个连接最多只能缓存5个未响应的请求，超过该数值之后就不能再向这个连接发送更多的请求了，除非有缓存的请求收到了响应（Response）。通过比较 双端队列的 size 与这个参数的大小来判断对应的节点中是否已经堆积了很多未响应的消息，如果真是如此，那么说明这个节点负载较大或网络连接有问题，再继续向其发送请求会增大请求超时的可能。</li><li>Kafka集群收到请求后会有一个响应级别<strong>acks</strong>，分别为<strong>0，1，all/-1</strong><ul><li><strong>0</strong>：生产者发送过来的数据，<strong>不需要等待数据落到Leader的磁盘上</strong>；采用这种配置，可能生产者发出的消息还在半路上，然后目的地 partition leader 的Broker就直接挂掉了，然后这个客户却还认为消息发送成功了，这就导致消息丢失。</li><li><strong>1</strong>：生产者发送过来的数据，<strong>Partition Leader 接收到消息并且写入磁盘</strong>了，就认为消息<strong>发送成功</strong>了，不管其他的follower是否同步这条消息。这也是 kafka 的默认设置。采用这种配置，很明显当 分区Leader 已经把消息落入磁盘，所在的 broker 挂掉，follower 又还没同步数据，就会造成这条消息的丢失。</li><li><strong>all/-1</strong>：生产者发送过来的数据，要等 <strong>partition leader 的 ISR 中所有跟 Leader 保持同步的 Follower 都把这条消息同步完后</strong>，才认为这条消息<strong>写入成功</strong>。</li><li>kafka集群应答之后，如果<strong>成功</strong>，进行<strong>数据的清理</strong>，如果<strong>失败</strong>，进行<strong>重试</strong>，<strong>默认重试次数是int的最大值</strong> </li></ul></li></ol><p><img src="/../../img/markdown_img/kafka.assets/image-20220705145304880.png" alt="image-20220705145304880"></p><h3 id="生产者消息发送"><a href="#生产者消息发送" class="headerlink" title="生产者消息发送"></a>生产者消息发送</h3><h4 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h4><p>如果ProducerRecord的partition<strong>指定了某个分区</strong>，那么<strong>消息体存储到指定的分区</strong>里</p><p>如果ProducerRecord的partition（其实就是分区号），如果<strong>没有指定分区器</strong>，则使用<strong>默认分区器DefaultPartitioner</strong>来计算，然后根据ProducerRecord的key来计算</p><p>如果<strong>key为空</strong>，则以<strong>轮询的方式</strong>来给主题下的各个<strong>可用分区</strong>来<strong>发送消息</strong>（注意这里，是可用分区）。</p><p>如果<strong>key不为空</strong>，则根据<strong>hash算法</strong>（采用MurmurHash2算法，具备高运算性能及低碰撞率）<strong>计算分区号</strong>，<strong>相同的key会分配到同一个分区</strong>。</p><p>DefaultPartitioner：是默认的分区器</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706143920155.png" alt="image-20220706143920155"></p><ol><li>指明partition的情况下，直 接将指明的值作为partition值； 例如partition=0，所有数据写入 分区0<ol><li><strong>没有指明partition值</strong>但<strong>有key</strong>的情况下，将<strong>key的Murmur2hash值</strong>与<strong>topic的 partition数</strong>进行<strong>取余</strong>得到<strong>partition值</strong>； 例如：key1的Murmur2hash值=5， key2的Murmur2hash值=6 ，topic的partition数=2，那 么key1 对应的value1写入1号分区，key2对应的value2写入0号分区。</li></ol></li><li><strong>既没有partition值</strong> <strong>又没有key值</strong>的情况下，Kafka采用<strong>Sticky Partition（黏性分区器）</strong>，会随机选择一个分区，并尽可能一直 使用该分区，待该分区的batch已满或者已完成，Kafka再随机一个分区进行使用（和上一次的分区不同）。 例如：第一次随机选择0号分区，等0号分区当前批次满了（默认16k）或者linger.ms设置的时间到， Kafka再随机一个分区进行使用（如果还是0会继续随机）。</li></ol><p>还可以<strong>自定义分区</strong>：</p><p>定义类<strong>实现Partition接口</strong>，<strong>重写partition方法</strong>，然后用Properties <strong>注入到 ProducerConfig.PARTITIONER_CLASS_CONFIG</strong></p><h4 id="普通异步发送"><a href="#普通异步发送" class="headerlink" title="普通异步发送"></a>普通异步发送</h4><p>创建Kafka生产者，异步的方式发送到 Kafka Broker</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.kafkademo.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.protocol.types.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者普通异步发送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Kafka 生产者配置对象</span></span><br><span class="line">        Properties propertites = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// Kafka 配置对象添加配置信息</span></span><br><span class="line">        propertites.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">&quot;192.168.73.137:9092&quot;</span>);</span><br><span class="line">        <span class="comment">// key,value 序列化</span></span><br><span class="line">        propertites.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,<span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        propertites.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,<span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建 Kafka 生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(propertites);</span><br><span class="line">        <span class="comment">// 调用 send 方法，发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            kafkaProducer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;first_test_topic&quot;</span>,<span class="string">&quot;ins1mnia message: &quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先启动 kafka 消费者，然后IDEA运行</p><p>可以看到消费者端消费到消息</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220705163134082.png" alt="image-20220705163134082"></p><h4 id="带回调函数的异步发送"><a href="#带回调函数的异步发送" class="headerlink" title="带回调函数的异步发送"></a>带回调函数的异步发送</h4><p>回调函数会在 producer 收到 ack 时调用，为异步调用，该方法有两个参数，分别是元数据信息（RecordMetadata）和异常信息（Exception），如果 Exception 为 null，说明消息发送成功，如果 Exception 不为 null，说明消息发送失败。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带有回调函数的异步发送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomProducerCallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// kafka topic</span></span><br><span class="line">        <span class="keyword">final</span> String topic = <span class="string">&quot;first_test_topic&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建生产者配置对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 配置 server</span></span><br><span class="line">        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">&quot;192.168.73.137:9092&quot;</span>);</span><br><span class="line">        <span class="comment">// 配置 序列化</span></span><br><span class="line">        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 创建kafka 生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(properties);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 添加回调函数</span></span><br><span class="line">            kafkaProducer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(topic,<span class="string">&quot;ins1mnia message: &quot;</span>+i),((metadata, exception) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 该方法在Producer收到 ack 时调用，为异步调用</span></span><br><span class="line">                <span class="keyword">if</span> (exception==<span class="keyword">null</span>)</span><br><span class="line">                    System.out.println(<span class="string">&quot;topic：&quot;</span>+metadata.topic()+<span class="string">&quot;-&gt;&quot;</span>+<span class="string">&quot; partition：&quot;</span>+metadata.partition());</span><br><span class="line">                <span class="keyword">else</span> System.out.println(exception.getMessage());</span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="comment">// 延迟一会会看到数据发往不同分区</span></span><br><span class="line">            Thread.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动Kafka消费者，然后IDEA运行</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706101246974.png" alt="image-20220706101246974"></p><p>回调函数打印：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">topic：first_test_topic-&gt; partition：<span class="number">2</span></span><br><span class="line">topic：first_test_topic-&gt; partition：<span class="number">2</span></span><br><span class="line">topic：first_test_topic-&gt; partition：<span class="number">2</span></span><br><span class="line">topic：first_test_topic-&gt; partition：<span class="number">2</span></span><br><span class="line"><span class="number">10</span>:<span class="number">10</span>:<span class="number">50.702</span> [kafka-producer-network-thread | producer-<span class="number">1</span>] DEBUG org.apache.kafka.clients.NetworkClient - [Producer clientId=producer-<span class="number">1</span>] Received PRODUCE response from node <span class="number">1</span> <span class="function"><span class="keyword">for</span> request with header <span class="title">RequestHeader</span><span class="params">(apiKey=PRODUCE, apiVersion=<span class="number">9</span>, clientId=producer-<span class="number">1</span>, correlationId=<span class="number">6</span>)</span>: <span class="title">ProduceResponseData</span><span class="params">(responses=[TopicProduceResponse(name=<span class="string">&#x27;first_test_topic&#x27;</span>, partitionResponses=[PartitionProduceResponse(index=<span class="number">1</span>, errorCode=<span class="number">0</span>, baseOffset=<span class="number">0</span>, logAppendTimeMs=-<span class="number">1</span>, logStartOffset=<span class="number">0</span>, recordErrors=[], errorMessage=<span class="keyword">null</span>)</span>])], throttleTimeMs</span>=<span class="number">0</span>)</span><br><span class="line"><span class="number">10</span>:<span class="number">10</span>:<span class="number">50.702</span> [kafka-producer-network-thread | producer-<span class="number">1</span>] DEBUG org.apache.kafka.clients.producer.internals.TransactionManager - [Producer clientId=producer-<span class="number">1</span>] ProducerId: <span class="number">1000</span>; Set last ack<span class="string">&#x27;d sequence number for topic-partition first_test_topic-1 to 0</span></span><br><span class="line"><span class="string">topic：first_test_topic-&gt; partition：1</span></span><br></pre></td></tr></table></figure><h4 id="同步发送API"><a href="#同步发送API" class="headerlink" title="同步发送API"></a>同步发送API</h4><p>同步发送就是消息发送完毕后，还要等待结果的响应，然后才会发送下一条消息。producer的send方法返回一个Future对象，我们可以通过调用这个对象的get方法，阻塞当前线程，直到收到收到ack消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomProducerSync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// kafka topic</span></span><br><span class="line">        <span class="keyword">final</span> String topic = <span class="string">&quot;first_test_topic&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建生产者配置对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 配置 server</span></span><br><span class="line">        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">&quot;192.168.73.137:9092&quot;</span>);</span><br><span class="line">        <span class="comment">// 配置 序列化</span></span><br><span class="line">        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 创建kafka 生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(properties);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 异步发送 默认</span></span><br><span class="line">            <span class="comment">// kafkaProducer.send(new ProducerRecord&lt;&gt;(&quot;first_test_topic&quot;,&quot;ins1mnia message: &quot;+i));</span></span><br><span class="line">            <span class="comment">// 同步发送</span></span><br><span class="line">            RecordMetadata recordMetadata = kafkaProducer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, <span class="string">&quot;ins1mnia message: &quot;</span> + i)).get();</span><br><span class="line">            <span class="keyword">if</span> (recordMetadata!=<span class="keyword">null</span> &amp;&amp; recordMetadata.hasOffset())</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功 -&gt;&quot;</span>+recordMetadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kafka-消费者"><a href="#Kafka-消费者" class="headerlink" title="Kafka 消费者"></a>Kafka 消费者</h2><h3 id="Kafka消费方式"><a href="#Kafka消费方式" class="headerlink" title="Kafka消费方式"></a>Kafka消费方式</h3><p><strong>pull 模式</strong>：consumer采用从broker中主动拉取数据。 Kafka采用这种方式。不足之处是，如果Kafka没有数据，消费者可能会陷入循环中，一直返回空数据。</p><p><strong>push 模式</strong>：Kafka没有采用这种方式，因为由broker 决定消息发送速率，很难适应所有消费者的消费速率。例如推送的速度是50m/s， Consumer1、Consumer2就来不及处理消息。 </p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706161522608.png" alt="image-20220706161522608"></p><h3 id="offset-偏移量"><a href="#offset-偏移量" class="headerlink" title="offset 偏移量"></a>offset 偏移量</h3><p>offse 偏移量有两种：</p><ol><li>生产者的offset，是<strong>分区最大的offset</strong></li><li><strong>消费者的offset</strong>，指出消费者消费到哪条消息</li></ol><p><strong>生产者offset：</strong></p><p>生产者消息会分配到特定的分区里，每个分区都有一个offset，也是最大的offset，只会加到末尾，不会删除</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706105326528.png" alt="image-20220706105326528"></p><p><strong>消费者offset：</strong></p><p>消费者C1 C2来自不同的消费者组（一个分区一个消费者组里的消费者只能消费一次）</p><p>生产者上次提交的偏移量是5，C1消费到了2，C2消费到了4，下次消费的时候，C1、C2就分别从上次消费的 offset 位置开始消费，当然也可以选择从头开始或者从最近的记录开始。</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706105717453.png" alt="image-20220706105717453"></p><p>当消费者在读取一个没有offset的分区或者offset无效的情况下，auto.offset.reset 配置指定了该如何处理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认值，在offset无效的情况下，消费者从最新的记录开始读取数据（也就是消费者启动后生成的记录）也就对应默认的命令</span></span><br><span class="line">auto.offset.reset=latest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 消费者从起始位置读取分区的记录 对应命令参数 --from-beginning</span></span><br><span class="line">auto.offset.reset=earliest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 抛出异常</span></span><br><span class="line">auto.offset.reset=none</span><br></pre></td></tr></table></figure><p>从0.9版本开始，consumer默认将offset保存在Kafka 一个内置的topic中，该topic为**__consumer_offsets**。Kafka0.9版本之前， consumer默认将offset 保存在Zookeeper中<img src="/../../img/markdown_img/kafka.assets/image-20220706162335248.png" alt="image-20220706162335248"></p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706162233817.png" alt="image-20220706162233817"></p><p>__consumer_offsets 主题里面采用 <strong>key 和 value 的方式存储数据</strong>。<strong>key</strong> 是 <strong>group.id+topic+ 分区号</strong>，<strong>value</strong> 就是当前 <strong>offset</strong> 的值。每隔一段时间，kafka 内部会对这个 topic 进行 <strong>compact</strong>，也就是每个 group.id+topic+分区号就保留最新数据。</p><p><strong>__consumer_offsets</strong> 也是主题，也是可以消费的，需要添加配置  exclude.internal.topics=false，默认是true 表示不能消费系统主题，改为false即可消费系统主题</p><h3 id="自动提交-offset"><a href="#自动提交-offset" class="headerlink" title="自动提交 offset"></a>自动提交 offset</h3><p>Kafka提供了自动提交offset的功能。</p><p>自动提交offset的相关参数： </p><ul><li><strong>enable.auto.commit</strong>：是否开启自动提交offset功能，默认是true。消费者会自动周期性地向服务器提交偏移量。</li><li><strong>auto.commit.interval.ms</strong>：自动提交offset的时间间隔，默认是5s</li></ul><p><strong>自动提交 offset 的重复消费问题：</strong></p><p><strong>自动提交有一个时间间隔</strong>的，如果 这段时间间隔消费者出现了故障，offset 没有提交到分区的主题，那么分区主题的offset就没有被更新。就会导致消息再被消费一次，也就是出现 <strong>重复消费</strong></p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706172947910.png" alt="image-20220706172947910"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String topic = <span class="string">&quot;first_test_topic&quot;</span>;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">&quot;192.168.73.137:9092&quot;</span>);</span><br><span class="line">    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置自动offset 提交</span></span><br><span class="line">    properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 提交间隔，默认5s</span></span><br><span class="line">    properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须 配置消费者组</span></span><br><span class="line">    properties.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册要消费的主题</span></span><br><span class="line">    ArrayList&lt;String&gt; topics = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    topics.add(topic);</span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    kafkaConsumer.subscribe(topics);</span><br><span class="line">    <span class="comment">// 拉取数据打印</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置1s 消费一批数据</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 打印 消费到的数据</span></span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : consumerRecords) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动提交-offset"><a href="#手动提交-offset" class="headerlink" title="手动提交 offset"></a>手动提交 offset</h3><p>虽然自动提交offset十分简单便利，但由于其是基于时间提交的，开发人员难以把握offset提交的时机。因 此Kafka还提供了手动提交offset的API。 </p><p>手动提交offset的方法有两种：分别是 <strong>commitSync</strong>（同步提交）和 <strong>commitAsync</strong>（异步提交）。</p><p><strong>相同点</strong>：都会将本次提交的一批数据最高的偏移量提交；</p><p><strong>不同点</strong>：同步提交 <strong>阻塞当前线程</strong>，一<strong>直到提交成功</strong>，<strong>并且会自动失败重试</strong>（由不可控因素导致，也会出现提交失败）；而<strong>异步提交</strong> 则<strong>没有失败重试机制</strong>，故有<strong>可能提交失败</strong>。</p><ul><li><strong>commitSync</strong>（同步提交）：<strong>必须等待offset提交完毕</strong>，再去消费下一批数据。 </li><li><strong>commitAsync</strong>（异步提交） ：<strong>发送完提交offset请求后</strong>，就开始消费下一批数据了。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String topic = <span class="string">&quot;first_test_topic&quot;</span>;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">&quot;192.168.73.137:9092&quot;</span>);</span><br><span class="line">    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置手动offset 提交</span></span><br><span class="line">    properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须 配置消费者组</span></span><br><span class="line">    properties.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册要消费的主题</span></span><br><span class="line">    ArrayList&lt;String&gt; topics = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    topics.add(topic);</span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    kafkaConsumer.subscribe(topics);</span><br><span class="line">    <span class="comment">// 拉取数据打印</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置1s 消费一批数据</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 打印 消费到的数据</span></span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : consumerRecords) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步提交offset</span></span><br><span class="line">        kafkaConsumer.commitAsync();</span><br><span class="line">        <span class="comment">// 同步提交</span></span><br><span class="line">        <span class="comment">//kafkaConsumer.commitSync();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于同步提交 offset 有失败重试机制，故更加可靠，但是由于一直等待提交结果，提交的效率比较低。</p><p>虽然同步提交 offset 更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞吐量会受到很大的影响。异步提交 offset 的方式效率高。</p><h3 id="指定-offset-消费"><a href="#指定-offset-消费" class="headerlink" title="指定 offset 消费"></a>指定 offset 消费</h3><p><strong>auto.offset.reset = earliest | latest | none</strong> 默认是 latest。 </p><p>当 Kafka 中没有初始偏移量（消费者组第一次消费）或服务器上不再存在当前偏移量 时（例如该数据已被删除）</p><ol><li>earliest：自动将偏移量重置为最早的偏移量，–from-beginning</li><li>latest（默认值）：自动将偏移量重置为最新偏移量，就是 消费consumer启动后 生产的消息</li><li>none：如果未找到消费者组的先前偏移量，则向消费者抛出异常</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String topic = <span class="string">&quot;first_test_topic&quot;</span>;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">&quot;192.168.73.137:9092&quot;</span>);</span><br><span class="line">    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须 配置消费者组</span></span><br><span class="line">    properties.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册要消费的主题</span></span><br><span class="line">    ArrayList&lt;String&gt; topics = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    topics.add(topic);</span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    kafkaConsumer.subscribe(topics);</span><br><span class="line"></span><br><span class="line">    Set&lt;TopicPartition&gt; assignment = kafkaConsumer.assignment();</span><br><span class="line">    <span class="comment">// 保证 consumer lead 把分区分配方案制定完毕</span></span><br><span class="line">    <span class="keyword">while</span> (assignment.size()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有获取到的话分区分配方案的话 我们之间poll 帮他拉取一下</span></span><br><span class="line">        kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//获取消费者分区分配信息 有了分区分配信息才能消费</span></span><br><span class="line">        assignment = kafkaConsumer.assignment();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有分区，并指定从 offset 100的位置开始消费</span></span><br><span class="line">    <span class="keyword">for</span> (TopicPartition topicPartition : assignment) &#123;</span><br><span class="line">        kafkaConsumer.seek(topicPartition,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费该主题</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置1s 消费一批数据</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 打印 消费到的数据</span></span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : consumerRecords) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kafka消费者工作流程"><a href="#Kafka消费者工作流程" class="headerlink" title="Kafka消费者工作流程"></a>Kafka消费者工作流程</h3><p><img src="/../../img/markdown_img/kafka.assets/image-20220706162155877.png" alt="image-20220706162155877"></p><h3 id="消费者组原理"><a href="#消费者组原理" class="headerlink" title="消费者组原理"></a>消费者组原理</h3><p>Consumer Group（CG）：消费者组，由多个consumer组成。形成一个消费者组的条件，是所有消费者的groupid相同。</p><ul><li>消费者组内<strong>每个消费者负责消费不同分区的数据</strong>，一个分区只能由一个组内消费者消费。 </li><li><strong>消费者组之间互不影响</strong>。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li></ul><p><img src="/../../img/markdown_img/kafka.assets/image-20220706162518256.png" alt="image-20220706162518256"></p><ol><li>如果向消费组中添加更多的消费者，<strong>消费者组内的消费者数 超过 主题分区数量</strong>，则有一<strong>部分消费者</strong>就会<strong>闲置</strong>，不会接收任何消息</li><li>消费者组之间互不影响</li></ol><p><strong>消费者组初始化流程：</strong></p><p><strong>coordinator</strong>：辅助实现消费者组的初始化和分区的分配。</p><p> coordinator节点选择 = groupid的hashcode值 % 50 (<strong>consumer_offsets的分区数量为50</strong>）</p><p>groupid 是客户端 手动设置的一个groupid</p><p>__例如： groupid的hashcode值 = 1，1% 50 = 1，那么__consumer_offsets 主题的1号分区，在哪个broker上，就选择这个节点的coordinator 作为这个消费者组的老大。消费者组下的所有的消费者提交offset的时候就往这个分区去提交offset。</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706162752859.png" alt="image-20220706162752859"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.kafkademo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.TopicPartition;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.StringDeserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个独立消费者，消费 指定 主题中数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String topic = <span class="string">&quot;first_test_topic&quot;</span>;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">&quot;192.168.73.137:9092&quot;</span>);</span><br><span class="line">        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,StringDeserializer.class.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须 配置消费者组</span></span><br><span class="line">        properties.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册要消费的主题</span></span><br><span class="line">        ArrayList&lt;String&gt; topics = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        topics.add(topic);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 消费某个主题的某个分区数据</span></span><br><span class="line"><span class="comment">        ArrayList&lt;TopicPartition&gt; topicPartitions = new</span></span><br><span class="line"><span class="comment">                ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        topicPartitions.add(new TopicPartition(topic, 0));</span></span><br><span class="line"><span class="comment">        kafkaConsumer.assign(topicPartitions);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅</span></span><br><span class="line">        kafkaConsumer.subscribe(topics);</span><br><span class="line">        <span class="comment">// 拉取数据打印</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置1s 消费一批数据</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 打印 消费到的数据</span></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : consumerRecords) &#123;</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者分区的分配"><a href="#消费者分区的分配" class="headerlink" title="消费者分区的分配"></a>消费者分区的分配</h3><ol><li><p>一个consumer group中有多个consumer组成，一个 topic有多个partition组成，现在的问题是，到底由哪个consumer来消费哪个 partition的数据。 </p></li><li><p>Kafka有四种主流的分区分配策略： <strong>Range</strong>、<strong>RoundRobin</strong>、<strong>Sticky</strong>、<strong>CooperativeSticky</strong>。 可以通过配置参数partition.assignment.strategy，修改分区的分配策略。默认策略是Range + CooperativeSticky。Kafka可以同时使用 多个分区分配策略。</p></li></ol><p>Kafka默认的消费逻辑是，位于某个主题中的一个分区只能被同一个消费者组中的一个消费者消费。<br>当主题分区发生变化时、或有新消费者加入群组时、或群组中有消费者挂掉时，Kafka会触发分区再均衡操作。 那分区再均衡有哪些优缺点呢？分区再平衡的优势在于能为消费者群组带来高可用性与伸缩性；但其缺点在于在发生再均衡这一期间内，消费者是无法读取信息的，所以这将会造成消费者群组会出现一小段时间不可用的情形。所以在应用Kafka的过程中，需要避免无用的分区再平衡发生。</p><ol><li><p>RoundRobin</p><p>RoundRobin 就是轮询，比如 在消费者订阅的主题都一致的情况下：假设有 3 个 topic，10 个 partition，分配结果就如下</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220707154635300.png" alt="image-20220707154635300"></p><p>如果 消费者订阅的主题不一致，那么结果会是这样：</p><p>C0轮询到 Topic-A-Partition-0，到C1了，C1只能选择Topic-B-Partition-0；</p><p>C0轮询到 Topic-A-Partition-1，到C1了，C1只能选择Topic-B-Partition-1；</p><p>…</p><p>最后 Topic-C 的所有分区都只能 C1 消费</p><p>所以，最好不要选择 RoundRobin</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220707154847183.png" alt="image-20220707154847183"></p></li><li><p>Range</p><p>Range 是默认的策略，不同于RoundRobin之处在于<strong>Range策略</strong>是<strong>面向Topic分配</strong>的(RoundRobin面向Partition)</p><p>首先对同一个 topic 里面的分区按照序号进行排序，并 对消费者按照字母顺序进行排序。</p><p>假如现在有 7 个分区，3 个消费者，排序后的分区将会 是0,1,2,3,4,5,6；消费者排序完之后将会是C0,C1,C2。</p><p>例如，7/3 = 2 余 1 ，除不尽，那么 消费者 C0 便会多 消费 1 个分区。 8/3=2余2，除不尽，那么C0和C1分别多 消费一个。 通过 partitions数/consumer数 来决定每个消费者应该 消费几个分区。如果除不尽，那么前面几个消费者将会多 消费 1 个分区。 分区分配策略之Range</p><p>注意：如果<strong>只是针对 1 个 topic 而言</strong>，<strong>C0</strong>消费者<strong>多消费1 个</strong>分区影响不是很大。但是如果<strong>有 N 多个 topic</strong>，那么针对每 个 topic，消费者 C0都将多消费 1 个分区，topic越多，<strong>C0消 费的分区</strong>会比其他消费者明显<strong>多消费 N 个分区</strong>。 容易产生数据倾斜！</p><ol start="3"><li><p>Sticky</p><p>可以理解为分配的结果带有“粘性的”。即在执行一次新的分配之前， <strong>考虑上一次分配的结果</strong>，尽量少的调整分配的变动，可以节省大量的开销。 粘性分区是 Kafka 从 0.11.x 版本开始引入这种分配策略，首先会尽量均衡的放置分区 到消费者上面，在出现同一消费者组内消费者出现问题的时候，会<strong>尽量保持原有分配的分 区不变化</strong>。</p><p>对于同一个主题，7个分区，3个消费者，那么就是 7/3=2…1，所以就3个消费者，C1 消费3个分区，C2和C3都消费两个。虽然这个结果消费数量看似和Range一样，但是Range里消费的分区都是排序了的，比如C1 消费的3个分区就应该是 0 1 6。而Sticky则是随机的分配到消费里面去，序号什么的无所谓，只有数量能对上</p><p>对于订阅不同主题：</p><p>假设C1订阅的T0，C2订阅T0，T1，C3订阅T0，T1，T2 对于RoundRobin，</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220707161140326.png" alt="image-20220707161140326"></p><p>这时候 假设 C1脱离了群组，根据RoundRobin再分配就是这样</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220707161226081.png" alt="image-20220707161226081"></p><p>对于Sticky，最终分配结果为</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220707161416151.png" alt="image-20220707161416151"></p><p>C1脱离，平衡结果为</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220707161438240.png" alt="image-20220707161438240"></p></li></ol></li></ol><h2 id="Kafka-幂等性-和-事务"><a href="#Kafka-幂等性-和-事务" class="headerlink" title="Kafka 幂等性 和 事务"></a>Kafka 幂等性 和 事务</h2><h3 id="Kafka-为啥需要幂等性"><a href="#Kafka-为啥需要幂等性" class="headerlink" title="Kafka 为啥需要幂等性"></a>Kafka 为啥需要幂等性</h3><p>Kafka在引入幂等性之前，Producer向Broker发送消息，然后Broker将消息追加到消息流中后给Producer返回Ack信号值。可能存在很多不确定的因素：比如 Producer 给 Broker 发送了信息， Broker 接收到了消息，在返回 ack 的时候网络异常等，Producer 没有收到。Producer 就触发重试机制，就会重新发送一条一样的消息给Broker，这条消息又被加到了某个partition</p><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p><strong>幂等性</strong>就是指Producer不论向Broker发送多少次重复数据，Broker端都<strong>只会持久化一条</strong>，<strong>保证了不重复</strong>。 </p><p><strong>幂等性</strong>只在<strong>单个partition内</strong>能保证，<strong>跨partition的幂等性</strong>不能保证。要保证不同partition和topic之间的幂等性，则需要 <strong>考虑 Kafka 事务</strong></p><p>Kafka 为了实现幂等性，解决Producer重试引起的重复。Kafka 增加了 Pid 和 Seq。</p><ul><li><p><strong>PID</strong>：每一个 Producer都分配一个唯一的PID。Producer 故障后重新启动后会被分配一个新的 PID。Producer 的 PID 向 server 端申请，server 端Controller 又会向 Zookeeper 申请，Zookeeper 可以生成分布式唯一ID，ZK 中有一个 /last_producer_id_block 节点，每申请一个 PID 段，都会把自己申请的PID段信息写入到/last_producer_id_block 节点，当下次 又有broker申请的PID的时候先读取这个节点的信息，然后根据block_end选择一个PID段，最后再把信息写回到ZK节点。broker向producer返回自己保存的PID。</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706143045048.png" alt="image-20220706143045048"></p></li><li><p>Sequence Number：Producer 发送数据的每个 topic partition 都对应一个从 0 单调递增的SequenceNumber。</p></li></ul><p>这样，Producer端会保存每一个，如果Producer 重试 再次发送消息，会携带PID 和 Seq ，在Boker那边能发现之前有这么一条消息，就不重复。</p><p><strong>不同的分区它的 序列化 Seq 是不同的，这就是为什么这个幂等性只在单个partition内能保证</strong></p><p><strong>使用幂等性</strong>：<strong>开启参数 enable.idempotence 默认为 true</strong></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Kafka中的事务与数据库的事务类似，Kafka中的事务属性是指一系列的Producer生产消息和消费消息提交Offsets的操作在一个事务中，即原子性操作。对应的结果是同时成功或者同时失败。<strong>kafka中的事务可以使应用程序将消费消息，生产消息、提交消费位移当作原子操作来处理，同时成功或者失败，即使该生产或消费跨越多个分区。</strong></p><p>kafka事务引入了 <strong>transactionId</strong> 和Epoch，设置<strong>transactional.id</strong>后，<strong>一个transactionId只对应一个pid</strong>, 且 Server 端会记录最新的 Epoch 值（<strong>Epoch是分配给Producer的一个递增的值</strong>）。这样<strong>有新的producer初始化</strong>时，会向<strong>TransactionCoordinator</strong>发送<strong>InitPIDRequest</strong> <strong>请求PID</strong>， TransactionCoordinator 已经有了这个 transactionId对应的 信息，<strong>会返回之前分配的 PID</strong>，<strong>并把 Epoch 自增 1 返回</strong>，这样<strong>当 old producer 恢复</strong>过来请求操作时，检查Epoch值不是最新的，将<strong>被认为是无效producer ** 抛出异常。如果</strong>没有开启事务<strong>，</strong>TransactionCoordinator会为新的producer返回new pid**，这样就起不到隔离效果，因此无法实现多会话幂等。</p><p>原来的幂等性是分配一个PID，然后跟每个topic和每个分区都有关，这里可以理解为就用一个整体的id 也就是 transaction.id 来代替了幂等性的那一串PID，Sequence等，所以跟分区无关了。也就实现了跨分区跨主题</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706160033630.png" alt="image-20220706160033630"></p><p><strong>Transaction Log：</strong>同 消费者offset <strong>__consumer_offsets</strong>一样，是一个系统topic  <strong>__transaction_state</strong> <strong>存储</strong>一些<strong>事务的最新状态</strong> 和 一些相关<strong>元数据信息</strong>。每个 transactional.id 通过 hash 都对应到 了 Transaction Log 的一个分区，所以每个 transactional.id 都有且仅有一个 transaction coordinator 负责。</p><p><strong>控制消息：</strong>专门用来标记事务的状态，同其他的正常消息一样都被存在日志中，但是 控制消息 不会返回给 consumer。控制消息共有两种类型：commit 和 abort，分别用来表征事务已经成功提交或已经被成功终止</p><p><strong>整个具体的事务流程：</strong></p><ol><li><p><strong>查找Transaction Coordinator</strong></p><p><strong>Producer</strong> 向任意一个Broker 发送 <strong>FindCoordinatorRequest</strong> 请求，<strong>获取到 Transaction Coordinator 的地址</strong></p></li><li><p><strong>初始化事务 initTransaction</strong></p><p>Producer 发送 <strong>initPidRequest</strong> 给 Transaction Coordinator，<strong>获取 PID</strong>， Transaction Coordinator 在 Transaction log 中<strong>建立 &lt; TransactionId,pid &gt;的映射</strong></p></li><li><p><strong>开始事务 beginTransaction</strong></p><p>执行Producer的beginTransacion()，它的作用是 <strong>Producer 在本地记录下这个transaction的状态为开始状态</strong>。这个操作并没有通知Transaction Coordinator，因为Transaction Coordinator只有在Producer发送第一条消息后才认为事务已经开启</p></li><li><p><strong>消息发送与记录</strong></p><p>一旦 Producer 开始发送消息， Transaction Coordinator 会将该 &lt;Transaction,Topic,Partition&gt; 存于 <strong>Transaction Log</strong> 内，设置事务状态开始。此外，针对该事务中第一个消息，Transaction Coordinator 在处理之前会开启计时，每个事务都有自己的超时时间</p><p>在注册 &lt;Transaction,Topic,Partition&gt; 于 Transaction Log 内，生产者发送数据，尽管没有被 Commit 或者 Abort，此时消息已经被持久化。即使后面Abort，也只是把消息字段标识修改为Abort标识</p></li><li><p><strong>事务提交或者丢弃  commitTransaction/abortTransaction</strong></p><p>Producer 在 提交或丢弃 的时候，Transaction Coordinator 也会有一个 <strong>两阶段提交</strong></p><ol><li>将 <strong>Transaction Log</strong> 内的<strong>事务状态</strong>改为 <strong>Prepare_Commit</strong> 或者 <strong>Prepare_Abort</strong></li><li>将 控制消息 写入该事务涉及到的所有消息（即将所有消息 标记为 Commit/Abort）。<strong>Transaction Coordinator 在向 topic-partition 的leader写完控制消息后，更新事务状态为 Commited 或者 Abort</strong></li></ol></li></ol><p>Kafka 事务下的API</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 初始化事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initTransactions</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 2 开启事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br><span class="line"><span class="comment">// 3 在事务内提交已经消费的偏移量（主要用于消费者）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOffsetsToTransaction</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets,</span></span></span><br><span class="line"><span class="function"><span class="params"> String consumerGroupId)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">ProducerFencedException</span>;</span><br><span class="line"><span class="comment">// 4 提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commitTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br><span class="line"><span class="comment">// 5 放弃事务（类似于回滚事务的操作）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abortTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomProducerTransactions</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         <span class="comment">// 1. 创建 kafka 生产者的配置对象</span></span><br><span class="line">         Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">         <span class="comment">// 2. 给 kafka 配置对象添加配置信息</span></span><br><span class="line">         properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.73.137:9092&quot;</span>);</span><br><span class="line">         <span class="comment">// key,value 序列化</span></span><br><span class="line">         properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, </span><br><span class="line">                        StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">         properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, </span><br><span class="line">                        StringSerializer.class.getName());</span><br><span class="line">         <span class="comment">// 必须设置事务 id，事务 id 任意起名</span></span><br><span class="line">         properties.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, </span><br><span class="line">                        <span class="string">&quot;transaction_id_0&quot;</span>);</span><br><span class="line">         <span class="comment">// 3. 创建 kafka 生产者对象</span></span><br><span class="line">         KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> </span><br><span class="line">             KafkaProducer&lt;String, String&gt;(properties);</span><br><span class="line">         <span class="comment">// 初始化事务</span></span><br><span class="line">         kafkaProducer.initTransactions();</span><br><span class="line">         <span class="comment">// 开启事务</span></span><br><span class="line">         kafkaProducer.beginTransaction();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 4. 调用 send 方法,发送消息</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                 <span class="comment">// 发送消息</span></span><br><span class="line">                 kafkaProducer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;first_test_topic&quot;</span>, </span><br><span class="line">                                                         <span class="string">&quot;ins1mnia &quot;</span> + i));</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// int i = 1 / 0;这样就不会提交成功，一条消息都发送不出去</span></span><br><span class="line">             <span class="comment">// 提交事务</span></span><br><span class="line">             kafkaProducer.commitTransaction();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             <span class="comment">// 终止事务</span></span><br><span class="line">             kafkaProducer.abortTransaction();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="comment">// 5. 关闭资源</span></span><br><span class="line">             kafkaProducer.close();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据同步原理"><a href="#数据同步原理" class="headerlink" title="数据同步原理"></a>数据同步原理</h2><h3 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h3><p>Kafka每个topic可以分为多个Partition，并且 <strong>多个Partition 会均匀的分布在集群的各个节点下</strong>。这样能够有效的对数据进行分片。但是 单点的Partition并不可靠，所以 Kafka 提出了<strong>副本（Replica）</strong>。通过 副本机制来实现冗余备份。</p><p>每个分区可以有多个副本。副本中 有一个 Leader 和 多个 Follower。所有的读写请求都由 Leader 进行处理，Follower 需要和 Leader 同步消息日志。</p><p>一般情况下，同一个分区的多个副本会被均匀分配到集群中的不同 broker上，这样当 某个 分区的Leader所在的 broker挂了，不会出现 所有follower也挂了。可以从其他 broker的这个分区的副本 选举出一个新的 Leader。</p><h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p><strong>ISR（In-Sync Replicas）：</strong>ISR 包含了 所有与Leader完全同步的Follower集合，可能有部分Follower故障没有与Leader完全同步，那么这个Follower就不在ISR集合中，而在 <strong>OSR（Out-Sync Relipcas）</strong>集合中，两个集合的并集，就是 所有副本 <strong>AR（Assigned Repllicas）</strong></p><p><strong>LEO（Log end offset）：</strong>日志末端位置，记录了该副本日志中<strong>下一条消息</strong>的位移量。下一条消息 表示 LEO=10，那么 该副本保存了10条消息，位移值范围是 [0,9]。Leader LEO 和 Follower LEO 的更新有所区别</p><p><strong>HW（High Watermark）：</strong>高水位值，对于同一个副本来说，HW &lt;= LEO。小于等于 HW 值的所有消息都认为是 <strong>已经备份</strong> 的。</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706113543512.png" alt="image-20220706113543512"></p><p><strong>具体流程：</strong></p><ol><li>broker1上的 leader 副本接收到消息，把自己的 LEO 值更新为 1 。</li><li>broker2 和 broker3 上的 follower 副本各自发送请求给 broker 1。（一般情况下，是follower定时给leader发送fetch请求的，就好像heartbeat心跳）</li><li>broker1收到fetch请求后，主动分别把该消息推送给 follower 副本 。</li><li>follower 副本接收到消息后各自更新自己的 LEO 为 1，并返回response。</li><li>leader 副本接收到其他 follower 副本的数据请求响应（ response ）之后，更新 HW 值为 1 。 此时位移为 0 的这条消息可以被 consumer 消费。</li></ol><p><strong>Leader选举过程：</strong></p><ol><li><strong>Kafka Controller</strong>监听 Zookeeper 的 /brokers/ids 下的所有节点，一旦有 broker 挂了，就进行Leader的选举</li><li>优先从 ISR 列表中选出第一个作为leader副本，具体过程：<strong>按照 AR 集合中副本的顺序 查找 第一个 存活的，并且 属于 ISR 集合的 副本作为新的 leader</strong>。一个分区的AR集合在创建分区副本的时候就被指定，只要不发生重分配的情况，AR集合内部副本的顺序是保持不变的，而分区的ISR集合上面说过因为同步滞后等原因可能会改变，所以注意这里是根据AR的顺序而不是ISR的顺序找。</li><li>一种 <strong>极端情况</strong>：<strong>所有的partition副本都不可用</strong>。Kafka 提供了两种选择<ul><li>选择 ISR 中 第一个 活 过来的副本作为 Leader</li><li>选择 第一个活过来的 副本（不一定是ISR中的）作为 Leader</li><li>这就需要在<strong>可用性</strong>和<strong>数据一致性</strong>当中做出选择，如果一定要<strong>等待ISR中的副本</strong>活过来，那<strong>不可用</strong>的时间可能会相对<strong>较长</strong>。选择<strong>第一个活过来的副本</strong>作为Leader，如果这个副本不在ISR中，那<strong>数据的一致性</strong>则难以<strong>保证</strong>。kafka<strong>支持用户通过配置选择</strong>，以根据业务场景在可用性和数据一致性之间做出权衡。</li></ul></li><li>Kafka Controller 也是有可能挂掉的，所以也有 Controller 的选举过程</li></ol><h2 id="Kafka-Controller"><a href="#Kafka-Controller" class="headerlink" title="Kafka Controller"></a>Kafka Controller</h2><p>Controller 控制器，是Kafka 集群中的核心组件，Kafka 集群中每一个Broker都可以是一个Controller，但是一个 Kafka 集群，同一时间 只能有一个 Controller 节点。</p><p>Controller 的作用 主要是 和 Zookeeper 协调管理 整个 Kafka集群。Controller 同 Zookeeper 进行交互，获取和更新集群中的元数据信息。这样，其他 Broker 就不用直接与 Zookeeper 进行通信，而是与 Controller 进行通信，并且同步Controller中的元数据信息。</p><p>元数据</p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706143036219.png" alt="image-20220706143036219"></p><p><img src="/../../img/markdown_img/kafka.assets/image-20220706143045048.png" alt="image-20220706143045048"></p><p><strong>Controller 主要作用</strong></p><ol><li><p><strong>主题管理</strong>：<br>创建、删除Topic，以及增加Topic分区等操作都是由控制器执行。</p></li><li><p><strong>分区重分配</strong>：<br>执行Kafka的reassign脚本对Topic分区重分配的操作，也是由控制器实现。<br>如果集群中有一个<strong>Broker异常退出</strong>，控制器会检查这个broker是否有分区的副本leader，如果有那么这个分区就需要一个新的leader，此时控制器就会去遍历其他副本，<strong>选举新leader</strong>，同时更新分区的ISR集合。<br>如果有一个<strong>Broker加入集群</strong>中，那么控制器就会通过Broker ID去判断新加入的Broker中是否含有现有分区的副本，如果有，就会从分区副本中去同步数据。</p></li><li><p><strong>Preferred leader选举</strong>：<br>因为在Kafka集群长时间运行中，broker的宕机或崩溃是不可避免的，leader就会发生转移，即使broker重新回来，也不会是leader了。在众多leader的转移过程中，就会产生<strong>leader不均衡现象</strong>，可能一<strong>broker上有大量的leader</strong>，影响了整个集群的性能，所以就需要把leader调整回最初的broker上，这就需要Preferred leader选举。</p></li><li><p><strong>集群成员管理</strong>：<br>控制器能够<strong>监控新broker的增加</strong>，<strong>broker的主动关闭与被动宕机</strong>，进而做其他工作。这也是利用Zookeeper的ZNode模型和Watcher机制，控制器会监听Zookeeper中/brokers/ids下临时节点的变化。同时对broker中的leader节点进行调整。</p><p>比如，控制器组件会利用 Watch 机制检查 ZooKeeper 的 /brokers/ids 节点下的子节点数量变更。目前，当有新 Broker 启动后，它会在 /brokers 下创建专属的 znode 节点。一旦创建完毕，ZooKeeper 会通过 Watch 机制将消息通知推送给控制器，这样，控制器就能自动地感知到这个变化，进而开启后续的新增 Broker 作业。</p><p>侦测 Broker 存活性则是依赖于刚刚提到的另一个机制：临时节点。每个 Broker 启动后，会在 /brokers/ids 下创建一个临时 znode。当 Broker 宕机或主动关闭后，该 Broker 与 ZooKeeper 的会话结束，这个 znode 会被自动删除。同理，ZooKeeper 的 Watch 机制将这一变更推送给控制器，这样控制器就能知道有 Broker 关闭或宕机了，从而进行“善后”</p></li><li><p><strong>元数据服务</strong>：<br>控制器上<strong>保存</strong>了<strong>最全的集群元数据信息</strong>，其他所有broker会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据</p></li></ol><h2 id="线上问题优化"><a href="#线上问题优化" class="headerlink" title="线上问题优化"></a>线上问题优化</h2><h3 id="如何防止消息丢失"><a href="#如何防止消息丢失" class="headerlink" title="如何防止消息丢失"></a>如何防止消息丢失</h3><p><strong>Producer 采用调用回调函数的异步发送：</strong></p><p>Producer端很可能会丢失消息，send(msg)这个API通常会立即返回，并不能保证消息发送成功。可能网络等原因，消息就没发送到Broker；或者消息本身不合规，比如消息太大，Broker拒收</p><p>**采用 send(msg，callback)**，带有回调函数的发送，一旦出现异常情况，就可以针对性的处理，利用回调函数，<code>Producer</code>重试就可以了；如果是消息不合规造成的，那么调整消息格式后再次发送。</p><p><strong>设置 acks 为 1 或者 -1/all：</strong></p><p>1 保证 分区 leader 把消息落入磁盘。</p><p>-1/all 要保证 ISR 中所有Follower 都把这条消息同步过后才返回。</p><p><strong>看消息的重要程度，可以设置为 1 或者 -1</strong></p><h3 id="Kafka如何保证消息的顺序消费"><a href="#Kafka如何保证消息的顺序消费" class="headerlink" title="Kafka如何保证消息的顺序消费"></a>Kafka如何保证消息的顺序消费</h3><p>如果我们用 Kafka 想要保证消息的有序性</p><p>Kafka 我们可以选择 Kafka 一个 topic，一个 partition，一个consumer，这样随便来条消息都是绝对有序的了。</p><p>此外，我们可以选择<strong>满足一个Partition 的消息消费有序</strong>。首先要在 发消息的时候 都进入到同一个 Partition，我们可以选择 生产者 直接指定对应的 Partition，或者 指定 Partition的 Key，有Key 的情况下，会对 Key 做一个 Hash 运算 然后同 partition 数取余 得到 Partition 值。这样到消费者来取这个Partition的数据都是有序的。但是如果 消费者有多个线程并发的处理消息，消息取出来后执行的顺序就会得不到保证。</p><p>这时候，我们可以写多个 队列，将我们想要保证的顺序key相同的放到同一个队列里去。每一个线程消费一个队列，这样消费到队列上就是有序的了。</p><p>但是上面这种情况下，还是有异常的可能性。本来在同一个分区下的消息来说是有序的，但是，Kafka 可能因为消费者宕机或者重启会进行消费者组的分区重新分配消费，就可能导致乱序的情况</p><h3 id="消息重试对顺序消息的影响"><a href="#消息重试对顺序消息的影响" class="headerlink" title="消息重试对顺序消息的影响"></a>消息重试对顺序消息的影响</h3><p>对于两条消息 1,2，正常情况下的消息发送顺序是A，然后B。但是如果在A发送失败的情况下，B发送成功，A由于重试机制在B发送完成之后重试发送成功。这时候本身顺序AB就变为了BA。</p><blockquote><p>The maximum number of unacknowledged requests the client will send on a single connection before blocking. Note that if this setting is set to be greater than 1 and there are failed sends, there is a risk of message re-ordering due to retries (i.e., if retries are enabled).</p></blockquote><p>这个时候我们需要设置 max.in.flight.requests.per.connection=1，客户端在单个连接上能够发送的未响应请求个数为1。这样，未响应的请求个数为1的时候，后面的消息不会进行发送，保证后一条消息发送的时候前一条消息是发送成功的。因此，这样也会降低系统的吞吐量，但是却不会因此造成乱序的情况</p><p>新版本kafka设置enable.idempotence=true后能够动态调整max-in-flight-request。正常情况下max.in.flight.requests.per.connection大于1。当重试请求到来且时，batch 会根据 seq重新添加到队列的合适位置，并把max.in.flight.requests.per.connection设为1，这样它 前面的 batch序号都比它小，只有前面的都发完了，它才能发。</p><h3 id="Kafka-如何防止消息的重复消费"><a href="#Kafka-如何防止消息的重复消费" class="headerlink" title="Kafka 如何防止消息的重复消费"></a>Kafka 如何防止消息的重复消费</h3><p>防止消息不丢失，生产者会有重试机制，可能造成消息重复消费；自动提交offset 也可能造成重复消费。</p><p>我们可以把自动提交改为手动提交，再加上 消费消息时的<strong>幂等性保证</strong>，就可以解决消息重复消费的问题。</p><p><strong>比如：</strong></p><p><strong>提高单条消息的处理速度</strong>，例如对消息处理中比较耗时的步骤可通过异步的方式进行处理、利用多线程处理等。</p><p>可以针对消息生成md5然后保存到mysql或者redis里面，在处理消息之前先去mysql或者redis里面判断是否已经消费过。这个方案其实就是<strong>利用幂等性的思想。</strong></p><p>给消息增加一个版本号属性，每次消费消息前，比较当前消息的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等。</p><h3 id="解决消息积压问题"><a href="#解决消息积压问题" class="headerlink" title="解决消息积压问题"></a>解决消息积压问题</h3><p>消息积压会导致很多问题，比如磁盘被打满、生产端发消息导致kafka性能过慢，就容易出现服务雪崩，就需要有相应的手段：</p><ul><li>方案一：在一个消费者中启动多个线程，<strong>让多个线程同时消费</strong>。——提升一个消费者的消费能力（<strong>增加分区增加消费者</strong>）。</li><li>方案二：如果方案一还不够的话，这个时候可以启动多个消费者，多个消费者部署在不同的服务器上。其实多个消费者部署在同一服务器上也可以提高消费能力——充分利用服务器的cpu资源。</li><li>方案三：让一个<strong>消费者去把收到的消息往另外一个topic上发</strong>，<strong>另一个topic设置多个分区和多个消费者 ，进行具体的业务消费</strong>。</li></ul><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>延迟队列的应用场景：在订单创建成功后如果超过 30 分钟没有付款，则需要取消订单，此时可用延时队列来实现</p><ul><li>创建多个topic，每个topic表示延时的间隔<ul><li>topic_5s: 延时5s执行的队列</li><li>topic_1m: 延时 1 分钟执行的队列</li><li>topic_30m: 延时 30 分钟执行的队列</li></ul></li><li>消息发送者发送消息到相应的topic，并带上消息的发送时间</li><li>消费者订阅相应的topic，消费时轮询消费整个topic中的消息<ul><li>如果消息的发送时间，和消费的当前时间超过预设的值，比如 30 分钟</li><li>如果消息的发送时间，和消费的当前时间没有超过预设的值，则不消费当前的offset及之后的offset的所有消息都消费</li><li>下次继续消费该offset处的消息，判断时间是否已满足预设值</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Kafka，基本概念，生产者原理，消费者原理，消费者组原理，分区，副本，集群搭建，常见消息队列问题比如消息重复</summary>
    
    
    
    <category term="Kafka" scheme="http://ins1mn1a.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://ins1mn1a.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity Oauth2</title>
    <link href="http://ins1mn1a.github.io/2022/07/27/SpringSecurity/SpringSecurity%20Oauth2/"/>
    <id>http://ins1mn1a.github.io/2022/07/27/SpringSecurity/SpringSecurity%20Oauth2/</id>
    <published>2022-07-27T14:44:17.161Z</published>
    <updated>2022-07-27T14:54:03.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Oauth-2-简介"><a href="#Oauth-2-简介" class="headerlink" title="Oauth 2 简介"></a>Oauth 2 简介</h2><p>第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间要遵循一定的接口协议。</p><p>　OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。</p><p>　Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。</p><p>下边分析一个Oauth2认证的例子，网站使用微信认证的过程：</p><p> <img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image39.png"></p><ol><li>用户进入网站的登录页面，点击微信的图标以微信账号登录系统，<strong>用户</strong>是自己在微信里信息的<strong>资源拥有者</strong>。</li></ol><p> <img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image40.png"></p><p>点击“微信”出现一个二维码，此时用户扫描二维码，开始给网站授权。</p><p> <img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image41.png"></p><ol start="2"><li><strong>资源拥有者</strong>同意<strong>给客户端授权</strong></li></ol><p>　资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会<strong>颁发一个授权码</strong>，并<strong>重定向到网站</strong>。</p><ol start="3"><li><strong>客户端获取到授权码</strong>，请求<strong>认证服务器申请令牌</strong></li></ol><p>　此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。</p><ol start="4"><li>认证服务器向客户端响应令牌</li></ol><p>　认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。</p><ol start="5"><li>客户端请求资源服务器的资源</li></ol><p>　客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。</p><ol start="6"><li>资源服务器返回受保护资源</li></ol><p>　资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。</p><p>注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。</p><p>Oauth2.0认证流程如下：</p><p>引自Oauth2.0协议rfc6749 <a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p> <img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image42.png"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><strong>客户端</strong></p><p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。</p><p><strong>资源拥有者</strong></p><p>通常为<strong>用户</strong>，也可以是应用程序，即该资源的拥有者。</p><p><strong>授权服务器（也称认证服务器）</strong></p><p>用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。比如 微信方就是一个授权服务器</p><p><strong>资源服务器</strong></p><p><strong>存储资源的服务器</strong>，就是后端服务，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。</p><h2 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h2><h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p>授权码模式的流程大概是：用户访问资源，但是需要先去授权服务器请求然后授权，获取授权码，重定向URL拿着授权码去 授权服务器申请 token，返回token后，拿着 token 去后端访问接口</p><p><img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image-20220715155250509.png" alt="image-20220715155250509"></p><p><strong>基本配置：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springsecurityoauth2andsso.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/oauth/**&quot;</span>, <span class="string">&quot;/login/**&quot;</span>, <span class="string">&quot;/logout/**&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>认证服务器配置：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springsecurityoauth2andsso.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 授权服务器配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>资源服务器配置：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springsecurityoauth2andsso.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源服务器配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .requestMatchers()</span><br><span class="line">                <span class="comment">//配置需要保护的资源路径</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserService 登录用户名和密码配置：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        String password = passwordEncoder.encode(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取授权码：</strong></p><p><a href="http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=http://www.baidu.com&amp;scope=all">http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=http://www.baidu.com&amp;scope=all</a> </p><p><img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image-20220715160628189.png" alt="image-20220715160628189"></p><p><strong>登录后，授权</strong></p><p><img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image-20220715160708033.png" alt="image-20220715160708033"></p><p>授权后，跳转到了百度</p><p><img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image-20220715160726081.png" alt="image-20220715160726081"></p><p>URL后面就是我们的授权码</p><p>接下来就可以拿着这个授权码去申请token了，可以用 postman 测试，http//:localhost:8080/oauth/token</p><p><img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image-20220715160857928.png" alt="image-20220715160857928"></p><p>申请到token</p><p><img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image-20220715160911584.png" alt="image-20220715160911584"></p><ul><li><p><code>grant_type</code>：授权类型，填写authorization_code，表示授权码模式</p></li><li><p><code>code</code>：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。</p></li><li><p><code>client_id</code>:客户端标识</p></li><li><p><code>redirect_uri</code>：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。</p></li><li><p><code>scope</code>:授权范围。</p></li></ul><h3 id="简化授权模式"><a href="#简化授权模式" class="headerlink" title="简化授权模式"></a>简化授权模式</h3><p>简化授权模式和授权模式相比，少了授权的过程，直接获取token</p><p><img src="/../../img/markdown_img/SpringSecurity%20Oauth2.assets/image-20220715155506102.png" alt="image-20220715155506102"></p><h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>客户端直接向用户获取账户和密码，然后向授权服务器获取token</p><ol><li>直接在客户端输入自己在 认证服务器上的 用户名和密码</li><li>客户端带着输入的用户名和密码去认证服务器上认证，获取token</li><li>认证服务器返回token</li></ol><p>这种用户要输入用户名和密码经过客户端，不安全。</p><h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>客户端直接通过客户端认证（比如client_id和client_secret）从认证服务器获取访问令牌。</p><p>这种模式可以说有点不像 oauth 2了，它直接让客户端以自己的身份去申请token，然后返回token</p>]]></content>
    
    
    <summary type="html">SpringSecurity Oauth2，认证方案，4种模式</summary>
    
    
    
    <category term="SpringSecurity" scheme="http://ins1mn1a.github.io/categories/SpringSecurity/"/>
    
    
    <category term="Oauth2" scheme="http://ins1mn1a.github.io/tags/Oauth2/"/>
    
  </entry>
  
  <entry>
    <title>Java总结</title>
    <link href="http://ins1mn1a.github.io/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://ins1mn1a.github.io/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-17T02:47:08.163Z</published>
    <updated>2022-05-17T03:01:27.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>byte short int long float double boolean char</p><p>1      2      4   8      4        8        1        2</p><h3 id="为什么要有包装类"><a href="#为什么要有包装类" class="headerlink" title="为什么要有包装类"></a>为什么要有包装类</h3><p>Java 本身就一个面向对象的语言，这些基本数据类型是比较基础的数据类型，但又不是面向对象的。为了让基本数据类型也有对象的特征，就给每个基本数据类型都创建了包装类型，使得这些基本数据类型都有了对象的性质，并且添加了属性和方法</p><p>并且向集合中添加元素的时候，放入基本数据类型是放不进去的，容器都是装Object的，所以就使用包装类型，然后提供自动拆箱装箱完成转换</p><h3 id="int-和-Integer的区别-new-Integer-127-new-Integer-127-是true还是false"><a href="#int-和-Integer的区别-new-Integer-127-new-Integer-127-是true还是false" class="headerlink" title="int 和 Integer的区别 new Integer(127) == new Integer(127) 是true还是false"></a>int 和 Integer的区别 new Integer(127) == new Integer(127) 是true还是false</h3><p>int 是基本数据类型，Integer 是引用数据类型，属于int 的包装类型，可以通过自动拆箱和装箱转换。</p><p> new Integer(127) == new Integer(127) 返回false 比较地址值，属于不同对象</p><p>Integer c1 = 127;     Integer c2 = Integer.valueOf(127);  <strong>c1==c2 返回true</strong>，Java对**-128到127进行了缓存**，故相等</p><p>Integer d1 = 128;     Integer d2 = 128;  <strong>d1==d2 返回false</strong> <strong>128不适用于缓存</strong>，不相等</p><h3 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h3><p>String内的成员变量char数组 value是用final修饰的，并且是private，value的引用是不可变的，但是value内的值是可以通过反射改变的，String本身也是个final类，是不能被继承的，也保证了没有子类对其修改</p><p>其次，String内的一些方法，返回的值也是String，但是这些个String都是在返回的时候重新new出来的一个String，而不是原来那个了</p><p>String 的不可变，首先可以保证一定的线程安全性，它不可变，那他可以被多个线程共享</p><p>其次String 的不可变，String的hashcode在创建的时候被缓存了，像map中键一般采用String类型也就是这个原因，这样通过key做hash的时候速度就比较快</p><h3 id="Math-round-11-5-和Math-round-11-5"><a href="#Math-round-11-5-和Math-round-11-5" class="headerlink" title="Math.round(11.5)和Math.round(-11.5)"></a>Math.round(11.5)和Math.round(-11.5)</h3><p>Math.round()函数就是取整四舍五入，然后在参数的基础上加0.5然后再做向下取整，所以结果就是12，-11</p><h3 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h3><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化） 会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p><h3 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗</h3><p> 对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。 而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p><h3 id="关于boolean的默认值"><a href="#关于boolean的默认值" class="headerlink" title="关于boolean的默认值"></a>关于boolean的默认值</h3><p>局部变量boolean没有默认值，打印编译不通过没有初始化，</p><p>静态变量有默认值，为false</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306165357708.png" alt="image-20220306165357708"></p><h3 id="Cloneable，深拷贝、浅拷贝、零拷贝"><a href="#Cloneable，深拷贝、浅拷贝、零拷贝" class="headerlink" title="Cloneable，深拷贝、浅拷贝、零拷贝"></a>Cloneable，深拷贝、浅拷贝、零拷贝</h3><p><strong>深拷贝</strong>：把内存对象完全复制了一份，也就是说内存中存在有两份一模一样的对象</p><p><strong>浅拷贝</strong>：相当于多一个引用指向同一个堆中的对象，两个引用实际上还是一样的</p><p>在 Object 中有一个本地方法 clone()，一个对象想要调用这个 clone 方法，必须实现 Cloneable 接口，重写 clone() 方法，里面先调用 父类 Object 的clone方法 <code>Person clone = (Person) super.clone();</code></p><p>这样拷贝出来的对象是一个新的对象，但是对象里面的各种属性等等和原来的都是一样的。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final就是一个关键字，可以用来修饰类，属性，变量，方法，表示的意思就是最终的意思，不可变的意思在里面，修饰类，那么类就不能被继承，修饰属性，那么属性就不能再改变（引用），</p><p>修饰符（关键字）如果一个<strong>类</strong>被声明<strong>为final</strong>，意味着它<strong>不能再派生出新的子类</strong>，<strong>不能</strong>作为父类<strong>被继承</strong>。因此一个类<strong>不能</strong>既被声明<strong>为 abstract</strong>的，<strong>又</strong>被声明<strong>为final</strong>的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为<strong>final的变量</strong>必须在声明时<strong>给定初值</strong>，而在以后的<strong>引用中只能读取</strong>，<strong>不可修改</strong>。被声明为<strong>final的方法</strong>也同样<strong>只能使用</strong>，<strong>不能重载</strong>。</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>finally是在异常中<strong>try catch finally</strong>中用到的，finally表示无论是否捕获到异常都会去执行finally语句块里面的代码，守护线程除外，主要用于做一些<strong>事后处理的操作</strong>，比如<strong>释放锁</strong>等</p><p>异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。一般异常处理块需要。</p><p>如果在try 里面使用了return 语句，finally里的语句还是照样会执行的，在return语句把控制权转移给其他的方法前会执行finally语句</p><p><strong>try</strong> 有 <strong>return</strong> 语句，会执行 try 里的 return 语句，然后将<strong>返回结果保存到栈</strong>中，接着执行 <strong>finally</strong> 里的语句块，如果 <strong>finally</strong> 里有 <strong>return</strong> 语句，则会 <strong>返回 finally 里 return 的结果</strong>，并终止方法，<strong>栈中的 return 不会被完成</strong></p><h3 id="fianlize"><a href="#fianlize" class="headerlink" title="fianlize"></a>fianlize</h3><p><strong>方法名</strong>，<strong>fianlize()<strong>是</strong>Object中</strong>的一个<strong>方法</strong>，当垃圾回收器将要释放一个对象的内存的时候，它会调用该对象的finalize()方法</p><p>这个方法是由<strong>垃圾收集器</strong>在确定<strong>这个对象没有被引用时</strong>对这个对象<strong>调用的</strong>。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p><p>在Java中很不幸，<strong>如果内存总是充足的</strong>，那么<strong>垃圾回收可能永远不会进行</strong>，也就是说<strong>finalize()可能永远不被执行</strong>，显然指望它做收尾工作是靠不住的。</p><h3 id="public、protected、缺省、private范围"><a href="#public、protected、缺省、private范围" class="headerlink" title="public、protected、缺省、private范围"></a>public、protected、缺省、private范围</h3><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220412091654001.png" alt="image-20220412091654001"></p><h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>throw是主动抛出某个异常，throw后面跟一个异常对象，表示程序什么什么情况下，比如参数为null，if判断到后，就throw一个NullPointerException。</p><p>throws则是跟在方法后面，表示这个方法可能会抛出某个异常，处理方式只是往上抛，抛到调用这个方法的地方。否则就直接try catch捕获住，然后直接throw某个异常</p><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>我们不能强制java中的garbage collection进程，它只是一个守护线程。将System.gc()方法视为垃圾收集应该运行的 VM 的”提示”。显示调用只能说程序员建议System.gc()，但是JVM并不一定真正gc。</p><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p><strong>static</strong> 关键字主要是为了能够<strong>创建独立与对象之外的方法或者属性</strong>，以至于可以使得没有创建对象，也能使用属性和调用方法。此外还可以使用 static 关键字用来形成静态代码块来做些初始化工作，因为静态代码块只会在类加载的时候执行一次。</p><p>被static修饰的变量，表示是一个静态变量，这个静态变量不属于某一个对象，而是所有对象共享的变量。</p><p>被static修饰的方法，表示是一个静态方法，这个静态方法可以看做类级别的，直接通过类点方法名调用。</p><p>静态方法只能方法静态变量，非静态方法都可以访问</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类可以分为：</p><ol><li><p>成员内部类</p><ul><li><p>成员内部类中的方法可以访问外部类中所有的变量，不受控制符的影响</p></li><li><p>必须使用外部类的对象才能创建内部类的对象，不能直接 new 一个内部类对象</p></li><li><p>```java<br>public class InternalClass {</p><pre><code>private int a=1;private class InnerClazz&#123;    int b=2;    public void test()    &#123;        System.out.println(&quot;a：&quot;+a);        System.out.println(&quot;b：&quot;+b);    &#125;&#125;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 静态内部类</span><br><span class="line"></span><br><span class="line">   * 静态内部类就是用static修饰过的成员内部类</span><br><span class="line"></span><br><span class="line">   * 静态内部类不能直接访问外部类的非static成员，只能通过new对象的方式访问对象的非static</span><br><span class="line"></span><br><span class="line">   * 创建静态内部类的对象时，可以直接创建，不需要通过外部类的对象来创建</span><br><span class="line"></span><br><span class="line">   * &#96;&#96;&#96;java</span><br><span class="line">     public class InternalClass2 &#123;</span><br><span class="line">     </span><br><span class="line">         private int a&#x3D;1;</span><br><span class="line">     </span><br><span class="line">         static class InnerClazz&#123;</span><br><span class="line">             int b&#x3D;2;</span><br><span class="line">             public void test()</span><br><span class="line">             &#123;</span><br><span class="line">                 System.out.println(&quot;a：&quot;+new InternalClass2().a);</span><br><span class="line">                 System.out.println(&quot;b：&quot;+b);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方法内部类</p><ul><li><p>方法内部类就是定义在外部类的方法里面的类，只能在对应方法里面去访问到</p></li><li><p>```java<br>public class Outer {</p><pre><code>private int out_a=1;private static int static_b=2;void outMethod()&#123;    final int a=10;    class Inner&#123;        void innerMethod()&#123;            System.out.println(a);            System.out.println(out_a);            System.out.println(static_b);        &#125;    &#125;    new Inner().innerMethod();    System.out.println(a);&#125;public static void main(String[] args) &#123;    Outer outer = new Outer();    outer.outMethod();&#125;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 匿名内部类</span><br><span class="line"></span><br><span class="line">   * 匿名内部类必须继承一个抽象类或者实现一个接口</span><br><span class="line">   * 匿名内部类不能定义任何静态成员和静态方法</span><br><span class="line">   * 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final</span><br><span class="line">   * 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</span><br><span class="line"></span><br><span class="line">   * 对于某个接口的实现，可以在new的时候直接创建一个匿名内部类，实现对应的方法</span><br><span class="line"></span><br><span class="line">### 多态</span><br><span class="line"></span><br><span class="line">**多态**就是指在程序中定义的**引用变量**，具体**所指向的具体类型**以及通过**该引用变量调用的方法**在**编译**的**时**候并**不确定**，而是**在程序运行时期去确定的**。即一个**引用变量**到底是**什么类型**，调用的对应的方法到底是哪个实现类对应的方法编译的时候是无法确定的。</span><br><span class="line"></span><br><span class="line">**多态**分为**编译时多态**和**运行时多态**：</span><br><span class="line"></span><br><span class="line">* 编译时多态：主要指的是方法的重载，它根据参数列表的不同来区分不同的函数调用</span><br><span class="line">* 运行时多态：运行时多态就是常说的多态，在程序运行时才能确定的。父类或者接口定义的引用可以指向子类或者实现类的实例对象</span><br><span class="line"></span><br><span class="line">实现多态：</span><br><span class="line"></span><br><span class="line">* **方法重写**</span><br><span class="line">* **继承或者实现关系**</span><br><span class="line"></span><br><span class="line">## 排序算法</span><br><span class="line"></span><br><span class="line">![image-20220419083720096](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220419083720096.png)</span><br><span class="line"></span><br><span class="line">1. 堆排序</span><br><span class="line">   * 按照给定的数组，构建一个完全二叉树</span><br><span class="line">   * 从最后一个非叶子节点 树中索引 n&#x2F;2 -1 开始，大顶堆就把它这个节点和它的子树进行比较交换，选择一个最大的</span><br><span class="line">   * 接着选定下一个非叶子节点，一直到根节点</span><br><span class="line">   * 排序：取出根节点，根节点就是最大值，然后把最后一个叶子节点取出来放到根节点，维护成一个大顶堆</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## JVM</span><br><span class="line"></span><br><span class="line">### Java代码执行过程理解JVM内存划分</span><br><span class="line"></span><br><span class="line">**结合一段Java代码的执行理解内存划分**</span><br><span class="line"></span><br><span class="line">![image-20220217220809311](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220217220809311.png)</span><br><span class="line"></span><br><span class="line">* 执行javac命令编译源代码为字节码</span><br><span class="line">* 执行java命令</span><br><span class="line">  1. 创建JVM，调用类加载子系统**加载class**，将类的信息存入**方法区**</span><br><span class="line">  2. 创建main线程，使用的内存区域是**JVM虚拟机栈**，开始执行main方法代码</span><br><span class="line">  3. 如果遇到了未见过的类，会继续触发类加载过程，同样会存入**方法区**</span><br><span class="line">  4. 需要创建**对象**，会使用**堆内存**来存储对象</span><br><span class="line">  5. 不再使用的对象，会由**垃圾回收器**在内存不足时回收其内存</span><br><span class="line">  6. 调用方法时，**方法内的局部变量、方法参数**所使用的是**JVM虚拟机栈**中的**栈帧内存**</span><br><span class="line">  7. 调用方法时，先要到**方法区**获得到该方法的字节码指令，由**解释器**将**字节码指令解释为机器码**执行</span><br><span class="line">  8. 调用方法时，会将要执行的指令行号读到**程序计数器**，这样当**发生了线程切换**，**恢复**时就可以从中断的位置继续</span><br><span class="line">  9. 对于非Java实现的方法调用，使用内存称为**本地方法栈**</span><br><span class="line">  10. 对于**热点方法调用**，或者**频繁的循环代码**，由**JIT即使编译器**将这些代码编译成机器码缓存，提高执行性能</span><br><span class="line"></span><br><span class="line">说明</span><br><span class="line"></span><br><span class="line">* 对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</span><br><span class="line"></span><br><span class="line">**会发生内存溢出的区域**</span><br><span class="line"></span><br><span class="line">* 不会出现内存溢出的区域 - 程序计数器</span><br><span class="line">* 出现OOM（OutOfMemoryError）的情况</span><br><span class="line">  * **堆内存耗尽** — 对象越来越多，又一直在使用，不能被垃圾回收</span><br><span class="line">  * **方法区内存耗尽** — 加载的类越来越多，很多框架都会在运行期间动态产生新的类</span><br><span class="line">  * **虚拟机栈累积** — 每个线程最多会占用1M内存，线程个数越来越多，而又长时间运行不销毁时</span><br><span class="line">* 出现 **StackOverflowError** 的区域</span><br><span class="line">  * **JVM虚拟机栈**，原因有**方法递归调用未正确结束**，**反序列化 json 时循环引用**</span><br><span class="line"></span><br><span class="line">### JVM常量池</span><br><span class="line"></span><br><span class="line">JVM的常量池，实际上划分为两种形态：静态常量池和动态常量池</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 字符串常量池</span><br><span class="line"></span><br><span class="line">字符串常量池存在堆内存中</span><br><span class="line"></span><br><span class="line">**字符串常量池为什么要移动到堆空间中？**</span><br><span class="line">个人的理解：对于字符串常量这种创建完成用几次就不被使用的对象，是很容易被回收的。而要进行频繁垃圾回收的地方是堆空间， 这样在JDK7就把字符串[常量池](https:&#x2F;&#x2F;so.csdn.net&#x2F;so&#x2F;search?q&#x3D;常量池&amp;spm&#x3D;1001.2101.3001.7020)移动到堆空间中就是很明智和有必要的选择了。</span><br><span class="line"></span><br><span class="line">**字符串常量池的设计思想**：</span><br><span class="line"></span><br><span class="line">* 字符串的分配，和其他对象一样，频繁的分配字符串的内存也需要消耗大量的资源</span><br><span class="line">* JVM 为了提高性能和减小内存开销，在实例化字符串常量的时候进行了一些优化</span><br><span class="line">  * 为字符串开辟一个字符串常量池，类似于缓冲区</span><br><span class="line">  * 创建字符串常量时，首先判断字符串常量池是否存在该字符串</span><br><span class="line">  * 存在该字符串，返回引用实例，不存在，就实例化该字符串并放入常量池</span><br><span class="line">* 实现基础</span><br><span class="line">  * 因为String 是不可变的，因此不用担心字符串共享产生的问题</span><br><span class="line">  * 运行时，实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JVM的几个组成部分</span><br><span class="line"></span><br><span class="line">JVM包含两个子系统和两个组件，共4个组成部分，**两个子系统**分别为：**类加载器**(ClassLoader)、**执行引擎**(Execution Engine)、**两个组件**分别为：**运行时数据区**(Runtime Data Area)、**本地接口**(Native interface)</span><br><span class="line"></span><br><span class="line">![image-20220214145053735](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220214145053735.png)</span><br><span class="line"></span><br><span class="line">**类加载器**：就是把字节码文件加载到运行时数据区的method area 方法区中</span><br><span class="line"></span><br><span class="line">**运行时数据区**：也就是常说的JVM的内存</span><br><span class="line"></span><br><span class="line">**执行引擎**：就是执行classes中的指令，包括有JIT即使编译器、GC垃圾回收器</span><br><span class="line"></span><br><span class="line">**本地接口**：就是底层和不同语言交互的接口，同一些本地库相关联</span><br><span class="line"></span><br><span class="line">执行流程就是：先把Java代码编译成字节码文件，然后类加载器就加载字节码文件到Method Area中，而字节码只是JVM的一套指令集规范，并不能直接交给底层的操作系统去执行，因此就需要特点的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由CPU执行，而这个过程中需要调用其他语言的本地接口（Native Interface）来实现整个程序的功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JVM类加载机制</span><br><span class="line"></span><br><span class="line">#### 简述java类加载机制</span><br><span class="line"></span><br><span class="line">虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的java类型。类加载器负责读取Java字节码，并转换成Java.lang.Class类的一个实例</span><br><span class="line"></span><br><span class="line">#### JVM加载Class文件的原理机制</span><br><span class="line"></span><br><span class="line">Java中的所有**类**，都需要**被类加载器加载**到**JVM的方法区**中，然后由**执行引擎去解析**最终被底层操作系统执行。**类加载器本身也是一个类**，**加载类**就是把**Class文件**从**硬盘**中**加载到内存**中去。</span><br><span class="line"></span><br><span class="line">加载的方式一般有两种：</span><br><span class="line"></span><br><span class="line">* 隐式加载：就是在程序中使用new关键字等方式创建出来的对象，隐式的调用类加载器加载对应的类到JVM中</span><br><span class="line">* 显式加载：通过Class.forname()、类.class或者说 对象.getClass()方法获取到字节码对象，显式加载所需要的类</span><br><span class="line"></span><br><span class="line">Java**类的加载**是动态（**懒惰**）的，**它并不会一次性将所有类全部加载后再运行**，而是保证程序运行的基础类完全加载到JVM中，至于其他类，则是在需要的时候才加载，从而节省内存开销</span><br><span class="line"></span><br><span class="line">#### 类加载器及其种类</span><br><span class="line"></span><br><span class="line">实现通过类的全限定类名来获取该类的二进制字节流的代码块叫做类加载器。</span><br><span class="line"></span><br><span class="line">主要有四种类加载器：</span><br><span class="line"></span><br><span class="line">1. 启动类加载器（Bootstrap ClassLoader）用来加载Java核心类库，无法被Java程序直接引用。是虚拟机自身的一部分，用来加载 Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库</span><br><span class="line">2. 扩展类加载器（Extensions ClassLoader）用来加载Java的扩展库，Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载Java类。如读取JRE&#x2F;lib&#x2F;ext&#x2F;*.jar中的包等</span><br><span class="line">3. 应用程序类加载器（Application ClassLoader）根据Java应用的类路径（CLASSPATH）来加载Java类。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它</span><br><span class="line">4. 用户自定义类加载器，通过继承java.lang.ClassLoader类的方式实现</span><br><span class="line"></span><br><span class="line">#### 类加载的执行过程</span><br><span class="line"></span><br><span class="line">类加载的执行过程分为加载、链接、初始化。链接又分为验证、准备、解析</span><br><span class="line"></span><br><span class="line">* **加载**：将class字节码文件加载到内存中</span><br><span class="line">* **链接**：</span><br><span class="line">  * **验证**：**检查**加载的class文件的**正确性**，确保没有问题</span><br><span class="line">  * **准备**：给类中的**静态变量分配内存空间**</span><br><span class="line">  * **解析**：虚拟机将**常量池**中的**符号引用**替换成**直接引用**（地址引用）的过程。符号引用就理解为一个标识，而在直接引用直接指向内存中的地址</span><br><span class="line">    * 符号引用：符号引用就是一个字符串，他给出一个名字，就好比类的全限定类名，必须要求通过这个字符串能唯一找到对应的引用</span><br><span class="line">    * 直接引用：直接引用就是指向类、方法、字段的指针或者偏移量</span><br><span class="line">* **初始化**：对静态变量和静态代码块执行初始化工作</span><br><span class="line"></span><br><span class="line">#### 双亲委派模型</span><br><span class="line"></span><br><span class="line">![image-20220214161654695](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220214161654695.png)</span><br><span class="line"></span><br><span class="line">如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类</span><br><span class="line"></span><br><span class="line">当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">双亲委派模型的具体实现主要在ClassLoader的loadClass()方法中，首先检查父类有没有去加载过，没有则让父类去加载，当父类抛出ClassNotFoundException的时候才让自己去加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### java类加载为什么采用双亲委派模型</span><br><span class="line"></span><br><span class="line">如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载（因为它在jdk8&#x2F;lib&#x2F;rt.jar中），因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。这样，会委派给启动类加载器去加载到rt.jar中的Object类</span><br><span class="line"></span><br><span class="line">#### 如何打破双亲委派机制</span><br><span class="line"></span><br><span class="line">1. 重写loadClass()方法破坏双亲委派模型</span><br><span class="line"></span><br><span class="line">   类加载器的加载方法的逻辑主要就在loadClass()方法中，里面的逻辑就是先判断当前类是否已经被加载过，如果没有加载过就将委派给父类加载器，如果父类加载器无法加载则向下传递，回来由自己进行加载。如果我们把这个方法重写了就能实现自定义的加载逻辑，就可以打破双亲委派模型</span><br><span class="line"></span><br><span class="line">2. 线程上下文加载器破坏双亲委派机制</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### new 一个对象发生了什么</span><br><span class="line"></span><br><span class="line">![image-20220405094342381](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220405094342381.png)</span><br><span class="line"></span><br><span class="line">**一、类加载**</span><br><span class="line"></span><br><span class="line">1. 看new 的那个类是否加载，没有加载则采用双亲委派模型进行类加载。</span><br><span class="line">2. 类加载过程：把字节码加载到方法区，验证字节码文件的正确性，为静态变量分配内存空间，将符号引用替换为直接引用，初始化为静态变量赋值、加载静态代码块</span><br><span class="line"></span><br><span class="line">**二、创建对象**</span><br><span class="line"></span><br><span class="line">1. 在堆区给**对象分配**需要的**空间**</span><br><span class="line">   * 分配的内存包括本类和父类的实例变量，静态变量不分配</span><br><span class="line">2. 对所有**实例变量设置默认值**</span><br><span class="line">   * 将方法区中对实例变量的定义拷贝一份，然后赋默认值</span><br><span class="line">3. **设置对象头**</span><br><span class="line">   * 设置新对象的哈希码、GC分代年龄、锁信息、对象所属类元信息</span><br><span class="line">4. 执行实例**初始化**代码</span><br><span class="line">   * 初始化成员变量，执行实例化代码块，调用构造方法，并将堆内对象的首地址赋值给引用变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Java内存</span><br><span class="line"></span><br><span class="line">![image-20220214163528925](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220214163528925.png)</span><br><span class="line"></span><br><span class="line">Java 虚拟机规范规定的区域分为以下 5 个部分： </span><br><span class="line"></span><br><span class="line">* **程序计数器**（Program Counter Register）：用于**保存当前线程执行的内存地址**。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。</span><br><span class="line">* **Java 虚拟机栈**（Java Virtual Machine Stacks）：用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息，是**每个线程所私有**的，每个**线程创建的同时会创建JVM栈**，栈中是**基本数据类型**和**堆中对象的引用**</span><br><span class="line">* **本地方法栈**（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而**本地方法栈**是**为虚拟机调用 Native 方法服务**的； </span><br><span class="line">* **Java 堆**（Java Heap）：Java 虚拟机中内存最大的一块，是**被所有线程共享**的，几乎所有的对象实例都在这里分配内存； 它是JVM用来**存储对象实例以及数组**值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收，Heap在32位的操作系统上最大为2G，在64位的操作系统上则没有限制，其大小通过-Xms和-Xmx来控制</span><br><span class="line">* **方法区**（Methed Area）：用于**存储**已被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译后的代码**等数据</span><br><span class="line"></span><br><span class="line">### 栈帧</span><br><span class="line"></span><br><span class="line">**栈帧** Stack Frame 是用来支持虚拟机进行**方法调用**和**方法执行**的数据结构，它是虚拟机运行时数据区中的**虚拟机栈的栈元素**。</span><br><span class="line"></span><br><span class="line">栈帧 Stack Frame 存储了方法的局部变量表、操作数栈、动态连接、和方法返回地址、额外的附加信息。</span><br><span class="line"></span><br><span class="line">每个方法在执行的同时，都会创建一个栈帧(Stack Frame)。**每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。**</span><br><span class="line"></span><br><span class="line">### 堆栈的区别</span><br><span class="line"></span><br><span class="line">1. 物理地址</span><br><span class="line"></span><br><span class="line">   堆的物理地址是不连续的，因此性能相对会比较慢，这样在GC的时候需要考虑的就更多，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记-压缩）</span><br><span class="line"></span><br><span class="line">2. 内存分配时期</span><br><span class="line"></span><br><span class="line">   堆中的内存因为是不连续的，所以需要在**运行期**确认大小，因此大小不固定。一般堆大小远大于栈。而栈的内存是连续分配的，所以一般在**编译时**就已经确定了内存大小，大小是固定的</span><br><span class="line"></span><br><span class="line">3. 存放的内容</span><br><span class="line"></span><br><span class="line">   **堆中更关注内存的存储**，因此堆中一般存放的是**对象实例**，或者**数组**</span><br><span class="line"></span><br><span class="line">   **栈更关注程序方法的执行**，因此栈内存中一般存放：**局部变量**，操作数栈，返回结果，对象的引用地址等。</span><br><span class="line"></span><br><span class="line">4. 可见性</span><br><span class="line"></span><br><span class="line">   栈中的数据线程之间是不共享的，堆中的内存线程之间是共享的</span><br><span class="line"></span><br><span class="line">### OOM，Java会存在内存泄漏吗？请简单描述 </span><br><span class="line"></span><br><span class="line">**会发生内存溢出的区域**</span><br><span class="line"></span><br><span class="line">* 不会出现内存溢出的区域 - 程序计数器</span><br><span class="line"></span><br><span class="line">* **出现OOM（OutOfMemoryError）的情况**</span><br><span class="line">  * **堆内存耗尽** — 对象越来越多，又一直在使用，不能被垃圾回收</span><br><span class="line">  </span><br><span class="line">    &#96;&#96;&#96;java</span><br><span class="line">    比如使用了Executors工具类中创建线程池的方法，比如newFixedThreadPool和newSingleThreadPool这些线程池的阻塞队列都是无界的，很有可能让阻塞队列拉满，导致内存溢出</span><br></pre></td></tr></table></figure></li><li><p>*解决方法**：</p></li></ul><p> 不要用这种new线程池，可以修改堆内存的大小-Xmx，扩大最大堆内存</p></li></ol><ul><li><strong>方法区内存耗尽</strong> — 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li><li><strong>虚拟机栈累积</strong> — 每个线程最多会占用1M内存，线程个数越来越多，而又长时间运行不销毁时<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比如使用了Executors工具类中创建线程池的方法，比如newScheduledThreadPool和newCachedThreadPool这些线程池的能创建的线程都是无限的，很有可能创建很多线程，导致内存溢出</span><br></pre></td></tr></table></figure></li><li>出现 <strong>StackOverflowError</strong> 的区域<ul><li><strong>JVM虚拟机栈</strong>，原因有<strong>方法递归调用未正确结束</strong>，<strong>反序列化 json 时循环引用</strong></li></ul></li></ul><p><strong>内存泄漏</strong>是指<strong>不再被使用的对象或者变量一直被占据在内存中</strong>。理论上来说， Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。 但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：<strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>， 尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导 致不能被回收，这就是java中内存泄露的发生场景</p><h3 id="JVM-server模式-和-client模式"><a href="#JVM-server模式-和-client模式" class="headerlink" title="JVM server模式 和 client模式"></a>JVM server模式 和 client模式</h3><p>JVM 有两种运行模式 Server 和 Client 模式</p><p><strong>Client</strong> 模式：采用较为轻量级的虚拟机来启动程序，<strong>采用代号为C1的轻量级编译器</strong>，因此 程序<strong>启动较快</strong>，<strong>内存占用少</strong>，<strong>编译快</strong>，<strong>针对桌面应用程序优化</strong>，为在客户端环境中<strong>减少启动时间</strong>而优化 </p><p><strong>Server</strong> 模式：采用较为重量级的虚拟机来启动程序，<strong>采用相对重量级代号为C2的编译器</strong>，因此 程序<strong>启动较慢</strong>，但是 <strong>编译得更完全</strong>，<strong>针对服务器应用优化</strong>，<strong>整个程序跑起来以后，性能会很高</strong></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="简述垃圾回收机制"><a href="#简述垃圾回收机制" class="headerlink" title="简述垃圾回收机制"></a>简述垃圾回收机制</h3><p>Java程序一般是不需要我们去管理其内存的回收，对象的释放，也就是垃圾回收。JVM中的垃圾回收线程是一个守护线程，它是低优先级的，正常情况下是不会执行的，它只有在虚拟机空闲或者当前堆内存不足的时候才会触发执行，扫描那些没有被引用的对象，并将它们添加到回收的集合中，进行回收。</p><h3 id="对象引用的类型强、软、弱、虚"><a href="#对象引用的类型强、软、弱、虚" class="headerlink" title="对象引用的类型强、软、弱、虚"></a><strong>对象引用的类型强、软、弱、虚</strong></h3><p><strong>强引用</strong>：</p><ul><li><p>普通变量赋值就是强引用，<code>A a=new A();</code></p></li><li><p>通过GC Root的引用链，如果强引用找不到该对象，该对象才能被回收</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307135659131.png" alt="image-20220307135659131"></p></li></ul><p><strong>软引用</strong>：</p><ul><li><p><code>SoftReference a = new SoftReference(new A())</code></p></li><li><p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍然不足，再次回收的时候才会释放对象</p></li><li><p>回收的时候只是回收后面的A对象，软引用本身不会释放，软引用自身需要配合引用队列来释放</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307135945240.png" alt="image-20220307135945240"></p></li></ul><p><strong>弱引用</strong>：</p><ul><li><p><code>WeakReference a = new WeakReference(new A())</code></p></li><li><p>如果仅有弱引用引用该对象，只要发生垃圾回收，就会释放该对象</p></li><li><p>同样，弱引用本身要配合引用队列来释放</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307140118825.png" alt="image-20220307140118825"></p></li></ul><p><strong>虚引用</strong>：</p><ul><li><p><code>PhantomReference a =new PhantomReference(new A())</code></p></li><li><p>必须配合引用队列一起使用，当虚引用引用的对象被回收时，会将虚引用对象入队，有Reference Handler线程释放其关联的外部资源</p></li><li><p>除了释放a、b对象以外，还要将虚引用对象入队，找出哪些对象被回收了，然后由Reference Handler线程释放掉其关联的外部资源</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307140553303.png" alt="image-20220307140553303"></p></li></ul><h3 id="什么是GC，为什么要GC"><a href="#什么是GC，为什么要GC" class="headerlink" title="什么是GC，为什么要GC"></a>什么是GC，为什么要GC</h3><p>GC就是Garbage Collection，垃圾回收，内存处理是程序员最容易出现问题的地方，忘记或者错误的内存回收将会导致程序或系统的不稳定甚至是崩溃，Java提供GC功能，不需要程序员去关注内存的回收，这些都由JVM中的垃圾回收线程去处理，这极大的方便了开发，提高了开发效率，也正是这样，因此Java对内存的控制，其实是比较粗糙的</p><h3 id="怎么判断对象是否可以回收"><a href="#怎么判断对象是否可以回收" class="headerlink" title="怎么判断对象是否可以回收"></a>怎么判断对象是否可以回收</h3><p>垃圾收集器必须完成的两件事就是：垃圾检测、垃圾回收。首先需要判定哪些内存是需要被回收的，哪些对象是存活的，不可以被回收；哪些对象已经死掉了，需要被回收</p><p>一般有两种方法来判断垃圾是否可回收</p><ul><li><p>引用计数法</p><p>为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0的时候就可以被回收。但是其有一个明显的缺点：<strong>不能解决循环引用的问题</strong>。也就是说我有两个对象，他们之间互相引用，除此之外没有其他对象引用它们，实际上这两个对象已经无法访问，也就是说是垃圾对象，但又因为是相互引用，计数不为0，导致无法回收。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> A();</span><br><span class="line">B b=<span class="keyword">new</span> B();</span><br><span class="line">a.setB(b);</span><br><span class="line">b.setA(a);</span><br></pre></td></tr></table></figure></li><li><p>可达性分析算法：从根集对象（GC Roots）出发向下搜索，搜索所走过的路径称为引用链。当<strong>一个对象到GC Roots没有任何引用链相连</strong>时候（<strong>也就是说这个对象不可达</strong>），则证明此对象是可以被回收的</p></li></ul><h3 id="哪些对象可以作为GC-ROOTS对象"><a href="#哪些对象可以作为GC-ROOTS对象" class="headerlink" title="哪些对象可以作为GC ROOTS对象"></a>哪些对象可以作为GC ROOTS对象</h3><p>主要是有四种对象：</p><ol><li>虚拟机栈中的对象</li><li>本地方法栈中<strong>Native方法引用的对象</strong></li><li>方法区中类<strong>静态属性引用的对象</strong></li><li>方法区中<strong>常量引用的对象</strong></li></ol><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><ol><li><p><strong>标记-清除</strong>（Mark-Sweep）</p><p>算法和名字一样，分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的</p><p>不足：标记、清除效率低；标记清除之后会<strong>产生大量不连续的内存碎片</strong></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220214203643235.png" alt="image-20220214203643235"></p></li><li><p><strong>复制</strong></p><p>此算法把内存空间划分为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现<strong>“内存碎片”</strong>问题。</p><p>不足：这样就<strong>需要两倍的内存空间</strong></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220214203937400.png" alt="image-20220214203937400"></p></li><li><p><strong>标记-整理</strong>（Mark-Compact）</p><p>在<strong>新生代</strong>中可以使用复制算法，但是在<strong>老年代</strong>就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除 算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片</p><p>因此算法结合了“标记清除”和“复制”算法的优点。同样的，分两个阶段，第一个阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220214204425385.png" alt="image-20220214204425385"></p></li><li><p><strong>分代收集算法</strong></p><p>这是当前商业虚拟机常用的垃圾收集算法。分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不<strong>同生命周期的对象可以采取不同的收集方式</strong>，以便提高回收效率。一般包括<strong>年轻代</strong>、<strong>老年代</strong>、<strong>永久代</strong></p><ul><li>对新生代的对象的收集称为Minor GC</li><li>对旧生代的对象的收集称为Full GC</li><li>程序中主动调用System.gc()或者Runtime.gc()强制执行的GC为Full GC</li></ul></li></ol><h3 id="为什么要运用分代垃圾回收策略"><a href="#为什么要运用分代垃圾回收策略" class="headerlink" title="为什么要运用分代垃圾回收策略"></a>为什么要运用分代垃圾回收策略</h3><p>GC 大都采用了<strong>分代回收思想</strong></p><ul><li>理论依据是<strong>大部分对象朝生夕灭</strong>，<strong>用完立刻就可以回收</strong>，另有<strong>少部分对象</strong>会<strong>长时间存活</strong>，每次很难回收</li><li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，<strong>新生代</strong>采用<strong>标记复制</strong>法、<strong>老年代</strong>一般采用<strong>标记整理</strong>法</li></ul><p>在Java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同，所具有的<strong>生命周期</strong>也<strong>不同</strong>；有的对象<strong>生命周期较长</strong>，比如Http请求中的<strong>Session</strong>对象，<strong>线程</strong>，<strong>Socket连接</strong>等；有的对象<strong>生命周期较短</strong>，比如<strong>String对象</strong>，由于其<strong>不变类</strong>的特性，有的在使用一次后即可回收。如果不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在不同的代上使用不同的垃圾回收方式</p><p>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></p><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h3><ol><li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213622704.png" alt="image-20210831213622704"></p><ol start="2"><li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213640110.png" alt="image-20210831213640110"></p><ol start="3"><li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213657861.png" alt="image-20210831213657861"></p><ol start="4"><li>将 from 和 to 交换位置</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213708776.png" alt="image-20210831213708776"></p><ol start="5"><li>经过一段时间后伊甸园的内存又出现不足</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213724858.png" alt="image-20210831213724858"></p><ol start="6"><li>标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213737669.png" alt="image-20210831213737669"></p><ol start="7"><li>将存活对象采用复制算法复制到 to 中</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213804315.png" alt="image-20210831213804315"></p><ol start="8"><li>复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213815371.png" alt="image-20210831213815371"></p><ol start="9"><li>将 from 和 to 交换位置</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213826017.png" alt="image-20210831213826017"></p><ol start="10"><li>老年代 old，当<strong>幸存区对象熬过几次回收（最多15次）</strong>，晋升到老年代（<strong>幸存区内存不足</strong>或<strong>大对象</strong>会导致提前晋升）</li></ol><h3 id="什么时候对象进入老年代"><a href="#什么时候对象进入老年代" class="headerlink" title="什么时候对象进入老年代"></a>什么时候对象<strong>进入老年代</strong></h3><ol><li><p><strong>大对象提前晋升</strong>：虚拟机提供了一个阈值参数，大于这个参数的对象的内存就直接到老年代中去分配。如果大对象进入到了新生代，采用 复制 算法去做垃圾回收的时候，就会导致在 eden 和 survivor 区中进行 大量的内存复制</p><p><strong>CMS(老年代） 配合 Serial 和 ParNew(年轻代)<strong>：可以</strong>参数设置</strong> 进入老年代。</p><p><strong>G1</strong>：当一个对象<strong>大小超过 Region 区的一半</strong>的时候，会是大对象，堆中会分配连续的（Homongous Region）区来存放 </p></li><li><p><strong>长期存活的对象进入老年代</strong>：通过 JVM 参数：<code>-XX:MaxTenuringThreshold</code> 来设置，默认是15岁，eden 到 survivor 中超过了 <strong>15</strong> 次就进入老年代</p></li><li><p><strong>动态对象年龄判断</strong>：在 Survivor 区中，<strong>年龄相同的对象</strong>，<strong>大小总和大于 Survivor 区总空间大小的一半</strong>，那么<strong>大于等于这个年龄的对象都会进入老年代</strong></p></li><li><p><strong>空间分配担保</strong>：当 <strong>Survivor 区空间不够</strong>的时候，就会通过 <strong>分配担保机制</strong>，将多出来的<strong>对象提前转移到老年代</strong>。为了 <strong>确保老年代的空间还有容纳这些对象的剩余空间</strong>，就取之前每次晋升到老年代的<strong>对象的大小的平均值</strong>作为经验值，与老年代的<strong>剩余空间做对比</strong>（因为无法提前知道会有多少对象存活下来）</p></li></ol><h3 id="Minor-GC、Mixed-GC、Full-GC"><a href="#Minor-GC、Mixed-GC、Full-GC" class="headerlink" title="Minor GC、Mixed GC、Full GC"></a>Minor GC、Mixed GC、Full GC</h3><p><strong>GC 规模</strong></p><ul><li><strong>Minor GC</strong> 发生在<strong>新生代的垃圾回收</strong>，<strong>Eden区空间不足的时候就会触发一次</strong>，<strong>暂停时间短</strong><ul><li><strong>触发时机</strong><ol><li>Eden区空间不足</li></ol></li></ul></li><li><strong>Mixed GC</strong> 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</li><li><strong>Full GC</strong> <strong>新生代 + 老年代完整垃圾回收</strong>，暂停时间长，<strong>应尽力避免</strong><ul><li><strong>触发时机</strong>：<ol><li><strong>旧生代空间不足</strong></li><li>显式调用 System.gc()</li><li>统计得到的 <strong>Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</strong></li></ol></li></ul></li></ul><h3 id="并发标记算法——三色标记与并发漏标问题"><a href="#并发标记算法——三色标记与并发漏标问题" class="headerlink" title="并发标记算法——三色标记与并发漏标问题"></a>并发标记算法——三色标记与并发漏标问题</h3><p><strong>三色标记</strong></p><p>即用三种颜色记录对象的标记状态</p><ul><li>黑色 – 已标记</li><li>灰色 – 标记中</li><li>白色 – 还未标记</li></ul><ol><li>起始的三个对象还未处理完成，用灰色表示</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;" /><ol start="2"><li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;" /><ol start="3"><li>依次类推</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;" /><ol start="4"><li>沿着引用链都标记了一遍</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;" /><ol start="5"><li>最后为标记的白色对象，即为垃圾</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;" /><p><strong>并发漏标问题</strong></p><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p><ol><li>如图所示标记工作尚未完成</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;" /><ol start="2"><li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;" /><ol start="3"><li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;" /><ol start="4"><li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;" /><p>因此对于<strong>并发标记</strong>而言，必须解决<strong>漏标问题</strong>，也就是要记录标记过程中的变化。有两种解决方法：</p><ol><li><strong>Incremental Update 增量更新法</strong>，<strong>CMS 垃圾回收器采用</strong><ul><li><strong>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</strong></li></ul></li><li><strong>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用</strong><ul><li>思路也是拦截每次赋值动作，不过<strong>记录的对象不同，记录的不再是黑色对象，而是新加对象或者被删除引用的对象</strong>，也需要在重新标记阶段对这些对象二次处理</li><li><strong>新加对象会被记录</strong></li><li><strong>被删除引用关系的对象也被记录</strong></li></ul></li></ol><h3 id="有哪些垃圾回收器"><a href="#有哪些垃圾回收器" class="headerlink" title="有哪些垃圾回收器"></a><strong>有哪些垃圾回收器</strong></h3><p><strong>垃圾回收器 - SerialGC</strong></p><ul><li><strong>串行</strong>垃圾回收器</li><li><strong>新生代</strong>采用<strong>复制算法</strong>，<strong>老年代</strong>采用 <strong>标记整理算法</strong></li><li><strong>单线程执行</strong>，一条垃圾回收线程进行垃圾回收</li><li>工作的时候都会 <strong>STW</strong>，直到收集结束</li></ul><p><strong>垃圾回收器 - Parallel Scavenge GC</strong></p><ul><li><strong>eden 内存</strong>不足发生 Minor GC，采用<strong>标记复制</strong>算法，需要暂停用户线程</li><li><strong>old 内存</strong>不足发生 Full GC，采用<strong>标记整理</strong>算法，需要暂停用户线程</li><li><strong>虽然会暂停用户线程，但是它会启动多个线程来一起回收，注重吞吐量</strong></li><li>可以使用参数 <code>-XX:ParallelGCThreads</code> 指定收集线程数，默认和CPU核心数相同</li></ul><p><strong>垃圾回收器 - ParNew收集器(-XX:+UseParNewGC)</strong></p><ul><li><strong>ParNew收集器</strong>其实<strong>跟Parallel收集器</strong>很<strong>类似</strong>，区别主要在于它可以和CMS收集器配合使用</li><li><strong>新生代</strong>采用<strong>复制</strong>算法，<strong>老年代</strong>采用<strong>标记-整理</strong>算法</li><li>运行在<strong>Server模式</strong>下的虚拟机的首要选择，除了Serial收集器外，只有它<strong>能与CMS收集器配合工作</strong></li></ul><h3 id="CMS-和-G1-的区别"><a href="#CMS-和-G1-的区别" class="headerlink" title="CMS 和 G1 的区别"></a>CMS 和 G1 的区别</h3><ol><li>CMS 工作于老年代，G1 适用于新生代，也适用于老年代</li><li>CMS 主要基于 标记-清除 算法，G1 则采用 标记-整理 算法</li><li>回收过程不同</li></ol><h3 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h3><p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p><ul><li>它是工作在 <strong>old 老年代</strong>，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法<ul><li>并发标记时不需暂停用户线程</li><li>重新标记时仍需暂停用户线程</li></ul></li><li>如果<strong>并发失败</strong>（即回收速度赶不上创建新对象速度），<strong>会触发 Full GC</strong></li><li><strong>注重响应时间</strong></li></ul><p><strong>回收过程</strong></p><ol><li>初始化标记：标记一些GC ROOTS对象，这个过程会STW(Stop The World)</li><li>并发标记：根据GC ROOTS对象并发的标记回收对象</li><li>重新标记：解决漏标问题</li><li>并发清理：并发清理</li><li>重置：CMS重置内部状态，准备下一并发回收期。重置CMS收集器的数据结构，等待下一次回收</li></ol><p><strong>优点</strong>： 并发收集低停顿</p><p><strong>缺点</strong>： 并发执行，对CPU资源压力大， 采用的<strong>标记清除算法</strong>会导致大量碎片</p><h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h3><p><strong>垃圾回收器 - G1 GC</strong></p><ul><li><strong>响应时间与吞吐量兼顾</strong></li><li><strong>划分</strong>成多个<strong>区域Region</strong>，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>分成三个阶段：<ol><li><strong>新生代回收</strong></li><li><strong>并发标记</strong></li><li><strong>混合收集</strong></li></ol></li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><strong>回收过程</strong></p><h4 id="G1-回收阶段-新生代回收"><a href="#G1-回收阶段-新生代回收" class="headerlink" title="G1 回收阶段 - 新生代回收"></a><strong>G1 回收阶段 - 新生代回收</strong></h4><ol><li>初始时，所有区域都处于空闲状态</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222639754.png" alt="image-20210831222639754" style="zoom:50%;" /><ol start="2"><li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222653802.png" alt="image-20210831222653802" style="zoom:50%;" /><ol start="3"><li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222705814.png" alt="image-20210831222705814" style="zoom:50%;" /><ol start="4"><li>复制完成，将之前的伊甸园内存释放</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222724999.png" alt="image-20210831222724999" style="zoom:50%;" /><ol start="5"><li>随着时间流逝，伊甸园的内存又有不足</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222737928.png" alt="image-20210831222737928" style="zoom:50%;" /><ol start="6"><li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222752787.png" alt="image-20210831222752787" style="zoom:50%;" /><ol start="7"><li>释放伊甸园以及之前幸存区的内存</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222803281.png" alt="image-20210831222803281" style="zoom:50%;" /><h4 id="G1-回收阶段-并发标记与混合收集"><a href="#G1-回收阶段-并发标记与混合收集" class="headerlink" title="G1 回收阶段 - 并发标记与混合收集"></a><strong>G1 回收阶段 - 并发标记与混合收集</strong></h4><ol><li>当<strong>老年代占用内存超过阈值后</strong>，触发<strong>并发标记</strong>，这时无需暂停用户线程</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222813959.png" alt="image-20210831222813959" style="zoom:50%;" /><ol start="2"><li><p><strong>并发标记</strong>之后，会有<strong>重新标记</strong>阶段<strong>解决漏标</strong>问题，此时需要<strong>暂停用户线程</strong>。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（<strong>存活对象少</strong>）的区域（这也是 Gabage First 名称的由来）。</p><p>回收价值：回收该region<strong>所获空间</strong>和<strong>所需时间</strong>的<strong>价值</strong></p></li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222828104.png" alt="image-20210831222828104" style="zoom:50%;" /><ol start="3"><li>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222841096.png" alt="image-20210831222841096" style="zoom:50%;" /><ol start="4"><li>下图显示了老年代和幸存区晋升的存活对象的复制</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222859760.png" alt="image-20210831222859760" style="zoom:50%;" /><ol start="5"><li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222919182.png" alt="image-20210831222919182" style="zoom:50%;" /><h3 id="划分方式"><a href="#划分方式" class="headerlink" title="划分方式"></a>划分方式</h3><p>将对象按照生命周期的不同划分为：年轻代、年老代、永久代。其中永久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代</p><h3 id="JVM内存参数"><a href="#JVM内存参数" class="headerlink" title="JVM内存参数"></a><strong>JVM内存参数</strong></h3><p>对于JVM内存配置参数：-Xmx10240m -Xms10240m -Xmn5120m -XX:SurvivorRatio=3 其最小内存值和Survivor区总大小分别是</p><ul><li><strong>-Xms</strong> 最小堆内存（包括新生代和老年代）</li><li><strong>-Xmx</strong> 最大堆内存（包括新生代和老年代）</li><li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li><li><strong>-Xmn</strong> 新生代的内存</li><li><strong>-XX:SurvivorRatio</strong>=3 Eden区占3份，from和to各占1份</li><li><strong>-XX:NewSize</strong> 与 <strong>-XX:MaxNewSize</strong> 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li></ul><h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><p><strong>JVM调优的重点</strong>是<strong>垃圾回收</strong>（gc）和<strong>内存管理</strong>，垃圾回收的时候会导致整个虚拟机暂停服务。因此，应该尽可能地缩短垃圾回收的处理时间</p><p>在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置,让JVM获得最佳性能</p><ol><li><p><strong>开启-server模式</strong>，（启动虽然慢，但是运行效率高）</p></li><li><p>针对<strong>JVM堆的设置</strong>一般，可以通过-Xms -Xmx 限定其最小，最大值，为了防止垃圾收集器在最小、最大之间收缩而产生额外的时间，我们通常把最大、最小设置为相同的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms2g: 初始化堆大小为2g；</span><br><span class="line">-Xmx2g：堆最大内存为2g；</span><br></pre></td></tr></table></figure></li><li><p>年轻代和年老代将根据<strong>默认</strong>的比例<strong>（1：2）</strong>分配堆内存。年轻代和年老代设置多大才算合理，<strong>原则是减少GC的频率和Full GC的次数</strong></p></li><li><p>在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法：</p><p>-XX：+UserParalleloldGC，默认为Serial收集</p></li><li><p>-XX:SurvivorRatio=8；默认是8，表示新生代Eden占8份，Survivor区的from和to各占1份，8:1:1</p></li><li><p><strong>线程堆栈的设置</strong>：<strong>每个线程默认会开启1M</strong>的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，<strong>一般256K就足用</strong>。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统</p></li></ol><h3 id="怎么获取Java程序使用的内存？堆使用的百分比？"><a href="#怎么获取Java程序使用的内存？堆使用的百分比？" class="headerlink" title="怎么获取Java程序使用的内存？堆使用的百分比？"></a>怎么获取Java程序使用的内存？堆使用的百分比？</h3><p>可以通过java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存以及最大堆内存。通过这些方法你也可以获取到堆使用的百分比以及堆内存的剩余空间。Runtime.freeMemory()方法返回剩余空间的字节数，Runtime.totalMemory()方法返回总内存的字节数，Runtime.maxMemory()返回最大内存的字节数</p><h3 id="JVM常用调试工具"><a href="#JVM常用调试工具" class="headerlink" title="JVM常用调试工具"></a>JVM常用调试工具</h3><p>jconsole 和 jvisualvm 两款视图监控工具：</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220416151404690.png" alt="image-20220416151404690"></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220217095213698.png" alt="image-20220217095213698"></p><h3 id="集合的fail-fast和fail-safe机制"><a href="#集合的fail-fast和fail-safe机制" class="headerlink" title="集合的fail-fast和fail-safe机制"></a>集合的fail-fast和fail-safe机制</h3><p>fail-fast和fail-safe是集合的一种错误检测机制，当集合的迭代器正在遍历集合的同时又对集合进行结构上的改变的操作，就有可能引起fail-fast机制</p><p>比如：线程1通过iterator正在遍历集合A中的元素，线程2修改了集合A的结构（<strong>是结构上面的修改，而不是简单的修改集合元素的内容</strong>），那么这个时候就会抛出异常<strong>ConcurrentModificationException</strong>，从而产生fail-fast机制</p><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量来记录在遍历期间集合是否发生改变。在每次迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为期望的expectedModCount，是的话则遍历，否则抛出异常，终止遍历</p><p>可以使用写时复制数组代替普通数组CopyOnWriteArrayList代替ArrayList。CopyOnWriteArrayList是Fail-Safe的，遍历的同时可以修改，原理是读写分离</p><h3 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h3><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。 </p><p>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。 </p><p>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h3 id="ArrayList-扩容"><a href="#ArrayList-扩容" class="headerlink" title="ArrayList 扩容"></a>ArrayList 扩容</h3><p>当我们添加第一个元素的时候，首次扩容为10，再次扩容为上次容量的1.5倍，实际上是上次容量右移1位后再加上上次的容量。接下来再判断扩容后的容量是不是大于期望的最小容量，选择两者中大的作为新容量，最后Arrays.copyOf()完成扩容</p><p><strong>扩容因子1.5的原因</strong>：</p><h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><p><strong>LinkedList</strong></p><ol><li>基于双向链表，无需连续的内存</li><li>随机访问慢，需要沿着链表进行遍历</li><li>头尾插入删除性能高</li><li>占用内存多，因为节点还要存一些prev，next的指向信息</li></ol><p><strong>ArrayList</strong></p><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p><ol><li>基于数组，需要连续的内存空间</li><li>随机访问快，因为内存空间连续，直接通过下标访问</li><li>尾部插入和删除性能高，其他部分的插入删除都会引起数组的移动，性能低</li><li>可以利用CPU缓存，局部性原理，访问到某一个下标时，把附近的也加载进入</li></ol><h3 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h3><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。 transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p><h3 id="HashSet如何检查重复？HashSet如何保证数据是不可重复的？"><a href="#HashSet如何检查重复？HashSet如何保证数据是不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet如何保证数据是不可重复的？"></a>HashSet如何检查重复？HashSet如何保证数据是不可重复的？</h3><p>HashSet底层就是一个HashMap实现的，调用HashSet的添加add(E e)方法就是调用的HashMap的put()方法，将HashSet中要添加的元素e作为HashMap的key，因为HashMap的key是不重复的，所以HashSet的的值也是不重复的</p><h3 id="为什么重写了equals还要重写hashcode"><a href="#为什么重写了equals还要重写hashcode" class="headerlink" title="为什么重写了equals还要重写hashcode"></a>为什么重写了equals还要重写hashcode</h3><p>对于基本数据类型equals比较的是值，对于引用数据类型，equals是比较的地址的引用是否相等。我们一般要比较对象是否相等的时候要重写equals方法，但是这还不够，因为java中会先进行hash运算，也即是hashcode方法得到哈希码来判断对象应该位于哪个桶里，如果位于不同桶里，也就是说hashcode的值不同的，这两个对象一定不同，如果hashcode相同，则还要去后续的链表中用equals方法去比较两个对象是否相等。如果没有重写hashcode方法，那么一开始两个相同的对象的hashcode值就不同，这样咋比也不会相同了。所以重写hashcode，就是确保我们认为相同的对象的hashcode也要相同</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet实现了Set接口，而HashMap实现的是Map接口。但是HashSet内部维护了一个map，HashSet调用add就是调用的map的put方法。但是HashSet不允许有重复的值，map中的put方法在判断出有重复值的时候不会添加元素，而是把旧值设置为新值后直接返回，最后并没有添加节点</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable可以说是就是线程安全版的Hashmap，因为它的方法都加了synchronized关键字，<strong>Hashtable不允许有null的key和value</strong>，put的时候就会检查value是否为null，key为空的话当key.hashcode方法的时候就会报错，都采用fail-fast机制，就是说在iterator遍历的时候，如果做了结构上的修改操作，那么就会抛出异常</p><p>Hashtable的初始容量是11，装载因子是0.75，扩容每次2n+1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>计算hash值的方法不同</strong></p><p><strong>Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。</strong><br><strong>HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。</strong></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>初始容量16</strong>  负载因子<strong>0.75</strong>  <strong>扩容2倍</strong></p><h4 id="HashMap-每次扩容两倍的原因"><a href="#HashMap-每次扩容两倍的原因" class="headerlink" title="HashMap 每次扩容两倍的原因"></a>HashMap 每次扩容两倍的原因</h4><p>HashMap 每次保证 map 的大小为2的倍数，目的则是为了能够更好的计算hash 值，让其元素分布均匀，并且2的倍数的话 可以采用位运算来代替取模运算，这样计算就会很方便，性能也会好很多</p><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><ul><li>1.7 数组 + 链表</li><li>1.8 数组 + （链表 | 红黑树）</li></ul><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>Hashmap可以采用keyset和entryset遍历以及values()方法获取所有的值</p><p>在用迭代器方法遍历的同时，如果调用hashmap自身的remove方法去删除一个key，将会引出fail-fast机制</p><p>调用nextNode方法的时候报错</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220305100357140.png" alt="image-20220305100357140"></p><p>但是如果用<strong>迭代器的remove()方法去删除一个key，则不会抛出异常</strong>，这是因为迭代器的remove()方法在删除的时候，会同时更新modCount和expectedModCount;这样就不会出现fail-fast，而hashmap的remove方法最终会修改modCount的值，而不会同步更新expectedModCount</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220305100331579.png" alt="image-20220305100331579"></p><h4 id="树化与退化"><a href="#树化与退化" class="headerlink" title="树化与退化"></a>树化与退化</h4><p><strong>树化意义</strong></p><ul><li>红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然情况才树化为红黑树，是保底策略</li><li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 O(log_2⁡n )，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li><li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li></ul><p><strong>树化规则</strong></p><ul><li>当<strong>链表长度超过</strong>树化阈值<strong>8</strong>时，先尝试扩容来减少链表长度，如果<strong>数组容量</strong>已经**&gt;=64**，才会进行树化</li></ul><p><strong>退化规则</strong></p><ul><li>情况1：在扩容时如果拆分树时，树元素个数 &lt;= 6 则会退化链表</li><li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul><h4 id="put与扩容"><a href="#put与扩容" class="headerlink" title="put与扩容"></a>put与扩容</h4><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220302204906775.png" alt="image-20220302204906775"></p><p><strong>put流程</strong></p><ol><li>HashMap 是懒惰创建数组的，首次使用才创建数组，首先看table是否为null，为null就去初始化table</li><li>table初始化完后，就看对应的table[i]是不是有不有值，没有值，直接插入</li><li>table[i]有值，就看table[i]的key是不是和要插入的重复了，重复了直接覆盖值</li><li>没有重复，就判断是不是treenode，是treenode就走红黑树的put流程</li><li>不是treenode，就准备插入到链表尾，判断链表需不需要转为红黑树</li><li>不需要转为红黑树，判断key是否存在，存在直接覆盖value</li><li>最后看需不需要扩容</li></ol><h4 id="Hashmap-并发死链的问题"><a href="#Hashmap-并发死链的问题" class="headerlink" title="Hashmap 并发死链的问题"></a>Hashmap 并发死链的问题</h4><p>Hashmap在多线程的情况还有可能发生死链的问题：</p><ul><li>JDK1.7在调用resize()方法的时候，会调用其中的transfer()方法，因为JDK1.7采用<strong>头插</strong>的方式，比如现在一个桶下的链有元素a，b。当线程1来的时候先指向这个引用，这个时候线程切换，线程2进行扩容，正常扩容完后因为头插法元素的顺序就b，a了，但是线程1这个时候之前已经拿到了这个两的引用，先把a头插，然后next原来指向的b，接着b头插，next又是a，头插a，这个时候a的next又指向的b，next指向null。这个就形成了一个死链，a的next是b，b的next又是a</li></ul><h4 id="HashMap初始容量10000，插入10000条数据，会不会扩容"><a href="#HashMap初始容量10000，插入10000条数据，会不会扩容" class="headerlink" title="HashMap初始容量10000，插入10000条数据，会不会扩容"></a>HashMap初始容量10000，插入10000条数据，会不会扩容</h4><p>不会扩容，因为带有初始容量的构造方法并不是直接把初始容量参数设置为threshold，而是经过一个tableSizeFor()方法，将阈值要设置为2的多少次方，10000的话应该是2^14次方=16384，所以16384*0.75=12288&gt;10000，所以能存</p><h4 id="HashMap-1-8-和-1-7区别，做了哪些优化"><a href="#HashMap-1-8-和-1-7区别，做了哪些优化" class="headerlink" title="HashMap 1.8 和 1.7区别，做了哪些优化"></a>HashMap 1.8 和 1.7区别，做了哪些优化</h4><ol><li>JDK 1.7 头插法，存在并发死链问题</li><li>JDK 1.8 采用的hash 算法不同，hashcode ^ (hashcode &gt;&gt;&gt; 16)</li></ol><h4 id="HashMap-table的初始化"><a href="#HashMap-table的初始化" class="headerlink" title="HashMap table的初始化"></a>HashMap table的初始化</h4><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="红黑树的引入"><a href="#红黑树的引入" class="headerlink" title="红黑树的引入"></a>红黑树的引入</h4><p><strong>有了二叉搜索树，为什么还要二叉平衡树</strong></p><ul><li>二叉搜索树是一棵排了序的二叉树，可以方便我们做一个数据的查找，二叉搜索树的中序遍历的结果就是一个排好序的结果，我们查找数据沿着根结点遍历，小于这个节点的就到左子树中去查找，大于这个节点的就到右子树中查找。</li><li>二叉搜索树的查找时间复杂度平均 O（log n），但是当这个二叉树退化为链表的，时间复杂度就退化为了O（n）</li><li>所以为了<strong>防止它退化为链表</strong>，就采用了二叉平衡树，<strong>二叉平衡树</strong>确保左右子树的<strong>高度差不超过1</strong>，在插入节点的时候，还需要去平衡二叉树的高度。保证最坏情况下其查找性能也是O（log n）</li></ul><p><strong>有了二叉平衡树，为什么还要红黑树</strong></p><ul><li>AVL 的严格要求左右子树高度差不能超过1，每次进行 插入/删除操作的时候，几乎都需要通过 旋转 操作保持平衡</li><li>所以在<strong>频繁插入/删除</strong>的场景中，<strong>二叉平衡树</strong>的<strong>平衡也严重影响了其性能</strong></li><li>红黑树通过牺牲严格的平衡，换取 插入/删除 时少量的旋转操作，整体性能高于 AVL<ul><li>红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决</li></ul></li><li>红黑树的红黑规则，保证最坏的情况下，也能在O ( log N ) 时间复杂度</li></ul><h4 id="红黑树规则"><a href="#红黑树规则" class="headerlink" title="红黑树规则"></a>红黑树规则</h4><p><strong>红黑树的规则：</strong></p><ul><li><strong>节点不是黑色</strong>，<strong>就是红色</strong></li><li><strong>根节点是黑色</strong></li><li><strong>叶子节点</strong>都是<strong>黑色</strong>（<strong>NIL</strong> / <strong>NULL</strong>）</li><li>从根路径到任意节点，<strong>不能连续出现两个红色节点</strong>（一个节点要是红色，其子节点都要是黑色）</li><li><strong>每个节点到叶子节点的所有路径</strong>，都<strong>包含相同数目的黑色节点</strong></li></ul><p>红黑树的红黑规则，保证最坏的情况下，也能在O ( log N ) 时间复杂度</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Hashtable是synchronized版的HashMap，但是它性能太低了，所以有了ConcurrentHashMap</p><ol><li><p>JDK 7</p><p>在JDK 7的时候，它的设计是采用<strong>Segment分段锁</strong>去实现的，有多个Segment，一个<strong>Segment</strong>就是一个<strong>ReentrantLock</strong>，因为它继承了ReentrantLock，加锁的时候就是<strong>对Segment进行加锁</strong>，这样<strong>不同Segment的操作</strong>就可以<strong>不用加锁</strong>，达到并发的效果。</p><p>它的put流程就是说先根据<strong>SegmentShift</strong>和<strong>SegmentMask</strong>计算出<strong>Segment</strong>的<strong>下标</strong>，然后拿着这个下标先去判断，<strong>Segment</strong>是不是null，在<strong>确保为null</strong>之后就采用<strong>CAS去创建Segment对象</strong>，然后<strong>进入segment的put流程</strong>，首先<strong>尝试给segment加锁tryLock()<strong>，加锁</strong>不成功</strong>，就进入scanAndLockForPut方法<strong>多次尝试加锁</strong>，在<strong>尝试期间</strong>，还会去看<strong>节点</strong>有没有创建出来，如果没有则还会去<strong>创建</strong>出来。</p><p><strong>加锁成功</strong>后，就可以安全的执行后续的put操作了，看<strong>有没有这个key</strong>，就看<strong>要不要覆盖值</strong>，没有就是新增，<strong>判断节点有没有被创建出来</strong>，因为刚才说了有可能在循环获取锁的时候可能会去创建出节点，然后看<strong>要不要扩容</strong></p></li><li><p>JDK 8</p><p>JDK 8采用的是<strong>CAS+synchronized</strong>来实现线程安全性，它的put流程主要如下，</p><p>获取到key的<strong>hash值</strong>，然后<strong>看tab有没有创建出来</strong>，tab<strong>没创建</strong>出来就走<strong>initTable()创建tab</strong>，initTable()里面会先去判断有不有其他线程正在创建tab，如果有就当前线程循环yield，让出CPU的使用权，否则就使用CAS替换sizeCtl的值尝试获取锁然后创建tab；如果tab创建出来了，就去判断对应tab[]下面的<strong>头节点有没有创建出来</strong>，如果<strong>没有</strong>，则<strong>新增的节点</strong>直接就是作为<strong>头结点</strong>，否则就看头结点<strong>是不是被搬迁过 MOVED</strong>，如果是说明<strong>正在扩容</strong>，那么就要去<strong>帮忙扩容helpTransfer()</strong></p><p>最后else说明<strong>tab创建完了</strong>，<strong>头结点也不为null</strong>，并且<strong>也不是forwarddingNode正在扩容</strong>，那么就加锁，<strong>synchronized锁住头结点</strong>，再次判断节点是否被移动，如果是<strong>链表</strong>，就走链表的put，<strong>遍历链表</strong>，找有不有重复，记录链表元素个数，如果是<strong>红黑树</strong>，走红黑树的put，最后<strong>看需不需要去树化</strong>，然后增加size计数</p></li></ol><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="流的划分"><a href="#流的划分" class="headerlink" title="流的划分"></a>流的划分</h3><ul><li>按照流的流向：输入流和输出流</li><li>按照流的操作单元：字符流和字节流</li><li>按照流的角色：节点流和处理流</li></ul><p><strong>字节流：</strong></p><ul><li>字节流就是每次处理单元是一个字节，主要用于二进制数据的读取，实际上它可以读取任意类型的数据，但是它不支持直接写入或者读取Unicode码元。<strong>字节流默认不使用缓冲区</strong>。字节输入流和输出流分别对应InputStream和OutputStream</li></ul><p><strong>字符流：</strong></p><ul><li>字符流每次处理单元是两个字节的一个Unicode字符。<strong>字符流使用缓冲区</strong>。字符输入流和输出流分别对应InputReader和OutputWriter</li></ul><p>节点流：可以从或向一个特定的地方（节点）读写数据。直接对数据源（文件，数组之类存放数据的地方）进行操作。常见的有 FileReader，FileWriter，FileInputStream，FileOutputStream</p><p>处理流：对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。处理流的构造方法总是要带一个其他的流对象做参数。常见的有 BufferedReader，BufferedWriter，BufferedInputStream，BufferedOutputStream。</p><p>比如<code>BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath))</code></p><p>Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的</p><ul><li><strong>InputStream/Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流</li><li> <strong>OutputStream/Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流</li></ul><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220215183701632.png" alt="image-20220215183701632"></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220215183940215.png" alt="image-20220215183940215"></p><h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul><li>Files. exists()：检测文件路径是否存在</li><li>Files. createFile()：创建文件 </li><li>Files. createDirectory()：创建文件夹</li><li>Files. delete()：删除一个文件或目录</li><li>Files. copy()：复制文件</li><li>Files. move()：移动文件</li><li>Files. size()：查看文件个数</li><li>Files. read()：读取文件</li><li>Files. write()：写入文件</li></ul><h3 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO,NIO,AIO"></a>BIO,NIO,AIO</h3><ul><li>BIO：Block IO 同步阻塞式IO，就是我们平时使用的传统IO，它的特点是模式简单使用方便，但并发处理能力低</li><li>NIO：Non IO 同步非阻塞IO，是传统IO的升级，客户端和服务端通过Channel（通道）通讯，实现了多路复用</li><li>AIO：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制</li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>在Unix系统中，一切都是文件。文件就是流的概念，在进行信息的交流过程中，对这些流进行数据的收发操作就是IO操作</p><blockquote><p>我们都知道unix(like)世界里，一切皆文件，而文件是什么呢？文件就是一串二进制流而已，不管socket，还是FIFO、管道、终端，对我们来说，一切都是文件，一切都是流。在信息交换的过程中，我们都是对这些流进行数据的收发操作，简称为 <strong>I/O 操作</strong>(input and output)，往<strong>流中读出数据</strong>，系统调用<strong>read</strong>，<strong>写入数据</strong>，系统调用<strong>write</strong>。不过话说回来了 ，计算机里有这么多的流，我怎么知道要操作哪个流呢？对，就是<strong>文件描述符</strong>，即通常所说的 <strong>fd</strong> ，一个 **fd **就是一个整数，所以，对这个整数的操作，就是对这个文件（流）的操作。我们创建一个socket，通过系统调用会返回一个文件描述符，那么剩下对socket的操作就会转化为对这个描述符的操作。不能不说这又是一种分层和抽象的思想。</p></blockquote><h3 id="磁盘IO为什么慢"><a href="#磁盘IO为什么慢" class="headerlink" title="磁盘IO为什么慢"></a>磁盘IO为什么慢</h3><p>我们要到磁盘上查找数据的话，内核会给磁盘映射一个地址，然后磁盘定位到盘片上，就让磁头去寻找具体数据读取出来。</p><p>磁盘IO的速度主要在于两个方面：</p><ol><li><strong>让磁头定位到指定位置的时间</strong></li><li><strong>磁头从盘片上读出数据的时间</strong></li></ol><h3 id="同步-与-异步"><a href="#同步-与-异步" class="headerlink" title="同步 与 异步"></a>同步 与 异步</h3><p>同步： 执行一个操作后，进程<strong>触发IO操作</strong>（其中要么就是等待数据的到达，也就是阻塞模式；要么通过轮询去查看数据是否到达也就是非阻塞忙轮询模式的）等待或者轮询 IO 操作是否就绪。</p><p>异步： 执行一个操作后，<strong>触发IO操作后不会导致请求进程阻塞</strong>。也就是说数据从内核到用户缓冲区的整个过程都是交给内核去完成的，用户进程无需阻塞一直等到IO操作完成，它只要执行一个操作<strong>触发IO操作后</strong>就可以继续<strong>执行其他操作</strong>，直到IO操作结束后，<strong>等到被通知</strong>就可以了。所以从根本来说异步从等待数据到把数据从内核空间拷贝到用户空间的过程中没有阻塞，只有发起该操作，和被通知该操作完成。所以异步是真正的没有阻塞在IO操作上的</p><h3 id="IO-阻塞-与-非阻塞"><a href="#IO-阻塞-与-非阻塞" class="headerlink" title="IO 阻塞 与 非阻塞"></a>IO 阻塞 与 非阻塞</h3><p><strong>阻塞</strong>：阻塞就是说在执行 IO 操作的时候，调用者一直等待请求结果返回，当前线程一直等待无法从事其他工作，只有当条件就绪时，才可以继续执行</p><p><strong>非阻塞</strong>：非阻塞则相反，不用一直等待请求结果返回，可以先去做别的事情</p><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO 也就是 Blocking IO，<strong>同步阻塞I/O模式</strong>，数据的读取写入<strong>必须阻塞在一个线程内等待其完成</strong>。</p><p>就是我们平时使用的传统IO，它的特点是模式简单使用方便，但并发处理能力低</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO 同时支持 阻塞和非阻塞</p><p><strong>同步非阻塞</strong>指的是：一个线程进行数据的读取写入的时候，<strong>不必一直阻塞等待</strong>，可以去做别的任务，只<strong>需要</strong>不停的<strong>轮询</strong>一下数据处理情况，如果数据处理完毕，也就可以执行下一步任务了。</p><p><strong>缺点</strong>：<strong>服务端</strong>要<strong>轮询</strong>所有连接的客户端拿数据（<code>recv</code>调用），很多调用是无意义的，这样会导致频繁的<strong>用户态切换成内核态</strong>，导致性能变差。</p><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>AIO （Asynchronous I/O）：异步非阻塞IO，异步IO肯定就是非阻塞的IO，只需要执行一个操作触发IO就可以去执行其他操作了，也不用一直轮询IO操作的状态，等IO操作结束后，只需要等待IO通知。</p><p>无论NIO，SELECT还是POLL，<strong>都是要遍历所有IO，询问状态,只不过遍历这件事到底是内核来做还是应用程序来做而已</strong></p><h3 id="Java-NIO-底层实现"><a href="#Java-NIO-底层实现" class="headerlink" title="Java NIO 底层实现"></a>Java NIO 底层实现</h3><p>Java  NIO 底层基于 epoll 的多路复用技术实现，与 select poll 不同的是，select poll 都是每次调用 select、poll 就把文件描述符从用户态拷贝到内核态，供修改，然后select 采用数组的形式 遍历数组作为一个监听，poll 采用链表的形式 作为监听 解决了select 的数组大小限制问题，但是他们都面临着一个遍历问题，就是都要遍历一次数组或者链表，来查看对应的 fd，时间复杂度O（n），epoll 则是在调用 epoll_ctl 的时候进行 fd 的拷贝，并且给每个 fd 注册指定一个回调函数，当准备就绪的时候，回调函数就会把 就绪的 fd 放到 就绪链表中去，epoll_wait 就等待 就绪链表有 就绪的fd 的时候。这样不用遍历，复杂度 O（1）</p><h3 id="多路-IO复用"><a href="#多路-IO复用" class="headerlink" title="多路 IO复用"></a>多路 IO复用</h3><p><strong>多路IO复用</strong>采用 select、poll、epoll 的三种方式，这个三个函数本质上都是同步I/O，因为他们都需要在读写事件就绪后再自己进行读写，也就是说这个读写过程是阻塞的</p><p>select 先阻塞，有活动套接字才返回，只不过 <strong>select</strong> 采用<strong>数组</strong>存文件描述符 <strong>fd</strong>，<strong>poll</strong> 采用<strong>链表</strong>存 文件描述符，和 阻塞IO 不相同的是，这个几个函数可以阻塞多个IO操作，而且可以同时对多个读操作，多个写操作的IO函数进行检测，修改 fd 来表示数据的准备情况</p><p>正因为 <strong>阻塞IO</strong> 只能<strong>阻塞 一个 IO 操作</strong>，而 <strong>IO复用模型</strong> 能<strong>阻塞多个 IO 操作</strong>，所以叫多路复用。</p><p>也就是说，<strong>IO 多路复用并不是非阻塞</strong>，<strong>只是它可以同时处理多个请求</strong>，<strong>原本的 单路IO 是一个处理完才能接入新的连接</strong>，多路复用就是<strong>可以同时接入多个连接</strong>。</p><p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程</strong></p><p>多路复用技术可以<strong>解决 NIO 的需要轮询客户端状态</strong>，<strong>造成用户态到内核态切换的问题</strong>。多个IO通过一个系统调用获得其中的IO状态，然后由程序对有状态的IO进行读写操作。在Linux系统中，多路复用的实现有：</p><ul><li><p><strong>select</strong></p><p><strong>select 监控</strong> 三类文件描述符，<strong>writefds</strong>、<strong>readfds</strong>、<strong>exceptfds</strong>，select 采用数组的形式存储这三类描述符，select 一直遍历这个描述符数组，内核在将数据准备好后或者应该说修改对应的描述符为1后，select 遍历到有描述符就绪，就知道这些数据是准备好的，然后将函数返回，返回后再接收数据</p><p><strong>缺点</strong>：</p><ul><li>文件描述符的数量，默认 <strong>1024</strong> 个</li><li><strong>开销会随着文件描述符线性增长</strong>，O（n）</li></ul></li><li><p><strong>poll</strong></p><p>poll 是为了解决 select 的数组数量有限的情况，所以 poll 采用<strong>链表</strong>的形式，这样在大小上就不会存在限制</p><p><strong>缺点</strong>：</p><ul><li><strong>仍然存在开销随着文件描述符线性增长</strong>，O（n）</li></ul></li><li><p><strong>epoll</strong></p><p>epoll 就解决了开销随文件描述符增长的情况。epoll 采用<strong>监听回调的机制</strong>，<strong>每当 fd 就绪</strong>，系统注册的<strong>回调函数</strong>就会被<strong>调用</strong>，就<strong>将就绪 fd 放到 就绪链表</strong>，<strong>epoll_wait</strong> 就去<strong>就绪链表中查看</strong>有不有就绪的fd（不用遍历所有的 fd，直接找到哪些 fd 就绪），<strong>epoll_ctl</strong> 注册监听对应的事件，拷贝fd到内核，epoll_wait 不拷贝</p><p>时间复杂度 O（1）</p><p>epoll对文件描述符的操作有两种模式：<strong>LT</strong>（level trigger）和<strong>ET</strong>（edge trigger），LT模式是默认模式，LT模式与ET模式的区别如下：</p><p>LT模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></p><p>ET模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</strong></p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</p></li></ul><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220408104126857.png" alt="image-20220408104126857"></p><p>Select</p><p>基于 Select 调用的 I/O 复用模型如下：</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220408091713550.png" alt="image-20220408091713550"></p><p>应用进程 select 调用，没有数据报准备好，到数据报准备完毕，进程一直阻塞等待，等待可能多个套接字中的任一个变为可读状态。等待内核返回可读条件的时，应用进程 recvfrom 再次发送系统调用拷贝数据报（将数据从内核拷贝到用户空间），拷贝完成返回成功，然后应用进程就可以继续执行操作了。</p><p><strong>select poll epoll的区别</strong></p><p>Nginx实现网络通讯时使用的是异步网络模型：<strong>epoll模型</strong></p><p><strong>select、poll、epoll都是I/O多路复用机制</strong>，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪，就能够通过程序进行相应的读写操作</p><p>select、poll、epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后再自己进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无须自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间</p><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><ul><li><p>select()函数监视的文件描述符分为三类，分别是writefds、readfds、exceptfds，调用后select()函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可）函数就会返回</p></li><li><p>首先会将多个文件描述符标志位存入一个数组中，当函数返回时，该数组中<strong>就绪的文件描述符便会被内核修改标志位</strong>，使得进程可以获得这些文件描述符从而进行后续的读写操作</p></li><li><p>然后select函数就会遍历文件描述符数组，如果读到标志位为1，则知道这些数据是准备好了的，然后对其进行读写</p><p><strong>缺点：</strong></p></li><li><p>文件描述符的数量默认为1024个</p></li><li><p>开销会随着文件描述符线性增长（遍历一遍需要很长时间 O(n)）</p></li></ul><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><ul><li><p>和select的执行过程是差不多的，但是数据结构改变了，poll机制中将select机制的文件描述符数组改善为了链表，将文件描述符标志位存入链表中</p></li><li><p>因为链表是可以无限延伸的，因此poll对于select来说，使得文件描述符的数量不再被限制</p><p><strong>缺点：</strong></p><p>开销会随着文件描述符线性增长（同样需要和select机制一样遍历一遍 O(n)）</p></li></ul><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ul><li><p>epoll是select和poll的增强版本，相对于select和poll来说，epoll更加灵活，没有描述符限制</p></li><li><p>当调用epoll_wait()函数获得就绪文件描述符的时候，返回的不是实际的文件描述符，而是一个代表就绪描述符数量的值，<strong>这个时候只需要去epoll指定的一个准备就绪链表中遍历一遍这些文件描述符就可以了</strong></p></li><li><p>epoll提供了三个函数：<code>epoll_create、epoll_ctl、epoll_wait</code></p><p>epoll_create是创建一个epoll句柄</p><p>epoll_ctl是注册要监听的事件类型</p><ul><li>在调用epoll_ctl()时把所有fd拷贝进内核，并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表（<strong>此处去掉了遍历文件描述符，而是通过监听回调的的机制</strong>，这正是epoll的魅力所在）</li><li>epoll_wait则是等待事件的产生，它的实际工作就是在查看在就绪链表中有没有就绪的fd</li></ul></li></ul><p>epoll的开销对于select和poll来说省下了许多，<strong>时间复杂度只需要O(1)</strong></p><h5 id="LT-ET"><a href="#LT-ET" class="headerlink" title="LT/ET"></a>LT/ET</h5><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger），LT模式是默认模式，LT模式与ET模式的区别如下：</p><p>LT模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></p><p>ET模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</strong></p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；<strong>这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制</strong></p><p>静态编译：在编译时确定类型，绑定对象</p><p>动态编译：在运行时确定类型，绑定对象</p><h3 id="反射优缺点"><a href="#反射优缺点" class="headerlink" title="反射优缺点"></a>反射优缺点</h3><ul><li>优点：运行期类型的判断，动态加载类，提高代码的灵活度</li><li>缺点：性能瓶颈，反射相当于一系列解释操作，通知JVM要做的事，性能比直接的Java代码要慢</li></ul><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>反射的框架设计的灵魂</p><p>我在项目中采用Redis用Hash的结构存入一个用户的授权对象，然后调用<code>redisTemplate.boundHashOps(uuid).entries()</code>取出来的时候需要将其从Map集合转换为一个对象，这个时候就编写了一个工具类就是运用反射将Map中的entry转换为一个实例对象</p><ol><li>在采用JDBC连接数据库的时候采用Class.forName()通过反射加载数据库的驱动</li><li>Spring中运用到的反射，最经典的就是xml的配置，Spring通过XML配置解析装载Bean<ul><li>将程序内所有XML或Properties配置文件加载入内存中</li><li>Java类里面解析XML或者Properties里面的内容，得到对应实体类的字节码字符串以及相关属性信息</li><li>使用反射机制，根据这个字符串获得某个类的实例</li><li>动态配置实例的属性</li></ul></li></ol><h3 id="反射的三种方法"><a href="#反射的三种方法" class="headerlink" title="反射的三种方法"></a>反射的三种方法</h3><p>假设有一个com.zc.test包下有类Student</p><ol><li>Class.forName(“com.zc.test.student”);</li><li>student.getClass();</li><li>Student.class;</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解的三种保留策略"><a href="#注解的三种保留策略" class="headerlink" title="注解的三种保留策略"></a>注解的三种保留策略</h3><p><strong>SOURCE</strong>：此类会被编译器丢弃，不将它保留到编译后的class文件</p><p><strong>CLASS</strong>：将注解保留到编译后的class文件，但是在运行时忽略它</p><p><strong>RUNTIME</strong>：将注解保留到编译后的class文件，并且会在第一次类加载的时候读取它</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220405185705147.png" alt="image-20220405185705147"></p><h3 id="注解的使用范围"><a href="#注解的使用范围" class="headerlink" title="注解的使用范围"></a>注解的使用范围</h3><p>@Traget 注解中的<code>ElementType[] value();</code>，ElementType 描述了注解的修饰范围</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任何类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol><li>形式上：字符常量是单引号引出来的一个字符，字符串是双引号引出的</li><li>含义上：字符串是相当于一个整型值（ASCII值），可以参加表达式运算，字符串常量代表一个地址值（该字符串在内存中存放位置）</li><li>占内存大小：字符常量只占一个字节，字符串常量占若干个字节（至少一个字符结束标志）</li></ol><h4 id="什么是字符串常量池"><a href="#什么是字符串常量池" class="headerlink" title="什么是字符串常量池"></a>什么是字符串常量池</h4><p><strong>字符串常量池</strong>位于<strong>堆内存</strong>中，专门用来<strong>存储字符串常量</strong>，可以提高内存的利用率，<strong>避免开辟多块空间存储相同的字符串</strong>，在<strong>创建字符串</strong>时<strong>JVM</strong>会首先<strong>检查字符串常量池</strong>，如果该<strong>字符串已经存在池中</strong>，则<strong>返回它的引用</strong>，如果<strong>不存在</strong>，则<strong>实例化</strong>一个<strong>字符串</strong>放到池中，并返回其引用。</p><h4 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h4><ol><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据 的一致性。</li><li>常量池优化：：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ol><h4 id="String真的是不可变的吗"><a href="#String真的是不可变的吗" class="headerlink" title="String真的是不可变的吗"></a>String真的是不可变的吗</h4><ol><li><p>String不可变但不代表引用不可以变 </p><p>String str =”Hello”;str = str +” World”; System.out.println(“str=”+ str);</p><p>结果：str=Hello World</p><p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已， 也就是说多开辟了一块内存区域给”Hello World”字符串。</p></li><li><p>通过反射可以修改所谓的“不可变”对象</p><p>通过反射打破封装，访问String对象的<code>char[] value</code>属性，修改其值</p></li></ol><h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 =<span class="string">&quot;hello&quot;</span>;<span class="comment">//str1指向静态区</span></span><br><span class="line">String str2 =<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);<span class="comment">//str2指向堆上的对象</span></span><br><span class="line">String str3 =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str4=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str4));<span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2 ==<span class="string">&quot;hello&quot;</span>);<span class="comment">//false</span></span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 ==<span class="string">&quot;hello&quot;</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h4><p>使用StringBuilder或者StringBuffer的reverse()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure><h4 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h4><ul><li>indexOf()：返回指定字符的索引</li><li>charAt()：返回指定索引处的字符</li><li>replace()：字符串替换</li><li>trim()：去除字符串两端空白</li><li>split()：分割字符串，返回一个分割后的字符串数组</li><li>getBytes()：返回字符串的byte类型数组</li><li>length()：返回字符串长度</li><li>toLowerCase()：字符串转成小写字母</li><li>toUpperCase()：将字符串转成大写字母</li><li>substring()：截取字符串</li><li>equals()：字符串比较</li></ul><h3 id="在使用HashMap的时候，用String做Key有什么好处"><a href="#在使用HashMap的时候，用String做Key有什么好处" class="headerlink" title="在使用HashMap的时候，用String做Key有什么好处"></a>在使用HashMap的时候，用String做Key有什么好处</h3><p>HashMap内部实现是通过Key的hashcode来确定value的存储位置的，因为字符串是不可变的，所有当创建字符串时，它的<strong>hashcode被缓存下来，不需要再次计算，所以相比于其他对象更快</strong></p><h3 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h3><ol><li><p>可变性</p><p>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与 StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p></li><li><p>线程安全性</p><p>String中的对象是不可变的，也就可以理解为常量，线程安全。<strong>AbstractStringBuilder</strong>是<strong>StringBuilder</strong>与<strong>StringBuffer</strong> 的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。 StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><p>StringBuilder非线程安全，StringBuffer线程安全</p></li><li><p>性能</p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer 每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p></li></ol><p>对于三者使用的总结：</p><p><strong>如果要操作少量的数据用</strong> = String </p><p><strong>单线程操作字符串缓冲区 下操作大量数据</strong> = StringBuilder </p><p><strong>多线程操作字符串缓冲区 下操作大量数据</strong> = StringBuffer</p><h2 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h2><p>Date、SimpleDateFormat、LocalDate、LocalTime、LocalDateTime、Calendar抽象类，Calendar.getInstance()获取一个实例</p><p>LocalDateTime可以用来获取指定时间的时间，里面封装一些方法，可以做一些时间的运算，比如加1周，等等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如何让每周四18:00:00 定时执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    LocalDateTime now= LocalDateTime.now();</span><br><span class="line">    <span class="comment">//获取当前周的周四时间</span></span><br><span class="line">    LocalDateTime time = now.withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.THURSDAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前时间大于本周周四，必须找到下周的周四</span></span><br><span class="line">    <span class="keyword">if</span> (now.compareTo(time)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialDelay 代表当前时间和周四的时间差</span></span><br><span class="line">    <span class="comment">// period 一周的间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算两个时间的差值</span></span><br><span class="line">    <span class="keyword">long</span> initialDelay = Duration.between(now, time).toMillis();</span><br><span class="line">    <span class="keyword">long</span> period = <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>;</span><br><span class="line">    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    &#125;,initialDelay,period, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Duration表示一个连续的时间段，可以用来做时间上的计算</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration.between(now, time).toMillis();</span><br><span class="line"><span class="comment">// 3 s 和 5 ns 的 Duration </span></span><br><span class="line">Duration duration = Duration.ofSeconds(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">Duration oneDay = Duration.between(today, yesterday);</span><br><span class="line"><span class="comment">// A duration of 3 seconds and 5 nanoseconds</span></span><br><span class="line">Duration duration = Duration.ofSeconds(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">Duration oneDay = Duration.between(today, yesterday);</span><br></pre></td></tr></table></figure><h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p>装箱：将基本类型用它们对应的引用类型包装起来；</p><p>拆箱：将包装类型转换为基本数据类型；</p><p>对于<strong>对象引用类型</strong>：==比较的是对象的<strong>内存地址</strong>。 </p><p>对于<strong>基本数据类型</strong>：==比较的是<strong>值</strong>。</p><p> 如果整型字面量的值在**-128到127<strong>之间，那么自动装箱时</strong>不会new新的Integer对象**，而是直接引用常量池中的Integer 对象，超过范围。</p><p>a1==b1的结果是false</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">    Integer b =<span class="number">3</span>;<span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">    <span class="keyword">int</span> c =<span class="number">3</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">// false 两个引用没有引用同一对象 </span></span><br><span class="line">    System.out.println(a == c);<span class="comment">// true a自动拆箱成int类型再和c比较 </span></span><br><span class="line">    System.out.println(b == c);<span class="comment">// true </span></span><br><span class="line">    Integer a1 =<span class="number">128</span>; </span><br><span class="line">    Integer b1 =<span class="number">128</span>; </span><br><span class="line">    System.out.println(a1 == b1);<span class="comment">// false </span></span><br><span class="line">    Integer a2 =<span class="number">127</span>; </span><br><span class="line">    Integer b2 =<span class="number">127</span>; </span><br><span class="line">    System.out.println(a2 == b2);<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="五种单例模式"><a href="#五种单例模式" class="headerlink" title="五种单例模式"></a><strong>五种单例模式</strong></h3><p>单例模式有<strong>饿汉式、懒汉式、枚举类(饿汉)、静态内部类</strong></p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：为什么<strong>类要加 final</strong></p><ul><li>防止子类继承后重写方法破坏单例</li></ul><p>问题2：如果实现了序列化接口，还要做什么来<strong>防止反序列化破坏单例</strong></p><ul><li>反序列化时候生成的对象可能会破坏单例，直接在类里加一个**public Object readResolve() {}**方法，可以让反序列化的时候调用这个方法返回单例的实例</li></ul><p>问题3：为什么<strong>构造方法设置为私有</strong>?</p><ul><li>避免其他类使用new生成新的实例，并不能防止反射创建新的实例，因为反射可以打破封装</li></ul><p>问题4：这样初始化是否能保证单例对象创建时的线程安全？</p><ul><li>可以保证，因为实例在<strong>类加载</strong>的时候就<strong>初始化</strong>，JVM会保证其线程安全性</li></ul><p>问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</p><ul><li>1.提供更好的<strong>封装性</strong>；2.提供<strong>泛型</strong>的支持</li></ul></blockquote><h4 id="饿汉式之枚举"><a href="#饿汉式之枚举" class="headerlink" title="饿汉式之枚举"></a>饿汉式之枚举</h4><p>饿汉式：因为枚举的变量，底层是通过public static final来修饰的，类加载就创建了，所以是饿汉式</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220122210404242.png" alt="image-20220122210404242"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span>+<span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingletonEnum instance = SingletonEnum.INSTANCE;</span><br><span class="line">        SingletonEnum instance1 = SingletonEnum.INSTANCE;</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">        instance.print();</span><br><span class="line">        instance1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">------<span class="number">1163157884</span></span><br><span class="line">------<span class="number">1163157884</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> EnumSingleton instance;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//JVM保证只执行一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：枚举单例是如何限制实例个数的</p><ul><li><strong>创建枚举类的时候就已经定义好了</strong>，每个枚举常量其实就是枚举类的一个静态成员变量</li></ul><p>问题2：枚举单例在创建时是否有并发问题</p><ul><li>没有并发问题，是线程安全的，因为枚举单例底层是一个静态成员变量，它是通过类加载器的加载而创建的，确保了线程安全</li></ul><p>问题3：枚举单例能否被反射破坏单例</p><ul><li><p><strong>反射无法破坏枚举单例</strong>, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">this</span>.clazz.getModifiers() &amp; <span class="number">16384</span>) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(“Cannot reflectively create <span class="class"><span class="keyword">enum</span> <span class="title">objects</span>”)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>问题4：枚举单例能否被反序列化破坏单例</p><ul><li><strong>反序列化不能破坏</strong>，枚举类默认也实现了序列号接口。但枚举类考虑到了这个问题，不会破坏单例。</li></ul><p>问题 5：枚举单例属于懒汉式还是饿汉式</p><ul><li>属于<strong>饿汉式</strong>, 静态成员变量, 通过类加载器的时候就加载了。</li></ul><p>问题 6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</p><ul><li>加构造方法，枚举也可以写构造方法，普通方法等</li></ul></blockquote><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点：</span></span><br><span class="line">    <span class="comment">// synchronized加在静态方法上，可以保证线程安全。缺点就是锁粒度大，效率低。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h4><p>DCL：double-check-locking</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：解释为什么要加 volatile</p><ul><li>因为在synchronized外部使用到了共享变量INSTANCE，可能存在一个线程先初始化了instance，但是别的线程没有从主存中获取instance，而是从工作内存中获取instance，仍然为空，volatile保证了可见性，保证读取变量的时候都从主存中去获取，这样就不会存在已经创建了实例，但读取到实例仍然为空的情况</li></ul><p>问题2：对比上面的懒汉式，说出这样做的意义</p><ul><li>增加了双重判断，如果存在了单例对象，别的线程再进来就无需加锁判断，<strong>提升效率</strong></li></ul><p>问题3：为什么还要加为空判断, 之前不是判断过了吗</p><ul><li>主要原因还是因为并发的时候产生线程不安全的问题</li><li>考虑这么一种情况：<ul><li>线程1第一次进入了synchronized代码，获取到了锁，判断到instance为null，然后就去创建实例</li><li>线程2此时已经进行了第一次判断为空，然后等待线程1释放锁。</li><li>如果不加判断，线程1创建完后释放锁，线程2进入同步代码块，此时没有了第二重为空判断，就会直接创建实例，此时就重复创建了实例，破坏了单例</li></ul></li></ul></blockquote><h4 id="懒汉式之静态内部类"><a href="#懒汉式之静态内部类" class="headerlink" title="懒汉式之静态内部类"></a>懒汉式之静态内部类</h4><p>通过静态内部类来创建单例，对外不可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：属于懒汉式还是饿汉式</p><ul><li>懒汉式，因为这是个静态内部类，类加载本身就是懒惰的，在没有用到这个类的时候，是不会进行类加载的，因此没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul><p>问题2：在创建时是否有并发问题</p><ul><li>没有并发问题，仍然是单例的。因为类加载是懒惰的，没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul></blockquote><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>静态代理：</strong></p><ul><li>静态代理就是代理对象和被代理对象实现相同的接口，然后代理对象关联一个被代理对象，然后代理对象的方法中就除了可以调用被代理对象的方法以外，还可以完成对方法的增强。之所以叫静态代理就是因为在<strong>编译期就已经决定好了代理对象的字节码</strong>，将被代理对象的字节码加入到代理对象中</li></ul><p><strong>动态代理：</strong></p><ul><li><strong>JDK动态代理</strong><ul><li>JDK动态代理也是基于接口的方式实现的，因为静态代理的缺陷很明显，要是我还有别的对象要代理，这样我还需要很多个代理对象去完成，极其不易扩展，那动态代理就是说通过反射机制，在运行期间动态的去完成对目标对象的一个代理。我们在代理类中关联一个Object对象，然后通过Proxy动态的在内存中拿着目标对象的信息去newInstance。最终它会生成一个继承了Proxy实现了目标对象的接口的子类，这也是为什么JDK动态代理需要基于接口去实现的原因，因为Java不支持多继承</li></ul></li><li><strong>CGLIB动态代理</strong><ul><li>CGLIB动态代理是为了解决JDK动态代理的缺陷，要是一个类确实不用实现其他的接口，这个时候就需要用CGLIB动态代理了，CGLIB底层是采用的字节码处理框架ASM去动态的对目标对象字节码完成一个转换，最终生成一个子类完成代理</li></ul></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><strong>简单工厂模式：</strong></p><ul><li><strong>简单工厂模式又叫静态工厂方法模式</strong>，在简单工厂模式中，可以<strong>根据参数的不同返回不同的实例类型</strong>。简单工厂模式<strong>专门定义一个类来负责创建其他类的实例</strong>，被创建的实例通常都有共同的父类。DateTime里面就是根据timeStyle来创建不同的对象实例的</li></ul><p><strong>工厂方法模式：</strong></p><ul><li><p><strong>定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法模式使一个类的实例化延迟到其子类。</strong></p></li><li><p>提供一个工厂的接口，具体的工厂由具体的子类去完成，像Collection接口就是一个工厂，Iterator迭代器就是产品，不同的工厂ArrayList产生自己的迭代器Itr产品、LinkedList产生自己的迭代器Itr产品</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306182342146.png" alt="image-20220306182342146"></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306182404398.png" alt="image-20220306182404398"></p></li></ul><p><strong>抽象工厂模式：</strong></p><ul><li><p><strong>抽象工厂模式就是在工厂方法模式上的一个扩展</strong>，工厂方法模式是一个产品体系，抽象工厂模式则对应一个产品族，可以提供多个产品体系</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306183258293.png" alt="image-20220306183258293"></p></li></ul><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p><strong>装饰器模式就是说装饰一个类，对其完成功能的扩展。他不同于继承的方式，继承是直接继承然后获得父类的方法，然后自己添加方法完成扩展，装饰器模式则是实现某个接口，同时又关联一个接口的对象，这样就可以利用动态，在运行时动态的决定装饰哪个对象，除了可以调用接口的方法以外，同时可以完成增强。</strong></p><p>装饰器模式就是可以扩展某个类的功能，他不同于继承的方式子类添加方法去完成方法扩展，他是通过关联一个<strong>顶层接口的对象</strong>，这样就可以利用多态，同时又实现接口，这样既能持有接口的方法，然后在还可以完成扩展</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式定义了一种一对多的对象间的依赖关系，让多个观察者对象同时监听某一个主体对象。当这个主体对象的状态发生变化的时候，就通知所有监听的观察者对象，从而做出对应的响应</p><p>在用 Java 实现文件监控系统的时候，采用WatchService类</p><p>在Commons-IO的一个工具类中，在实现其中的FileMonitor的时候，就使用到了观察者模式。</p><ol><li>首先，创建文件观察者，FileAlterationObserver，Observer里面维护了一个list，就是用来存对应的 listener 监听器的</li><li>然后，继承文件变动监听适配器 FileAlterationListenerAdaptor 自定义一个文件变动后对应的操作，里面重写对应的文件发生变动的方法，比如要把对应事件存到数据库</li><li>给创建的Observer注册对应的监听器，<code>observer.addListener(new FileListener());</code></li><li>最后，就拿着这个Observer去创建一个线程实现监控</li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同表示</strong></p><p>使用场景： </p><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式</li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.interview;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String sex=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=builder.name;</span><br><span class="line">        <span class="keyword">this</span>.num=builder.num;</span><br><span class="line">        <span class="keyword">this</span>.sex=builder.sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num=-<span class="number">1</span>;</span><br><span class="line">        String sex=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sex = sex;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Student <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, num=&quot;</span> + num +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student zs = <span class="keyword">new</span> Student.Builder().setName(<span class="string">&quot;张三&quot;</span>).setNum(<span class="number">123</span>).setSex(<span class="string">&quot;男&quot;</span>).build();</span><br><span class="line">        System.out.println(zs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><ul><li><p>进程</p><p>进程是一个在内存运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。比如在windows系统中，一个运行的xx.exe程序就是一个进程</p></li><li><p>线程</p><p>线程是进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据</p></li></ul><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p><strong>线程间通信</strong>无非就是要<strong>实现对共享资源的控制</strong></p><ol><li><strong>同步</strong>：采用synchronized关键字、对共享数据加锁等方式实现线程间的同步</li><li><strong>wait-notify等待唤醒机制</strong>：对共享数据进行同步，采用wait-notify来让某个线程等待，唤醒某个线程</li><li><strong>CAS</strong>：CASwhile循环，尝试操作共享数据</li></ol><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><p><strong>常见的进程通信方式：</strong></p><ol><li><strong>普通管道pipe</strong>：管道是一种<strong>半双工</strong>的通信方式，<strong>数据只能单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指<strong>父子进程关系</strong></li><li><strong>命名管道FIFO</strong>：去除了第二种限制,可以在许多并不相关的进程之间进行通讯</li><li><strong>信号量</strong>：它是一个<strong>计数器</strong>，<strong>记录资源能被多少个进程同时访问</strong>。用于控制多进程对临界资源的访问（同步)，并且是非负值。主要作为<strong>进程间</strong>以及<strong>同一进程的不同线程间</strong>的<strong>同步</strong>手段。比如<strong>操作系统中的P，V操作</strong>。临界资源：同一时刻，只能被一个进程访问的资源；临界区：访问临界资源的代码区；原子操作：任何情况下不能被打断的操作</li><li><strong>消息队列MessageQueue</strong>：消息队列是<strong>消息的链表</strong>，是存放<strong>在内核中</strong>并由<strong>消息队列标识符标识</strong>。因此是随内核持续的，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。消息队列<strong>克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区受限</strong>等特点。允许不同进程将格式化的数据流以消息队列形式发送给任意进程，对消息队列具有操作权限的进程都可以使用msgget完成对消息队列的操作控制，通过使用消息类型，进程可以按顺序读信息，或为消息安排优先级顺序</li><li><strong>共享存储SharedMemory</strong>：<strong>共享内存</strong>就是映射一段<strong>能被其他进程所访问的内存</strong>，这段<strong>共享内存由一个进程创建，但多个进程都可以访问</strong>。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li></ol><h3 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h3><ol><li><strong>根本区别</strong>：<strong>进程</strong>是操作系统<strong>资源分配</strong>的<strong>基本单位</strong>，<strong>线程</strong>是<strong>处理器任务调度和执行的基本单位</strong></li><li><strong>资源开销</strong>：每个<strong>进程</strong>都有<strong>独立的代码和数据空间</strong>（程序上下文），<strong>程序之间的切换会有较大的开销</strong>；<strong>线程</strong>可以看做轻量级的进程，同一类线程共享代码和数据空间，<strong>每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</strong></li><li>包含关系：一个进程可以包含多个线程，多个线程共同完成进程的任务。一个线程只属于一个进程</li><li>内存分配：同一个进程内的线程的资源是共享的，而进程之间的地址空间和资源是相互独立的</li><li>执行过程：每个<strong>独立的进程都有程序运行的入口</strong>、顺序执行序列和程序出口。但是<strong>线程不能独立执行</strong>，必须依赖于应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li></ol><h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3><p>当前线程任务获取到CPU时间片，当分配的CPU时间片用完或者说线程阻塞后，线程会保存当前状态以便下次再次切回这个任务时，能再次加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><h3 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h3><ul><li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li><li>守护(Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。<strong>一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</strong></li></ul><p><strong>注意事项：</strong> </p><ol><li>setDaemon(true)必须在start()方法前执行，否则会抛出 IllegalThreadStateException 异常 </li><li>在守护线程中产生的新线程也是守护线程</li><li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li><li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。<strong>finally语句块中的语句也不一定被执行</strong></li></ol><h3 id="windows和linux查看进程和线程"><a href="#windows和linux查看进程和线程" class="headerlink" title="windows和linux查看进程和线程"></a>windows和linux查看进程和线程</h3><ol><li>windows<ul><li>任务管理器查看进程和线程，杀死进程</li><li><code>tasklist</code> 查看进程</li><li><code>taskkill /F /PID 进程号</code> 杀死进程</li></ul></li><li>linux<ul><li><code>ps -fe </code>查看所有进程</li><li><code>ps -ft -p &lt;PID&gt;</code> 查看某个进程的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>pkill -9 &lt;PID&gt;</code> 杀死进程，-9代表一类操作，杀死进程</li><li><code>top</code> 查看进程信息</li><li><code>top -H -P &lt;PID&gt;</code> 查看某个进程PID的所有线程</li></ul></li><li>Java<ul><li><code>jps</code> 查看所有Java进程</li><li><code>jstack &lt;PID&gt;</code> 查看某个Java进程的所有线程状态</li><li><code>jconsole</code> 连接查看某个Java进程中线程的运行情况（Windows直接win+r 输入jconsole，图形界面）</li></ul></li></ol><h3 id="形成死锁的4个必要条件"><a href="#形成死锁的4个必要条件" class="headerlink" title="形成死锁的4个必要条件"></a>形成死锁的4个必要条件</h3><ol><li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能 被一个线程(进程)占用，直到被该线程(进程)释放</li><li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源</li><li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路 （类似于死循环），造成永久阻塞</li></ol><h3 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a><strong>线程池相关</strong></h3><h4 id="创建线程的4种方式"><a href="#创建线程的4种方式" class="headerlink" title="创建线程的4种方式"></a>创建线程的<strong>4种方式</strong></h4><ol><li><p>通过继承Thread创建线程</p><p>使用继承的好处就是在线程run()直接用this就可以代表当前线程了，也不用Thread.currentThread()方法</p><p>不好的地方就在于有很大的局限性，Java中不支持多继承，所以说继承了Thread就不能继承其他的类了。另外任务和代码没有分离，相当于多个线程执行一样的任务时需要多份任务代码</p></li><li><p>使用Runnable接口创建Thread</p><p>可以实现Runnable接口，重写里面的run方法，来编写任务代码。</p><p>使用Runnable创建的时候，相当于一个任务被分配给多个线程去执行了，多个线程获取到的是相同的资源。继承Thread创建线程相当于多个线程多个任务，每个线程都接收到相同的任务</p><p><strong>分析 Thread 的源码，查看与 Runnable 的关系</strong>，可以发现采用Runnable的方式最终new Thread的时候最终就是把实现Runnable作为Thread中的target成员，然后判断如果target不为null，就运行target的run()方法，也就是Runnable的run方法</p><ul><li>继承Thread方式: 是把线程和任务合并在了一起</li><li>实现Runnable方式: 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul></li><li><p>使用FutureTask与Thread结合</p><p>使用<strong>FutureTask可以用泛型指定线程的返回值类型</strong>（Runnable的run方法没有返回值），FutureTask实现了RunnableFuture，RunnableFuture继承了Runnable接口。</p><p>task.get()可以获得线程执行完毕后的返回值，如果还没执行完毕get()方法会阻塞起来等待线程执行完才返回结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread r1 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">r1.start();</span><br><span class="line"><span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池创建线程</p><p>好处：</p><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p></li></ol><ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？四种！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>ThreadPoolExecutor使用int的高3位来表现线程池的状态，低29位来表示线程数量</p><p><strong>RUNNING</strong>    111    接收新任务，同时处理任务队列中的任务</p><p><strong>SHUTDOWN</strong>    000    <strong>不接收</strong>新任务，但是<strong>处理</strong>任务队列中的任务</p><p><strong>STOP</strong>    001    <strong>中断正在执行的任务</strong>，同时<strong>抛弃</strong>阻塞队列中的任务</p><p><strong>TIDYING</strong>    010    任务执行完毕，<strong>活动线程为0</strong>，<strong>即将进入终结</strong>阶段</p><p><strong>TERMINATED</strong>    011    线程池进入<strong>终结</strong>阶段</p><h4 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h4><ol><li>提交任务给线程池</li><li>判断核心线程corePoolSize有没有用完</li><li>核心线程没用完，创建一个新的核心线程完成任务</li><li>核心线程使用完了，判断阻塞队列是否已满</li><li>阻塞队列不满，放入阻塞队列中，等待空闲线程执行</li><li>阻塞队列满了，判断最大线程数和核心线程数，也即是看有不有救急线程可用</li><li>有救急线程可用，救急线程执行任务</li><li>无救急线程可用，采用拒绝策略</li></ol><h4 id="如何实现线程复用"><a href="#如何实现线程复用" class="headerlink" title="如何实现线程复用"></a><strong>如何实现线程复用</strong></h4><p>实现线程复用，看源码主要是这样的：</p><p>有一个 <strong>worker</strong>，<strong>实现</strong>了 <strong>Runnable</strong>，所以这个 woker 就可以看做一个线程，它的 <strong>run()</strong> 方法，里面主要先<strong>循环</strong>去<strong>判断</strong>，当前要运行的<strong>初始任务是不是空</strong>（因为在创建 worker 的时候会同时传进一个 Runnable 任务 firstTask ），或者说 从<strong>阻塞队列中取出任务</strong> getTask() 方法如果<strong>不为null</strong>，就一直去<strong>执行任务</strong>。然而在 <strong>getTask()</strong> 方法中，里面一个<strong>死循环 for( ; ; )</strong> 主要去从阻塞队列 <strong>workQueue</strong> 中去 <strong>take</strong>（不带超时） 或者 <strong>poll</strong>（带超时）一个任务出来，会一直阻塞直到队列中有任务返回，然后return 到 runWoker() 方法的 while 循环里去执行，如果阻塞队列中为空，就进入。</p><p>因此，其实现 线程复用 的原理主要就是：while 循环一直去 阻塞队列中获取任务 getTask()，死循环<strong>直到</strong>阻塞队列中<strong>成功获取任务</strong> workQueue.take() ，成功获取就返回，到while 中去执行，进入下一次while 循环，又去 getTask()</p><h4 id="核心线程可以过期吗"><a href="#核心线程可以过期吗" class="headerlink" title="核心线程可以过期吗"></a><strong>核心线程</strong>可以过期吗</h4><p>可以过期，有一个allowCoreThreadTimeout()方法，会将救急线程的keepAliveTime设置为核心线程的过期时间</p><h4 id="有哪几种阻塞队列"><a href="#有哪几种阻塞队列" class="headerlink" title="有哪几种阻塞队列"></a>有哪几种阻塞队列</h4><ol><li><strong>LinkedBlockingQueue</strong><ul><li>这种阻塞队列基于链表实现的，构造的时候有一个dummy节点，用来占位，第一个入队就把节点放到dummy的next，然后出队，就把dummy节点换成本来该出队的节点，然后拿着要出队的节点的值返回，把下一个节点的item设为null，就成为新的dummy节点</li><li>它采用两把锁，一把putLock和一把takeLock，分别锁住头结点和尾节点，put和take这样锁住不同的对象，可以实现生产的时候同时消费</li><li>入队 先 加锁，加锁之后 判断队列满了没有，如果队列满了，就等待队列不满，调用notFull条件变量的 wait方法</li><li>队列不满的时候，就入队，入完队容量加1，然后再1看能不能再put一个，能就notFull条件的signal 唤醒，解锁</li></ul></li><li><strong>ArrayBlockingQueue</strong><ul><li>这种队列基于数组的实现，需要事先指定好队列的大小，因为数组需要指定大小，它采用的是一把锁，不能同时生产和消费</li><li><strong>性能比较</strong><ul><li>Linked支持有界，Array强制有界，毕竟是数组，创建需要有个大小限制</li><li>Linked是链表实现的，Array是数组</li><li>Linked是懒惰创建的，Array在初始化时就创建完所有的Node</li><li>Linked每次入队会生成一个新Node，而Array的Node是提前创建好的</li><li>Linked使用两把锁，一个锁住头，一个锁住尾，Array只使用了一把锁</li></ul></li></ul></li><li><strong>SynchronousQueue</strong><ul><li>这个阻塞队列是一种特殊的队列，没有容量，没有线程取的话是放不进去的，就类似于一手交钱一手交货</li></ul></li><li>DelayedWorkQueue</li><li><strong>ConcurrentLinkedQueue</strong><ul><li>和LinkedBlockingQueue非常相似</li><li>采用两把锁，同一时刻，可以允许两个线程同时（一个生产者一个消费者）执行</li><li>dummy节点的引入让两把锁锁住的不是同一个对象，避免竞争</li><li>只是ConcurrentLinkedQueue采用CAS来实现锁</li></ul></li></ol><h4 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h4><ol><li><strong>核心线程数</strong></li><li><strong>最大线程数</strong></li><li>救急线程的<strong>存活时间</strong></li><li>时间<strong>单位</strong></li><li><strong>阻塞队列</strong></li><li><strong>线程工厂</strong></li><li><strong>拒绝策略</strong><ul><li>Abort 直接抛弃，同时抛出异常</li><li>Discard 直接抛弃，不抛出异常</li><li>DiscardOldest 抛弃，最老的任务，即队列头</li><li>CallersRuns 调用者去处理</li></ul></li></ol><h4 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂 ThreadFactory"></a>线程工厂 ThreadFactory</h4><p>线程工厂就是用来创建线程的，像 <strong>SimpleThreadFactory</strong> 就是一个简单的new Thread，在 线程池中 如果没有指定线程工厂使用的是默认的 DefaultThreadFactory，里面创建非守护线程，控制了一下优先级设置，统计了线程个数等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="线程池刚初始化有线程吗，可以指定初始化有线程吗"><a href="#线程池刚初始化有线程吗，可以指定初始化有线程吗" class="headerlink" title="线程池刚初始化有线程吗，可以指定初始化有线程吗"></a>线程池刚初始化有线程吗，可以指定初始化有线程吗</h4><h3 id="线程相关（run、start、Callable、Future）"><a href="#线程相关（run、start、Callable、Future）" class="headerlink" title="线程相关（run、start、Callable、Future）"></a>线程相关（run、start、Callable、Future）</h3><h4 id="调用sleep-0-方法有什么作用"><a href="#调用sleep-0-方法有什么作用" class="headerlink" title="调用sleep(0)方法有什么作用"></a>调用sleep(0)方法有什么作用</h4><p>sleep(0)，睡眠0s可以触发一次CPU的竞争，sleep让当前线程放弃CPU使用权，睡眠一定时间，这样可以在服务压力大的时候，某个线程一直占用某个资源，占用时间过长了，可以一定程度上避免饥饿现象</p><h4 id="线程的run-和start-有什么区别"><a href="#线程的run-和start-有什么区别" class="headerlink" title="线程的run()和start()有什么区别"></a>线程的run()和start()有什么区别</h4><p>每个线程最终都是要调用其中的run()放来执行任务的。调用Thread类的start()方法来启动一个线程，调用了start()方法后，线程进入就绪状态，此刻还没有执行，等待CPU分配时间片然后继续执行。如果直接调用run()方法不调用start方法，这跟调用普通方法差不多，并没有开启多线程的运行，而只是普普通通的执行了一个run()方法而已</p><p>start()方法只能调用一次，源码会判断线程状态是否是0即新建状态，不是则抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br></pre></td></tr></table></figure><h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>new一个Thread，进入新建状态。调用start会启动一个线程进入就绪状态，等待分配时间片，分配到时间片后就可以开始运行了。start()之后会执行到run()方法完成任务。如果直接调用run()方法跟调用一个普通方法没啥区别，就是一个普通方法执行了而已，并没有开启多线程</p><h4 id="什么是-Callable-和-Future"><a href="#什么是-Callable-和-Future" class="headerlink" title="什么是 Callable 和 Future?"></a>什么是 Callable 和 Future?</h4><p>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 <strong>Runnable</strong> <strong>不会返回结果</strong>，并且<strong>无法抛出返回结果的异常</strong>，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值</p><p>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 <strong>Callable用于产生结果，Future 用于获取结果。</strong></p><h4 id="什么是-FutureTask"><a href="#什么是-FutureTask" class="headerlink" title="什么是 FutureTask"></a>什么是 FutureTask</h4><p>FutureTask 表示一个异步运算的任务。<strong>FutureTask 里面可以传入一个 Callable 的具体实现类</strong>，可以对这个异步运算的任务的结果进行<strong>等待获取</strong>、<strong>判断是否已经完成</strong>、<strong>取消任务</strong>等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所 以 FutureTask 也可以放入线程池中</p><h4 id="什么叫线程安全？servlet-是线程安全吗"><a href="#什么叫线程安全？servlet-是线程安全吗" class="headerlink" title="什么叫线程安全？servlet 是线程安全吗?"></a>什么叫线程安全？servlet 是线程安全吗?</h4><p>指某个方法在多线程环境中被调用时，能够正确地处 理多个线程之间的共享变量，使程序功能正确完成。 Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一 个方法，是不能保证共享变量的线程安全性的。</p><p>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</p><h4 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h4><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程 会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低 优先级，10 代表最高优先级。 Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><h4 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h4><p>总的来说就是哪里new的，就是哪里调用的</p><p>假设 Thread2 中 new 了 Thread1，main 函数中 new 了 Thread2，那么： </p><p>（1）Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方 法是Thread2 自己调用的 （2）Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法 是Thread1 自己调用的</p><h4 id="Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取-线程堆栈？"><a href="#Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取-线程堆栈？" class="headerlink" title="Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取 线程堆栈？"></a>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取 线程堆栈？</h4><p>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump 文件中。</p><p> 在 <strong>Linux</strong> 下，你可以通过命令 <strong>kill -3 PID</strong> （Java 进程的进程 ID）来获取 Java应用的 dump 文件。 </p><p>在 Windows 下，你可以按下 <strong>Ctrl + Break</strong> 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件 中，具体位置依赖应用的配置。</p><h4 id="一个线程运行时发生异常会怎样"><a href="#一个线程运行时发生异常会怎样" class="headerlink" title="一个线程运行时发生异常会怎样"></a>一个线程运行时发生异常会怎样</h4><p>如果异常<strong>没有被捕获该线程将会停止执行</strong></p><p> Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理</p><h4 id="Java-线程数过多会造成什么异常？"><a href="#Java-线程数过多会造成什么异常？" class="headerlink" title="Java 线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h4><ul><li>线程的生命周期开销非常高 </li><li>消耗过多的 CPU</li><li>降低稳定性JVM</li></ul><h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><p><strong>synchronized底层原理</strong>其实就是 每个<strong>Java对象</strong>，都有一个<strong>对象头</strong>，对象头包含mark word和Klass word，<strong>每个对象</strong>都可以<strong>关联一个Monitor</strong>，当进入synchronized同步代码块的时候，该锁对象就把它的<strong>markword值设置为</strong>关联的对应<strong>monitor的地址值</strong>，然后把monitor的<strong>owner线程</strong>设为当前线程。后面有别的线程进入synchronized，会发现obj已经有一个关联的monitor，其owner线程为之前的线程，他就会进入monitor对象的EntryList中等待</p><p>它加锁依赖于底层操作系统的指令，会造成用户态和内核态之间的切换，比较耗性能</p><p>在JDK 6的时候采用了偏向锁和轻量级锁进行优化</p><p><strong>轻量级锁用于优化重量级锁</strong>，轻量级锁<strong>主要用于</strong>有一个线程要加锁，别的线程也需要，但是他们的加锁时间是错开的，就是说<strong>没有竞争的情况</strong>，会在线程栈帧中创建一个<strong>lock record 锁记录</strong>，然后把锁对象的<strong>markword</strong> 和 <strong>锁记录地址</strong>进行一个<strong>CAS交换</strong>，交换成功就是加锁成功，这样markword存的是锁记录的地址，锁记录地址就是对象的markword。如果后面又有线程来<strong>CAS加锁</strong>，那么就是可能出现<strong>锁膨胀</strong>或者<strong>锁重入</strong>的情况，锁膨胀就是说发生了竞争，这个时候就要升级为重量级锁了</p><p><strong>偏向锁</strong>主要用于<strong>优化轻量级锁</strong>，主要场景是：没有竞争的时候，一个线程多次进入<strong>synchronized需要重入加锁</strong>的时候，<strong>将进入临界区的线程的ID, 直接设置给锁对象的Mark word,</strong> 下次该线程<strong>又获取锁</strong>, 发现<strong>线程ID是自己</strong>, 就<strong>不需要CAS</strong>了</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220416220641010.png" alt="image-20220416220641010"></p><p>synchronized最开始其实是重量级锁，在JDK6以后引入了轻量级锁和偏向锁的概念，它们只是jvm上的逻辑，避免了重量级锁频繁且不必须的在用户态和内核态之间的切换。</p><p>首先线程执行到synchronized同步代码块，会在栈帧中创建一个锁记录Lock Record，锁记录主要有两部分，一部分存放锁记录地址+00两位标识，还有一部分存储锁对象的地址。尝试加锁，首先会去将锁记录和锁对象的Mark Word进行CAS交换，第一次因为没人加锁，所以交换成功，然后锁记录里就存放着锁对象的markword和锁对象的地址。而锁对象的markword现在存放的是锁记录的地址。</p><p>如果后续当前加锁的线程还没释放锁，又准备进行一次加锁，即发生锁重入，线程首先也会创建锁记录，然后尝试一次CAS，这次加锁失败了，因为发现锁对象markword中记录的指向就是自己线程中的锁记录，所以就会把新建的锁记录地址设置为null，然后object reference指向锁对象。退出同步代码块的时候，发现锁记录的锁记录地址是null，说明有锁重入，计数器减去1，到最后发现不为null，就CAS交换回锁对象的markword。</p><p>锁膨胀：在Thread0线程还没释放锁的时候，如果又有一个线程Thread1执行到同步代码块，准备加锁，发现锁对象的markword已经是00了，说明已经是轻量级锁了，这个时候会进入锁膨胀的过程，生成一个monitor对象，将锁对象关联到monitor对象，然后将锁对象的markword重新指向monitor的地址，然后把monitor的Owner设置为Thread0，当前加锁失败的线程就进入Monitor的EntryList等待</p><p>Thread0线程执行完后，发现锁对象的markword已经是01了，已经是重量级锁，说明发生了锁膨胀，这样就进入重量级锁的解锁流程，根据锁对象的markword找到对应的monitor，然后设置Owner线程为null，唤醒EntryList中的Thread1</p><h3 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park Unpark"></a>Park Unpark</h3><p>park和unpark原理：每个线程都有一个parker对象，这个对象主要有3个值_counter、 _mutex、 _cond</p><p>park的时候先检查_counter的值是否为0，如果为0，就进入 _cond等待队列阻塞，如果为1，就继续运行，设置 _counter为0</p><p>unpark直接设置_counter值为1，唤醒 _cond中的线程，线程恢复运行设置counter为0</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile <strong>原子性、可见性、有序性的概念</strong> —–&gt; <strong>读写屏障</strong>保证可见性、有序性<strong>原理</strong> —–&gt;<strong>CAS 保证原子性</strong>，<strong>volatile保证 可见性、有序性</strong> <strong>乐观锁实现无锁并发</strong> ——&gt; CAS的<strong>底层lock指令</strong> —–&gt; API 层面的<strong>compareAndSwap方法</strong> —–&gt; <strong>缺点一直重试</strong>，竞争激烈效率反而降低，并且会有<strong>ABA问题</strong> —–&gt; <strong>优点</strong> 没有synchronized<strong>悲观的思想</strong>，<strong>没有线程上下文的切换</strong></p><p>volatile 关键字主要用于来保证多线程共享数据的安全性问题，主要保证其有序性和可见性。三个特性：原子性指程序代码的执行不会受到线程上下文切换的影响，这个主要采用加锁来保证。可见性指程序代码的执行不会受到缓存的影响，JIT即时编译器对于程序代码的优化，保证去主存中读取数据，更新数据到主存中。有序性指程序代码的执行不会受到CPU优化的影响，比如指令重排。因为CPU的指令是类似一条流水线，一个周期，多个指令。</p><p>volatile通过内存屏障来保证有序性和可见性。</p><p>保证可见性：就是在读数据的加一个读屏障，保证读取共享的数据的时候都去主存中读取，然后再加一个写屏障，保证更新数据都把数据更新到主存中</p><p>保证有序性：也是通过读写屏障，读屏障保证读屏障之后的代码不会重排到前面。写屏障保证写屏障之前的代码不会重排到写屏障后面。</p><p>结合CAS+volatile关键字就可以实现无锁并发。volatile保证有序性、可见性。CAS保证原子性</p><p>CAS底层采用一个lock指令，在多线程下能保证 比较-交换 操作的原子性。它会把CPU总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程不会被多线程调度机制所打断</p><p>在Java API层面就对应一个CompareAndSwap()方法，它需要一个期望的值，以及要修改的值，先拿着期望的值去主存中的值作比较，如果相等就去修改值，要是不相等，就代表CAS失败，这个时候就加一个while循环，让其一直尝试CAS去比较并交换。</p><p>可以发现它没有阻塞，而是一直去尝试更新值，更新不成功就再CAS一次。这种也会带来一定的开销，因为在竞争激烈的时候它可能一直CAS失败，效率反而会降低。不过它避免了synchronized的悲观锁的思想，避免了线程上下文的切换造成的开销。</p><p>此外CAS 还有可能造成ABA问题</p><h3 id="原子包装类"><a href="#原子包装类" class="headerlink" title="原子包装类"></a>原子包装类</h3><p><strong>java.util.concurrent.atomic</strong>提供的是一些原子类，都是基于CAS + volatile 来实现的</p><p><strong>原子整数类：</strong></p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p><strong>原子引用类：</strong>原子引用保证引用类型的共享变量是线程安全的，刚才的是规定了数据类型比如为Integer</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicMarkableReference</code>：原子更新带有<strong>标记</strong>的引用类型。该类并不关心中途修改了多少次，只关心有没有修改过，所以只需要用一个 boolean 标记与引用关联起来，可以解决ABA 问题</li><li><code>AtomicStampedReference</code> ：原子更新带有<strong>版本号</strong>的引用类型。用版本号一般是整型来标识是否被修改过，用来解决 ABA 问题</li></ul><p><strong>原子数组类：</strong>原子数组用来保证数组内的元素的线程安全，使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><h3 id="AQS、ReentrantLock-条件变量-使用、ReentrantLock-原理"><a href="#AQS、ReentrantLock-条件变量-使用、ReentrantLock-原理" class="headerlink" title="AQS、ReentrantLock 条件变量 使用、ReentrantLock 原理"></a>AQS、ReentrantLock 条件变量 使用、ReentrantLock 原理</h3><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p><strong>AQS</strong>是<strong>抽象的队列同步器</strong>，是<strong>JDK1.5</strong>提供的一套<strong>实现阻塞锁</strong>的并且<strong>依赖于FIFO队列 CLH 队列 的同步器</strong>，<strong>AQS定义</strong>了一套<strong>多线程访问共享资源的方法</strong>，<strong>提供</strong>了一个<strong>等待队列</strong>，<strong>类似于</strong>Monitor中的<strong>EntryList</strong>。里面<strong>可以</strong>去<strong>获得锁</strong>，<strong>加锁</strong>，<strong>释放锁</strong>等一些<strong>操作</strong>，但是有的方法比如 <code>tryAcquire()</code> 是由其子类去实现的。AQS 主要还是起到一个模板的作用。像 通常都 创建一个 Sync 然后 继承 AQS，同时里面去实现一些自己的方法，然后 Sync 又对应 NonfairSync 和 FairSync，里面去实现其 自己的 tryAcquire() 方法。使用了 <strong>模板方法设计模式</strong></p><p>它<strong>用state属性</strong>来<strong>表示资源的状态</strong>，子类需要定义如何<strong>维护这个状态</strong>，<strong>控制</strong>如何<strong>获取锁和释放锁</strong>，比如<strong>state为0</strong>就是<strong>没有线程持有锁</strong>，<strong>把state改为1就是有线程持有锁</strong>，采用<strong>CAS来更新state</strong>的值</p><p><strong>AQS锁</strong>分为<strong>独占锁</strong>和<strong>共享锁</strong>，<strong>独占锁</strong>的实现主要有<strong>ReentrantLock</strong>，<strong>共享锁</strong>的实现主要有<strong>CountDownLatch</strong>、<strong>ReentrantReadWriteLock中的读锁</strong>。</p><h3 id="ReentrantLock-加锁"><a href="#ReentrantLock-加锁" class="headerlink" title="ReentrantLock 加锁"></a>ReentrantLock 加锁</h3><p>ReentrantLock 默认是非公平锁实现，构造方法就是构造一个非公平同步器，加锁就调用同步器的lock()方法。lock()方法先用CAS尝试将state的值改为1，如果修改成功，就设置独占锁线程为当前线程。假设第一个竞争出现，已经有Thread0加锁成功，那么当前线程Thread1cas失败，就<strong>加锁失败</strong>。进入acquire()方法，会<strong>再次尝试去获取一次锁，调用tryAquire()方法</strong>，如果仍然获取失败，就尝试加入到等待队列里去，加入返回true就调用selfInterrupt把该线程打断。</p><p>尝试加入等待队列中调用acquireQueued方法，等待队列是一个Node双向链表队列，首先会判断没获得锁的情况下，是否下一个就是自己，如果是就<strong>再一次尝试获取锁，调用tryAcquire()尝试加锁</strong>，这次成功了就把自己设置为Head节点。这次加锁失败，那么就应该<strong>在加锁失败后park住shouldParkAfterFailedAcquire</strong>这个方法会将前驱节点即head的waitStatus值改为-1，-1表示前面线程有责任唤醒后面的线程。最后返回false，结束判断后又进入for循环去尝试获取一次锁，假设又失败，那么又进入shouldParkAfterFailedAcquire方法，因为前面已经修改waitStatus值为-1，这次肯定设置失败，返回true，返回true后就进入parkAndCheckInterrupt把当前线程park住</p><h3 id="ReentrantLock-释放锁"><a href="#ReentrantLock-释放锁" class="headerlink" title="ReentrantLock 释放锁"></a>ReentrantLock 释放锁</h3><p>ReentrantLock 释放锁 release 方法，首先进入 tryRelease 方法，把 state 的值减去1，如果 state 的值为0，则将独占锁的Owner线程设置为null。如果全部释放了，就去 unparkSuccessor 唤醒队列中等待线程</p><h3 id="ReentrantLock-可打断与不可打断"><a href="#ReentrantLock-可打断与不可打断" class="headerlink" title="ReentrantLock 可打断与不可打断"></a>ReentrantLock 可打断与不可打断</h3><p>synchronized 的打断指的是获取到了锁以后，可以进行打断，打断正在运行的线程或者说打断在sleep，wait，join的线程</p><p>ReentrantLock 的打断指的是没获得到锁，被park阻塞住以后，可以打断它的阻塞</p><ol><li><strong>不可打断</strong><ul><li>ReentrantLock的可打断指的是在线程没获取到锁，去阻塞队列里等待的时候，是可以打断阻塞的</li><li>其实现原理：在线程正常尝试获取锁，获取失败后，进入parkAndCheckInterrupt方法park住的时候，方法的返回值是<code>return Thread.interrupted();</code>。这个方法会返回线程的打断标记，并且清除打断标记，也就是说线程在park被打断后，会返回true，然后打断标记重新置为false；从这个方法里面出来后，就把方法里的局部变量interrupted设置为true，然后下一次循环，获取到锁，回到acquire()方法，再进行一次自我打断selfInterrupt()，重新打断一次，如果是正常运行状态不是sleep中就不会抛打断异常</li></ul></li><li><strong>可打断</strong><ul><li>可打断是因为在park住后被唤醒了，返回线程是不是被打断，同时清除打断标记，如果要是被打断过了，返回为true，那就进入if代码块内部，抛出异常，否则返回false，直接进入下一次循环</li></ul></li></ol><h3 id="ReentrantLock-可重入"><a href="#ReentrantLock-可重入" class="headerlink" title="ReentrantLock 可重入"></a>ReentrantLock 可重入</h3><p>ReentrantLock 可重入主要基于它的 state 值，它tryAcquire方法会去判断要加锁的线程是不是当前线程，如果是，就把state的值+1，释放锁的时候，会一直把state的值减到0</p><h3 id="ReentrantLock-公平与非公平锁"><a href="#ReentrantLock-公平与非公平锁" class="headerlink" title="ReentrantLock 公平与非公平锁"></a>ReentrantLock 公平与非公平锁</h3><p>ReentrantLock 下面有不同的同步器实现，FairSycn或者nonFairSycn，</p><p>公平锁与非公平锁的实现区别主要在tryAcquire方法里，在使用CAS state的值之前，会先去判断队列里面是否还有前驱节点，也就是说还有不有线程关联的节点在排队，如果有，直接就返回false了。否则才去尝试 CAS</p><h3 id="ReentrantLock-条件变量"><a href="#ReentrantLock-条件变量" class="headerlink" title="ReentrantLock 条件变量"></a>ReentrantLock 条件变量</h3><p>AQS 中有个ConditionObject是实现了Condition的公共内部类，每个条件变量对对应着一个ConditionObject，每个ConditionObject 维护了一个等待队列</p><p><strong>await</strong>：</p><ul><li>线程持有锁的情况下，在调用条件变量的 await 方法时，首先将当前线程关联一个在ConditionObject中的一个节点，加入等待队列的尾部，然后 fullyRelease 释放所有的锁，最后再唤醒 AQS 队列中的下一个节点</li></ul><p><strong>signal</strong>：</p><ul><li>先判断是否持有独占锁，只有持有锁，才能去唤醒条件变量中的线程；然后每次取条件变量队列中的第一个 node ，然后就把这个节点断开，把这个节点加入到 ReentrantLock 的等待队列中去，把上一个节点的 waitStatus 值设置为-1</li></ul><h3 id="多线程顺序打印"><a href="#多线程顺序打印" class="headerlink" title="多线程顺序打印"></a>多线程顺序打印</h3><h3 id="多线程交替输出"><a href="#多线程交替输出" class="headerlink" title="多线程交替输出"></a>多线程交替输出</h3><h3 id="Semaphore、CountDownLatch、CycleBarrier"><a href="#Semaphore、CountDownLatch、CycleBarrier" class="headerlink" title="Semaphore、CountDownLatch、CycleBarrier"></a>Semaphore、CountDownLatch、CycleBarrier</h3><p><strong>Semaphore</strong> 信号量，可以用来控制同一时间有多少个线程能够执行，构造方法传入允许的 permits 最大的限制数。首先获取共享锁，将state-1看state是否小于0，如果是小于，那么就放入队列中等待，如果不是小于0，就尝试CAS把state的值减去1，CAS成功就成功返回。释放了一个线程后归还一个信号量，那么下一个线程才能执行。</p><p><strong>CountDownLatch</strong> 倒计时锁，维护一个计数器，当计数器的值不为0时，调用 await 方法就可以进行阻塞，每次使用就 countDown 计数减1，当计数器为0，所有阻塞的线程从 await 中返回执行</p><p>利用这个特性我们可以用来合并多个线程最终的结果，或者以此来模拟并发请求调用等等，如下并发请求代码</p><h3 id="CopyOnWriteArrayList原理"><a href="#CopyOnWriteArrayList原理" class="headerlink" title="CopyOnWriteArrayList原理"></a>CopyOnWriteArrayList原理</h3><p>CopyOnWriteArrayList写时复制list，是一个<strong>线程安全的list</strong>，底层通过<strong>复制数组</strong>的方式来实现。当我们往<strong>容器添加元素</strong>时，不直接往容器中添加，而是先将当前容器进行复制，<strong>复制出一个新的容器</strong>，<strong>然后往新的容器添加元素</strong>，添加完元素之后，再将原容器引用指向新容器。</p><p><strong>比较适合 读多写少 的场景，因为本身这样不能保证数据的强一致性，可能读到旧数据；此外，如果频繁的写入的话，因为它会创建出一个新的数组，写多，创建的新的数组就多，很容易就触发GC</strong></p><p>这样做的好处就是可以对CopyOnWrite容器进行并发的读而不需要加锁，因为当前容器不会被修改。</p><p>缺点：</p><ul><li>写时复制的机制，进行写操作的时候，内存里会同时驻扎两个对象的内存，也就是会同时存在两个容器</li><li>CopyOnWriteArrayList不能保证数据的实时一致性，可能读到旧数据</li></ul><h3 id="什么是ConcurrentHashMap？"><a href="#什么是ConcurrentHashMap？" class="headerlink" title="什么是ConcurrentHashMap？"></a>什么是ConcurrentHashMap？</h3><p>ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现。涉及高并发如果要用map结构，那第一时间想到的就是它。相对于hashmap来说，ConcurrentHashMap就是线程安全的map，其中利用了锁分段的思想提高了并发度。</p><p>JDK 1.6版本关键要素：</p><ul><li>segment继承了ReentrantLock充当锁的角色，为每一个segment提 供了线程安全的保障； </li><li>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。 </li></ul><p>JDK1.8后，ConcurrentHashMap抛弃了原有的Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p><h3 id="SynchronizedMap和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap和 ConcurrentHashMap 有什么区别？</h3><p>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访问map。</p><p>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。 ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。</p><p>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中， 当iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时 new 新的数据从 而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【<strong>资源对象</strong>】的<strong>线程隔离</strong>，让<strong>每个线程各用各的</strong>【<strong>资源对象</strong>】，<strong>避免争用</strong>引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个<strong>线程内</strong>有一个 <strong>ThreadLocalMap</strong> 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li>初始容量 16，扩容因子 2/3，扩容容量翻倍</li><li>key 索引冲突后用开放寻址法解决冲突</li></ul>]]></content>
    
    
    <summary type="html">JVM,JUC，IO总结</summary>
    
    
    
    <category term="Java基础" scheme="http://ins1mn1a.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="http://ins1mn1a.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://ins1mn1a.github.io/2022/05/17/JUC/ThreadLocal/"/>
    <id>http://ins1mn1a.github.io/2022/05/17/JUC/ThreadLocal/</id>
    <published>2022-05-17T02:42:58.375Z</published>
    <updated>2022-05-17T02:45:01.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal 可以实现 <strong>线程间</strong> 的 <strong>资源隔离</strong>，让每个线程各用各的 资源对象，避免争用引发的线程安全问题</p><p>局部变量也是每个方法一个资源，但是局部变量的缺点就是 不能实现方法外的 其他方法对资源的调用。</p><p>所以 ThreadLocal 同时实现了**线程内 **的 <strong>资源共享</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+Utils.getConnection());</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+Utils.getConnection());</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+Utils.getConnection());</span><br><span class="line">            &#125;,<span class="string">&quot;t&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                Connection connection = Utils.getConnection();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+connection);</span><br><span class="line">            &#125;,<span class="string">&quot;t&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 从当前线程的 threadLocalMap 中获取</span></span><br><span class="line">            Connection conn = tl.get();</span><br><span class="line">            <span class="keyword">if</span> (conn==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建新的 connection 对象</span></span><br><span class="line">                conn = innerGetConnection();</span><br><span class="line">                <span class="comment">// 存入当前线程</span></span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">innerGetConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><p>其原理是，每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象。</p><p>下面是 <strong>Thread</strong> 类 里 带有的 <strong>ThreadLocalMap threadLocals 成员</strong>，由ThreadLocal 维护</p><p><img src="/../../img/markdown_img/ThreadLocal.assets/image-20220416093811433.png" alt="image-20220416093811433"></p><ol><li><p>调用 set 方法，先获取到 当前线程的 ThreadLocalMap ，当前线程的 ThreadLocalMap 还没被创建出来，就去<code>createMap</code>，同时<strong>设置 key value</strong>；如果 ThreadLocalMap 已经创建出来了，就以 ThreadLocal 作为 Key，资源对象 作为 value，放入当前线程的 ThreadLocalMap 集合中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>调用 get 方法，同样获取到 当前线程的 ThreadLocalMap，然后以 ThreadLocal 作为 Key，到当前线程的 ThreadLocalMap 中 查找关联的资源值value</p><p><strong>get方法与其他 map 不同的是，如果发现 get 的key  就不存在 ，它仍然会 设置 key 为 threadlocal，只不过 value 为null</strong></p></li><li><p>调用 remove 方法，获取到 当前线程的 ThreadLocalMap，以 ThreadLocal 作为 key，移除当前线程关联的资源值</p></li></ol><p>所以 起到 线程间隔离 作用的是 每个线程内的 ThreadLocalMap ，而 ThreadLocal 则是用来 关联资源对象的</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><ul><li>ThreadLocalMap 初始大小 16，扩容因子 2/3</li><li>key 的 hash 值 统一分配，每次获取 nextHashcode，桶下标 就和 tab 的 长度-1 &amp; 运算</li><li>扩容容量翻倍</li><li>key 索引冲突后采用 <strong>开放寻址法</strong> 解决冲突</li></ul><h2 id="弱引用-key"><a href="#弱引用-key" class="headerlink" title="弱引用 key"></a><strong>弱引用 key</strong></h2><p>ThreadLocalMap 中的 <strong>key</strong> 被设计为 <strong>弱引用（内存不足的时候就会回收）</strong>，原因如下：</p><ul><li><p>只要 别的地方的引用 没有引用到ThreadLocal了，那么 ThreadLocalMap 中 key 设计的为弱引用，所以垃圾回收的时候就可以直接进行回收。如果是强引用，key 引用了，ThreadLocal 是不会回收的</p></li><li><p>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时 释放其占用的内存</p></li></ul><p>只有其 Key 设置为了 弱引用，其 value 还是强引用，那么 其 value 的内存释放时机如下</p><h2 id="value-内存释放时机"><a href="#value-内存释放时机" class="headerlink" title="value 内存释放时机"></a><strong>value 内存释放时机</strong></h2><ol><li>获取 key 时 发现 null key<ul><li>只是 发现 key 为null，会把 对应的 value 清理掉，同时 把 key 设置为 threadLocal</li></ul></li><li>set key value 时，会使用启发式扫描，清除临近的 null key，启发次数与元素个数，是否发现 null key 有关</li><li>remove 时（推荐），因为一般使用 ThreadLocal 时都把它作为 静态变量，因此 GC 无法回收，所以一般都 手动 remove</li></ol><p>使用 ThreadLocal 的时候一般都把它作为 static final 变量，所以 是无法进行 GC回收的，因此 value 内存释放的时候前两种 发现 null key 进行回收是回收不了的</p><p>所以必须要手动 remove ，否则就会发生内存泄露</p><h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>ThreadLocalMap 的生命周期和 Thread 是一致的，因此 尽管 ThreadLocalMap 里的 key 是弱引用，理论上 作为 key 的 thread local 可以回收，但是 static final 的 ThreadLocal 强引用还是存在的，所以回收不了，其中 Entry 的 value 也就回收不了，因此，只能我们手动去 remove 掉 Entry对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    <span class="comment">// Reference 类中 clear，this.referent = null;</span></span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>使用 ThreadLocal 来数据库的Connection 对象，可以避免多次获取数据库连接对象</p><p>使用 ThreadLocal 来保存会话 Session 信息，可以避免 在把 session 对象 各处传递，就可以把 Session 对象放到 ThreadLocal 里面</p>]]></content>
    
    
    <summary type="html">ThreadLocal 原理，ThreadLocalMap，ThreadLocal 内存泄露</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="http://ins1mn1a.github.io/2022/05/17/JUC/ConcurrentHashMap/"/>
    <id>http://ins1mn1a.github.io/2022/05/17/JUC/ConcurrentHashMap/</id>
    <published>2022-05-17T02:42:58.370Z</published>
    <updated>2022-05-17T02:46:09.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK-8-ConcurrentHashMap"><a href="#JDK-8-ConcurrentHashMap" class="headerlink" title="JDK 8 ConcurrentHashMap"></a>JDK 8 ConcurrentHashMap</h2><h3 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span></span></span><br></pre></td></tr></table></figure><h3 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h3><p>initialCapacity初始容量至少得有concurrencyLevel并发度的大小，如果小于，则赋值为并发度。</p><p>懒惰初始化，在<strong>构造方法中仅仅计算了table的大小</strong>，以后在第一次使用的时候才会真正创建</p><p><code>concurrencyLevel</code>并发度，可以理解为分段Segment的个数，这个初始化之后就不会改变了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">// （1+8/0.75) = 11</span></span><br><span class="line">        <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">//  tableSizeFor 是保证计算的大小是 2^n, 即 16,32,64 ...</span></span><br><span class="line">    <span class="comment">// 16</span></span><br><span class="line">        <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">     <span class="comment">// spread 方法能确保返回结果是正数</span></span><br><span class="line">     <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">     (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 如果头结点已经是要查找的 key</span></span><br><span class="line">         <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">         <span class="keyword">return</span> e.val;</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="comment">// hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找</span></span><br><span class="line">        <span class="comment">// 扩容中为forwarddingNode 为-1 treebin 为-2</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 正常遍历链表, 用 equals 比较</span></span><br><span class="line">     <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">     ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">     <span class="keyword">return</span> e.val;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h3><p>put流程先获取得到hash值，然后看<strong>tab有没有创建</strong>了，因为是懒惰初始化，<strong>没有创建</strong>就走<strong>initTable</strong>流程，如果<strong>创建出来了就去判断头结点为null</strong>，就不用遍历直接<strong>采用CAS把头结点换成要put的节点</strong>，否则看<strong>头结点</strong>是不是<strong>MOVED</strong> 也就是<strong>forwardding Node</strong>，如果是就说明正在扩容，去**帮忙扩容helpTransfer()**。</p><p>最后就说明table已经创建，头结点也不为null，那么就<strong>synchronized加锁头结点</strong>，<strong>再次判断头结点</strong>是否被<strong>移动</strong>，然后如果是链表就去遍历链表，创建node或者覆盖node，如果是红黑树就走红黑树的流程，期间采用<strong>bitCount计数</strong>，<strong>判断链表的大小是否超过树化阈值</strong>，如果超过，走treefiyBin流程。</p><p>最后<strong>addCount</strong>，采用<strong>LongAdder</strong>的思想，使用<strong>CounterCells</strong>做<strong>累加计数</strong>，size+1；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认putIfAbsent false 即默认是覆盖值的 如果为true，不会覆盖值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 获得hash spread会综合高低位，具有更好的hash性</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 死循环扩容</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">// 看tab有没有创建，因为懒惰初始化</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 初始化table 使用了CAS去初始化</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">// 如果对应的头结点为null 不用遍历 就CAS把头结点换成要put的就ok</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 看hash值是不是MOVED(-1) 如果是说明当前节点处下面的正在被扩容，就帮忙扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明已经初始化 已经有头结点，没有在扩容</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 锁住链表的头结点</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">//再次判断头结点是否被移动</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">// 如果是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// binCount 计数 可以理解为链表的长度</span></span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">// 遍历链表</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="comment">// 看key是否重复</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="comment">// key不重复 new Node到链表尾</span></span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果是红黑树</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            <span class="comment">// 设置binCount为2</span></span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不等于0说明有冲突</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 有冲突 看binCount长度是不是大于树化阈值</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加size计数</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h3><p>初始化表，判断如果sizeCtl为-1，就说明有人正在创建tab，yield()让出CPU使用权，否则CAS设置sizeCtl的值，获得锁，创建table。创建完后sizeCtl就代表了下一次要扩容的阈值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是sizeCtl为-1 说明有人正在创建了 就yield() 让出CPU使用权</span></span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="comment">// CAS将sizeCtl设置为-1 （表示初始化table）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 获得锁，创建table，这时候其他线程会在while循环中yield</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        <span class="comment">// 现在 sc sizeCtl 代表下一次要扩容的阈值</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><h3 id="size计算"><a href="#size计算" class="headerlink" title="size计算"></a>size计算</h3><p>size计算实际发生在put和remove改变集合元素的操作之中</p><ul><li>没有竞争发生，向baseCount累加计数</li><li>有竞争发生，新建CounterCells，向其中的一个cell累加计数<ul><li>counterCells初始有两个cell</li><li>如果计数竞争比较激烈，会创建新的cell来累加计数</li></ul></li><li>因此，累加计数其实可能是有一定的错误的，尽管已经采用了CounterCells来做优化</li></ul><h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h3><p>首先**<code>if(nextTab=null)</code><strong>判断如果要搬迁的链表为空，就创建一个大小为<code>n&gt;&gt;1</code>右移1位也就是</strong>扩大两倍的新的tab**</p><p>**<code>else if((f=tabAt(tab,i))==null)</code>**表示如果整个链表都搬迁完了，那就把原来tab的节点换成forwardingNode</p><p><code>else if((fh=f.hash)==MOVED)</code>表示如果已经搬迁过了，因为会有帮忙扩容的流程，MOVED是forwarding node 的hash值 -1</p><p>否则就对链表头加锁，如果是链表就走链表的搬迁流程，如果是TreeBin就走树的流程</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319092911812.png" alt="image-20220319092911812"></p><h3 id="JDK-8-ConcurrentHashMap-1"><a href="#JDK-8-ConcurrentHashMap-1" class="headerlink" title="JDK 8 ConcurrentHashMap"></a>JDK 8 ConcurrentHashMap</h3><p>JDK 8 数组（Node）+（链表 Node | 红黑树 TreeNode）</p><ul><li><p><strong>初始化</strong>，使用<strong>CAS来保证并发安全</strong>，<strong>懒惰初始化table</strong>，判断tab的sizectl，当前有没有正在创建table，有就把当前线程yield，让出CPU使用权，循环yield直到tab被初始化完成，最后sizeCtl的值为下一次要扩容的值</p></li><li><p><strong>树化</strong>，当<strong>table.length &lt; 64** ，会先**尝试扩容**，**超过64**，并且链表的**长度 &gt;8</strong>，会将链表<strong>树化</strong>，树化过程会用<strong>synchronized锁住链表头</strong></p></li><li><p><strong>put</strong>，看table是否创建，懒惰创建table，再看链表是否创建，如果未创建就<strong>cas创建链表</strong>，看头结点是不是null，不是null看是不是forwarddingNode；如果已有链表，后续锁住链表头进行put操作，元素添加到链表的尾部</p></li><li><p><strong>get</strong>，<strong>无锁读操作</strong>，仅需要保证<strong>可见性</strong>，扩容过程中如果get操作拿到的是ForwardingNode它会让get操作去新的table中进行搜索</p></li><li><p><strong>扩容transfer</strong>，扩容时以链表为单位，对<strong>链表头进行synchronized加锁</strong>，但是这个时候其他竞争线程不是无事可做，它们会帮助其他链表进行扩容，扩容时平均只有1/6的节点会把复制到新table中</p><p>先看有不有其他线程在扩容，sizectl是不是&lt;0，小于0说明有，那就yield</p></li><li><p>size，元素个数保存在baseCount中，并发时的个数变动保存在CounterCell[]中，最后统计数量累加</p></li></ul><h2 id="JDK-7-ConcurrentHashMap"><a href="#JDK-7-ConcurrentHashMap" class="headerlink" title="JDK 7 ConcurrentHashMap"></a>JDK 7 ConcurrentHashMap</h2><p>它维护了一个Segment数组，每个Segment对应一把锁，继承了ReentrantLock</p><ul><li>优点：如果多个线程访问不同的Segment，实际上是没有冲突的，这与JDK 8类似</li><li>缺点：<strong>Segments数组默认大小为16</strong>，这个<strong>容量初始化指定后就不能改变</strong>了，并且<strong>不是懒惰初始化</strong>的</li></ul><h3 id="构造器分析-1"><a href="#构造器分析-1" class="headerlink" title="构造器分析"></a>构造器分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"> <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line"> concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"> <span class="comment">// ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小</span></span><br><span class="line">     <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">     ++sshift;</span><br><span class="line">     ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// segmentShift 默认是 32 - 4 = 28</span></span><br><span class="line"> <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// segmentMask 默认是 15 即 0000 0000 0000 1111</span></span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"> <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line"> ++c;</span><br><span class="line"> <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line"> <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line"> cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 创建 segments and segments[0]</span></span><br><span class="line"> Segment&lt;K,V&gt; s0 =</span><br><span class="line"> <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">  (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line"> Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[]) <span class="keyword">new</span> Segment[ssize];</span><br><span class="line"> UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line"> <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后构造出来Segments数组16个Segment默认，</p><p>可以发现ConcurrentHashMap没有实现懒惰初始化，空间占用不友好，其中<strong>this.segmentShift和this.segmentMask的作用是决定将key的hash结果匹配到哪个segment。</strong></p><h3 id="put流程-1"><a href="#put流程-1" class="headerlink" title="put流程"></a>put流程</h3><p>put流程先利用segmentShift和segmentMask计算出对应的segment下标j，然后拿着下标j去判断对应的segment是不是为null，如果是null，就创建该segment，然后用<code>ensureSegment(j)</code>方法利用CAS确保segment的安全性，因为其他线程也可能发现segment为null</p><p>最后走segment的put流程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> Segment&lt;K,V&gt; s;</span><br><span class="line"> <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> <span class="keyword">int</span> hash = hash(key);</span><br><span class="line"> <span class="comment">// 计算出 segment 下标</span></span><br><span class="line"> <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 获得 segment 对象, 判断是否为 null, 是则创建该 segment</span></span><br><span class="line"> <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject </span><br><span class="line"> (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 这时不能确定是否真的为 null, 因为其它线程也发现该 segment 为 null,</span></span><br><span class="line"> <span class="comment">// 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性</span></span><br><span class="line"> s = ensureSegment(j);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 进入 segment 的put 流程</span></span><br><span class="line"> <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>segment 继承了可重入锁（ReentrantLock），它的 put 方法为</p><p>首先尝试给segment加锁，加锁不成功进入scanAndLockForPut流程，里面会while循环尝试lock，并且尝试期间还顺便看该节点有没有被创建出来，没有就顺便创建出来</p><p>加锁成功就走遍历entry的流程，判断key存不存在，存在就覆盖，不存在就新增node到链表头</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 尝试加锁</span></span><br><span class="line"> HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line"> <span class="comment">// 如果不成功, 进入 scanAndLockForPut 流程</span></span><br><span class="line"> <span class="comment">// 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程</span></span><br><span class="line"> <span class="comment">// 在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来</span></span><br><span class="line"> scanAndLockForPut(key, hash, value);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 执行到这里 segment 已经被成功加锁, 可以安全执行</span></span><br><span class="line"> V oldValue;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line"> <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line"> HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line"> <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line"> <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 更新</span></span><br><span class="line"> K k;</span><br><span class="line"> <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line"> (e.hash == hash &amp;&amp; key.equals(k))) &#123; </span><br><span class="line"> oldValue = e.value;</span><br><span class="line"> <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line"> e.value = value;</span><br><span class="line"> ++modCount;</span><br><span class="line"> &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> e = e.next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 新增</span></span><br><span class="line"> <span class="comment">// 1) 之前等待锁时, node 已经被创建, next 指向链表头</span></span><br><span class="line"> <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line"> node.setNext(first);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="comment">// 2) 创建新 node</span></span><br><span class="line"> node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line"> <span class="keyword">int</span> c = count + <span class="number">1</span>; </span><br><span class="line"> <span class="comment">// 3) 扩容</span></span><br><span class="line"> <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">        <span class="comment">// rehash()</span></span><br><span class="line"> rehash(node);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="comment">// 将 node 作为链表头</span></span><br><span class="line"> setEntryAt(tab, index, node);</span><br><span class="line"> ++modCount;</span><br><span class="line"> count = c;</span><br><span class="line"> oldValue = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rehash流程"><a href="#rehash流程" class="headerlink" title="rehash流程"></a>rehash流程</h3><p>rehash发生在put流程的新增并且扩容中，才会进行rehash，做“搬迁”操作，</p><p>这个<strong>搬迁操作</strong>对于那些节点来说，<strong>有的节点</strong>是<strong>直接搬迁</strong>到新table，而<strong>有的节点</strong>则是<strong>创建出一个新的node</strong>放到新的table，这样原来的table上还存在原来的旧节点</p><ul><li>如果发现链表的下一个为null，也就是说<strong>链表中只有一个节点</strong>，那么就直接原节点搬迁到新的table中</li><li>否则，遍历一次链表，尽可能把rehash之后，idx不变的节点直接搬迁，也就是说rehash之后<strong>原来对应的table下标和新的table下标相同</strong>的<strong>直接搬迁</strong></li><li>剩下的节点就需要创建了</li></ul><p>完成扩容后，最后再把put进来的新node添加到对应table下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line"> HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line"> <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line"> <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line"> threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line"> HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line"> (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line"> <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line"> HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line"> <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"> HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line"> <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line"> <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="comment">// Single node on list</span></span><br><span class="line"> newTable[idx] = e;</span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line"> HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                    <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line"> <span class="comment">// 过一遍链表, 尽可能把 rehash 后 idx 不变的节点重用</span></span><br><span class="line"> <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line"> last != <span class="keyword">null</span>;last = last.next) &#123;</span><br><span class="line"> <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line"><span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">lastIdx = k;</span><br><span class="line"> lastRun = last;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> newTable[lastIdx] = lastRun;</span><br><span class="line"> <span class="comment">// 剩余节点需要新建</span></span><br><span class="line"> <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                     V v = p.value;</span><br><span class="line">                     <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                     <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                     HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                     newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 扩容完成, 才加入新的节点</span></span><br><span class="line"><span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line"> node.setNext(newTable[nodeIndex]);</span><br><span class="line"> newTable[nodeIndex] = node;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 替换为新的 HashEntry table</span></span><br><span class="line"> table = newTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="get流程-1"><a href="#get流程-1" class="headerlink" title="get流程"></a>get流程</h3><p>get的时候并没有加锁，采用<strong>UNSAFE的getObjectVolatile</strong>方法保证可见性，<strong>get先发生就从旧表中读取内容，get后发生就去新表中取内容</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">  HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">     <span class="keyword">int</span> h = hash(key);</span><br><span class="line">     <span class="comment">// u 为 segment 对象在数组中的偏移量</span></span><br><span class="line">     <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">     <span class="comment">// s 即为 segment</span></span><br><span class="line">     <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">     (tab = s.table) != <span class="keyword">null</span>) </span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">     e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">        &#123;</span><br><span class="line">     K k;</span><br><span class="line">     <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">     <span class="keyword">return</span> e.value;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size计算流程"><a href="#size计算流程" class="headerlink" title="size计算流程"></a>size计算流程</h3><ul><li><strong>计算元素个数前</strong>，<strong>先不加锁计算</strong>两次，如果<strong>前后两次结果</strong>一样，认为<strong>个数正确返回</strong></li><li>如果<strong>不一样</strong>，进行<strong>重试</strong>，重试次数<strong>超过3次</strong>，则<strong>将所有的Segment加锁</strong>，然后<strong>重新计数返回</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">     <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">     <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">     <span class="keyword">int</span> size;</span><br><span class="line">     <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">     <span class="keyword">long</span> sum; <span class="comment">// sum of modCounts</span></span><br><span class="line">     <span class="keyword">long</span> last = <span class="number">0L</span>; <span class="comment">// previous sum</span></span><br><span class="line">     <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">     <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK)</span><br><span class="line">            &#123;</span><br><span class="line">     <span class="comment">// 超过重试次数, 需要创建所有 segment 并加锁</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">     ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">     &#125;</span><br><span class="line">      sum = <span class="number">0L</span>;</span><br><span class="line">         size = <span class="number">0</span>;</span><br><span class="line">         overflow = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">         &#123;</span><br><span class="line">          Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">          <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">         sum += seg.modCount;</span><br><span class="line">         <span class="keyword">int</span> c = seg.count;</span><br><span class="line">         <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">         overflow = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">         <span class="keyword">if</span> (sum == last)</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">      last = sum;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 如果重试次数 &gt; RETRIES_BEFORE_LOCK说明加过锁，就释放锁</span></span><br><span class="line">     <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK)</span><br><span class="line">        &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">     segmentAt(segments, j).unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue原理"><a href="#LinkedBlockingQueue原理" class="headerlink" title="LinkedBlockingQueue原理"></a>LinkedBlockingQueue原理</h2><h3 id="基本的出队入队"><a href="#基本的出队入队" class="headerlink" title="基本的出队入队"></a>基本的出队入队</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * next 可能的三种情况：</span></span><br><span class="line"><span class="comment">        *  - next指向真正的后继节点</span></span><br><span class="line"><span class="comment">        *  - next指向自己，发生在出队时</span></span><br><span class="line"><span class="comment">        *  - next为null，表示没有后继节点，到最后了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><strong>初始化链表</strong>，<code>last = head = new Node&lt;E&gt;(null);</code>创建一个null节点，称为<strong>dummy节点</strong>，用来<strong>占位</strong>，item为null</li></ol><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319140544412.png" alt="image-20220319140544412"></p><ol start="2"><li><p>入队，<code>last = last.next = node;</code>，两个赋值操作，把last的next设置为node，last指向node</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319140824636.png" alt="image-20220319140824636"></p></li><li><p>第二个节点入队，<code>last = last.next = node;</code></p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319140908114.png" alt="image-20220319140908114"></p></li><li><p>出队</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert head.item == null;</span></span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        Node&lt;E&gt; first = h.next;</span><br><span class="line">        h.next = h; <span class="comment">// help GC</span></span><br><span class="line">        head = first;</span><br><span class="line">        E x = first.item;</span><br><span class="line">        first.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>h=head;</code> h 临时节点指向dummy</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141049604.png" alt="image-20220319141049604"></p><p><code>first=h.next;</code> first指向dummy的next</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141124537.png" alt="image-20220319141124537"></p><p><code>h.next=h;</code> 帮助回收，把next指向自己</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141305471.png" alt="image-20220319141305471"></p><p><code>head=first;</code> 把first节点作为头节点，后面会将这个节点直接设置为null，成为新的dummy节点</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141446363.png" alt="image-20220319141446363"></p><p><code>E x = first.item;</code> <code>first.item=null</code> <code>return x;</code></p><p>x 记录first节点的item，然后把这个节点做为dummy节点，设置item为null，返回x</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141549779.png" alt="image-20220319141549779"></p></li></ol><h3 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h3><p><strong>LinkedBlockingQueue</strong>主要在于使用了两把锁和dummy节点</p><ul><li>同一把锁，同一时刻，只允许一个线程（生产者或者消费者）执行</li><li>两把锁，同一时刻，可以运行两个线程（一个生产者和一个消费者）共同执行<ul><li>消费者和消费者线程仍然串行</li><li>生产者和生产者线程仍然串行</li></ul></li></ul><p><strong>线程安全分析</strong>：</p><ul><li>当节点了总数大于2时（包括dummy节点），<strong>putLock</strong>保证的是 <strong>last</strong> 节点的线程安全，<strong>takeLock</strong>保证的是 <strong>head</strong> 节点的线程安全，两把锁保证入队和出队之间没有竞争</li><li>当节点总数等于2时（包括dummy节点），<strong>putLock</strong>和<strong>takeLock</strong>仍然是两个锁对象，不会竞争</li><li>当节点总数等于1时（只有一个dummy节点），这时 <strong>take</strong> 线程会被 <strong>isEmpty</strong> 条件阻塞，有竞争，会阻塞</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>put操作：</p><ul><li>加锁，判断队列是不是满了，如果满了就去notFull条件变量中等待</li><li>队列没满的时候，就<code>enqueue()</code>入队</li><li>入完队后判断是否还能再入队，如果能就去notFull条件变量中<code>signal()</code></li><li>解锁，判断如果当前有元素就去notEmpty条件变量中唤醒一个消费者take</li></ul><p><code>put(E e) </code> 和 <code>offer(E e)</code>的区别就是put方法在队列已经满的时候会去条件变量中等待被唤醒，而offer方法如果队列已经满了则会直接返回false不会去条件变量中等待被唤醒</p><p><code>offer(E e,TimeUnit unit)</code>则会去条件变量中等待unit时间，没等到自动被唤醒再次去尝试入队</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// c 表示当前队列的大小，初始化为-1</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">// count 维护元素计数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 加的可打断锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列满了 等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 等待队列不满 nutFull</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等到了 入队</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 入完队后当前的队列容量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 如果当前容量还可以再put一个元素，那就去notFull条件变量中唤醒一个</span></span><br><span class="line">        <span class="comment">// 这里使用的signal()而不是signalAll() 为了避免把全部唤醒后大家去竞争</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中有一个元素，叫醒take</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里调用的是notEmpty.signal()而不是notEmpty.signalAll()</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h4><p>take()同put()的操作相对应</p><ul><li>请求消费，如果队列没有元素，去notEmpty条件变量中等待队列里有元素</li><li>队列中有元素，出队，判断出队后的队列的剩余元素是不是大于1，大于1说明还可以消费就去唤醒一个notEmpty条件变量中的线程</li><li>解锁，然后判断是不是可以去唤醒生产者notFull条件变量中的put线程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue和ArrayBlockingQueue"><a href="#LinkedBlockingQueue和ArrayBlockingQueue" class="headerlink" title="LinkedBlockingQueue和ArrayBlockingQueue"></a>LinkedBlockingQueue和ArrayBlockingQueue</h2><p>性能比较</p><ul><li>Linked支持有界，Array强制有界，毕竟是数组，创建需要有个大小限制</li><li>Linked是链表实现的，Array是数组</li><li>Linked是懒惰创建的，Array在初始化时就创建完所有的Node</li><li>Linked每次入队会生成一个新Node，而Array的Node是提前创建好的</li><li>Linked使用两把锁，一个锁住头，一个锁住尾，Array只使用了一把锁</li></ul><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue的设计和LinkedBlockingQueue非常相似</p><ul><li>两把锁，同一时刻，可以允许两个线程同时（一个生产者一个消费者）执行</li><li>dummy节点的引入让两把锁的锁住的不是同一个对象，避免竞争</li><li>只是ConcurrentLinkedQueue采用CAS来实现锁的</li></ul><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>写时复制ArrayList，可以保证写时复制，读写分离，但是会有弱一致性的问题</p><p>JDK 8 中采用的是ReentrantLock来实现加锁，JDK 11 采用synchronized来实现的</p><p>添加元素的流程就是：**ReentrantLock加锁后，去getArray()获取到数组，然后使用Array.copyof()复制出一个新的数组，然后在新数组里做修改操作，修改完成后再去setArray()**同步</p><p>读取的时候不加锁，实现并发的读，但是就有<strong>可能读到不一致的数据</strong>，所以具有<strong>弱一致性</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ConcurrentHashMap jdk1.7，ConcurrentHashMap jdk1.8</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法</title>
    <link href="http://ins1mn1a.github.io/2022/05/17/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://ins1mn1a.github.io/2022/05/17/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-05-17T02:39:12.302Z</published>
    <updated>2022-05-17T02:41:41.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode-300-最长递增子序列"><a href="#leetcode-300-最长递增子序列" class="headerlink" title="leetcode 300 最长递增子序列"></a>leetcode 300 最长递增子序列</h2><ul><li><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></li><li><p>示例 1：</p><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p><p>示例 2：</p><p>输入：nums = [0,1,0,3,2,3]<br>输出：4</p><p>示例 3：</p><p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li><p>首先，看着好像滑动窗口，但是仔细一想，滑动窗口，window 滑动的条件确定不了，也就是什么时候扩大窗口，什么时候缩小窗口</p></li><li><p>动态规划：</p><ul><li><p><strong>状态转移方程</strong></p><p>dp[i] 为 以 nums[i] 结尾的最长严格递增子序列的长度，要 根据dp[i-1] 去计算出 dp[i]。</p><p>可以联想到跟 nums[i] 有关。我们 <strong>要找到前面那些 结尾 比nums[i] 小的子序列，然后把 3 接到这些子序列的末尾，这样就构成了一个新的递增子序列，而且这个新的子序列长度+1。</strong></p><p><strong>找到 j∈(0,i) nums[j] 小于 nums[i] 的 j，然后 找到最大的一个 dp[j]，再把 nums[i] 拼接到后面</strong></p></li><li><p>dp[i] = Math.max(dp[i] , dp[j]+1)，其中 j∈(0,i) 且 nums[j] &lt; nums[i] </p></li><li><p>比如 下面的 nums[5]，找到 &lt; nums[5] 的，nums[1,4]，则其中最大的 dp[j]+1就是dp[i]；</p></li><li><p><strong>base case</strong></p><p>最小的dp 值 肯定至少为1，算上nums[i] 本身就是1，所以初始化dp数组最小值为1</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20220506154635172.png" alt="image-20220506154635172"></p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dp[i]  以 第 i 位结尾的最长递增子序列</span></span><br><span class="line"><span class="comment">     * 要 根据 dp[i-1] 计算出 dp[i]</span></span><br><span class="line"><span class="comment">     * 先找到 nums 中 比 nums[i] 小的数的下标 j</span></span><br><span class="line"><span class="comment">     * dp[i] = max(dp[j]) + 1</span></span><br><span class="line"><span class="comment">     * dp[i] = max(dp[i],dp[j] + 1 )</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 肯定最小值为1</span></span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 找到 结尾比nums[i]小的 然后 加1，</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]&gt;max)</span><br><span class="line">                max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最大的dp</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>该题还可以通过二分查找算法来解决。类似扑克牌游戏，从左到右，拿出一个数字，作为一个堆，下一个数字如果比上一个数字小，则可以直接放在这个堆上。如果没有堆可放，就创建一个新的堆来放。要保证下面的数字是大于上面的数字的</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20220506155240845.png" alt="image-20220506155240845"></p><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><ol start="5"><li>最长回文子串</li></ol><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p><strong>示例 1：</strong></p><ul><li>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案</li></ul><p><strong>示例 2：</strong></p><ul><li>输入：s = “cbbd”<br>输出：”bb”</li></ul><h3 id="动态规划解法："><a href="#动态规划解法：" class="headerlink" title="动态规划解法："></a><strong>动态规划解法：</strong></h3><p>回文串具有天然的动态规划性质</p><p>用一个 boolean 类型的二维数组作为 dp数组，dp[i] [j] 表示 s[i…j] 是回文串。那么状态转移方程就很明确，主要是如何去根据 状态转移方程 遍历这个dp数组</p><p><strong>状态转移</strong>：</p><ul><li>总的来说就是：dp[i] [j] = dp[i+1] [j-1] &amp;&amp; s[i] == s[j]</li><li>如果 s[i] == s[j] 的话，dp[i] [j] 是不是回文串由dp[i+1] [j-1]决定</li><li>同时，如果 i 到 j 长度只有 2 或者 3 的话 即 j-i+1 == 2 或者 j-i+1==3 —&gt; j-i&lt;3，那么又有  s[i] == s[j] ，则 s[i…j] 一定是回文串</li></ul><p><strong>遍历方式</strong>：</p><ul><li>dp[i] [j] 与 dp[i+1] [j-1] 有关，只能竖着遍历</li><li>如果 dp[i] [j] 为 true，那么就更新 记录 一下 起始位置 和 最大长度</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s = &quot;babad&quot;  ---&gt; bab  aba</span></span><br><span class="line">        <span class="comment">// dp[i][j] s[i...j] 是回文子串</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i+1][j-1] &amp;&amp; s[i] == s[j]</span></span><br><span class="line">        <span class="comment">// base case dp[i][i] = true</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最大长度为 1，单个字符</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp[i+1][j-1] 要一列一列的遍历 那就固定 j 从1开始</span></span><br><span class="line">        <span class="comment">// 一列一列的遍历 但是在对角线上方 所以 i&lt;j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i)!=s.charAt(j))</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当 s[i...j] 的长度等于 2 或者 3的时候</span></span><br><span class="line">                    <span class="comment">// s[i...j] 是否是回文串，由s[i] 是否等于 s[j] 决定</span></span><br><span class="line">                    <span class="comment">// 即 aba 或者 aa</span></span><br><span class="line">                    <span class="comment">// s[i...j] 之间的长度为 j-i+1 == 2 || j-i+1 == 3</span></span><br><span class="line">                    <span class="comment">// j-i==1 || j-i==2  ---&gt; j-i&lt;3</span></span><br><span class="line">                    <span class="keyword">if</span> (j-i &lt; <span class="number">3</span>)</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 是回文串  更新</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j-i+<span class="number">1</span>&gt;maxLen)</span><br><span class="line">                    &#123;</span><br><span class="line">                        maxLen = j-i+<span class="number">1</span>;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+maxLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="双指针解法："><a href="#双指针解法：" class="headerlink" title="双指针解法："></a><strong>双指针解法：</strong></h3><p>对于字符串 s ，从 0 到 n-1，将 每一个字符 s[i]（或者 每两个字符，因为回文串可以为奇数也可以为偶数） 作为中心，计算 以 s[i] （或者s[i]  s[i+1]） 为中心的最大的回文子串，最后 取 大的那个最为 res，这样，把字符串遍历一遍，也就 找到了 最长的回文子串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String s1 = palindrome(s, i, i);</span><br><span class="line">            String s2 = palindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">            res = res.length() &gt;s1.length() ? res:s1;</span><br><span class="line">            res = res.length() &gt;s2.length() ? res:s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找 s 中 以 i j 为中心的 回文串 的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">palindrome</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;s.length()</span><br><span class="line">        &amp;&amp; s.charAt(i) == s.charAt(j))</span><br><span class="line">        &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><ul><li><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p></li><li><p>示例 1：</p><p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>解决两个字符串的动态规划问题，常用两个指针 <strong>i，j 分别指向两个字符串的最后</strong>，然后一步步往前移动，缩小问题的规模。</p><p>这道题中两个字符串 s1，s2，我们用 i ，j 两个指针从后往前开始：</p><ol><li>如果 s1[i] == s2[j] ，相等 就不用变动，什么都不做，继续调用 dp 函数即可</li><li>s1[i] != s2[j]，不相等，就采用三种方式，增、删、替换的方式分别去执行，最后返回三个中的最小值即可</li><li><strong>base case</strong>：<ul><li>走到最后（假设将s1变为s2），那么 当 i 走完0的时候，j 还没走完，那么只能把 s2 剩下的全部插入到 s1 中，所以就返回 j+1；</li><li>当 j 走完 0 的时候，i 还没走完，那么只能把 s1 中剩下的删除所以就返回 i+1；</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditDistance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(word1,word2,word1.length()-<span class="number">1</span>,word2.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(String word1, String word2, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="comment">// i 走完了 j 还没走完，就只能把 j 剩余的插入到 s1</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// j 走完了 i 还没走完，就只能把s1 i 剩余的删除</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j))</span><br><span class="line">            <span class="keyword">return</span> dp(word1, word2, i-<span class="number">1</span>, j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(</span><br><span class="line">                dp(word1, word2, i, j - <span class="number">1</span>) + <span class="number">1</span>,<span class="comment">// 插入</span></span><br><span class="line">                dp(word1, word2, i - <span class="number">1</span>, j) + <span class="number">1</span>,<span class="comment">// 删除</span></span><br><span class="line">                dp(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span><span class="comment">// 替换</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a,Math.min(b,c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h3><p>上面是采用 递归的方法，对于这种递归，存在重叠子问题，因为dp(i,j-1) dp(i-1,j) 会出现调用同一个dp()函数，所以可以采用 <strong>备忘录</strong> 的形式，记录下来 dp[ i ] [ j ]</p><p>动态规划，自底向上的方式迭代求解</p><ol><li><p><strong>状态定义</strong></p><ul><li>dp[i] [j] 表示 s1[0…i-1]  s2[0…j-1] 的最小编辑距离</li></ul></li><li><p><strong>状态转移</strong></p><ul><li><p>s1[i] s2[j]相等的时候，什么都不用做，所以 dp[i] [j] = dp[i-1] [j-1]</p></li><li><p>否则，做增删替换三种操作，选择最小值，即：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = min(</span><br><span class="line">     <span class="comment">// 增 在s1 i的后面 插入一个 所以 dp[i][j]的最小编辑距离 应该是j的前一个</span></span><br><span class="line">    <span class="comment">// 比如 ....b ..a  有 b!=a，所以 在....b增加一个a 成为 ....ba</span></span><br><span class="line">    <span class="comment">// 此时 ....ba 和 ..a 这样 i+1 和 j 是相等的，</span></span><br><span class="line">    <span class="comment">// i还是对应的b，j对应a，a 已经添加了对应成功了，所以对应 j-1</span></span><br><span class="line">        dp[i][j-<span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">        dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, <span class="comment">// 删除</span></span><br><span class="line">        dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span> <span class="comment">//替换</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归 return recursion(word1,word2,word1.length()-1,word2.length()-1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s1[0...i-1] s2[0...j-1] 的最小编辑距离</span></span><br><span class="line">    <span class="comment">// 最后就要 返回 dp[m][n] 所以new m+1 n+1</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">// 注意这里是 i-1,j-1 而不是 i,j</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(</span><br><span class="line">                            dp[i][j-<span class="number">1</span>] + <span class="number">1</span>, <span class="comment">// 增</span></span><br><span class="line">                            dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, <span class="comment">// 删除</span></span><br><span class="line">                            dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span> <span class="comment">//替换</span></span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="931-下降路径最小和"><a href="#931-下降路径最小和" class="headerlink" title="931 下降路径最小和"></a>931 下降路径最小和</h2><p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">https://leetcode-cn.com/problems/minimum-falling-path-sum/</a></p><p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p><p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>这题用个二维dp，很容易就能想到状态转移方程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = 到 i 行 j 列的下降路径最小和</span><br><span class="line">dp[i][j] = min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j+<span class="number">1</span>],dp[i-<span class="number">1</span>][j])+matrix[i][j]</span><br></pre></td></tr></table></figure><p>这题的关键是，对于 base case 的处理，显然初始化第一行，就是输入矩阵的第一行</p><p>对于<strong>第一列</strong>，和<strong>最后一列</strong>的数据，有点特殊，它<strong>只需要比较两个地方</strong>的就可以了，因此，我们可以在进行 dp 的时候，对这两个条件进行一个过滤，或者说在初始化的时候将-1 列 和 n列初始化为一个最大数比如99999，为Integer.MAX_VALUE 会发生溢出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] = 到 i 行 j 列的下降路径最小和</span></span><br><span class="line">        <span class="comment">// dp[i][j] = min(dp[i-1][j-1],dp[i-1][j+1],dp[i-1][j])+matrix[i][j]</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][n] = <span class="number">99999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j+<span class="number">1</span>])+matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j+<span class="number">1</span>])+matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到最后一行的最小值</span></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            res = Math.min(res,dp[m-<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(i,Math.min(i1,i2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者 用 if 进行过滤</p><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><ol start="53"><li>最大子数组和</li></ol><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>思路一：</strong></p><ul><li>设 dp[i] 为 nums[0…i] 中的最大和</li><li>这样定义 dp 数组的问题在于，没有办法根据 dp[i-1] 推出 dp[i]</li></ul><p><strong>思路二：</strong></p><ul><li>设 dp[i] <strong>以 i 结尾的最大和</strong></li><li>dp[i] 是以 i 结尾，根据dp[i-1] 推出 dp[i] 只有两种情况，要么 把 nums[i] 接到 dp[i-1] 的后面，要么 dp[i] 就是最大的</li><li>dp[i] = max(nums[i]，dp[i-1] + nums[i] )</li><li>因为 dp[i] 只和 dp[i-1] 有关，所以可以用两个 dp 变量递推，不用 dp 数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i] 到 第 i 位的最大和</span></span><br><span class="line">        <span class="comment">// if nums[i] &lt; 0 dp[i] = dp[i-1] 可以发现 无法根据 dp[i-1] 推出 dp[i]</span></span><br><span class="line">        <span class="comment">// dp[i] 以 i 结尾的最大和</span></span><br><span class="line">        <span class="comment">// 根据dp[i-1] 推出 dp[i] 只有两种情况</span></span><br><span class="line">        <span class="comment">// 要么 nums[i] 接到 dp[i-1]的后面 要么 dp[i] 就是最大的 = nums[i]</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_0=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp_1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp_1 = Math.max(nums[i],dp_0+nums[i]);</span><br><span class="line">            dp_0 = dp_1;</span><br><span class="line">            res = Math.max(res,dp_1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i] 到 第 i 位的最大和</span></span><br><span class="line">    <span class="comment">// if nums[i] &lt; 0 dp[i] = dp[i-1] 可以发现 无法根据 dp[i-1] 推出 dp[i]</span></span><br><span class="line">    <span class="comment">// dp[i] 以 i 结尾的最大和</span></span><br><span class="line">    <span class="comment">// 根据dp[i-1] 推出 dp[i] 只有两种情况</span></span><br><span class="line">    <span class="comment">// 要么 nums[i] 接到 dp[i-1]的后面 要么 dp[i] 就是最大的 = nums[i]</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp =<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[i],dp[i-<span class="number">1</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : dp) &#123;</span><br><span class="line">        res = Math.max(res,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><p>关键还是在于 怎么列状态转移方程，实际上，这种子序列问题，一般都需要 <strong>从 i 到 j</strong>，毕竟子序列嘛，i 到 j 才是子序列，这种子序列的动态规划也是一样，时间复杂度一般都在O(n2)。</p><p>对于这种子序列问题，一般有 <strong>两种思路</strong></p><p><strong>思路一：</strong></p><p><strong>一个一维的 dp 数组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = array.length;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在 **最长递增子序列 **中，我们定义 dp数组：</p><p>dp[i] 为 以 nums[i] 结尾的最长严格递增子序列的长度</p><p><strong>思路二：</strong></p><p><strong>一个二维的 dp 数组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = arr.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[n][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种一般较为常用，比如 <strong>最长公共子序列</strong>。 这里将 <strong>dp数组含义又分为 只涉及一个字符串 和 涉及两个字符串</strong> 两种情况</p><ol><li><p><strong>涉及两个字符串/数组</strong>时（比如 <strong>最长公共子序列、编辑距离</strong>），dp 数组的含义如下：</p><p>在子数组 <strong>arr1[0..i]</strong> 和子数组 <strong>arr2[0..j]</strong> 中，我们要求的<strong>子序列</strong>（最长公共子序列）<strong>长度</strong>为 <strong>dp[i]</strong></p></li><li><p><strong>只涉及一个字符串/数组</strong>时（比如 <strong>最长回文子序列</strong>），dp 数组的含义如下：</p><p>在子数组 <strong>array[ i…j ]</strong> 中，我们要求的<strong>子序列</strong>（最长回文子序列）的<strong>长度</strong>为 <strong>dp[i] [j]</strong></p></li></ol><h2 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h2><ol start="1143"><li>最长公共子序列</li></ol><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1</strong>：</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p><h3 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>状态定义</strong>：</p><ul><li>dp[i] [j] 为 s1[0…i] 和 s2[0…j] 的最长公共子串 LCS</li></ul><p>接下来推状态转移方程，如果一时不知道怎么递推，那么可以先初始化 dp 数组，看看 dp 初始化后是个什么样子，就可以大概看出递推关系</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20220508164210014.png" alt="image-20220508164210014"></p><p><strong>状态转移</strong>：</p><ul><li>if s1[i] == s[j] dp[i] [j] = dp[i-1] [j-1] + 1</li><li>else dp[i] [j] = max(dp[i-1] [j] , dp[i] [j-1])</li></ul><p><strong>base case</strong> ：</p><ul><li>dp[0] [j] = 0,dp[i] [0] = 0;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://labuladong.github.io/algo/3/24/79/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i][j] s1 以i 结尾，s2 以j 结尾的最长公共子序列</span></span><br><span class="line">    <span class="comment">// dp[i][j]</span></span><br><span class="line">    <span class="comment">// if s1[i] == s2[j] dp[i][j] = dp[i-1][j-1]+1;</span></span><br><span class="line">    <span class="comment">// else dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])</span></span><br><span class="line">    <span class="comment">// 初始化 dp[0][j] = 0,dp[i][0] = 0;</span></span><br><span class="line">    <span class="keyword">int</span> m = text1.length();</span><br><span class="line">    <span class="keyword">int</span> n = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case dp[0][j] = 0,dp[i][0] = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="comment">//char c1 = text1.charAt(i-1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">//char c2 = text2.charAt(j-1);</span></span><br><span class="line">            <span class="comment">// if (c1==c2)</span></span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个字符串的删除操作-LCS解决"><a href="#两个字符串的删除操作-LCS解决" class="headerlink" title="两个字符串的删除操作 (LCS解决)"></a>两个字符串的删除操作 (LCS解决)</h2><ol start="583"><li>两个字符串的删除操作</li></ol><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。</p><p>每步 可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1</strong>：</p><p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2<br>解释: 第一步将 “sea” 变为 “ea” ，第二步将 “eat “变为 “ea”</p><p><strong>示例  2</strong>:</p><p>输入：word1 = “leetcode”, word2 = “etco”<br>输出：4</p><h3 id="LCS解决"><a href="#LCS解决" class="headerlink" title="LCS解决"></a>LCS解决</h3><p>最后删除完事结果就是两个字符串的最长公共子序列，所以返回LCS 的长度，最后减去即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最后 删除的结果 剩下的就是 word1 与 word2 的最长公共子序列</span></span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span> subsequenceLen = longestCommonSubsequence(word1,word2);</span><br><span class="line">        <span class="keyword">return</span> m - subsequenceLen + n - subsequenceLen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="两个字符串的最小ASCII删除和（LCS-解决）"><a href="#两个字符串的最小ASCII删除和（LCS-解决）" class="headerlink" title="两个字符串的最小ASCII删除和（LCS 解决）"></a>两个字符串的最小ASCII删除和（LCS 解决）</h2><ol start="712"><li>两个字符串的最小ASCII删除和</li></ol><p>给定两个字符串s1 和 s2，返回 使两个字符串相等所需删除字符的 ASCII 值的最小和 。</p><p><strong>示例 1</strong>：</p><p>输入: s1 = “sea”, s2 = “eat”<br>输出: 231</p><p>解释: 在 “sea” 中删除 “s” 并将 “s” 的值(115)加入总和<br>在 “eat” 中删除 “t” 并将 116 加入总和<br>结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和</p><p><strong>示例 2</strong>：</p><p>输入: s1 = “delete”, s2 = “leet”<br>输出: 403</p><p>解释: 在 “delete” 中删除 “dee” 字符串变成 “let”，<br>将 100[d]+101[e]+101[e] 加入总和。在 “leet” 中删除 “e” 将 101[e] 加入总和<br>结束时，两个字符串都等于 “let”，结果即为 100+101+101+101 = 403<br>如果改为将两个字符串转换为 “lee” 或 “eet”，我们会得到 433 或 417 的结果，比答案更大</p><h3 id="LCS-解决"><a href="#LCS-解决" class="headerlink" title="LCS 解决"></a>LCS 解决</h3><p>同理 LCS ，只不过要求返回的是最小ASCII值的最小和，而不最长子序列的长度了，但是大致 dp 思路一样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] ---&gt; s1[0...i-1] s2[0...j-1] minimumDeleteSum</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// base case dp[0][j] = s2[1...j] 的 ASCII 值和, dp[i][0] 同</span></span><br><span class="line">        <span class="keyword">int</span> m = s1.length();</span><br><span class="line">        <span class="keyword">int</span> n = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + s2.codePointAt(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + s1.codePointAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j] + s1.codePointAt(i),dp[i][j-<span class="number">1</span>] + s2.codePointAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><ol start="516"><li>最长回文子序列</li></ol><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列</p><p><strong>示例 1</strong>：</p><p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” </p><p><strong>示例 2</strong>：</p><p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” </p><h3 id="子序列问题-1"><a href="#子序列问题-1" class="headerlink" title="子序列问题"></a>子序列问题</h3><p>关键还是在于 怎么列状态转移方程，实际上，这种子序列问题，一般都需要 <strong>从 i 到 j</strong>，毕竟子序列嘛，i 到 j 才是子序列，这种子序列的动态规划也是一样，时间复杂度一般都在O(n2)。</p><p>对于这种子序列问题，一般有 <strong>两种思路</strong></p><p><strong>思路一：</strong></p><p><strong>一个一维的 dp 数组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = array.length;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在 **最长递增子序列 **中，我们定义 dp数组：</p><p>在 子数组 array[0…i] 中，我们要求的子序列（最长递增子序列）的长度是 dp[i]。</p><p><strong>思路二：</strong></p><p><strong>一个二维的 dp 数组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = arr.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[n][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种一般较为常用，比如 <strong>最长公共子序列</strong>。 这里将 <strong>dp数组含义又分为 只涉及一个字符串 和 涉及两个字符串</strong> 两种情况</p><ol><li><p><strong>涉及两个字符串/数组</strong>时（比如 <strong>最长公共子序列、编辑距离</strong>），dp 数组的含义如下：</p><p>在子数组 <strong>arr1[0..i]</strong> 和子数组 <strong>arr2[0..j]</strong> 中，我们要求的<strong>子序列</strong>（最长公共子序列）<strong>长度</strong>为 <strong>dp[i]</strong></p></li><li><p><strong>只涉及一个字符串/数组</strong>时（比如 <strong>最长回文子序列</strong>），dp 数组的含义如下：</p><p>在子数组 <strong>array[ i…j ]</strong> 中，我们要求的<strong>子序列</strong>（最长回文子序列）的<strong>长度</strong>为 <strong>dp[i] [j]</strong></p></li></ol><h3 id="动态规划解决"><a href="#动态规划解决" class="headerlink" title="动态规划解决"></a>动态规划解决</h3><ol><li><p><strong>定义 dp</strong> 数组</p><p>这是 <strong>只涉及到一个字符串</strong> 的子序列问题</p><p>考虑 <strong>设 s[i…j] 的最长回文子序列长度为 dp[i] [j]</strong></p></li><li><p><strong>状态转移</strong></p><p>当 s[i] == s[j] 的时候，说明 s[i…j] 的最长回文子序列 长度 是 s[i+1…j-1] 的长度 加上它两；</p><p>如果 它两不相等，那么 s[i] 和 s[j] 只可能出现在一个子序列中，不会同时出现，要么 是在 s[i+1…j] 的子序列中，要么 是在 s[i…j-1] 的子序列中</p><p>所以</p><ul><li><strong>if  s[i] == s[j]  dp[i] [j] = dp[i+1] [j-1] + 2</strong></li><li><strong>else dp[i] [j] = Math.max( dp[i+1] [j] , dp[i] [j-1])</strong> </li></ul></li><li><p><strong>base case</strong></p><p> 很明显，dp[i] [i] == 1，从 s[i…i] 为1，其他的初始化就为0,</p></li><li><p><strong>遍历方式</strong></p><p>可以发现 base case 主要是二维数组的 对角线，在 根据 dp[i] [j] 与其他 dp[] [] 的关系，可以发现，要能遍历出来，对遍历顺序是有一定要求的，只能选择 斜着遍历 或者 反着遍历。</p><p><strong>为了保证每次计算 <code>dp[i][j]</code>，左下右方向的位置已经被计算出来，只能斜着遍历或者反着遍历</strong>：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20220510154359407.png" alt="image-20220510154359407"></p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// bbabab</span></span><br><span class="line">        <span class="comment">// dp[i][j] 为 子串s[i...j] 的 最长回文子序列长度</span></span><br><span class="line">        <span class="comment">// dp[i][j]</span></span><br><span class="line">        <span class="comment">// if s[i] == s[j] dp[i][j] = dp[i+1][j-1] + 2;</span></span><br><span class="line">        <span class="comment">// else dp[i][j] = Math.max(dp[i+1][j],dp[i,j-1]);</span></span><br><span class="line">        <span class="comment">// base case dp[i][i] = 1;</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为 dp[i+1][j-1] [i+1][j] dp[i,j-1] </span></span><br><span class="line">    <span class="comment">//所以只能选择 斜着遍历 或者 反着遍历，才能推出dp[i][j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="让字符串成为回文串的最少插入次数"><a href="#让字符串成为回文串的最少插入次数" class="headerlink" title="让字符串成为回文串的最少插入次数"></a>让字符串成为回文串的最少插入次数</h2><ol start="1312"><li>让字符串成为回文串的最少插入次数</li></ol><p>给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。</p><p>请你返回让 s 成为回文串的 最少操作次数 。</p><ul><li><p><strong>示例 1</strong>：</p><p>输入：s = “zzazz”<br>输出：0<br>解释：字符串 “zzazz” 已经是回文串了，所以不需要做任何插入操作</p></li><li><p><strong>示例 2</strong>：</p><p>输入：s = “mbadm”<br>输出：2<br>解释：字符串可变为 “mbdadbm” 或者 “mdbabdm” </p></li></ul><ol><li><p>状态定义</p><p><strong>dp[i] [j] 为 s[i…j] 成为回文串的最小插入次数</strong></p></li><li><p>状态转移</p><p><strong>if s[i] == s[j] dp[i] [j] = dp[i+1] [j-1]</strong></p><p><strong>else dp[i] [j] = min(dp[i+1] [j],dp[i] [j-1]) + 1</strong></p><p>这里不能是 **else dp[i] [j] = Math.min(dp[i-1] [j]+1, dp[i] [j+1]+1)**，这样会发现没办法遍历 dp</p><p>并且：mbadm 在 b 的前面插入d，这个时候mdbadm，i 成为了d，那么 i+1 就是b，所以是dp[i+1] [j]</p></li><li><p>base case 对角线为0</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j]: s[i...j] 为回文串的最小插入次数</span></span><br><span class="line">        <span class="comment">// if s[i] == s[j] dp[i][j] = dp[i+1][j-1]</span></span><br><span class="line">        <span class="comment">// else dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j+1]+1)</span></span><br><span class="line">        <span class="comment">// mbadm 1.在 b 的前面插入d 这个时候mdbadm i就是d，那么 i+1 就是b所以dp[i+1][j]</span></span><br><span class="line">        <span class="comment">// else dp[i][j] = min(dp[i+1][j],dp[i][j-1]) + 1</span></span><br><span class="line">        <span class="comment">// base case dp[i][i] = 0</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏</h2><ol start="174"><li>地下城游戏</li></ol><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><p><strong>错误思路：</strong></p><ul><li><p>这题 最开始我的思路是，设dp[i] [j] 为 从起点到 dungeon[i] [j] 所需要的最低 HP</p></li><li><p>接下来找状态转移方程，发现状态转移方程没法找，因为中间可能会有 大于 0 的 dungeon，那这样就应该加 HP，dp[i] [j]  与 dp[i-1] [j] 、dp[i] [j-1]  的关系 根本无法确定 </p></li><li><p>```java<br>// dp[i][j] 到 dungeon[i][j] 所需的最低 HP</p><pre><code>    // if dungeon[i][j] &lt; 0    // dp[i][j] = dp[i-1][j] + abs(dungeon[i][j])    // else dp[i][j] = dp[i-1][j]    // if dungeon[i][j] &lt; 0    // dp[i][j] = dp[i][j-1] + abs(dungeon[i][j])    // else dp[i][j] = dp[i][j-1]    // dp[i][j] = max(   )    // base case dp[0][0]</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**正确思路：**</span><br><span class="line"></span><br><span class="line">* 定义 dp[i] [j]  为 从 dungeon[i] [j] 到终点（右下角）所需的最小生命值</span><br><span class="line">* 这样就可以找状态转移表达式了，dp[i] [j] &#x3D; dp[i] [j] 下方 和 dp[i] [j] 右边 中到终点所需HP最小的那一个，再减去当前dungeon 的hp ，即 - dungeon[i] [j];</span><br><span class="line">* 这样 dp[i] [j] 到 终点 所需的最小生命值 也是最小的</span><br><span class="line">* 当然 减去dungeon[i] [j]后，如果为 &lt;&#x3D;0，说明不需要额外的HP就行，只需要起始的 1 HP就 ok</span><br><span class="line"></span><br><span class="line">**base case**：</span><br><span class="line"></span><br><span class="line">* 显然需要倒着遍历，从最后一行到第一行，所以 dp[i] [n] &#x3D; Integer.MAX_VALUE; dp[m] [i] &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F; 选择 所需最小的一个,再加上当前 要[掉]的HP，或者减去 要[加]的HP</span><br><span class="line">int res &#x3D; Math.min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];</span><br><span class="line">&#x2F;&#x2F; 如果 减去 结果 为 &lt;&#x3D;0 非正数，说明不需要额外HP，来个 起始 HP 1就 ok</span><br><span class="line">dp[i][j] &#x3D; res &lt;&#x3D; 0 ? 1:res;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] 从 dungeon[i][j] 到 终点 所需的最小生命值</span></span><br><span class="line">        <span class="comment">// dp[i][j] =</span></span><br><span class="line">        <span class="comment">// base case dp[n-1][n-1] =</span></span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[m-<span class="number">1</span>][n-<span class="number">1</span>] = dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>] &lt; <span class="number">0</span> ? -dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][n] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[m][i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>; j &gt;=<span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="comment">// dp[m-1][n-1] 已经计算过了</span></span><br><span class="line">                <span class="keyword">if</span> (i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 选择 所需最小的一个,再加上当前 要[掉]的HP，或者减去 要[加]的HP</span></span><br><span class="line">                <span class="keyword">int</span> res = Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">                <span class="comment">// 如果 减去 结果 为 &lt;=0 非正数，说明不需要额外HP，来个 起始 HP 1就 ok</span></span><br><span class="line">                dp[i][j] = res &lt;= <span class="number">0</span> ? <span class="number">1</span>:res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Leetcode各种动态规划问题</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-02-09T15:01:55.449Z</published>
    <updated>2022-03-08T12:45:23.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p><strong>JMM</strong> 即 <strong>Java Memory Model</strong> ，它从Java层面定义了<strong>主存</strong>、<strong>工作内存</strong>抽象概念，底层对应着CPU 寄存器、缓存、硬件内存、CPU 指令优化等。JMM 体现在以下几个方面</p><ul><li><strong>原子性</strong> - 保证指令不会受 线程上下文切换的影响</li><li><strong>可见性</strong> - 保证指令不会受 cpu 缓存的影响 (JIT对热点代码的缓存优化)</li><li><strong>有序性</strong> - 保证指令不会受 cpu 指令并行优化的影响</li></ul><p><strong>Java内存模型</strong>描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。<br>在内存模型中，所有的变量都存储在主内存中。<strong>每个线程都有自己独立的工作内存</strong>，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)。</p><p><strong>JMM线程操作内存的两条基本的规定:</strong></p><ol><li>关于线程与主内存：线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写</li><li>关于线程间工作内存：不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要经过主内存来完成。</li></ol><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><code>在主线程中修改的静态变量的值，对应t线程来说是不可见的</code></p><p>这是因为t线程的run方法是个<code>while (run)</code>循环，JIT即使编译器会对t线程中的run变量进行缓存到本地工作内存，不去主存中取run的值，这样可以加快执行速度。也就是JVM达到一定阈值时，<code>while (run)</code>循环变成了<strong>热点代码</strong>， 所以一直访问的都是缓存到本地工作内存(局部)中的run。当主线程修改<strong>主存中的run变量</strong>的时候，t1线程一直访问的是自己缓存的, 所以不认为run已经改为false了。 所以一直运行并不会结束循环，我们为主存(成员变量)进行<strong>volatile</strong>修饰, 增加变量的可见性, 当主线程修改run为false, t1线程对run的值可见。这样就可以退出循环。</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120131625943.png" alt="image-20220120131625943"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (run)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;停止 t线程&quot;</span>);</span><br><span class="line">    run=<span class="keyword">false</span>;<span class="comment">// 没有volatile，事实上并不会退出t线程</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用<strong>volatile解决</strong>以外还可以使用<strong>synchronized解决</strong>问题</p><ul><li><strong>在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存，然后主内存中拷贝最新变量的副本到工作内存 ，执行完代码后，将更改后的共享变量的值刷新到主内存中，最后释放互斥锁。</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1s内,一直都在无限循环获取锁. 1s后主线程抢到锁,修改为false, 此时t1线程抢到锁对象,while循环也退出</span></span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!run)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当主线程获取到锁的时候, 就修改为false了</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            run = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul><li>前面例子体现的实际就是<code>可见性</code>，<strong>它保证的是在多个线程之间一个线程对 volatile 变量的修改对另一个线程可见</strong>， <strong>而不能保证原子性</strong>。volatile用在一个写线程，多个读线程的情况, 比较合适。 上例从字节码理解是这样的：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">putstatic run <span class="comment">// 线程 main 修改 run 为 false， 仅此一次</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run false </span></span><br></pre></td></tr></table></figure><ul><li>比较一下之前线程安全时的例子：两个线程一个 <strong>i++</strong> 一个 <strong>i–</strong> ，只能<strong>保证</strong>看到最新值(<strong>可见性</strong>)，<strong>不能</strong>解决<strong>指令交错(原子性)</strong></li></ul><p><strong>注意</strong> ：</p><ul><li><strong>synchronized</strong> 语句块既可以<strong>保证</strong>代码块的<strong>原子性</strong>，也同时<strong>保证</strong>代码块内变量的<strong>可见性</strong>。但缺点是 synchronized 是属于重量级操作，性能相对更低。</li><li> 如果在前面示例的死循环中加入 <strong>System.out.println()</strong> 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了</li><li>因为<strong>System.out.println() 方法里面有synchronized修饰</strong>。</li></ul><h2 id="volatile实现模式之两阶段终止"><a href="#volatile实现模式之两阶段终止" class="headerlink" title="volatile实现模式之两阶段终止"></a>volatile实现模式之两阶段终止</h2><ul><li>当我们在执行线程一时，想要终止线程二，这是就需要使用<code>interrupt方法</code>来优雅的停止线程二。这是之前的做法</li></ul><ul><li>使用volatile关键字来实现两阶段终止模式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是两个线程操作共享变量stop</span></span><br><span class="line">        Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        monitor.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;Monitor&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private boolean stop = false; // 不会停止程序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>; <span class="comment">// 会停止程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动监控器线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread monitor = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//开始不停的监控</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于停止监控器线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式之-Balking"><a href="#模式之-Balking" class="headerlink" title="模式之 Balking"></a>模式之 Balking</h2><ul><li>定义：<code>Balking （犹豫）模式</code>用在 <strong><code>一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</code>。有点类似于单例。</strong></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>JIT即时编译器的优化，可能会导致<strong>指令重排</strong>。为什么要优化? 因为CPU 支持多级指令流水线，例如支持同时执行 <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 的处理器，效率更快 </p><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120155001076.png" alt="image-20220120155001076"></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="指令重排序导致错误结果"><a href="#指令重排序导致错误结果" class="headerlink" title="指令重排序导致错误结果"></a>指令重排序导致错误结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span></span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line"> r.r1 = num + num;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> num = <span class="number">2</span>;</span><br><span class="line"> ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程1执行actor1方法, 线程2执行actor2方法</p><p>但是最终的结果还有可能让r.r1=0</p><ul><li><p>这样情况是在actor2方法进行了<strong>指令重排序</strong>，因为<code> num = 2;</code>和<code>ready = true;</code>互相之间看起来并没有影响，因此先执行<code>ready = true;</code>，这时候num=2还没执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重排序后</span></span><br><span class="line">ready = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//此时发生线程切换</span></span><br><span class="line">num = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>此时，发送线程上下文切换，<code>ready = true;</code>，线程1判断为true，就<code>r.r1=num+num</code>，最后r.r1=0;</p></li></ul><p>这种现象叫做指令重排，是JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现，可以使用jcstress工具进行测试。上面仅是从代码层面体现出了有序性问题，下面的 <strong>double-checked locking</strong> (双重检查锁)还会从java字节码的层面了解有序性的问题。</p><p><strong>指令重排序</strong>操作<strong>不会对</strong>存在<strong>数据依赖关系</strong>的操作进行<strong>重排序</strong>。比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p>重排序是为了优化性能，但是不管怎么重排序，<strong>单线程</strong>下程序的执行结果<strong>不会被改变</strong>。</p><p><strong>指令重排序 在 单线程模式下是一定会保证最终结果的正确性，</strong> 但是在多线程环境下，问题就出来了。</p><p><strong>解决方法</strong>：<code>volatile 修饰的变量，可以禁用指令重排</code></p><h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p><strong>volatile</strong> 的<strong>底层实现</strong>原理是<strong>内存屏障</strong>，<strong>Memory Barrier</strong>（Memory Fence）</p><p>对 volatile 变量的<strong>写指令</strong>后会加入<strong>写屏障</strong>。(保证写屏障之前的写操作, <strong>都能同步到主存中</strong>)</p><p>对 volatile 变量的<strong>读指令</strong>前会加入<strong>读屏障</strong>。(保证读屏障之后的读操作, <strong>都能读到主存的数据</strong>)</p><h3 id="volatile保证可见性原理"><a href="#volatile保证可见性原理" class="headerlink" title="volatile保证可见性原理"></a>volatile保证可见性原理</h3><ul><li><p><strong>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">     num = <span class="number">2</span>;</span><br><span class="line">     ready = <span class="keyword">true</span>; <span class="comment">// ready是被volatile修饰的 ，赋值带写屏障</span></span><br><span class="line">     <span class="comment">// 写屏障(在ready=true写指令之后加的, </span></span><br><span class="line">     <span class="comment">//在该屏障之前对共享变量的改动, 都同步到主存中，包括num)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 读屏障</span></span><br><span class="line"> <span class="comment">//  ready是被volatile修饰的 ，读取值带读屏障</span></span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;<span class="comment">// ready, 读取的就是主存中的新值</span></span><br><span class="line"> r.r1 = num + num; <span class="comment">// num, 读取的也是主存中的新值</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="volatile保证有序性原理"><a href="#volatile保证有序性原理" class="headerlink" title="volatile保证有序性原理"></a>volatile保证有序性原理</h3><ul><li><strong>写屏障</strong>会确保<strong>指令重排序</strong>时，<strong>不会将写屏障之前的代码排在写屏障之后</strong></li><li><strong>读屏障</strong>会确保<strong>指令重排序</strong>时，<strong>不会将读屏障之后的代码排在读屏障之前</strong></li></ul><h3 id="volatile不能解决指令交错-不能解决原子性-："><a href="#volatile不能解决指令交错-不能解决原子性-：" class="headerlink" title="volatile不能解决指令交错 (不能解决原子性)："></a>volatile不能解决<strong>指令交错</strong> (不能解决<strong>原子性</strong>)：</h3><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其它线程的读, 跑到它前面去</li><li><strong>有序性的保证也只是保证了本线程内相关代码不被重排序</strong>，并不能保证指令的交错</li><li>比如线程2先读到i，然后被切换成了线程1执行完后，线程2还是把i当做没更新的i值执行。可以使用<code>synchronized</code>来解决原子性</li></ul><h2 id="double-checked-locking-双重检查锁"><a href="#double-checked-locking-双重检查锁" class="headerlink" title="double-checked locking (双重检查锁)"></a>double-checked locking (双重检查锁)</h2><p>首先<strong>synchronized</strong>可以<strong>保证</strong>它的临界区的资源是<strong>原子性、可见性、有序性</strong>的, <strong>有序性的前提</strong>是, 在synchronized代码块中的共享变量, 不会在代码块外使用到, 否则<strong>有序性</strong>不能被保证, 只能使用<strong>volatile</strong>来保证有序性。<br>下面代码的第二个双重检查单例，就出现了这个问题(在synchronized外使用到了INSTANCE)，此时synchronized就不能防止指令重排，确保不了指令的有序性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最开始的单例模式是这样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      多线程同时调用getInstance(), 如果不加synchronized锁, 此时两个线程同时</span></span><br><span class="line"><span class="comment">      判断INSTANCE为空, 此时都会new Singleton(), 此时就破坏单例了.所以要加锁,</span></span><br><span class="line"><span class="comment">      防止多线程操作共享资源,造成的安全问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//INSTANCE没有加volatile</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是上面的<code>if(INSTANCE == null)</code>判断代码没有在同步代码块synchronized中，不能享有synchronized保证的原子性、可见性、以及有序性</strong>。所以可能会导致指令重排。</p><p>上述方法的字节码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span> <span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="comment">// ldc是获得类对象</span></span><br><span class="line">6: ldc #3 // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="comment">// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="comment">// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span></span><br><span class="line"><span class="comment">// 将类对象的引用地址存储了一份，是为了将来解锁用</span></span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line">11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="comment">// 新建一个实例</span></span><br><span class="line">17: new #3 // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="comment">// 复制了一个实例的引用</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="comment">// 通过这个复制的引用调用它的构造方法</span></span><br><span class="line">21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"><span class="comment">// 最开始的这个引用用来进行赋值操作</span></span><br><span class="line">24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line">37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><p>上述字节码最关键的地方在于17-&gt;24</p><ul><li><p><strong>正常情况</strong>先新建一个实例，然后复制实例的引用，再通过这个复制的引用调用它的构造方法，最后进行赋值操作赋值给instance。</p></li><li><p>但是JVM可能会优化这里的代码：<code>先执行 24(赋值)，再执行 21(构造方法)</code>。也就是先给instance赋值，这样instance并不为null，这个时候t2线程进入，第一个判断，<code> if(INSTANCE == null)</code>，ifnonnull，发现不为null，跳转到37行，最终获取到一个假的不为null的对象。</p></li><li><p>如果两个线程 t1，t2 按如下时间序列执行：</p></li></ul><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120171355261.png" alt="image-20220120171355261"></p><p>所以最终的问题</p><ul><li><code>INSTANCE = new Singleton();</code>操作不是一个<strong>原子操作</strong>, 它总共被分为4个指令，<code>21, 24两个指令</code>此时可能就会<strong>发生指令重排</strong>的问题。</li><li>此时又因为 <code>0: getstatic</code> 这行代码在 monitor 控制之外，也就是说第一次判断null的时候没有在synchronized控制下，其他线程可以来获取，判断instance的值</li><li>synchronized是可以保证变量的原子性、有序性和可见性，不会出现因为指令重排而产生错误，<strong>前提是</strong>：synchronized必须把这个变量完全的管理住。上面的问题就是因为第一次判空是没有被synchronized所管理到的。</li></ul><p>因此，解决方案就是加个volatile，<code>private static volatile Singleton INSTANCE = null</code>。加了<strong>volatile之后就会在putstatic加个写屏障，这样写屏障之前的指令就不会被重排序。</strong></p><p>读写 volatile 变量操作（即getstatic操作和putstatic操作）时会加入<strong>内存屏障</strong>，保证下面两点：</p><ul><li><strong>可见性</strong><br>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中<br>读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li><li><strong>有序性</strong><br>写屏障 会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后<br>读屏障 会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性<br>加上volatile之后, 保证了指令的有序性, 不会发生指令重排, 21就不会跑到24之后执行了</li></ul><p><strong>synchronized 既能保证原子性、可见性、有序性，其中有序性是在该共享变量完全被synchronized 所接管（包括共享变量的读写操作），上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。</strong></p><p><strong>对共享变量加volatile关键字可以保证可见性和有序性，但是不能保证<code>原子性</code>（即不能防止<code>指令交错</code>）。</strong></p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120172649628.png" alt="image-20220120172649628"></p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120172629908.png" alt="image-20220120172629908"></p><h2 id="Happens-before规则"><a href="#Happens-before规则" class="headerlink" title="Happens-before规则"></a>Happens-before规则</h2><p>happens-before规定了多共享变量的写操作对于其他线程的读操作的可见性。抛开以下规则，JVM并不能保证一个线程对共享变量的写操作对于其它线程对该共享变量的读可见。</p><h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>对于synchronized锁，会保证每次去主存中读取数据，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="volatile-变量"><a href="#volatile-变量" class="headerlink" title="volatile 变量"></a>volatile 变量</h3><ul><li><p>线程对volatile 变量的写，对接下来其它线程对该变量的读可见</p><p><strong>volatile修饰的变量, 通过<code>写屏障</code>, 共享到主存中, 其他线程通过<code>读屏障</code>, 读取主存的数据</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="start-前的写操作"><a href="#start-前的写操作" class="headerlink" title="start() 前的写操作"></a>start() 前的写操作</h3><ul><li><p>线程 start() 前对变量的写，对该线程开始后对该变量的读可见</p><p>线程还没启动时, 修改变量的值, 在启动线程后, 获取的变量值, 肯定是修改过的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">   System.out.println(x);</span><br><span class="line">  &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="t1-isAlive-或-t1-join-等待结束"><a href="#t1-isAlive-或-t1-join-等待结束" class="headerlink" title="t1.isAlive() 或 t1.join()等待结束"></a>t1.isAlive() 或 t1.join()等待结束</h3><ul><li><p>线程结束前 对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><p>主线程获取的x值, 是线程执行完对x的写操作之后的值。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure><h3 id="interrupt打断"><a href="#interrupt打断" class="headerlink" title="interrupt打断"></a>interrupt打断</h3><ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后, 对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(x); <span class="comment">// 10, 打断了, 读取的也是打断前修改的值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);<span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><ul><li>对变量默认值（0，false，null）的写，对其它线程对该变量的 读可见 (最基本)</li><li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</li><li>因为x加了volatile, 所以在volatile static int x 代码的上面添加了读屏障, 保证读到的x和y的变化是可见的(包括y, 只要是读屏障下面都OK); 通过传递性, t2线程对x,y的写操作, 都是可见的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">y = <span class="number">10</span>;</span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span> ).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">//x=20对t2可见，同时y=10 也对t2可见</span></span><br><span class="line">    system.out. print1n(x);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span> ).start();</span><br></pre></td></tr></table></figure><p><strong><code>volatile</code>主要用在<code>一个线程改,多个线程读时的来保证可见性</code>，和<code>double-checked locking模式中保证synchronized代码块外的共享变量的</code>指令重排序<code>问题</code></strong></p><h2 id="五种单例模式"><a href="#五种单例模式" class="headerlink" title="五种单例模式"></a><strong>五种单例模式</strong></h2><p>单例模式有<strong>饿汉式、懒汉式、枚举类(饿汉)、静态内部类</strong></p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：为什么<strong>类要加 final</strong></p><ul><li>防止子类继承后重写方法破坏单例</li></ul><p>问题2：如果实现了序列化接口，还要做什么来<strong>防止反序列化破坏单例</strong></p><ul><li>反序列化时候生成的对象可能会破坏单例，直接在类里加一个**public Object readResolve() {}**方法，可以让反序列化的时候调用这个方法返回单例的实例</li></ul><p>问题3：为什么<strong>构造方法设置为私有</strong>?</p><ul><li>避免其他类使用new生成新的实例，并不能防止反射创建新的实例，因为反射可以打破封装</li></ul><p>问题4：这样初始化是否能保证单例对象创建时的线程安全？</p><ul><li>可以保证，因为实例在<strong>类加载</strong>的时候就<strong>初始化</strong>，JVM会保证其线程安全性</li></ul><p>问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</p><ul><li>1.提供更好的<strong>封装性</strong>；2.提供<strong>泛型</strong>的支持</li></ul></blockquote><h3 id="饿汉式之枚举"><a href="#饿汉式之枚举" class="headerlink" title="饿汉式之枚举"></a>饿汉式之枚举</h3><p>饿汉式：因为枚举的变量，底层是通过public static final来修饰的，类加载就创建了，所以是饿汉式</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220122210404242.png" alt="image-20220122210404242"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：枚举单例是如何限制实例个数的</p><ul><li><strong>创建枚举类的时候就已经定义好了</strong>，每个枚举常量其实就是枚举类的一个静态成员变量</li></ul><p>问题2：枚举单例在创建时是否有并发问题</p><ul><li>没有并发问题，是线程安全的，因为枚举单例底层是一个静态成员变量，它是通过类加载器的加载而创建的，确保了线程安全</li></ul><p>问题3：枚举单例能否被反射破坏单例</p><ul><li><p><strong>反射无法破坏枚举单例</strong>, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">this</span>.clazz.getModifiers() &amp; <span class="number">16384</span>) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(“Cannot reflectively create <span class="class"><span class="keyword">enum</span> <span class="title">objects</span>”)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>问题4：枚举单例能否被反序列化破坏单例</p><ul><li><strong>反序列化不能破坏</strong>，枚举类默认也实现了序列号接口。但枚举类考虑到了这个问题，不会破坏单例。</li></ul><p>问题 5：枚举单例属于懒汉式还是饿汉式</p><ul><li>属于<strong>饿汉式</strong>, 静态成员变量, 通过类加载器的时候就加载了。</li></ul><p>问题 6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</p><ul><li>加构造方法，枚举也可以写构造方法，普通方法等</li></ul></blockquote><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点：</span></span><br><span class="line">    <span class="comment">// synchronized加载静态方法上，可以保证线程安全。缺点就是锁粒度大，效率低。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h3><p>DCL：double-check-locking</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：解释为什么要加 volatile</p><ul><li>因为在synchronized外部使用到了共享变量INSTANCE，可能存在一个线程先初始化了instance，但是别的线程没有从主存中获取instance，而是从工作内存中获取instance，仍然为空，volatile保证了可见性，保证读取变量的时候都从主存中去获取，这样就不会存在已经创建了实例，但读取到实例仍然为空的情况</li></ul><p>问题2：对比上面的懒汉式，说出这样做的意义</p><ul><li>增加了双重判断，如果存在了单例对象，别的线程再进来就无需加锁判断，<strong>提升效率</strong></li></ul><p>问题3：为什么还要加为空判断, 之前不是判断过了吗</p><ul><li>主要原因还是因为并发的时候产生线程不安全的问题</li><li>考虑这么一种情况：<ul><li>线程1第一次进入了synchronized代码，获取到了锁，判断到instance为null，然后就去创建实例</li><li>线程2此时已经进行了第一次判断为空，然后等待线程1释放锁。</li><li>如果不加判断，线程1创建完后释放锁，线程2进入同步代码块，此时没有了第二重为空判断，就会直接创建实例，此时就重复创建了实例，破坏了单例</li></ul></li></ul></blockquote><h3 id="懒汉式之静态内部类"><a href="#懒汉式之静态内部类" class="headerlink" title="懒汉式之静态内部类"></a>懒汉式之静态内部类</h3><p>通过静态内部类来创建单例，对外不可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：属于懒汉式还是饿汉式</p><ul><li>懒汉式，因为这是个静态内部类，类加载本身就是懒惰的，在没有用到这个类的时候，是不会进行类加载的，因此没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul><p>问题2：在创建时是否有并发问题</p><ul><li>没有并发问题，仍然是单例的。因为类加载是懒惰的，没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">原子性、可见性、volatile原理，读写屏障、单例设计，双重检查锁DCL</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/AQS%20ReentrantLock%E5%8E%9F%E7%90%86/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/AQS%20ReentrantLock%E5%8E%9F%E7%90%86/</id>
    <published>2022-02-09T14:53:07.569Z</published>
    <updated>2022-03-08T12:45:23.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h3><p>AQS全称<strong>AbstractQueueSynchronizer</strong>，抽象的队列的同步器，是JDK1.5提供的一套实现阻塞锁和一系列依赖FIFO等待队列的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类的实现都依赖于它，比如常用的ReentrantLock/ Semaphore/ CountDownLatch等。具体用法是通过<strong>继承AQS</strong>，<strong>实现</strong>其模板<strong>方法</strong>，来达到同步状态的管理。</p><h3 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h3><p>AQS在功能上可以分为</p><ul><li><strong>独占锁</strong>：每次只能有一个线程持有锁，比如ReentrantLock</li><li><strong>共享锁</strong>：允许多个线程同时获得锁，并发访问共享资源，比如ReentrantReadWriteLock中的读锁、CountDownLatch</li></ul><p>特点：</p><ul><li><p>用state属性来表示资源的状态（分独占模式和共享模型），子类需要定义如何维护这个状态，控制如何获取锁和释放锁，比如state为0就是没有线程持有锁，把state改为1就是有线程持有锁</p><ul><li>getState：获取state状态</li><li>setState：设置state状态</li><li>compareAndSetState：cas机制设置state状态，这里的cas只是原子性的来修改state的值，AQS仍然是一个阻塞式的，尝试设置失败后会进入阻塞的队列里去</li><li>独占模式是只有一个线程能访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li><p>提供了基于FIFO的等待队列，类似Monitor的EntryList</p></li><li><p>条件变量来实现等待，唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</p></li></ul><p>子类主要需要实现下面一些方法</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared：获取共享锁</li><li>tryReleaseShared：释放共享锁</li><li>isHeldExclusively：是否用于独占锁</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取锁的姿势</span></span><br><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁的姿势</span></span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承AQS自定义不可重入锁"><a href="#继承AQS自定义不可重入锁" class="headerlink" title="继承AQS自定义不可重入锁"></a>继承AQS自定义不可重入锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;TestAQS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            <span class="comment">// 不可重入锁</span></span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;locking...&quot;);</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占锁  同步器类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 确保原子性</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里不需要保证原子性, 因为是持锁者进行释放</span></span><br><span class="line">            <span class="comment">// 在setState(0)上面设置Owner为null, 防止指令重排序带来的问题</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// state是volatile修饰的, 在setState(0)前面的属性修改, 对于其他线程也是可见的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><p>ReentrantLock实现了Lock接口，同步内部还有一个自定义的抽象同步器Sync，Sync又包含了公平和非公平同步器，FairSync和NonfairSync都是ReentrantLock的static final 内部类，Sync是抽象的static 内部类继承自AQS</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129101733186.png" alt="image-20220129101733186"></p><h3 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h3><p>从构造方法来看，<strong>默认是非公平锁NonfairSync</strong>实现，NonfairSync继承了AQS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其lock方法调用的是同步器的lock方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看非公平同步器的lock方法，加锁流程就是现在cas机制原子性设置state值从0变为1，如果成功，就把独占锁Owner设置为当前线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有竞争时，Thread0进来加锁，把state变量为1，同时把独占锁Owner线程设置为Thread0</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129102122337.png" alt="image-20220129102122337"></p><p>第一个竞争出现时，假设已经有Thread0加锁成功，那么当前线程Thread1就<strong>加锁失败</strong>。</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129103843420.png" alt="image-20220129103843420"></p><p>加锁失败则进入AQS的acquire方法，会再一次尝试去获取锁，调用tryAcquire()，如果仍然获取失败，就尝试加入到等待队列里去，加入返回true就调用selfInterrupt把该线程打断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的addWaiter就是构造一个Node 双向链表队列</p><ol><li>下图中黄色三角表示该 Node 的<strong>waitStatus</strong>状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li><strong>第一次创建其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</strong></li></ol><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129104152327.png" alt="image-20220129104152327"></p><p>然后进入acquireQueued方法，这个方法内部是一个死for循环，获取当前线程关联节点的前驱节点p，<strong>如果p等于head，也就是说如果自己是紧邻着head（注意看图上的箭头，head指向的是node）</strong>，讲道理下一个就可以获得锁，那么Thread1就再一次的tryAcquire尝试去加锁；如果这次加锁成功了就把自己设置为Head节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果这次加锁失败或者p!=head，那么就应该在加锁失败后park住<strong>shouldParkAfterFailedAcquire</strong>，这个方法会将前驱节点即<strong>head</strong>的<strong>waitStatus</strong>修改为-1，**-1表示前面线程有责任唤醒后面的线程，也就是Thread1获取失败了，进入阻塞，把waitStatus设为-1 即将进入阻塞那么Thread0，就要有责任将Thread1唤醒<strong>，然后</strong>返回false**。</p><p>返回false后结束判断又进入for循环去尝试获取一次，假设<strong>又失败</strong>，那么又进入shouldParkAfterFailedAcquire方法，<strong>因为之前已经将waitStatus的值设置为-1了，这次肯定设置失败了，所以就返回了true</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">    * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>返回true后就进入<strong>parkAndCheckInterrupt</strong>方法，把当前线程park阻塞住</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129110313691.png" alt="image-20220129110313691"></p><p>假设有多个线程经历上述过程加锁失败，变成下图：</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129110452722.png" alt="image-20220129110452722"></p><h3 id="释放锁的流程"><a href="#释放锁的流程" class="headerlink" title="释放锁的流程"></a>释放锁的流程</h3><p>Thread0释放锁，进入tryRelease流程，将OwnerThread设置为null，state设置为0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后判断head是否为空，并且waitStatus==-1，进入unparkSuccessor方法，会找到离head最近的一个node(没取消的)，unpark唤醒。因此就是Thread1会被唤醒，然后Thread1继续执行acquireQueued方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Thread1加锁成功，设置</p><ol><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ol><p>如果有Thread4前来竞争，Thread1又加锁失败，Thread1再次进入acquireQueued流程，获取锁失败，重新进入park阻塞</p><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>以非公平锁NonfairSync的源码为例，NonfairSync在进行获取锁nonfairTryAcquire的时候，其实就是对state的值做一个判断，如果state的值为0，说明没线程加过锁；如果state的值不是0，说明已经有线程加过锁了，那就判断一下这个加锁的线程是不是当前线程，如果是当前线程那就<strong>把state的值再加1</strong>，<strong>表示当前线程又加了一次锁</strong></p><p>释放锁的时候相反，先让获取state的值，然后减去1，看看值是不是为0，为0才表示这个线程没有锁了，如果不为0，那就更新一下state的值就ok</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是Sync 继承过来的方法，实际上NonfairSync的tryAcquire里面也就是直接调用的这个nonfairTryAcquire方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 正常加锁流程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p>ReentrantLock默认是不可打断的，不可打断指的是，某个线程在尝试获取锁，然后获取锁失败了会进入parkAndCheckInterrupt()方法被park阻塞，这个时候是不可打断的。</p><h4 id="不可打断"><a href="#不可打断" class="headerlink" title="不可打断"></a>不可打断</h4><p>当在parkAndCheckInterrupt方法中park阻塞住，然后被打断后，会<strong>Thread.interrupted()清除打断标记</strong>，让下次park仍然可以阻塞。当被打断后，线程醒过来会接着执行return Thread.interrupted()，这个时候就会<strong>返回true</strong>，但同时会清除<strong>打断标记</strong>，也就是<strong>置为false</strong>，这样下次<strong>仍可以park</strong>阻塞住。</p><p>返回为true后，执行interrupted = true，然后<strong>又进入循环</strong>，看能否获取锁，不能获取又进入park阻塞。如果这次能获取锁了，interrupted = true，最后acquireQueued方法返回的就是interrupted=true。也就是说需要获取到锁之后，才能返回打断状态。</p><p>然后就从acquireQueued方法出来，<strong>也就是获取到锁之后进行一次selfInterrupt()，重新打断一次，如果是正常运行状态不是sleep中就不会抛打断异常</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        <span class="comment">// 被park阻塞的线程, 可以被别的线程调用它的interrupt方法打断该park阻塞</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted会返回是否被打断过，同时会清除打断标记; 下次park仍然可以阻塞</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)&amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>可打断则是在park方法被打断之后，执行完了parkAndCheckInterrupt方法，进入if内部，<strong>直接抛出异常，不会再次执行for循环</strong>，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入可打断的获取锁流程</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><p>与非公平锁的区别主要在tryAcquire方法里，公平锁并不会直接cas 去设置state的值，它会先去检查一下AQS队列中有不有前驱节点，也就是说还有不有线程在等待，如果有就退出if，获取锁失败，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">           <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(current);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                (<span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">            (s = h.next) == <span class="keyword">null</span> || <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">                                s.thread != Thread.currentThread()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>在AQS中ConditionObject是一个实现了Condition的公共内部类，每个条件变量其实就对应着一个ConditionObject，ConditionObject维护了一个等待队列</p><h4 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a>await流程</h4><p>下面是ConditionObject中的await方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>开始 Thread0 持有锁，conditionObject对象调用 await</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145922395.png" alt="image-20220129145922395"></p><p>进入 ConditionObject 的 addConditionWaiter方法，这个方法会将Thread0在ConditionObject 的等待队列中关联一个节点，首先创建新的Node状态为 -2(Node.CONDITION)，关联 Thread-0，加入等待队列尾部。</p><p>然后fullyRelease()，释放掉Thread0的所有锁，因为是可重入的</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145830741.png" alt="image-20220129145830741"></p><p>内部调用release(args)方法，unparkSuccessor(h)，唤醒AQS队列中的下一个节点，竞争锁</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145906453.png" alt="image-20220129145906453"></p><p>最后会进入await方法中的while循环，park阻塞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h4 id="signal流程"><a href="#signal流程" class="headerlink" title="signal流程"></a>signal流程</h4><p>下面是ConditionObject的<strong>signal</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>假设Thread1要来唤醒Thread0</p><p>首先判断Thread1是否持有独占锁if (!<strong>isHeldExclusively</strong>())，只有持有锁，才能去唤醒条件变量里的线程</p><p>然后<strong>每次都取条件变量中等待队列的第一个</strong><code>Node first = firstWaiter</code>，如果存在等待线程，就dosignal方法</p><p><strong>dosignal</strong> 先做些事后处理，判断是否还有下一个node，并且端口thread0的节点</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129151114179.png" alt="image-20220129151114179"></p><p>然后<strong>transferForSignal</strong>()，这个方法会将要唤醒Node加入到AQS的等待队列里去，并且将等待队列中最后一个node(即是图上的Thread3)的waitStatus修改为-1，因为要唤醒的node加入到它后面了</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129151221485.png" alt="image-20220129151221485"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">AbstractQueueSynchronizer，ReentrantLock实现原理，公平锁非公平锁实现原理，条件变量实现原理</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/CAS/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/CAS/</id>
    <published>2022-02-09T14:52:57.069Z</published>
    <updated>2022-03-08T12:45:23.057Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Java中 <strong>synchronized</strong> 和 <strong>ReentrantLock</strong> 等独占锁是 <strong>悲观锁</strong> 思想的实现</li><li>在Java中<strong>java.util.concurrent.atomic包下面的原子变量类</strong>是使用了乐观锁的一种实现方式 <strong><code>CAS</code></strong> 实现</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li>有如下需求，保证account.withdraw()取款方法的线程安全, 下面使用<code>synchronized</code>保证线程安全</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> AccountUnsafe(<span class="number">10000</span>));</span><br><span class="line">        Account.demo(<span class="keyword">new</span> AccountCas(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountUnsafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java8之后接口新特性, 可以添加默认方法、静态方法</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 1000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(thread -&gt; thread.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end - start) / <span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS解决"><a href="#CAS解决" class="headerlink" title="CAS解决"></a>CAS解决</h2><ul><li>上面的代码中使用synchronized加锁操作来保证线程安全，但是 **synchronized加锁操作太耗费资源 (线程上下文切换)**，我们还可以使用 <strong>无锁CAS</strong> 来解决此问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountCas</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用原子整数</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AccountCas</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//得到原子整数的值</span></span><br><span class="line"><span class="keyword">return</span> balance.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//获得修改前的值</span></span><br><span class="line"><span class="keyword">int</span> prev = balance.get();</span><br><span class="line"><span class="comment">//获得修改后的值</span></span><br><span class="line"><span class="keyword">int</span> next = prev - amount;</span><br><span class="line"><span class="comment">//比较并设置值</span></span><br><span class="line">            <span class="comment">//一个原子操作，比较并设置。会先去比较一下线程当前知道的值prev和主存中的balance</span></span><br><span class="line">            <span class="comment">//比较发现如果相等就设置balance的值为next，然后返回true，不相等就直接返回false</span></span><br><span class="line"><span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h2><p>使用原子操作CAS来保证线程访问共享资源的安全性，需要保证共享变量的可见性</p><h3 id="保证账户余额线程安全原理"><a href="#保证账户余额线程安全原理" class="headerlink" title="保证账户余额线程安全原理"></a>保证账户余额线程安全原理</h3><p><strong>compareAndSet</strong> 保证共享变量安全性：</p><ul><li>调用compareAndSet方法, 会先去比较一下线程当前知道的值prev和主存中的balance，比较发现如果相等就设置balance的值为next，然后返回true，不相等就直接返回false<br>如果不相同，表示其他线程也修改了balance值，此时就设置next值失败，然后进入while循环，重新获取balance.get()的值，计算出next值。并判断本次的prev和balnce的值是否相同</li></ul><p>其实 <strong>CAS</strong> 的底层是 <strong>lock cmpxchg 指令（X86 架构）</strong>，在单核 CPU 和多核 CPU 下都能够保证比较-交换的原子性。<br>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p><h3 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h3><p>在上面代码中的<strong>AtomicInteger</strong>类，内部的<strong>value</strong>属性使用了<strong>volatile</strong> 修饰。获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰，这样能保证线程对属性的修改对其他线程可见。(volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>使用<strong>CAS</strong>+重试无锁情况下，即使重试失败，<strong>线程</strong>始终在<strong>高速运行</strong>，没有停歇，而 <strong>synchronized</strong>会让线程在没有获得锁的时候，发生<strong>上下文切换</strong>，进入<strong>阻塞</strong>。</p><p>打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</p><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p><p>因此，CAS这种方式也比较依靠CPU核心数，如果CPU核心数不够，即使有再多的线程，线程分不到时间片，一样会阻塞住，一样会上下文切换，所以最好线程数不要大于CPU核心数。</p><h3 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，<strong>适用于线程数少、多核 CPU</strong> 的场景下。</p><p><strong>CAS</strong> 是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，那就再尝试一次。<br><strong>synchronized</strong>是基于<strong>悲观锁</strong>的思想：最悲观的估计，保证不让其它线程来修改共享变量，上了锁其他线程都不能操作，修改完了解开锁，其他线程才有机会。<br><strong>CAS 体现的是无锁并发、无阻塞并发</strong>，因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一，**但如果竞争激烈(写操作多)**，可以想到重试必然频繁发生，反而效率会受影响</p><h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p><strong>java.util.concurrent.atomic</strong>提供的是一些原子类，</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p>上面三个类提供的方法几乎相同，以 <strong>AtomicInteger</strong>为例。<br>通过观察源码可以发现AtomicInteger 内部是通过cas的来实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">    System.out.println(i.getAndIncrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">    System.out.println(i.incrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">    System.out.println(i.decrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">    System.out.println(i.getAndDecrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">    System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    <span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line">    <span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">    System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i.getAndAccumulate(10, (p, x) -&gt; p + x)</code>：函数式编程接口，(p, x) -&gt; p + x做为一个参数可以理解为实现了某一种方法，这种方式就是返回p+x的值</p><p><code>updateAndGet</code>方法的实现：实际上是相当于把匿名内部类简化了一下，以函数式的风格就可以调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    updateAndGet(i, <span class="keyword">new</span> IntUnaryOperator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(<span class="keyword">int</span> operand)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> operand / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i.get()); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateAndGet</span><span class="params">(AtomicInteger i, IntUnaryOperator operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = i.get(); <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">int</span> next = operator.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span> (i.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子引用-AtomicReference"><a href="#原子引用-AtomicReference" class="headerlink" title="原子引用 (AtomicReference)"></a>原子引用 (AtomicReference)</h2><p>原子引用保证引用类型的共享变量是线程安全的，刚才的是规定了数据类型比如为Integer</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicMarkableReference</code>：原子更新带有版本号的引用类型。用版本号一般是整型来标识是否被修改过，用来解决 ABA 问题。</li><li><code>AtomicStampedReference</code> 原子更新带有标记的引用类型。该类并不关心中途修改了多少次，只关心有没有修改过，所以只需要用一个 boolean 标记与引用关联起来，可以解决ABA 问题。</li></ul><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>ABA问题就是说在采用原子类型操作的时候，比如如果用上面的AtomicInteger，一个线程想把1改为3，但这个线程成功之前，线程2先把1改为了2，然后某个线程又把2改回了1，这时候想改为3的线程虽然也能改成功，因为它从主存中获取到的值仍然为1，但是实际上已经被其他线程修改过了，这就是ABA问题，简单点来说就是A修改到B后又修改回了A，但是其他线程并不知道修改过了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String pre = ref.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//把ref中的A改为C，也会修改成功，这就是ABA问题 仍然是true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C &quot;</span> + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 线程start后主线程sleep了，所以这个线程把A-&gt;B，并且能改成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 再将B-&gt;A，同样也能修改成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicStampedReference-版本号解决ABA问题"><a href="#AtomicStampedReference-版本号解决ABA问题" class="headerlink" title="AtomicStampedReference (版本号解决ABA问题)"></a>AtomicStampedReference (版本号解决ABA问题)</h3><p><strong>AtomicStampedReference</strong> 可以加一个版本号，来解决ABA问题，在构造的时候初始化一个版本号，如果有线程修改了就版本号加1，这样其他线程就能根据这个版本号来判断是否被修改过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String pre = ref.getReference();</span><br><span class="line">            <span class="comment">//获得版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp(); <span class="comment">// 此时的版本号还是第一次获取的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把ref中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C stamp &quot;</span> + stamp + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicMarkableReference-boolean解决ABA问题"><a href="#AtomicMarkableReference-boolean解决ABA问题" class="headerlink" title="AtomicMarkableReference (boolean解决ABA问题)"></a>AtomicMarkableReference (boolean解决ABA问题)</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; </p><p>A -&gt;C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，就可以使用<strong>AtomicMarkableReference</strong></p><h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><p><strong>原子数组用来保证数组内的元素的线程安全，使用原子的方式更新数组里的某个元素</strong></p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><p>下面<strong>不安全的示例</strong>中采用了函数式编程，可以理解为demo(…)方法里的参数，都是一种方法，在调用demo方法的时候实现好方法的内容，然后直接返回给参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo(</span><br><span class="line">                () -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">                array -&gt; array.length,</span><br><span class="line">                (array, index) -&gt; array[index]++,</span><br><span class="line">                array -&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment">     * 参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment">     * 参数3，自增方法，回传 array, index</span></span><br><span class="line"><span class="comment">     * 参数4，打印数组的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line">    <span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line">    <span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;void</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;T, Integer&gt; putConsumer, </span></span></span><br><span class="line"><span class="function"><span class="params">        Consumer&lt;T&gt; printConsumer)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        T array = arraySupplier.get();</span><br><span class="line">        <span class="keyword">int</span> length = lengthFun.apply(array);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建10个线程, 每个线程对数组作 10000 次操作</span></span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    putConsumer.accept(array, j % length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ts.forEach(t -&gt; t.start()); <span class="comment">// 启动所有线程</span></span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 等所有线程结束</span></span><br><span class="line"></span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安全的实现只需要用AtomicIntegerArray数组来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">        ()-&gt; <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>),</span><br><span class="line">        (array) -&gt; array.length(),</span><br><span class="line">        (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">        array -&gt; System.out.println(array)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><p><strong>保证多线程访问同一个对象的成员变量时，成员变量的线程安全性。</strong></p><ul><li>AtomicReferenceFieldUpdater：引用类型</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>注意：利用字段更新器，可以针对对象的某个域或者叫属性（Field）进行原子操作，但是<strong>属性需要被volatile 修饰</strong>，否则会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be <span class="keyword">volatile</span> type</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">// 获得原子更新器</span></span><br><span class="line">      <span class="comment">// 泛型</span></span><br><span class="line">      <span class="comment">// 参数1 newUpdater(类的字节码对象,被更新的属性的字节码对象,属性的名称)</span></span><br><span class="line">        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//最初为null，想要修改为&quot;张三&quot;</span></span><br><span class="line">        System.out.println(updater.compareAndSet(stu, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(updater.compareAndSet(stu, stu.name, <span class="string">&quot;王五&quot;</span>));</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子累加器-LongAddr"><a href="#原子累加器-LongAddr" class="headerlink" title="原子累加器 (LongAddr)"></a>原子累加器 (LongAddr)</h2><p>原子累加器是jdk8的新的几个类，它优化了原始原子整数的方法，能够得到更快的效率</p><ul><li>LongAddr</li><li>LongAccumulator</li><li>DoubleAddr</li><li>DoubleAccumulator</li></ul><p><strong>AtomicLong和LongAddr的性能比较</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----AtomicLong----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----LongAdder----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> LongAdder(), adder -&gt; adder.increment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">        T adder = adderSupplier.get();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                    action.accept(adder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(t -&gt; t.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start) / <span class="number">1000_000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LongAddr性能提升的原因"><a href="#LongAddr性能提升的原因" class="headerlink" title="LongAddr性能提升的原因"></a><strong>LongAddr性能提升的原因</strong></h3><ul><li>就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 失败的次数，从而提高性能。</li></ul><p>AtomicLong等都是在一个共享资源变量上进行竞争, while(true)循环进行CAS，性能没有LongAdder高</p><h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><ul><li><strong>Unsafe</strong> 对象提供了非常底层的操作内存和线程的方法，Unsafe 对象<strong>不能直接调用</strong>，<strong>只能</strong>通过<strong>反射</strong></li><li>可以发现AtomicInteger以及其他的原子类, 底层都会使用一个Unsafe的属性</li></ul><h3 id="使用Unsafe实现原子操作"><a href="#使用Unsafe实现原子操作" class="headerlink" title="使用Unsafe实现原子操作"></a>使用Unsafe实现原子操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射获得Unsafe对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Person对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获得其属性 name 的偏移量（相对于类的属性值的地址偏移量）</span></span><br><span class="line">        <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="keyword">long</span> ageOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过unsafe的CAS操作改变值</span></span><br><span class="line">        unsafe.compareAndSwapObject(person, nameOffset, <span class="keyword">null</span>, <span class="string">&quot;guizy&quot;</span>);</span><br><span class="line">        unsafe.compareAndSwapInt(person, ageOffset, <span class="number">0</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配合CAS操作，必须用volatile修饰</span></span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CAS，原子整数，原子引用，原子数组，累加器，Unsafe类</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/ReentrantLock/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/ReentrantLock/</id>
    <published>2022-02-09T14:20:56.592Z</published>
    <updated>2022-03-08T12:45:23.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><p>一个并发应用程序能及时执行的能力称为活跃性</p><ul><li>活跃性相关的一系列问题都可以用 ReentrantLock 进行解决。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br>如：线程1获取A对象锁, 线程2获取B对象锁; 此时线程1又想获取B对象锁, 线程2又想获取A对象锁; 它们都等着对象释放锁, 此时就称为死锁</p><h3 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h3><ol><li>互斥条件<br>在一段时间内，一种资源只能被一个进程所使用</li><li>请求和保持条件<br>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进阻塞状态，并且不释放自己已有的资源</li><li>不可抢占条件<br>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li><li>循环等待条件<br>发生死锁时，必然存在一个进程——资源的循环链</li></ol><h3 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h3><h4 id="JPS-JStack进程ID"><a href="#JPS-JStack进程ID" class="headerlink" title="JPS+JStack进程ID"></a>JPS+JStack进程ID</h4><p>首先JPS找到JVM进程，JStack +进程ID查看进程状态</p><h4 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h4><p>jconsole连接进程，检测死锁</p><h4 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h4><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li><li>当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。</li></ul><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁出现在两个线程互相改变对方的结束条件，谁也无法结束。</p><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><ul><li>某些线程因为优先级太低，导致一直无法获得资源的现象。</li></ul><ul><li>在使用顺序加锁时，可能会出现饥饿现象</li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock特点：</p><ul><li>可中断</li><li>可设置超时时间</li><li>可设置为公平锁</li><li>支持多个条件变量，根据不同条件加锁</li></ul><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//需要执行的代码</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//需要执行的代码</span></span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>ReentrantLock是可以中断的，调用reentrantLock. lockInterruptibly()，那么这个reentrantLock就是一个可打断的锁；如果这个锁没有竞争，那么它跟正常的lock方法是没有区别的。但是如果发生了竞争并且线程进入了阻塞队列，那么这个阻塞状态是可以被其他线程打断的。避免了一直阻塞。</p><ul><li><strong>synchronized</strong>是获得了锁以后，可以进行打断，<strong>打断正在运行的线程或者说打断在sleep，wait，join的线程</strong></li><li><strong>ReentrantLock</strong>的可<strong>打断</strong>的意思是没获得锁，前往阻塞队列，可以<strong>打断它的阻塞</strong>，<strong>避免一直获取不到锁而阻塞，可以用来避免死锁</strong>，**<code>防止死锁的思想还是避免一直等待</code>**</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//lockInterruptibly方法表示是可中断的</span></span><br><span class="line">            <span class="comment">// 也就是说reentrantLock还没获得锁，竞争后进入了阻塞队列，别的线程可以打断reentrantLock的阻塞</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有竞争这个方法跟lock()是一样的</span></span><br><span class="line">                <span class="comment">//如果有竞争进入阻塞队列，可以被其他线程打断</span></span><br><span class="line">                System.out.println(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">                reentrantLock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有获取锁，返回&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在t1线程获取到锁前先锁住</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打断t1&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">尝试获取锁</span><br><span class="line">打断t1</span><br><span class="line">没有获取锁，返回</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly (AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly( AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">at com.zc.reentrantlock.Test.lambda$main$<span class="number">0</span>(Test.java:<span class="number">22</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>如果是reentrantLock.lock()方法，则是不可打断的；会发现先尝试获取锁，获取不到，然后就阻塞，接下来主线程打断t1，但是没有打断成功，程序一直运行。</li></ul><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p><strong>锁超时</strong>是指用ReentrantLock的**tryLock()**方法上锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>tryLock()<strong>方法返回boolean值，会</strong>先判断能否成功获取锁</strong>，不能则返回false。</li><li>**tryLock(long timeout, TimeUnit unit)**表示在一定timeout时间内去尝试获取锁，在这时间段仍获取不到锁则返回false。同样这个方法同lockInterruptibly()方法一样，也是一个可打断的方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!reentrantLock.tryLock()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取不到锁，返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reentrantLock.lock();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trylock-解决哲学家就餐问题"><a href="#trylock-解决哲学家就餐问题" class="headerlink" title="trylock()解决哲学家就餐问题"></a>trylock()解决哲学家就餐问题</h3><p>哲学家在拿到左边的筷子的时候也就是左边筷子加锁，然后准备给右边筷子加锁，采用trylock()保证其不会一直占着左边的筷子不放，如果没能成功给右边筷子加锁，那么就会释放左边的筷子。</p><p>原来采用synchronized会产生死锁是因为synchronized给左边的的筷子加锁后，又想给右边筷子加锁，右边筷子加锁要是不成功，就不会继续往下执行，也就是不会释放左边筷子的锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哲学家就餐问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;PhilosopherEatingProblem.class&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhilosopherEatingProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Chopstick left;</span><br><span class="line">    <span class="keyword">final</span> Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//获得左手边筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//获得成功，获取右边筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承ReentrantLock, 让筷子类成为锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock<strong>默认</strong>是<strong>非公平锁</strong>，可以在<strong>构造方法</strong>的时候指定其为<strong>公平锁</strong>；</p><p>在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。一般不设置ReentrantLock为公平的, 会降低并发度。</p><p>Synchronized底层的Monitor锁就是不公平的, 和谁先进入阻塞队列是没有关系的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>公平锁可以解决饥饿问题，也就是说不会存在某个线程一直获取不到锁。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li>synchronized中也有条件变量，当条件不满足的时候，进入waitSet集合，但是它的waitSet只有一个</li><li>ReentrantLock可以有多个条件变量，也就是说可以有多个waitSet，不同条件的进入不同的waitSet等待，这样可以<strong>避免虚假唤醒</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">//条件变量一</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Condition condition1= lock.newCondition();</span><br><span class="line">   <span class="comment">//条件变量2</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Condition condition2= lock.newCondition();</span><br></pre></td></tr></table></figure><ul><li>condition.await()方法进入对应条件的waitSet</li><li>condition.signal()方法唤醒对应条件的waitSet中的一个线程</li><li>condition.signalAll()方法唤醒对应条件的waitSet中的所有线程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 等待烟的休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitCigaretteSet = lock.newCondition();</span><br><span class="line">    <span class="comment">// 等外卖的休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitTakeoutSet = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小南进入到等烟的休息室</span></span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;烟来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小女进入到等外卖的休息室</span></span><br><span class="line">                        waitTakeoutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送外卖的来咯~&quot;</span>);</span><br><span class="line">                hasTakeout = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等外卖的小女线程</span></span><br><span class="line">                waitTakeoutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送烟的来咯~&quot;</span>);</span><br><span class="line">                hasCigarette = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等烟的小南线程</span></span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="顺序打印"><a href="#顺序打印" class="headerlink" title="顺序打印"></a>顺序打印</h3><ul><li>要求两个线程先打印2，再打印1</li></ul><h4 id="wait-notify实现"><a href="#wait-notify实现" class="headerlink" title="wait-notify实现"></a>wait-notify实现</h4><p>设置一个标记变量，只有2还没打印，就wait，2打印完了，唤醒1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSeqPrint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> has2Printed=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!has2Printed) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)</span><br><span class="line">            &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">                has2Printed=<span class="keyword">true</span>;</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock的await-signal实现"><a href="#ReentrantLock的await-signal实现" class="headerlink" title="ReentrantLock的await/signal实现"></a>ReentrantLock的await/signal实现</h4><p>不满足条件去其条件变量中等待</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (!has2Printed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">        has2Printed=<span class="keyword">true</span>;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="LockSupport的park和unpark实现"><a href="#LockSupport的park和unpark实现" class="headerlink" title="LockSupport的park和unpark实现"></a>LockSupport的park和unpark实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();;</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><ul><li>要求线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。</li></ul><h4 id="wait-notify实现-1"><a href="#wait-notify实现-1" class="headerlink" title="wait-notify实现"></a>wait-notify实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;a线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;b线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;c线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出内容    等待标记    下一个标记</span></span><br><span class="line"><span class="comment">        a           1          2</span></span><br><span class="line"><span class="comment">        b           2          3</span></span><br><span class="line"><span class="comment">        c           3          1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, <span class="keyword">int</span> waitFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (waitFlag != <span class="keyword">this</span>.flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="keyword">this</span>.flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：abcabcabcabcabc</p><h4 id="condition-await-signal实现"><a href="#condition-await-signal实现" class="headerlink" title="condition.await/signal实现"></a>condition.await/signal实现</h4><p>设置3个条件变量，去各自的waitSet中等待，先让3个线程都阻塞，然后开始唤醒a，直接a唤醒b，b唤醒c</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAwaitSignal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a_condition = awaitSignal.newCondition();</span><br><span class="line">        Condition b_condition = awaitSignal.newCondition();</span><br><span class="line">        Condition c_condition = awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a_condition, b_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b_condition, c_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c_condition, a_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==========开始=========&quot;</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a_condition.signal();  <span class="comment">//首先唤醒a线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Condition condition, Condition next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.out.print(str);</span><br><span class="line">                    next.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LockSupport的park-unpark实现"><a href="#LockSupport的park-unpark实现" class="headerlink" title="LockSupport的park/unpark实现"></a>LockSupport的park/unpark实现</h4><p>先全部阻塞，然后唤醒a，接着a唤醒b，b唤醒c，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread a;</span><br><span class="line">    <span class="keyword">static</span> Thread b;</span><br><span class="line">    <span class="keyword">static</span> Thread c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark parkUnpark = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;a&quot;</span>, b);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;b&quot;</span>, c);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;c&quot;</span>, a);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h2><p><img src="/../../img/markdown_img/ReentrantLock.assets/image-20220118111830515.png" alt="image-20220118111830515"></p>]]></content>
    
    
    <summary type="html">ReentrantLock、条件变量Condition、LockSupport Park，unPark</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程的安全性问题</title>
    <link href="http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2022-01-17T10:35:35.045Z</published>
    <updated>2022-03-08T12:45:23.047Z</updated>
    
    <content type="html"><![CDATA[<ul><li>线程安全问题</li><li>synchronized保证线程安全</li><li>private或final的重要性</li><li>线程八锁问题分析</li><li>变量的线程安全分析</li></ul><h2 id="临界区与竞态条件"><a href="#临界区与竞态条件" class="headerlink" title="临界区与竞态条件"></a>临界区与竞态条件</h2><p>一个程序运行多线程本身是没有问题的，问题出现在多个线程共享资源(临界资源)的时候</p><p>多个线程同时对共享资源进行读操作本身也没有问题 - 对读操作没问题</p><p>问题出现在对对共享资源同时进行读写操作时就有问题了 - 同时读写操作有问题</p><p>先定义一个叫做临界区的概念：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为<strong>临界区</strong>; 共享资源也成为<strong>临界资源</strong></p><ul><li>多个线程在<code>临界区</code>执行，那么由于<strong>代码指令的执行不确定而导致的结果问题</strong>，称为<code>竞态条件</code></li></ul><p>为了避免临界区中的竞态条件发生，由多种手段可以达到</p><ul><li>阻塞式解决方案： synchronized , Lock (ReentrantLock)</li><li>非阻塞式解决方案： 原子变量 (CAS)</li></ul><p>使用synchronized来进行解决，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><p>注意: 虽然Java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码。同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</p><h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><ul><li>其实就是考察<code>synchronized 锁住的是哪个对象</code>, 如果锁住的是<code>同一对象</code>, 就不会出现<code>线程安全</code>问题</li></ul><h3 id="锁住同一个对象都是this，结果为：1-2或者2-1"><a href="#锁住同一个对象都是this，结果为：1-2或者2-1" class="headerlink" title="锁住同一个对象都是this，结果为：1,2或者2,1"></a>锁住同一个对象都是this，结果为：1,2或者2,1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1/2 或 2/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁住同一个对象都是this，结果为：1s后1-2-2-1s后1"><a href="#锁住同一个对象都是this，结果为：1s后1-2-2-1s后1" class="headerlink" title="锁住同一个对象都是this，结果为：1s后1,2 || 2,1s后1"></a>锁住同一个对象都是this，结果为：1s后1,2 || 2,1s后1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1s后1,2 || 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a，b锁住同一个对象都是this，c没有上锁。"><a href="#a，b锁住同一个对象都是this，c没有上锁。" class="headerlink" title="a，b锁住同一个对象都是this，c没有上锁。"></a>a，b锁住同一个对象都是this，c没有上锁。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会出现安全问题, 因为前两个线程, 执行run方法时, 都对相同的对象加锁;</span></span><br><span class="line"><span class="comment"> *              而第三个线程,调用的方法c, 并没有加锁, 所以它可以同前两个线程并行执行;</span></span><br><span class="line"><span class="comment"> *  打印结果顺序为: 分析: 因为线程3和线程1,2肯定是并行执行的, 所以有以下情况</span></span><br><span class="line"><span class="comment"> *               3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1</span></span><br><span class="line"><span class="comment"> *               至于 1,3,2的情况是不会发生的, 可以先调用到1,但需要sleep一秒.3肯定先执行了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                e1.a();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.c()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住对象this，b锁住对象this"><a href="#a锁住对象this，b锁住对象this" class="headerlink" title="a锁住对象this，b锁住对象this"></a>a锁住对象this，b锁住对象this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会出现安全问题, 线程1的锁对象为e1, 线程2的锁对象为e2. 所以他们会同一时刻执行1,2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是e2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住的是类-b锁住的是this"><a href="#a锁住的是类-b锁住的是this" class="headerlink" title="a锁住的是类, b锁住的是this"></a>a锁住的是类, b锁住的是this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是e2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-b锁住的是类-会发生互斥"><a href="#a-b锁住的是类-会发生互斥" class="headerlink" title="a,b锁住的是类, 会发生互斥"></a>a,b锁住的是类, 会发生互斥</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span></span><br><span class="line"><span class="comment"> *              结果: 2,1s后1 || 1s后1,2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住的是类-b锁住的是this-1"><a href="#a锁住的是类-b锁住的是this-1" class="headerlink" title="a锁住的是类, b锁住的是this"></a>a锁住的是类, b锁住的是this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是this,e2对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-b锁住的是类-会发生互斥-1"><a href="#a-b锁住的是类-会发生互斥-1" class="headerlink" title="a,b锁住的是类, 会发生互斥"></a>a,b锁住的是类, 会发生互斥</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1 || 1s后1,2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><h3 id="成员变量和静态变量的线程安全分析"><a href="#成员变量和静态变量的线程安全分析" class="headerlink" title="成员变量和静态变量的线程安全分析"></a>成员变量和静态变量的线程安全分析</h3><p>如果变量没有在线程间共享，那么变量是安全的<br>如果变量在线程间共享<br>如果只有读操作，则线程安全<br>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p><h3 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h3><p>局部变量【局部变量被初始化为基本数据类型】是安全的<br>但<strong>局部变量引用的对象</strong>则未必线程安全 （要看该对象是否被共享且被执行了读写操作）</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul><li>如果<code>局部变量引用的对象逃离方法的范围</code>，那么<code>要考虑线程安全问题</code>的，代码示例如下</li></ul><blockquote><p>循环创建了100个线程, 在线程体里面都调用了method1方法, 在method1方法中又循环调用了100次method2,method3方法，也即是arrayList 的add和remove；这里的arrayList 是多线程中共享的变量，因为都是unsafeTest，对于这个共享的变量，虽然arrayList 的操作是加了同步代码块的，但是arrayList.add()和arrayList.remove()并不能保证也是同步的，这样必然会出现线程安全问题，最后以异常的形式抛出。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeTest unsafeTest = <span class="keyword">new</span> UnsafeTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                unsafeTest.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;线程1&quot;</span> Exception in thread <span class="string">&quot;线程2&quot;</span> java.lang.ArrayIndexOutOfBoundsException: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>解决方法就是可以将arrayList作为局部变量，放在method1内部，这样arrayList就可以认为是一个线程私有的。局部变量存放在<strong>栈帧</strong>中, 栈帧又存放在<code>虚拟机栈</code>中, <strong>虚拟机栈是作为线程私有的;</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            method2(arrayList);</span><br><span class="line">            method3(arrayList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(List&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(List&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private-或-final的作用"><a href="#private-或-final的作用" class="headerlink" title="private 或 final的作用"></a><code>private</code> 或 <code>final</code>的作用</h3><p>使用这两个修饰符可以提高线程的安全性，private和final让子类不能重写父类的方法，当我们的方法如果是public，也即是上面的代码method2,method3都是public时，虽然上面代码不会出现线程安全问题，如果有一个子类继承了这个UnsafeTest类，然后又因为是public方法，就可以重写覆盖父类的方法，此时在子类中开多线程操作list对象，就有可能造成线程安全问题：子类和父类共享了list对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSafe threadSafe = <span class="keyword">new</span> ThreadSafeSubClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                threadSafe.method1(<span class="number">10</span>);</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见线程安全类-1"><a href="#常见线程安全类-1" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类 JUC</li></ul><p>这里说它们是线程安全的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong> , 也可以理解为 <strong>它们的每个方法是原子的</strong>，因为方法都被加上了synchronized</p><p>但注意它们的<code>多个方法的组合不是原子的</code>，所以可能<strong>会出现线程安全问题</strong></p>]]></content>
    
    
    <summary type="html">临界区与竞态条件、线程八锁问题</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-01-17T10:26:55.204Z</published>
    <updated>2022-03-08T12:43:57.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程、并行并发、同步异步概念"><a href="#线程与进程、并行并发、同步异步概念" class="headerlink" title="线程与进程、并行并发、同步异步概念"></a>线程与进程、并行并发、同步异步概念</h2><ul><li>线程创建</li><li>线程重要api，如start，run，sleep, join，interrupt等</li><li>线程状态</li><li>应用方面<ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li>原理方面<ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式的源码</li></ul></li><li><font color="green">模式方面</font><ul><li>两阶段终止</li></ul></li></ul><h2 id="进程与进程"><a href="#进程与进程" class="headerlink" title="进程与进程"></a>进程与进程</h2><p>进程: 资源分配的最小单位</p><p>进程是线程的容器, 一个进程中包含多个线程, 真正执行任务的是线程<br>线程: 资源调度的最小单位</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序由指令和数据组成，但是这些 指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令,管理内存,管理IO的<br>当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程<br>进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程之内可以分为多个线程。<br>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行<br>Java 中，线程作为资源的最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。</p><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集<br>进程拥有共享的资源，如内存空间等，供其内部的线程共享; 进程间通信较为复杂<br>同一台计算机的进程通信称为 IPC（Inter-process communication）<br>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP<br>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<br>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>并发: 在单核CPU下, 一定是并发执行的, 也就是在同一个时间段内一起执行. 实际还是串行执行, CPU的时间片切换非常快, 给人一种同时运行的感觉。</p><p>并行: 在多核CPU下, 能真正意义上实现并行执行, 在同一个时刻, 多个线程同时执行; 比如说2核cpu, 同时执行4个线程. 理论上同时可以有2个线程是并行执行的. 此时还是存在并发, 因为2个cpu也会同时切换不同的线程执行任务罢了</p><h3 id="并发-concurrent"><a href="#并发-concurrent" class="headerlink" title="并发 (concurrent)"></a>并发 (concurrent)</h3><p>微观串行, 宏观并行<br>在单核 cpu下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu 在线程间（时间片很短）的切换非常快，给人的感觉是同时运行的 。一般会将这种线程轮流使用 CPU的做法称为并发（concurrent）<br>将线程轮流使用cput称为并发(concurrent)</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p><h3 id="二者对比-1"><a href="#二者对比-1" class="headerlink" title="二者对比"></a>二者对比</h3><p>引用 Rob Pike 的一段描述：<br>并发（concurrent）: 是同一时间应对（dealing with）多件事情的能力<br>并行（parallel）: 是同一时间动手做（doing）多件事情的能力<br>例子</p><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发<br>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）<br>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是 并行</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>以调用方的角度讲</p><ul><li>如果需要等待结果返回才能继续运行的话就是同步</li><li>如果不需要等待就是异步</li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这5秒cpu什么都做不了，其它代码都得暂停</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>UI 程序中，开线程进行其他操作，避免阻塞 UI 线程</li></ul><h2 id="线程的创建-重点"><a href="#线程的创建-重点" class="headerlink" title="线程的创建 (重点)"></a>线程的创建 (重点)</h2><h3 id="创建一个线程（非主线程）"><a href="#创建一个线程（非主线程）" class="headerlink" title="创建一个线程（非主线程）"></a>创建一个线程（非主线程）</h3><h4 id="通过继承Thread创建线程"><a href="#通过继承Thread创建线程" class="headerlink" title="通过继承Thread创建线程"></a>通过继承Thread创建线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">myThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用继承方式的好处是，在run()方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread()方法；不好的地方是<strong>Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</strong></li></ul><h4 id="使用Runnable配合Thread-推荐"><a href="#使用Runnable配合Thread-推荐" class="headerlink" title="使用Runnable配合Thread (推荐)"></a>使用Runnable配合Thread (推荐)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread2</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;my runnable running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">      thread.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</li></ul><h5 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h5><ul><li><p>当一个接口带有**@FunctionalInterface**注解时，是可以使用lambda来简化操作的</p></li><li><p>所以方法二中的代码可以被简化为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="comment">//直接写方法体即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Thread-与-Runnable的关系"><a href="#Thread-与-Runnable的关系" class="headerlink" title="Thread 与 Runnable的关系"></a>Thread 与 Runnable的关系</h5><p>分析 Thread 的源码，查看与 Runnable 的关系，可以发现采用Runnable的方式最终new Thread的时候最终就是把实现Runnable作为Thread中的target成员，然后判断如果target不为null，就运行target的run()方法，也就是Runnable的run方法。</p><ul><li>继承Thread方式: 是把线程和任务合并在了一起</li><li>实现Runnable方式: 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h4 id="使用FutureTask与Thread结合"><a href="#使用FutureTask与Thread结合" class="headerlink" title="使用FutureTask与Thread结合"></a>使用FutureTask与Thread结合</h4><p>使用<strong>FutureTask可以用泛型指定线程的返回值类型</strong>（Runnable的run方法没有返回值），FutureTask实现了RunnableFuture，FutureRunable继承了Runnable接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread r1 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">r1.start();</span><br><span class="line"><span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseFutureTask</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">      FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCall());</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">      thread.start();</span><br><span class="line">      <span class="comment">// 获得线程运行后的返回值</span></span><br><span class="line">      System.out.println(futureTask.get());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用线程池来创建线程"><a href="#使用线程池来创建线程" class="headerlink" title="使用线程池来创建线程"></a>使用线程池来创建线程</h4><p>创建线程的方式四：使用线程池</p><p>好处：</p><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p></li></ol><ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？四种！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：创建多线程有几种方式？四种！"><a href="#面试题：创建多线程有几种方式？四种！" class="headerlink" title="面试题：创建多线程有几种方式？四种！"></a>面试题：创建多线程有几种方式？四种！</h4><p>总结</p><ul><li>使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</li><li>开发中一般使用线程池的方式</li></ul><h2 id="三、Linux-Windows命令查看进程和线程"><a href="#三、Linux-Windows命令查看进程和线程" class="headerlink" title="三、Linux Windows命令查看进程和线程"></a>三、Linux Windows命令查看进程和线程</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul><li>任务管理器查看进程和线程，杀死进程</li><li> <code>tasklist</code> 查看进程</li><li><code>taskkill /F /PID 进程号</code> 杀死进程</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><code>ps -fe </code>查看所有进程</li><li><code>ps -ft -p &lt;PID&gt;</code> 查看某个进程的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>pkill -9 &lt;PID&gt;</code> 杀死进程，-9代表一类操作，杀死进程</li><li><code>top</code> 查看进程信息</li><li><code>top -H -P &lt;PID&gt;</code> 查看某个进程PID的所有线程</li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><code>jps</code> 查看所有Java进程</li><li><code>jstack &lt;PID&gt;</code> 查看某个Java进程的所有线程状态</li><li><code>jconsole</code> 连接查看某个Java进程中线程的运行情况（Windows直接win+r 输入jconsole，图形界面）</li></ul><h2 id="线程运行原理-重点"><a href="#线程运行原理-重点" class="headerlink" title="线程运行原理 (重点)"></a>线程运行原理 (<code>重点</code>)</h2><h3 id="虚拟机栈与栈帧"><a href="#虚拟机栈与栈帧" class="headerlink" title="虚拟机栈与栈帧"></a>虚拟机栈与栈帧</h3><ul><li>虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法被执行</strong>的时候都会同时创建一个<strong>栈帧(stack frame)<strong>用于</strong>存储局部变量表</strong>、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。当Java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧(在栈顶)，<strong>对应着当前正在执行的那个方法</strong>。</li><li>每个线程都拥有自己的一个栈内存，里面对应着多个栈帧。可以用IDEA开启线程模式的调试功能。</li></ul><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101108334.png" alt="image-20220115101108334"></p><p>t1线程的多个栈帧：</p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115100910857.png" alt="image-20220115100910857"></p><p>主线程的多个栈帧：</p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101011097.png" alt="image-20220115101011097"></p><h3 id="线程上下文切换（Thread-Context-Switch"><a href="#线程上下文切换（Thread-Context-Switch" class="headerlink" title="线程上下文切换（Thread Context Switch)"></a>线程上下文切换（Thread Context Switch)</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程</p><ul><li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当Thread Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>线程的状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能，所以线程数也不能过多，如果线程数大于CPU核心数，可能并不会提升性能</li></ul><h3 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h3><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111642378.png" alt="image-20220115111642378"></p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111913619.png" alt="image-20220115111913619"></p><h4 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h4><h5 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h5><p>调用 sleep() 会让当前线程从 Running(运行状态) 进入 Timed Waiting 状态（阻塞）<br>其它线程可以使用interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 InterruptedException异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】<br>睡眠结束后的线程未必会立刻得到执行 (需要分配到cpu时间片)<br>建议用 TimeUnit 的 sleep() 代替 Thread 的 sleep()来获得更好的可读性</p><h5 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h5><p>调用 yield 会让当前线程从Running 进入 Runnable 就绪状态，然后调度执行其它线程</p><p>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</p><p>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>线程<code>优先级</code>会<code>提示（hint）调度器优先调度该线程</code>，但它仅仅是一个提示，调度器可以忽略它, 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><ul><li>在<code>主线程</code>中调用<code>t1.join</code>，则<code>主线程</code>会<code>等待t1线程执行完之后</code>再<code>继续执行</code></li></ul><h4 id="interrupt-方法详解"><a href="#interrupt-方法详解" class="headerlink" title="interrupt 方法详解"></a>interrupt 方法详解</h4><p>该方法用于打断 sleep，wait，join的线程, 在阻塞期间cpu不会分配给时间片</p><ul><li><p>如果一个线程在在运行中被打断，打断标记会被置为true</p></li><li><p>如果是打断因sleep wait join方法而被阻塞的线程，只是会抛出一个Interrupted 异常，以这个异常来表示线程被打断了，打断标记仍然是false</p></li></ul><p>sleep，wait，join的线程，这几个方法都会让线程进入阻塞状态，join方法底层就是用的wait方法，以 sleep 为例，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>); <span class="comment">// wait, join</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;iterrupt..&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.isInterrupted()); <span class="comment">// 如果是打断sleep,wait,join的线程, 即使打断了, 标记也为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sleep...</span><br><span class="line">iterrupt..</span><br><span class="line">打断标记为:<span class="keyword">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.zc.ThreadPrintDemo.lambda$main$<span class="number">0</span>(ThreadPrintDemo.java:<span class="number">14</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h5><ul><li>调用Interrupt方法去打断一个正在运行的线程，就好比是一个打断请求，只是把其打断标记记为True，实际上是不是要被打断由线程自己决定，线程并不会直接暂停。我们可以判断<code>Thread.currentThread().isInterrupted();</code>的值来手动停止线程</li><li>这样可以方便当线程被打断时做一些后续的操作，料理线程后事</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被打断了, 退出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;打断标记为: &quot;</span>+t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interrupt</span><br><span class="line">被打断了, 退出循环</span><br><span class="line">打断标记为: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="终止模式之两阶段终止模式-多线程设计模式"><a href="#终止模式之两阶段终止模式-多线程设计模式" class="headerlink" title="终止模式之两阶段终止模式(多线程设计模式)"></a>终止模式之两阶段终止模式(多线程设计模式)</h4><p>当我们在执行线程一时，想要终止线程二，这时就需要使用interrupt方法来优雅的停止线程二。</p><h5 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h5><ul><li><p>使用线程对象的stop()方法停止线程</p><p>stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p></li><li><p>使用System.exit(int)方法停止线程</p><p>目的仅是停止一个线程，但这种做法会让整个程序都停止</p></li></ul><p>如下所示：那么线程的isInterrupted()方法可以取得线程的打断标记</p><p>如果线程在睡眠sleep期间被打断，打断标记是不会变的，为false，但是sleep期间被打断会抛出异常，我们据此手动设置打断标记为true；<br>如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为true。处理好这两种情况那我们就可以放心地来料理后事啦！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">monitor.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">monitor.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置线控器线程，用于监控线程状态</span></span><br><span class="line">monitor = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//开始不停的监控</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">//判断当前线程是否被打断了</span></span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;处理后续任务&quot;</span>);</span><br><span class="line">                        <span class="comment">//终止线程执行</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;监控器运行中...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//线程休眠</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span></span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">monitor.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于停止监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//打断线程</span></span><br><span class="line">monitor.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sleep，yiled，wait，join-对比"><a href="#sleep，yiled，wait，join-对比" class="headerlink" title="sleep，yiled，wait，join 对比"></a>sleep，yiled，wait，join 对比</h4><ul><li>sleep，join，yield，interrupted是Thread类中的方法</li><li>wait/notify是object中的方法</li><li>sleep 不释放锁、释放cpu</li><li>join 释放锁、抢占cpu</li><li>yiled 不释放锁、释放cpu</li><li>wait 释放锁、释放cpu</li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>当Java进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，Java进程才会结束。但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</p><p>注意:</p><p>垃圾回收器线程就是一种守护线程<br>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会继续等待</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即Thread thread = new Thread();，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行</p><ul><li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li><p>阻塞状态<br>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】<br>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p><p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h3 id="Java-API层面"><a href="#Java-API层面" class="headerlink" title="Java API层面"></a>Java API层面</h3><p>根据<code>Thread.State 枚举，分为六种状态</code></p><ul><li><strong><code>新建状态</code>、<code>运行状态</code>(就绪状态, 运行中状态)、<code>阻塞状态</code>、<code>等待状态</code>、<code>定时等待状态</code>、<code>终止状态</code></strong></li></ul><ul><li><strong>NEW (新建状态)</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE (运行状态)</strong> 当调用了 start() 方法之后，注意，Java API 层面的<strong>RUNNABLE 状态</strong>涵盖了操作系统层面的 <strong>【就绪状态】、【运行中状态】和【阻塞状态】</strong>（由于 BIO 导致的线程阻塞，比如在读取文件时的操作系统层面的阻塞，也认为是运行状态，在 Java 里无法区分，仍然认为是可运行）</li><li><strong>BLOCKED (阻塞状态)</strong> ， <strong>WAITING (等待状态)</strong> ， <strong>TIMED_WAITING(定时等待状态)</strong> 都是 Java API 层面对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。</li><li><strong>TERMINATED (结束状态)</strong> 当线程代码运行结束</li></ul>]]></content>
    
    
    <summary type="html">线程的几种创建方式，线程设计原理，线程常用方法，多线程设计模式之两阶段终止模式</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized底层原理</title>
    <link href="http://ins1mn1a.github.io/2022/01/17/JUC/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/"/>
    <id>http://ins1mn1a.github.io/2022/01/17/JUC/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</id>
    <published>2022-01-17T10:26:55.173Z</published>
    <updated>2022-03-08T12:45:23.057Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Synchronized底层原理</li><li>Monitor 监视器、管程</li><li>轻量级锁</li><li>重量级锁</li><li>偏向锁</li></ul><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p><strong>对象头</strong>包含两部分：Mark Word和<strong>类型指针</strong> (Klass Word)</p><ol><li>Mark Word<ul><li>哈希值（HashCode），可以看作是堆中对象的地址</li><li>GC分代年龄（年龄计数器） (用于新生代from/to区晋升老年代的标准, 阈值为15)</li><li>锁状态标志 (用于JDK1.6对synchronized的优化 -&gt; 轻量级锁)</li><li>线程持有的锁</li><li>偏向线程ID (用于JDK1.6对synchronized的优化 -&gt; 偏向锁)</li><li>偏向时间戳</li></ul></li><li>类型指针<ul><li>确定该对象所属的类型。指向的其实是方法区中存放的类元信息<code>Class</code>字节码信息</li></ul></li></ol><p>说明：<strong>如果对象是数组，还需要记录数组的长度</strong></p><ul><li>以 <strong>32 位虚拟机</strong>为例,普通对象的对象头结构如下，其中的Klass Word为类型指针，指向方法区`对应的Class对象；</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230503852.png" alt="image-20220115230503852"></p><ul><li>数组对象</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230515921.png" alt="image-20220115230515921"></p><ul><li><strong>其中 Mark Word 结构为: 无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)</strong></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230553563.png" alt="image-20220115230553563"></p><ul><li>所以一个对象的结构如下：</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230631675.png" alt="image-20220115230631675"></p><h2 id="Monitor-原理-Synchronized底层实现-重量级锁"><a href="#Monitor-原理-Synchronized底层实现-重量级锁" class="headerlink" title="Monitor 原理 (Synchronized底层实现-重量级锁)"></a>Monitor 原理 (Synchronized底层实现-重量级锁)</h2><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p><strong>多线程同时访问临界区: 使用重量级锁</strong></p><ul><li>JDK6对Synchronized的优先状态：<code>偏向锁–&gt;轻量级锁–&gt;重量级锁</code></li></ul><p>每个Java对象都可以关联一个(操作系统的)<strong>Monitor</strong>。如果使用synchronized给对象上锁（<strong>重量级</strong>），该对象头的MarkWord中就被设置为指向Monitor对象的指针。</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115231347421.png" alt="image-20220115231347421"></p><p>上图是关联Monitor的原理图，可以理解为：</p><ul><li>Thread2最初执行到<strong>锁对象synchronized(obj)<strong>，会尝试让锁对象synchronized(obj)<strong>关联Monitor</strong>，如果</strong>关联成功</strong>，则将obj对象头的<strong>MarkWord</strong>字段<strong>指向Monitor的地址</strong>，同时将其后两位从<strong>00</strong>设置为10，<strong>Thread2</strong>会成为对应Monitor的<strong>Owner</strong>；</li><li>后续有<strong>Thread1</strong>也执行到了synchronized(obj)，会检查发现obj<strong>已经</strong>有了一个关联的monitor，其<strong>Owner为Thread2</strong>，然后Thread1也会同Monitor关联起来，只不过是<strong>和EntryList关联</strong>，会进入Monitor的EntryList<strong>阻塞（BLOCKED）</strong>起来，等待；</li><li>当<strong>Thread2执行完</strong>临界区代码后，Monitor的Owner就会空出来，此时就会<strong>通知EntryList阻塞队列</strong>的线程，这些线程经过<strong>竞争</strong>，得出新的<strong>Owner</strong>；</li><li>图中 WaitSet 中的线程是之前获得过锁，但条件不满足调用锁对象的wait方法进入 WAITING 状态的线程</li></ul><p><strong>注意：</strong></p><ul><li>synchronized 必须是进入同一个锁对象的 Monitor 才有上述的效果；也就要使用同一把锁</li><li>不加 synchronized的锁对象不会关联监视器，不遵从以上规则</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>它加锁就是依赖底层操作系统的 <code>mutex</code>相关指令实现, 所以会造成<code>用户态和内核态之间的切换</code>, 非常耗性能 !</p><ul><li>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗。</li></ul><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反编译的字节码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">stack&#x3D;2，locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">0: getstatic#2&#x2F;&#x2F; &lt;- lock引用( synchronized开始)</span><br><span class="line">3: dup</span><br><span class="line">4: astore_1&#x2F;&#x2F; lock引用-&gt; slot 1</span><br><span class="line">5: monitorenter&#x2F;&#x2F; 将lock对象Markword置为Monitor指针</span><br><span class="line">6: getstatic#3&#x2F;&#x2F; &lt;- i</span><br><span class="line">9: iconst_1&#x2F;&#x2F; 准备常数1</span><br><span class="line">10: iadd&#x2F;&#x2F; +1</span><br><span class="line">11: putstatic#3&#x2F;&#x2F; -&gt; i</span><br><span class="line">14: aload_1&#x2F;&#x2F; &lt;- lock引用</span><br><span class="line">15: monitorexit&#x2F;&#x2F; 将lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">16: goto24</span><br><span class="line">19: astore_2&#x2F;&#x2F; e -&gt; slot 2</span><br><span class="line">20: aload_1&#x2F;&#x2F; &lt;- lock引用</span><br><span class="line">21: monitorexit&#x2F;&#x2F; 将lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">22: aload_2&#x2F;&#x2F; &lt;- slot 2 (e)</span><br><span class="line">23: athrow&#x2F;&#x2F; throw e</span><br><span class="line">24: return</span><br><span class="line">    Exception table:</span><br><span class="line">        fromtotargettype</span><br><span class="line">            61619any</span><br><span class="line">            192219any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 6</span><br><span class="line">        line 10: 14</span><br><span class="line">        line 11: 24</span><br><span class="line">    LocalVariableTable:</span><br></pre></td></tr></table></figure><p>上面除了体现了正常执行的代码以外，还体现了异常情况。在16的时候goto到24。Exception table描述了异常的情况处理从19到22。</p><p>方法级别的 synchronized 不会在字节码指令中有所体现</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗。所以MarkWord对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁</p><p>轻量级锁用于优化重量级锁</p><p>通过<code>锁记录</code>的方式, 场景 : <strong>多个线程交替进入临界区</strong></p><ul><li><strong><code>轻量级锁的使用场景</code>: 如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用<code>轻量级锁来进行优化</code>。</strong></li></ul><ul><li>轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code> (jdk6对synchronized的优化)，假设有两个方法同步块，利用同一个对象加锁</li></ul><p>在method1加完锁的同时，调用了method2又会加锁synchronized(obj)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 B</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次执行到synchronized代码块时，都会在<code>栈帧中</code>创建<code>锁记录（Lock Record）对象</code>，锁记录内部最开始储存的是<code>lock record的地址 00</code>和<code>锁对象引用reference</code>。还有一个Object锁对象，锁对象头中存储的<strong>MarkWord</strong>（MarkWord包含了HashCode，分代年龄，偏向锁，加锁状态位），Klass Word表示是哪一类的对象。</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092015889.png" alt="image-20220116092015889"></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092231673.png" alt="image-20220116092231673"></p><ul><li>让锁记录中的<strong>Object reference</strong>指向<strong>锁对象地址</strong>，并且尝试用<strong>CAS(compare and swap)<strong>将栈帧中的</strong>锁记录的的地址</strong>(lock record 地址 00)替换Object对象的<strong>Mark Word</strong>，将Mark Word 的值存入锁记录原先存地址的地方(lock record地址 00)，这个交换是一个原子性的操作。这两个字段的后两位标识着一个状态，起到一个标志作用。01表示无锁，00表示轻量级锁，所以在交换成功后，Object存Mark Word的地方后两位就变成了00，就是一个轻量级锁的状态</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092637419.png" alt="image-20220116092637419"></p><p>如果cas<strong>替换成功</strong>，那么对象的对象头储存的就是锁记录的地址和状态00，表示由该线程给对象加锁</p><ul><li>线程中锁记录，记录了锁对象的锁状态标志；锁对象的对象头中存储了锁记录的地址和状态, 标志哪个线程获得了锁</li><li>此时栈帧中存储了对象的对象头中的锁状态标志,年龄计数器,哈希值等; 对象的对象头中就存储了栈帧中锁记录的地址和状态00, 这样的话对象就知道了是哪个线程锁住自己。</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116093326551.png" alt="image-20220116093326551"></p><p>如果cas<strong>替换失败</strong>，有两种情况 : ① 锁膨胀 ② 重入锁失败</p><p>1、如果是其它线程已经持有了该Object的轻量级锁（观察到Object对象头中已经存储了别的线程的锁记录地址 00,指向了其他线程），表示有竞争，将进入锁膨胀阶段</p><p>2、如果是自己的线程已经执行了synchronized进行加锁，那么再添加一条 Lock Record 作为重入锁的计数，同样按照正常的流程去cas交换，但这次交换肯定是失败的，发现这个锁是自己这个线程加的，其中记录锁地址的地方为null。（线程多次加锁, <strong>锁重入</strong>）</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116093748640.png" alt="image-20220116093748640"></p><p>在上面代码中,临界区中又调用了method2，method2中又进行了一次synchronized加锁操作， 此时就会在虚拟机栈中再开辟一个method2方法对应的栈帧(栈顶)， 该栈帧中又会存在一个独立的Lock Record，此时它发现对象的对象头中指向的就是自己线程中栈帧的锁记录; 加锁也就失败了。这种现象就叫做<strong>锁重入</strong>，线程中有多少个锁记录，就能表明该线程对这个对象加了几次锁 (锁重入计数)</p><ul><li><p>当<code>线程退出synchronized代码块</code>的时候，如果获取的是取值为 null 的锁记录，表示有<code>锁重入</code>，这时重置锁记录，表示重入计数减一</p></li><li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null；那么使用cas将Mark Word的值恢复给对象，将直接替换的内容还原。</p><ul><li>成功则解锁成功 (轻量级锁解锁成功)</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程 (Monitor流程)</li></ul></li></ul><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>锁膨胀就是当Thread0已经让某个对象加了轻量级锁，Thread0里的锁记录存着对象的MarkWord，锁对象obj的MarkWord又存着锁记录的地址，这个时候有一个Thread1也执行到了synchronized，也想对obj进行加锁，但是肯定是加锁失败的，Thread1发现锁对象的MarkWord里已经是00了，即已经是轻量级锁了。</p><ul><li><p><strong>因为轻量级锁没有阻塞队列的概念，因此会进入锁膨胀的过程，让锁成为一个重量级锁。</strong>这时Thread1就会为锁对象obj申请一个monitor，让obj的MarkWord执行monitor的地址，并且后两位为01表示重量级锁，monitor将Owner设为Thread0，Thread1则进入Monitor的EntryList阻塞起来</p></li><li><p>在<strong>Thread0执行完毕</strong>后，想要恢复锁记录的地址和MarkWord的时候，肯定会恢复失败，发现原来obj的MarkWord已经是<strong>01重量级锁</strong>了，即进行了<strong>锁膨胀</strong>，因此Thread0<strong>进入重量级锁的解锁流程</strong>，会根据<strong>obj的MarkWord</strong>（这时指向的是对象obj的Monitor）找到对应的monitor，将monitor的Owner设为空，<strong>唤醒EntryList</strong>中的<strong>Thread1</strong>。</p></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116100043133.png" alt="image-20220116100043133"></p><h2 id="自旋锁优化（优化重量级锁竞争）"><a href="#自旋锁优化（优化重量级锁竞争）" class="headerlink" title="自旋锁优化（优化重量级锁竞争）"></a>自旋锁优化（优化重量级锁竞争）</h2><ul><li>发生<strong>重量级锁竞争</strong>的时候，还可以使用<strong>自旋</strong>来进行优化 (不加入Monitor的阻塞队列EntryList中)，如果当前线程<strong>自旋成功</strong>（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以<strong>不用进行上下文切换</strong>(持锁线程执行完synchronized同步块后，释放锁，Owner为空，唤醒阻塞队列来竞争，胜出的线程得到cpu执行权的过程) 就获得了锁</li><li>优化的点: <strong>不用将线程加入到阻塞队列, 减少cpu切换</strong>。</li></ul><p><strong>自旋成功的情况：</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116101816612.png" alt="image-20220116101816612"></p><p><strong>自旋失败的情况：</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116101902140.png" alt="image-20220116101902140"></p><ul><li><p><strong>自旋会<code>占用 CPU 时间</code>，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势</strong>。</p></li><li><p>在 <code>Java 6 之后自旋锁是自适应</code>的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能。</p></li></ul><h2 id="偏向锁-biased-lock-用于优化轻量级锁重入"><a href="#偏向锁-biased-lock-用于优化轻量级锁重入" class="headerlink" title="偏向锁 (biased lock) (用于优化轻量级锁重入)"></a>偏向锁 (biased lock) (用于优化轻量级锁重入)</h2><ul><li>场景: 没有竞争的时候, 一个线程中多次使用synchronized需要重入加锁的情况; (只有一个线程进入临界区)</li></ul><p>在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭，将进入临界区的线程的ID, 直接设置给锁对象的Mark Word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了。</p><ul><li>在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行CAS替换操作，这是有点耗时。</li><li>那么java6开始引入了偏向锁，将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了</li><li><strong>升级为轻量级锁</strong>的情况 (会进行偏向锁撤销)：获取偏向锁的时候, 发现线程ID不是自己的, 此时通过<strong>CAS替换操作, 操作成功</strong>了, 此时该线程就获得了锁对象。( <strong>此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁</strong>)</li><li><strong>升级为重量级锁</strong>的情况 (会进行偏向锁撤销) : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过<strong>CAS替换操作, 操作失败</strong>了, 此时说明发生了锁竞争。( <strong>此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁</strong>)</li></ul><h2 id="偏向、轻量级、重量级锁关系"><a href="#偏向、轻量级、重量级锁关系" class="headerlink" title="偏向、轻量级、重量级锁关系"></a>偏向、轻量级、重量级锁关系</h2><p>最开始synchronized锁只有重量级锁，依赖操作系统的mutex指令，需要用户态和内核态切换，性能损耗明显。重量级锁需要用到monitor对象，而偏向锁则是MarkWord中记录线程的ID，如果某个线程发现Mark Word线程的ID是自己，就不需cas交换锁记录地址和MarkWord。如果不是发现对象的MarkWord中线程ID不是自己，此时就需要通过CAS替换操作，如果<strong>操作成功</strong>，就说明有<strong>多个线程访问临界区</strong>，但是是<strong>交替进行</strong>的，就<strong>撤销偏向锁</strong>，<strong>升级为轻量级锁</strong>，如果<strong>操作失败</strong>，就说明有<strong>多个线程方法临界区</strong>，并且存<strong>在锁竞争</strong>，就撤销偏向锁，<strong>升级为重量级锁</strong>。</p><p><strong>偏向锁</strong>是将锁对象<strong>MarkWord的线程ID</strong>和自己的线程<strong>ID比对</strong>，<strong>轻量级锁</strong>则是将MarkWord和Lock Record进行交换，采用<strong>CAS+自旋</strong>的方式判断是否存在竞争，然后加重量级锁，<strong>重量级锁</strong>则是采用<strong>Monitor</strong>，用<strong>阻塞队列</strong>的形式，将后续线程阻塞起来。</p><ol><li>只有一个线程进入临界区—&gt;偏向锁</li><li>多个线程交替进入临界区—&gt;轻量级锁</li><li>多个线程竞争进入临界区—&gt;重量级锁</li></ol><h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p><strong>64bit虚拟机</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116112754583.png" alt="image-20220116112754583"></p><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</li></ul><ul><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，最后2位为状态（00）</li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，最后2位为状态(10)</li></ul><p>如果开启了<strong>偏向锁</strong>（<strong>默认开启偏向锁</strong>），在创建对象时，对象的Mark Word后三位应该是101</p><p>但是偏向锁<strong>默认是有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态。如果想避免延迟，可以添加虚拟机参数来禁用延迟：</p><p><strong><code>-XX:BiasedLockingStartupDelay=0</code></strong></p><p>打印出101，这时它的hashcode、age都为0，表示它现在是一种<strong>可以偏向的状态</strong>，或者叫匿名偏向锁的状态，也就是说biased_lock位是1，可以偏向，要<strong>真正加锁</strong>还**需要加上synchronized(obj)**。</p><p>这加了synchronized(obj)之后，才是真正加了偏向锁的状态。</p><p>可以用org.openjdk.jol包打印信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">log.debug( classLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">synchronized</span> (d)&#123;</span><br><span class="line">log.debug( ClassLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">log.debug( classLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="撤销偏向锁-hashcode方法-了解"><a href="#撤销偏向锁-hashcode方法-了解" class="headerlink" title="撤销偏向锁-hashcode方法 (了解)"></a>撤销偏向锁-hashcode方法 (了解)</h3><ul><li>测试 <code>hashCode</code>：当<code>调用对象的hashcode方法</code>的时候就会<code>撤销这个对象的偏向锁</code>，<strong>因为使用偏向锁时没有位置存<code>hashcode</code>的值了</strong></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116115419509.png" alt="image-20220116115419509"></p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>在下面的代码中，b方法采用了synchronized，但可以发现它加的对象锁其实并没有启到作用。</p><p>JIT即时编译器会优化热点代码，JIT借助<strong>逃逸分析</strong>发现对象o不能逃离这个方法，对这样的对象加锁是没有意义的，因此JIT即时编译器会把synchronized优化掉，进行锁消除。</p><p>我们也可以在测试的时候加上JVM参数，让它不进行锁消除，<code>-XX:-EliminateLocks</code></p><p>字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，**<code>同步省略（锁消除）操作是在解释运行时发生的</code>**</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">            x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="wait、notify"><a href="#wait、notify" class="headerlink" title="wait、notify"></a>wait、notify</h2><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220117094637795.png" alt="image-20220117094637795"></p><p>Thread0线程<strong>获取到了对象Obj的锁</strong>，成为Monitor的Owner时候，发现自己执行synchronized代码块条件不满足，这时它就会调用**obj.wait()**方法，进入到Monitor的WaitSet集合，此时Thread0处于WAITING状态。</p><ul><li>处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。</li><li>但是有所区别：<ul><li>BLOCKED状态的线程是在竞争锁对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身的原因无法执行synchroized的临界区资源需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li><li><strong>BLOCKED线程</strong>会在<strong>Owner线程释放锁</strong>的时候被<strong>唤醒</strong></li><li><strong>WATITING线程</strong>会在Owner线程调用锁对象的<strong>notify</strong>或者<strong>notifyALL</strong>方法时唤醒，但唤醒后并不意味着立刻获得锁，仍需<strong>进入EntryList重新竞争</strong></li></ul></li></ul><h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><p>下面的三个方法都是Object中的方法; 通过锁对象来调用</p><p>**wait()**：让获得对象锁的线程到waitSet中一直等待</p><p>**wait(long n)**：当该等待线程没有被notify, 等待时间到了之后, 也会自动唤醒</p><p>**notify()**：让获得对象锁的线程, 使用锁对象调用notify去waitSet的等待线程中挑一个唤醒</p><p>**notifyAll()**：让获得对象锁的线程, 使用锁对象调用notifyAll去唤醒waitSet中所有的等待线程</p><p>它们都是线程之间进行协作的手段, 都属于Object对象的方法, 必须获得此对象的锁, 才能调用这些方法</p><p><strong>注：只有当对象被锁以后(成为Owner)，才能调用wait和notify方法</strong></p><p>拥有锁才能wait</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">LOCK.wait();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sleep-long-n-和-Wait-long-n-的区别"><a href="#Sleep-long-n-和-Wait-long-n-的区别" class="headerlink" title="Sleep(long n) 和 Wait(long n)的区别"></a>Sleep(long n) 和 Wait(long n)的区别</h3><ul><li><p>不同点</p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li><strong>Sleep</strong>在阻塞的时候<strong>不会释放锁</strong>，而<strong>Wait</strong>在阻塞的时候会<strong>释放锁</strong> (不释放锁的话, 其他线程就无法唤醒该线程了)</li><li>Sleep方法不需要与synchronized一起使用，而Wait方法需要与synchronized一起使用（wait/notify等方法, <strong>必须要使用对象锁来调用</strong>）</li></ul></li><li><p>相同点</p><ul><li>阻塞状态都为TIMED_WAITING (限时等待)</li></ul></li></ul><h3 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3><p>对象的WaitSet中有多个等待线程，而<strong>notify只能挑一个唤醒</strong>，并<strong>不能指定唤醒线程</strong>，所以有可能会出现<strong>虚假唤醒的状态</strong>。采用notifyAll会唤醒所有线程，但是这样会把其他条件可能仍然不满足的线程唤醒。对于那些线程来说也是一个虚假唤醒。</p><p>因此，那些线程必须得把<strong>If(条件)+wait的方法</strong>改为<strong>while(条件)+wait</strong>的方法，避免采用if判断语句被虚假唤醒后直接结束了，让其<strong>被虚假唤醒后</strong>发现仍然条件不满足，会<strong>继续调用wait方法</strong>再次等待。</p><h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><p>这是一种多线程设计模式，rpc框架的调用中就使用到了这种模式。</p><p>一个线程等待另一个线程的执行结果，一对一的情况，也就是一个生产者对应一个消费者。</p><p>线程2等待线程1执行完毕，线程1执行完后会改变它俩共享变量的状态，线程2据此来判断消费。同时还可以设置超时时间，线程2等到一定时间后就不再等待，退出while循环。</p><p>**join(long millis)**方法和future的原理都用到了这种模式</p><p>join方法设置了超时时间millis，判断是否isAlive()，如果线程还存活，就最多等待millis，<strong>注意每次循环等待时间为delay而不是millis</strong>，防止被虚假唤醒后，下次的等待时间仍然是millis，这显然不对</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多任务版的保护性暂停就需要把公共的锁对象GuardedObject，抽象出来到一个整体，比如一个邮箱，然后里面的每一个对应的信件GuardedObject就是一个锁。</strong></p><h2 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h2><p>这种生产者/消费者模式<strong>不需要一一对应</strong>，也就是说不需要一个生产者对应一个消费者，可以是多个生产者生产，只要生产了，消费者都能用。</p><p>左边三个生产者，生产了就put进中间的<strong>消息队列</strong>，消息队列存放生产者生产出的产品，那右边就一个消费者，只要消息队列里面有产品，那就可以消费。</p><p>这样生产者只关注自己能不能产生结果，消费者只关注自己能不能消费结果。</p><p>消息队列是有容量限制的，不能消费空数据，容量满也不能产生新数据。</p><p>RabbitMQ的原理也类似，但是MQ是实现进程之间的通信。</p><h2 id="park和unpark方法"><a href="#park和unpark方法" class="headerlink" title="park和unpark方法"></a>park和unpark方法</h2><ul><li>park和unpark是LockSupport的方法，可以<strong>指定线程</strong>唤醒。</li><li>park方法是让当前线程进入WAITING状态，unpark方法是让指定线程唤醒</li></ul><p><strong>但是unpark方法可以先执行，后再进行park</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Thread t1 start&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure><h3 id="park、unpark原理"><a href="#park、unpark原理" class="headerlink" title="park、unpark原理"></a>park、unpark原理</h3><p>每一个线程都有自己的<strong>Parker对象</strong>，由三部分组成：</p><ul><li>_counter：相当于一个信号量，只有0和1的状态</li><li>_cond：条件变量，相当于线程的阻塞队列</li><li>_mutex：互斥锁，关联一个 _cond</li></ul><h4 id="先调用park再调用unpark"><a href="#先调用park再调用unpark" class="headerlink" title="先调用park再调用unpark"></a>先调用park再调用unpark</h4><p>调用<strong>park</strong>方法：</p><ul><li><strong>线程t1</strong>，先<strong>调用park方法</strong>，检查_counter的值，发现为0，这时会获得一个互斥锁 _mutex，然后线程进入cond等待队列阻塞，同时还需要<strong>再设置counter为0</strong></li></ul><p>调用**unpark(t1)**方法：</p><ul><li><strong>设置counter为1</strong>，<strong>唤醒</strong>cond中的<strong>线程t1</strong>，t1恢复运行，设置counter为0</li></ul><h4 id="先调用unpark再调用park"><a href="#先调用unpark再调用park" class="headerlink" title="先调用unpark再调用park"></a>先调用unpark再调用park</h4><ul><li>设置counter为1，当前线程调用park方法，检查counter，无需阻塞继续运行，设置counter为0</li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2>]]></content>
    
    
    <summary type="html">Java对象MarkWord，偏向锁、轻量级锁、重量级锁、锁膨胀、</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ins1mn1a.github.io/2022/01/11/Bug%E4%B9%8B%E7%8E%8B/log4j%E7%9A%84mave%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>http://ins1mn1a.github.io/2022/01/11/Bug%E4%B9%8B%E7%8E%8B/log4j%E7%9A%84mave%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-11T14:18:59.692Z</published>
    <updated>2022-01-11T14:38:18.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ClassNotFoundException：org-apache-log4j-logger"><a href="#ClassNotFoundException：org-apache-log4j-logger" class="headerlink" title="ClassNotFoundException：org.apache.log4j.logger"></a>ClassNotFoundException：org.apache.log4j.logger</h3><p>最初的问题是报错ClassNotFoundException：org.apache.log4j.logger</p><p>说明在maven依赖中有某个依赖用到了org.apache.log4j.logger，而maven依赖中又没有引入log4j</p><p>我的项目中是有一个dubbo的依赖，排除了servlet-api防止依赖冲突，没有排除log4j，并且没有引入log4j</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dubbo.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，解决方法有两种</p><ol><li>直接把dubbo依赖中的log4j排除</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.dubbo.springboot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>不排除dubbo中的log4j，增加一个log4j依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="IllegalArgumentException-LoggerFactory-is-not-a-Logback-LoggerContext-but-Logback-is-on-the-classpath"><a href="#IllegalArgumentException-LoggerFactory-is-not-a-Logback-LoggerContext-but-Logback-is-on-the-classpath" class="headerlink" title="IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath."></a>IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath.</h3><p>完整报错信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;ASUS&#x2F;.m2&#x2F;repository&#x2F;org&#x2F;slf4j&#x2F;slf4j-log4j12&#x2F;1.7.30&#x2F;slf4j-log4j12-1.7.30.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;ASUS&#x2F;.m2&#x2F;repository&#x2F;ch&#x2F;qos&#x2F;logback&#x2F;logback-classic&#x2F;1.2.3&#x2F;logback-classic-1.2.3.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing implementation</span><br></pre></td></tr></table></figure><p>这个问题是因为slf4j的依赖冲突，spring-boot-starter正常打印日志是采用的logback，在引入了slf4j-log4j12的情况下会有两个绑定，</p><p>根据提示信息就可以发现，有两种解决方案：</p><ol><li>移除slf4j-log4j12</li><li>把spring-boot-starter-logging移除</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ClassNotFoundException：org-apache-log4j-logger&quot;&gt;&lt;a href=&quot;#ClassNotFoundException：org-apache-log4j-logger&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>经典排序算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.212Z</published>
    <updated>2022-03-08T12:49:10.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="部分排序算法"><a href="#部分排序算法" class="headerlink" title="部分排序算法"></a>部分排序算法</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆是一种数据结构，一种叫做完全二叉树的数据结构。</p><p>大顶堆：每个节点的值都大于或者等于它的左右子节点的值。</p><p>小顶堆：每个节点的值都小于或者等于它的左右子节点的值。</p><h3 id="最大堆的构建过程"><a href="#最大堆的构建过程" class="headerlink" title="最大堆的构建过程"></a>最大堆的构建过程</h3><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110195006939.png" alt="image-20211110195006939"></p><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110194953869.png" alt="image-20211110194953869"></p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ol><li>将待排序的序列构建成一棵树，然后最大堆化，形成一个大顶堆。这样，大顶堆的根结点一定是当前序列中最大的一个元素。</li><li>将根结点取出，将堆的最后一个元素换到根结点处，然后重新构建成一个大顶堆，同样使得最大的元素位于根结点。</li><li>重复步骤2，每次都能获得一个最大值，这样就排成了一个有序的序列。</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">&#123;</span><br><span class="line">l&lt;-LEFT(i)</span><br><span class="line"> r&lt;-RIGHT(i)</span><br><span class="line"><span class="keyword">if</span> l &lt;= heap-size[A] and A[l]&gt;A[i]</span><br><span class="line">then largest&lt;-l</span><br><span class="line"><span class="keyword">else</span> largest&lt;-i</span><br><span class="line"><span class="keyword">if</span> r &lt;= heap-size[A] and A[r]&gt;A[largest]</span><br><span class="line">then largest&lt;-r</span><br><span class="line"><span class="keyword">if</span> largest ≠ i</span><br><span class="line">then exchange A[i]&lt;-&gt;A[largest]</span><br><span class="line">MAX-HEAPIFY(A,largest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">&#123;</span><br><span class="line">heap-size[A] &lt;- length [A]</span><br><span class="line"> <span class="keyword">for</span> i &lt;- length[A]/<span class="number">2</span> downto <span class="number">1</span></span><br><span class="line"><span class="keyword">do</span> MAX-HEAPIFY(A,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HEAPSORT(A)</span><br><span class="line">&#123;</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line"><span class="keyword">for</span> i length[A] downto <span class="number">2</span></span><br><span class="line"><span class="keyword">do</span> exchange A[<span class="number">1</span>] A[i]</span><br><span class="line">heap-size[A]  heap-size[A]-<span class="number">1</span></span><br><span class="line">MAX-HEAPIFY(A,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>计数排序不基于比较，它只适用于待排序序列数值范围相差不大的情况下，否则，会造成大量的数组空间的浪费。</p><p>待排序序列A[1:n]，将辅助空间数组C[1:k]初始化为0，其中k为A[1:n]的最大取值，也可以直接设为n。对数组A的每一个数遍历一次，将数作为数组C[1:k]的的下标值，将对应值加1，这样，数组C[1:k]就记录了数组A[1:n]中每个数的出现次数，即A[i]的出现次数为C[ A[i] ]。然后，只需要对数组C遍历，每次遍历到C[i]用一个while循环，做C[i]–，直到C[i]=0。</p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110204919521.png" alt="image-20211110204919521"></p><p>插入排序    稳定</p><p>快速排序    不稳定    在位</p><p>归并排序    稳定        不在位</p><p>堆排序        不稳定    在位</p><p>计数排序    稳定        不在位</p><p>基数排序    稳定        不在位</p>]]></content>
    
    
    <summary type="html">包括堆排序，计数排序等</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.180Z</published>
    <updated>2022-03-08T12:49:10.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="回溯法的基本思想"><a href="#回溯法的基本思想" class="headerlink" title="回溯法的基本思想"></a>回溯法的基本思想</h2><p>回溯法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。</p><p>回溯法从开始结点（根结点）出发，以深度优先方式搜索整个解空间。这个开始结点成为活结点，同时也成为当前的扩展结点。在当前扩展结点处，搜索向纵深方向移至一个新结点，同时，也成为当前的扩展结点。</p><h2 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h2><p>当所给的问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间树称为子集树。</p><p>例如：n个物品的0-1背包问题所相应的解空间树是一棵子集树，这类子集树通常有2^n个叶结点，其结点总数为2^(n+1)-1。遍历子集树的算法需要Ω(2^n)计算时间。但是，回溯法我们一般可以通过一种剪枝策略对这棵树进行剪枝，从而减少遍历的时间。</p><p>用回溯法搜索子集树的一般算法可以描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        output(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=i;</span><br><span class="line">        <span class="keyword">if</span>(constraint(t)&amp;&amp;bound(t))</span><br><span class="line">            backtrack(t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h2><p>当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。</p><p>排列树通常有n!个叶结点，因此遍历需要Ω(n!)计算时间。同样，我们可以通过一种剪枝策略对这棵树进行剪枝，从而减少遍历的时间。</p><p>用回溯法搜索排列树的一般算法可以描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        output(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x[t],x[i]);</span><br><span class="line">        <span class="keyword">if</span>(constraint(t)&amp;&amp;bound(t))</span><br><span class="line">            backtrack(t+<span class="number">1</span>);</span><br><span class="line">        swap(x[t],x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P和NP问题"><a href="#P和NP问题" class="headerlink" title="P和NP问题"></a>P和NP问题</h1><p>如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。</p><p>NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。</p>]]></content>
    
    
    <summary type="html">回溯法，包括子集树和排列树</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.178Z</published>
    <updated>2022-03-08T12:49:11.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>二分搜索算法是分治法的一个典型策略。</p><p>给定已经排好序的n个元素a[0 : n-1]，现在要从中找出一个特定的元素x。</p><p>首先容易想到的是用顺序搜索方法，逐个比较a[0 : n-1]中元素，直到找到x或者搜索遍整个数组后确定x不在其中。这个方法没有很好地利用n个元素已经排好序这个条件，因此在最坏的情况下，顺序搜索方法需要O(n)次比较。</p><p>二分搜索方法充分利用了元素间的次序关系，采用分治策略，可以在最坏情况下用O(log n)时间找到元素x。</p><p>它的基本思想是：将这n个元素分成个数大致相同的两半，取a[n/2]与x进行比较，如果a[n/2]==x，则程序结束；如果x&lt;a[n/2]，只需要在a[0 : n/2]中再利用这种方法进行搜索；如果x&gt;a[n/2]，只需要在a[n/2 : n]中再利用这种方法进行搜索；</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==a[middle]) <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;a[middle]) right=middle-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left=middle+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易看出，每执行一次算法的while循环，待搜索的数组就将减少一半。因此，在最坏的情况下，while循环被执行O(log n)次。循环体内运算需要O(1)时间，因此整个算法在最坏的情况下时间复杂性为O(log n)。</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>合并排序算法是用分治策略实现对n个元素进行排序的算法。</p><p>其基本思想是：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并为所要求排好序的集合。下图可以很好的理解合并算法的分治思想。</p><blockquote><p>注：图源网络(dreamcatcher-cx)</p></blockquote><p><img src="/../../img/markdown_img/%E7%AE%97%E6%B3%95.assets/image-20211106093310191.png" alt="image-20211106093310191"></p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(a,left,mid-<span class="number">1</span>);</span><br><span class="line">        mergeSort(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(a,b,left,mid,right);<span class="comment">//合并到数组b</span></span><br><span class="line">        copy(a,b,left,right);<span class="comment">//复制回数组a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">                b[t++] = a[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b[t++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//左边剩余元素</span></span><br><span class="line">            b[t++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//右边剩余元素</span></span><br><span class="line">            b[t++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的merge方法，就是将一组一组子集合递归的合并到数组b。合并排序算法对n个元素进行排序，在最坏情况下所需的计算时间为T(n)满足：<strong>T(n)=2T(n/2)+O(n)  n&gt;1</strong></p><p>求解递归方程可知T(n)=O(n log n)。但是排序算法的时间下界为Ω(n log n)，故合并排序算法是渐进最优算法。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>快速排序算法是基于分治算法的另一个排序算法。</p><p>对于输入的子数组a[p : r]，按以下步骤进行排序：</p><ol><li>分解：以a[p]为基准元素将a[p : r]划分为3段a[p : q-1]，a[q]和a[q+1 : r]，并且让a[p : q-1]中的任何元素都小于等于a[q]，a[q+1 : r]中的任何元素都大于等于a[q]。通俗的来说就是，小于基准的放左边，大于基准的放右边。</li><li>递归求解：通过递归的调用快排算法，分别对a[p : q-1]，a[q+1 : r]两段递归调用算法。</li><li>合并：对于a[p : q-1]，a[q+1 : r]的排序是就地进行的，所以在a[p : q-1]，a[q+1 : r]排好序后不需要执行任何计算，原数组就排好序。</li></ol><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=partition(p,r);</span><br><span class="line">        qSort(p,q-<span class="number">1</span>);</span><br><span class="line">        qSort(q+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=p;</span><br><span class="line">    <span class="keyword">int</span> right=r;</span><br><span class="line">    <span class="keyword">int</span> x=a[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=x)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            a[left]=a[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;=x)</span><br><span class="line">            left--; </span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            a[right]=a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    a[left]=x;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的关键在于partition中以确定的基准元素a[p]进行划分。partition方法每次都以x=a[p]为基准，然后左边left和右边right移位，右边开始，如果a[right]比基准元素x大或者等于，那么right继续移位；如果a[right]&lt;x，那么则将当前的a[right]赋值到a[left]，因为left此时并未开始移位，未动，因此是就地排序。赋值完成后left就开始移动，同理。</p><p>快速排序最差情况划分过程产生的两个区域分别包含n-1个元素和1个元素，并且每一次都出现这种不对称的划分，则有T(n)=T(n-1)+O(n)；解得最坏情况下T(n)=O(n^2)；</p><p>快排最好和平均情况下的时间复杂度都是O(n log n)；</p><p>快速排序算法是不稳定的算法。</p><h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>元素选择的问题一般是：给定线性序列有n个元素，一个整数k，找到这n个元素中第k小的元素。</p><p>线性时间选择算法实际上是模仿快速排序算法设计出来的。其基本思想也是对输入数组进行递归划分。随机选择一个下标 i 作为基准 a[i]，将小于 a[i] 的放左边，大于 a[i] 的放在右边。j 为划分后左边有的元素个数，这样只需要比较k和j的大小，如果k &lt;= j，那么说明第k小的元素一定在基准左边，接下来就只需要对左半部分递归找第 k 小的元素即可；同理，如果<strong>k&gt;j</strong>，说明，第k小的元素在基准右边，那么就对右半部分递归找第<strong>k-j</strong>小的元素即可。</p><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomizedSelect</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=randomizedPartition(p,r);</span><br><span class="line">    <span class="keyword">int</span> j=i-p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=j)</span><br><span class="line">        <span class="keyword">return</span> randomizedSelect(p,i,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> randomizedSelect(i+<span class="number">1</span>,r,k-j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=random(p,r);</span><br><span class="line">    MyMath.swap(a,i,p);</span><br><span class="line">    <span class="keyword">return</span> partiton(p,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，最坏情况下randomizedSelect需要Ω(n^2)计算时间，这里的partition函数同快速排序算法的partition函数是一致的。由于随机划分算法randomizedPartition使用了随机数产生器random，它能随机的产生p和r之间的一个随机整数，因此，randomizedPartition产生的划分基准是随机的，在这个条件下，可以证明，算法randomizedSelect可以在O(n)平均时间内找出n个输入元素中第k小的数。</p><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>问题描述：</p><p>给定由n个整数(可负)组成的序列a1 ,a2 ,…,an，求该序列形如∑ak的子段和的最大值。当所有整数均为负整数时定义其最大子段和为0。 依此定义，所求的最优值为<img src="/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B../../img/markdown_img/%E7%AE%97%E6%B3%95.assets/image-20211106133058064.png" alt="image-20211106133058064"></p><p>例如,当(a1 ,a2 ,…,a6 ）= (-2, 11, -4, 13, -5, -2)时，最大子段和为 20 ( 11, -4, 13)。</p><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p>如果将所给的序列a[1 :  n]分为长度相同的两段a[1 : n/2]、a[n/2+1 : n]，分别求出这两段的最大子段和，则a[1 : n]的最大子段和分为三种情况：</p><ol><li>a[1 : n]的最大子段和同a[1 : n/2]的最大子段和相同。</li><li>a[1 : n]的最大子段和同a[n/2 : n]的最大子段和相同。</li><li>a[1 : n]的最大子段和等于位于a[1 : n/2]的子段和和位于a[n/2+1 : n]的子段和的和</li></ol><p>1和2的情况可以直接递归求得，第3种情况，a[n/2]和a[n/2+1]在最优子序列之中，我们只需要计算出左边a[1 : n/2]从n/2开始的最大子段和s1，右边a[ n/2+1 : n]从n/2+1开始的最大子段和，然后将两者相加s=s1+s2；s即为第3种情况的最优值。</p><h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubSum</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)</span><br><span class="line">        <span class="keyword">return</span> a[left]&gt;<span class="number">0</span>?a[left]:sum;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftSum=MaxSubSum(a,left,mid);</span><br><span class="line">        <span class="keyword">int</span> rightSum=MaxSubSum(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempS=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=left;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tempS+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(tempS&gt;s1)</span><br><span class="line">                s1=tempS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s2=<span class="number">0</span>;</span><br><span class="line">        tempS=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempS+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(tempS&gt;s2)</span><br><span class="line">                s2=tempS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回三者中最大的</span></span><br><span class="line">        <span class="keyword">return</span> max(leftSum,rightSum,s1+s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(n)=2T(n/2)+O(n)，因此时间复杂度为O(n log n)</p>]]></content>
    
    
    <summary type="html">分治法，包括二分搜索算法，合并排序，快排，线性时间选择，最大字段和</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.176Z</published>
    <updated>2022-03-08T12:49:10.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适用于动态规划法求解的问题，经分解得到的子问题往往不是相互独立的。在用分治法求解的时候，有些子问题被重复计算了许多次。如果能够保存已解决的子问题的答案，而在需要的时候再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间的算法。</p><p>动态规划算法适用于解最优化问题，通常可以按以下步骤设计的动态规划算法：</p><ol><li>找出最优解的性质，并刻画其结果特征。</li><li>递归地定义最优值。</li><li>以自底向上的方式计算出最优值。</li><li>根据计算最优值时得到的信息，构造最优解。</li></ol><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>先来看一下最大子段和用分治法思想的分析：</p><p>如果将所给的序列a[1 :  n]分为长度相同的两段a[1 : n/2]、a[n/2+1 : n]，分别求出这两段的最大子段和，则a[1 : n]的最大子段和分为三种情况：</p><ol><li>a[1 : n]的最大子段和同a[1 : n/2]的最大子段和相同。</li><li>a[1 : n]的最大子段和同a[n/2 : n]的最大子段和相同。</li><li>a[1 : n]的最大子段和等于位于a[1 : n/2]的子段和和位于a[n/2+1 : n]的子段和的和</li></ol><p>1和2的情况可以直接递归求得，第3种情况，a[n/2]和a[n/2+1]在最优子序列之中，我们只需要计算出左边a[1 : n/2]从n/2开始的最大子段和s1，右边a[ n/2+1 : n]从n/2+1开始的最大子段和，然后将两者相加s=s1+s2；s即为第3种情况的最优值。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>从上述分治法思想注意到，我们可以记b[ j ]为1 ~ j 中的最大子段和，其中j∈[1，n]；<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106135813232.png" alt="image-20211106135813232"></p><p>这样，那么所求的1 ~ n 中的最大子段和就为 i~j 的和可以表示为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106135834099.png" alt="image-20211106135834099"></p><p>意思就是，j从1到n，依次找到最大子段和。</p><p>由b[ j ]的定义易知，当b[ j-1 ]&gt;0 时b[ j ]= b[ j-1 ] +a[j]，否则 b[ j ]=a[ j ]。 由此可得计算b[j]的动态规划递归式：</p><p><strong>b[j] = max {b[j-1] +a[j], a[j] } ，1≤j ≤ n</strong></p><p>当前的最优解，就等于前一个最优解加上当前值和当前值中的较大者。</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106141924973.png" alt="image-20211106141924973"></p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">            b+=a[i];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            b=a[i];</span><br><span class="line">        <span class="keyword">if</span>(b&gt;sum)</span><br><span class="line">            sum=b;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><p>给定n个矩阵{A1，A2……An} ， 其中Ai与Ai+1可乘，i=1,2,3…n-1 。 如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。</p><p>考察这n个矩阵的连乘积     A1A2…An</p><p>由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。 </p><p>若一个矩阵连乘积的计算次序完全确定，也就是说该连乘积已完全加括号，则可以依此次序反复调用2个矩阵相乘的标准算法计算出矩阵连乘积。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>将矩阵连乘积 AiAi+1…Aj简记为A[i:j] ，这里i ≤ j  考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵 Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106143929876.png" alt="image-20211106143929876"></p><p>计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上 A[i:k]和A[k+1:j]相乘的计算量。</p><p><strong>最优解结构</strong>：</p><ul><li><p>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。 </p></li><li><p>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。</p></li></ul><p><strong>建立递归关系</strong>：</p><ol><li><p>设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]</p></li><li><p>当i=j时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n</p></li><li><p>当i&lt;j时，m[i , j]=m[i , k] + m[k+1 , j] + pi-1 * pk * pj ，这里Ai的维数为pi-1 * pi</p></li><li><p>递归的定义m[i , j]为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106144514820.png" alt="image-20211106144514820"></p><p>k的位置只有j-i种可能。</p></li></ol><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150225461.png" alt="image-20211106150225461"></p><p>计算的时候是斜着对角进行计算的，这样再计算下一轮的时候就可以用到前面已经求得的值。</p><p>计算过程：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150353882.png" alt="image-20211106150353882"></p><p>比如m[2] [5]就可以表示为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150243929.png" alt="image-20211106150243929"></p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matrixChain</span><span class="params">(<span class="keyword">int</span> []p,<span class="keyword">int</span> n,<span class="keyword">int</span> [][]m,<span class="keyword">int</span> [][]s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化对角线全为0 因为当i=j时，A[i:j]=Ai，因此，m[i,i]=0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) m[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">2</span>;r&lt;=n;r++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-r+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//这是把 m[i][j]分成i-&gt;i i+1-&gt;j的情形，m[i][i]=0</span></span><br><span class="line">            <span class="comment">//m[i , j]=m[i , k] + m[k+1 , j] + pi-1 * pk * pj</span></span><br><span class="line">            m[i][j]= m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="comment">//这里就是除了i-&gt;i i+1-&gt;j的情形以外的情况，要找到最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析： 算法matrixChain的主要计算量取决于算法中对r，i 和 k 的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n^3 )。因此算法的计算时间上界为O(n^3 )。算法所占用的空间显然为O(n^2 )。</p><h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><p>若给定序列X={x1 ,x2 ,…,xm}，则另一序列 Z={z1 ,z2 ,…,zk }，是X的子序列是指存在一个严格递增 下标序列{i1 ,i2 ,…,ik }使得对于所有j=1,2,…,k有：zj=xi。 例如，序列Z={B，C，D，B}是序列X={A，B，C，B， D，A，B}的子序列，相应的递增下标序列为{2，3，5， 7}。</p><p>给定2个序列X和Y，当另一序列Z既是X的子序列又是 Y的子序列时，称Z是序列X和Y的公共子序列。</p><p>给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，找 出X和Y的最长公共子序列。</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>设序列X={x1 ,x2 ,…,xm}和Y={y1 ,y2 ,…,yn }的最长公共子序列为 Z={z1 ,z2 ,…,zk } ，则</p><ul><li>若xm==yn，则zk=xm=yn。X与Y的最长公共子序列为{x1 ,x2 ,…,x(m-1)}，{y1 ,y2 ,…,y(n-1) }的最长公共子序列+xm</li><li>若xm!=yn且zk!=xm，则X与Y的最长公共子序列为{x1 ,x2 ,…,x(m-1)}，{y1 ,y2 ,…,yn }的最长公共子序列</li><li>若xm!=yn且zk!=yn，则X与Y的最长公共子序列为{x1 ,x2 ,…,xm}，{y1 ,y2 ,…,y(n-1) }的最长公共子序列</li></ul><p>由此可见，2个序列的最长公共子序列包含了这2个序列的前缀 的最长公共子序列。因此，最长公共子序列问题具有最优子结 构性质。</p><p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用c[i] [j]记录序列和的最长公共子序列的长度。其中，Xi={x1 ,x2 ,…,xi }；Yj={y1 ,y2 ,…,yj }。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时C[i] [j]=0。其它情况下，由最优子结构性质可建立递归关系如下：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106152638761.png" alt="image-20211106152638761"></p><p>Algorithms和alchemist：</p><p>i=0和j=0，则c[i] [j]为0；然后，首先X1  A 和Y1  A相同，那么就取左上方c[i-1] [j-1]+1 ；接下来，X1 A和Y2 L不同，则c[i] [j] 就等于左边c[i] [j-1] 和 上边 c[i-1] [j] 中的较大者。</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106155347486.png" alt="image-20211106155347486"></p><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LCSLength</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">char</span> []x,<span class="keyword">char</span> []y,<span class="keyword">int</span> [][]c,<span class="keyword">int</span> [][]b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//i=0或者j=0，空序列为最长公共子序列，因此c[i][j]=0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (x[i]==y[j]) </span><br><span class="line">            &#123; </span><br><span class="line">c[i][j]=c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>; </span><br><span class="line">                <span class="comment">//记录</span></span><br><span class="line">                b[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c[i-<span class="number">1</span>][j]&gt;=c[i][j-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i-<span class="number">1</span>][j];</span><br><span class="line">            b[i][j]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i][j-<span class="number">1</span>]; </span><br><span class="line">                b[i][j]=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造最长公共子序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LCS</span><span class="params">(<span class="keyword">int</span> i，<span class="keyword">int</span> j，<span class="keyword">char</span> []x，<span class="keyword">int</span> []b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i ==<span class="number">0</span> || j==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (b[i][j]== <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        LCS(i-<span class="number">1</span>，j-<span class="number">1</span>，x，b); </span><br><span class="line">        System.out.print(x[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b[i][j]== <span class="number">2</span>) </span><br><span class="line">        LCS(i-<span class="number">1</span>，j，x，b);</span><br><span class="line"><span class="keyword">else</span> LCS(i，j-<span class="number">1</span>，x，b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法LCSLength耗时O(m*n)，算法LCS的计算时间为O(m+n)。</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>设所给0-1背包问题的子问题<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106191015562.png" alt="image-20211106191015562"></p><p>的最优值为m[i] [j]，即m(i,j)是背包容量为j，可选择物品为i，i+1，…，n时0-1背包问题的最优值。</p><p>由0-1背包问题的最优子结构性质，可以建立如下计算m(i，j)的递归式：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106191335277.png" alt="image-20211106191335277"></p><p>递归式的意思就是：如果当前背包容量小于当前物品的重量，那么就是不能装下，这样就等于下一个到m(i+1 , j)。如果当前背包容量能大于当前物品的重量，那么就是能装下，这样就只需要比较装下该物品（如果选择装下该物品，那么前面物品的总价值就会被压缩，因为该物品占了重量所以要去找m(i+1 , j-wi)然后再加上刚装下物品的价值）或者不装该物品，哪一个得到的价值更大。</p><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> []v,<span class="keyword">int</span> []w,<span class="keyword">int</span> c,<span class="keyword">int</span> [][]m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=v.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">        m[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        m[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&gt;=c;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">                m[i][j]=max(m[i-<span class="number">1</span>][j],m[i-<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[i][j]=m[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用m[i] [j]=max(m[i-1] [j],m[i-1] [j-w[i]]+v[i]);同上方i+1意思是一样的，只不过初始化不同。</p><p>时间复杂度O(nc)；</p>]]></content>
    
    
    <summary type="html">算法之动态规划，包括最大字段和，矩阵连乘，最长公共子序列问题，01背包问题</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
