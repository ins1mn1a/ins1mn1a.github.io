<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ins1mn1a</title>
  
  <subtitle>反方向的钟</subtitle>
  <link href="http://ins1mn1a.github.io/atom.xml" rel="self"/>
  
  <link href="http://ins1mn1a.github.io/"/>
  <updated>2022-03-08T12:45:23.057Z</updated>
  <id>http://ins1mn1a.github.io/</id>
  
  <author>
    <name>ins1mnia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 内存模型</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-02-09T15:01:55.449Z</published>
    <updated>2022-03-08T12:45:23.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p><strong>JMM</strong> 即 <strong>Java Memory Model</strong> ，它从Java层面定义了<strong>主存</strong>、<strong>工作内存</strong>抽象概念，底层对应着CPU 寄存器、缓存、硬件内存、CPU 指令优化等。JMM 体现在以下几个方面</p><ul><li><strong>原子性</strong> - 保证指令不会受 线程上下文切换的影响</li><li><strong>可见性</strong> - 保证指令不会受 cpu 缓存的影响 (JIT对热点代码的缓存优化)</li><li><strong>有序性</strong> - 保证指令不会受 cpu 指令并行优化的影响</li></ul><p><strong>Java内存模型</strong>描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。<br>在内存模型中，所有的变量都存储在主内存中。<strong>每个线程都有自己独立的工作内存</strong>，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)。</p><p><strong>JMM线程操作内存的两条基本的规定:</strong></p><ol><li>关于线程与主内存：线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写</li><li>关于线程间工作内存：不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要经过主内存来完成。</li></ol><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><code>在主线程中修改的静态变量的值，对应t线程来说是不可见的</code></p><p>这是因为t线程的run方法是个<code>while (run)</code>循环，JIT即使编译器会对t线程中的run变量进行缓存到本地工作内存，不去主存中取run的值，这样可以加快执行速度。也就是JVM达到一定阈值时，<code>while (run)</code>循环变成了<strong>热点代码</strong>， 所以一直访问的都是缓存到本地工作内存(局部)中的run。当主线程修改<strong>主存中的run变量</strong>的时候，t1线程一直访问的是自己缓存的, 所以不认为run已经改为false了。 所以一直运行并不会结束循环，我们为主存(成员变量)进行<strong>volatile</strong>修饰, 增加变量的可见性, 当主线程修改run为false, t1线程对run的值可见。这样就可以退出循环。</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120131625943.png" alt="image-20220120131625943"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (run)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;停止 t线程&quot;</span>);</span><br><span class="line">    run=<span class="keyword">false</span>;<span class="comment">// 没有volatile，事实上并不会退出t线程</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用<strong>volatile解决</strong>以外还可以使用<strong>synchronized解决</strong>问题</p><ul><li><strong>在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存，然后主内存中拷贝最新变量的副本到工作内存 ，执行完代码后，将更改后的共享变量的值刷新到主内存中，最后释放互斥锁。</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1s内,一直都在无限循环获取锁. 1s后主线程抢到锁,修改为false, 此时t1线程抢到锁对象,while循环也退出</span></span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!run)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当主线程获取到锁的时候, 就修改为false了</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            run = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul><li>前面例子体现的实际就是<code>可见性</code>，<strong>它保证的是在多个线程之间一个线程对 volatile 变量的修改对另一个线程可见</strong>， <strong>而不能保证原子性</strong>。volatile用在一个写线程，多个读线程的情况, 比较合适。 上例从字节码理解是这样的：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">putstatic run <span class="comment">// 线程 main 修改 run 为 false， 仅此一次</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run false </span></span><br></pre></td></tr></table></figure><ul><li>比较一下之前线程安全时的例子：两个线程一个 <strong>i++</strong> 一个 <strong>i–</strong> ，只能<strong>保证</strong>看到最新值(<strong>可见性</strong>)，<strong>不能</strong>解决<strong>指令交错(原子性)</strong></li></ul><p><strong>注意</strong> ：</p><ul><li><strong>synchronized</strong> 语句块既可以<strong>保证</strong>代码块的<strong>原子性</strong>，也同时<strong>保证</strong>代码块内变量的<strong>可见性</strong>。但缺点是 synchronized 是属于重量级操作，性能相对更低。</li><li> 如果在前面示例的死循环中加入 <strong>System.out.println()</strong> 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了</li><li>因为<strong>System.out.println() 方法里面有synchronized修饰</strong>。</li></ul><h2 id="volatile实现模式之两阶段终止"><a href="#volatile实现模式之两阶段终止" class="headerlink" title="volatile实现模式之两阶段终止"></a>volatile实现模式之两阶段终止</h2><ul><li>当我们在执行线程一时，想要终止线程二，这是就需要使用<code>interrupt方法</code>来优雅的停止线程二。这是之前的做法</li></ul><ul><li>使用volatile关键字来实现两阶段终止模式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是两个线程操作共享变量stop</span></span><br><span class="line">        Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        monitor.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;Monitor&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private boolean stop = false; // 不会停止程序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>; <span class="comment">// 会停止程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动监控器线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread monitor = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//开始不停的监控</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于停止监控器线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式之-Balking"><a href="#模式之-Balking" class="headerlink" title="模式之 Balking"></a>模式之 Balking</h2><ul><li>定义：<code>Balking （犹豫）模式</code>用在 <strong><code>一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</code>。有点类似于单例。</strong></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>JIT即时编译器的优化，可能会导致<strong>指令重排</strong>。为什么要优化? 因为CPU 支持多级指令流水线，例如支持同时执行 <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 的处理器，效率更快 </p><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120155001076.png" alt="image-20220120155001076"></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="指令重排序导致错误结果"><a href="#指令重排序导致错误结果" class="headerlink" title="指令重排序导致错误结果"></a>指令重排序导致错误结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span></span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line"> r.r1 = num + num;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> num = <span class="number">2</span>;</span><br><span class="line"> ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程1执行actor1方法, 线程2执行actor2方法</p><p>但是最终的结果还有可能让r.r1=0</p><ul><li><p>这样情况是在actor2方法进行了<strong>指令重排序</strong>，因为<code> num = 2;</code>和<code>ready = true;</code>互相之间看起来并没有影响，因此先执行<code>ready = true;</code>，这时候num=2还没执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重排序后</span></span><br><span class="line">ready = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//此时发生线程切换</span></span><br><span class="line">num = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>此时，发送线程上下文切换，<code>ready = true;</code>，线程1判断为true，就<code>r.r1=num+num</code>，最后r.r1=0;</p></li></ul><p>这种现象叫做指令重排，是JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现，可以使用jcstress工具进行测试。上面仅是从代码层面体现出了有序性问题，下面的 <strong>double-checked locking</strong> (双重检查锁)还会从java字节码的层面了解有序性的问题。</p><p><strong>指令重排序</strong>操作<strong>不会对</strong>存在<strong>数据依赖关系</strong>的操作进行<strong>重排序</strong>。比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p>重排序是为了优化性能，但是不管怎么重排序，<strong>单线程</strong>下程序的执行结果<strong>不会被改变</strong>。</p><p><strong>指令重排序 在 单线程模式下是一定会保证最终结果的正确性，</strong> 但是在多线程环境下，问题就出来了。</p><p><strong>解决方法</strong>：<code>volatile 修饰的变量，可以禁用指令重排</code></p><h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p><strong>volatile</strong> 的<strong>底层实现</strong>原理是<strong>内存屏障</strong>，<strong>Memory Barrier</strong>（Memory Fence）</p><p>对 volatile 变量的<strong>写指令</strong>后会加入<strong>写屏障</strong>。(保证写屏障之前的写操作, <strong>都能同步到主存中</strong>)</p><p>对 volatile 变量的<strong>读指令</strong>前会加入<strong>读屏障</strong>。(保证读屏障之后的读操作, <strong>都能读到主存的数据</strong>)</p><h3 id="volatile保证可见性原理"><a href="#volatile保证可见性原理" class="headerlink" title="volatile保证可见性原理"></a>volatile保证可见性原理</h3><ul><li><p><strong>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">     num = <span class="number">2</span>;</span><br><span class="line">     ready = <span class="keyword">true</span>; <span class="comment">// ready是被volatile修饰的 ，赋值带写屏障</span></span><br><span class="line">     <span class="comment">// 写屏障(在ready=true写指令之后加的, </span></span><br><span class="line">     <span class="comment">//在该屏障之前对共享变量的改动, 都同步到主存中，包括num)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 读屏障</span></span><br><span class="line"> <span class="comment">//  ready是被volatile修饰的 ，读取值带读屏障</span></span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;<span class="comment">// ready, 读取的就是主存中的新值</span></span><br><span class="line"> r.r1 = num + num; <span class="comment">// num, 读取的也是主存中的新值</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="volatile保证有序性原理"><a href="#volatile保证有序性原理" class="headerlink" title="volatile保证有序性原理"></a>volatile保证有序性原理</h3><ul><li><strong>写屏障</strong>会确保<strong>指令重排序</strong>时，<strong>不会将写屏障之前的代码排在写屏障之后</strong></li><li><strong>读屏障</strong>会确保<strong>指令重排序</strong>时，<strong>不会将读屏障之后的代码排在读屏障之前</strong></li></ul><h3 id="volatile不能解决指令交错-不能解决原子性-："><a href="#volatile不能解决指令交错-不能解决原子性-：" class="headerlink" title="volatile不能解决指令交错 (不能解决原子性)："></a>volatile不能解决<strong>指令交错</strong> (不能解决<strong>原子性</strong>)：</h3><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其它线程的读, 跑到它前面去</li><li><strong>有序性的保证也只是保证了本线程内相关代码不被重排序</strong>，并不能保证指令的交错</li><li>比如线程2先读到i，然后被切换成了线程1执行完后，线程2还是把i当做没更新的i值执行。可以使用<code>synchronized</code>来解决原子性</li></ul><h2 id="double-checked-locking-双重检查锁"><a href="#double-checked-locking-双重检查锁" class="headerlink" title="double-checked locking (双重检查锁)"></a>double-checked locking (双重检查锁)</h2><p>首先<strong>synchronized</strong>可以<strong>保证</strong>它的临界区的资源是<strong>原子性、可见性、有序性</strong>的, <strong>有序性的前提</strong>是, 在synchronized代码块中的共享变量, 不会在代码块外使用到, 否则<strong>有序性</strong>不能被保证, 只能使用<strong>volatile</strong>来保证有序性。<br>下面代码的第二个双重检查单例，就出现了这个问题(在synchronized外使用到了INSTANCE)，此时synchronized就不能防止指令重排，确保不了指令的有序性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最开始的单例模式是这样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      多线程同时调用getInstance(), 如果不加synchronized锁, 此时两个线程同时</span></span><br><span class="line"><span class="comment">      判断INSTANCE为空, 此时都会new Singleton(), 此时就破坏单例了.所以要加锁,</span></span><br><span class="line"><span class="comment">      防止多线程操作共享资源,造成的安全问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//INSTANCE没有加volatile</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是上面的<code>if(INSTANCE == null)</code>判断代码没有在同步代码块synchronized中，不能享有synchronized保证的原子性、可见性、以及有序性</strong>。所以可能会导致指令重排。</p><p>上述方法的字节码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span> <span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="comment">// ldc是获得类对象</span></span><br><span class="line">6: ldc #3 // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="comment">// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="comment">// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span></span><br><span class="line"><span class="comment">// 将类对象的引用地址存储了一份，是为了将来解锁用</span></span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line">11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="comment">// 新建一个实例</span></span><br><span class="line">17: new #3 // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="comment">// 复制了一个实例的引用</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="comment">// 通过这个复制的引用调用它的构造方法</span></span><br><span class="line">21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"><span class="comment">// 最开始的这个引用用来进行赋值操作</span></span><br><span class="line">24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line">37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><p>上述字节码最关键的地方在于17-&gt;24</p><ul><li><p><strong>正常情况</strong>先新建一个实例，然后复制实例的引用，再通过这个复制的引用调用它的构造方法，最后进行赋值操作赋值给instance。</p></li><li><p>但是JVM可能会优化这里的代码：<code>先执行 24(赋值)，再执行 21(构造方法)</code>。也就是先给instance赋值，这样instance并不为null，这个时候t2线程进入，第一个判断，<code> if(INSTANCE == null)</code>，ifnonnull，发现不为null，跳转到37行，最终获取到一个假的不为null的对象。</p></li><li><p>如果两个线程 t1，t2 按如下时间序列执行：</p></li></ul><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120171355261.png" alt="image-20220120171355261"></p><p>所以最终的问题</p><ul><li><code>INSTANCE = new Singleton();</code>操作不是一个<strong>原子操作</strong>, 它总共被分为4个指令，<code>21, 24两个指令</code>此时可能就会<strong>发生指令重排</strong>的问题。</li><li>此时又因为 <code>0: getstatic</code> 这行代码在 monitor 控制之外，也就是说第一次判断null的时候没有在synchronized控制下，其他线程可以来获取，判断instance的值</li><li>synchronized是可以保证变量的原子性、有序性和可见性，不会出现因为指令重排而产生错误，<strong>前提是</strong>：synchronized必须把这个变量完全的管理住。上面的问题就是因为第一次判空是没有被synchronized所管理到的。</li></ul><p>因此，解决方案就是加个volatile，<code>private static volatile Singleton INSTANCE = null</code>。加了<strong>volatile之后就会在putstatic加个写屏障，这样写屏障之前的指令就不会被重排序。</strong></p><p>读写 volatile 变量操作（即getstatic操作和putstatic操作）时会加入<strong>内存屏障</strong>，保证下面两点：</p><ul><li><strong>可见性</strong><br>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中<br>读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li><li><strong>有序性</strong><br>写屏障 会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后<br>读屏障 会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性<br>加上volatile之后, 保证了指令的有序性, 不会发生指令重排, 21就不会跑到24之后执行了</li></ul><p><strong>synchronized 既能保证原子性、可见性、有序性，其中有序性是在该共享变量完全被synchronized 所接管（包括共享变量的读写操作），上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。</strong></p><p><strong>对共享变量加volatile关键字可以保证可见性和有序性，但是不能保证<code>原子性</code>（即不能防止<code>指令交错</code>）。</strong></p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120172649628.png" alt="image-20220120172649628"></p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120172629908.png" alt="image-20220120172629908"></p><h2 id="Happens-before规则"><a href="#Happens-before规则" class="headerlink" title="Happens-before规则"></a>Happens-before规则</h2><p>happens-before规定了多共享变量的写操作对于其他线程的读操作的可见性。抛开以下规则，JVM并不能保证一个线程对共享变量的写操作对于其它线程对该共享变量的读可见。</p><h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>对于synchronized锁，会保证每次去主存中读取数据，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="volatile-变量"><a href="#volatile-变量" class="headerlink" title="volatile 变量"></a>volatile 变量</h3><ul><li><p>线程对volatile 变量的写，对接下来其它线程对该变量的读可见</p><p><strong>volatile修饰的变量, 通过<code>写屏障</code>, 共享到主存中, 其他线程通过<code>读屏障</code>, 读取主存的数据</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="start-前的写操作"><a href="#start-前的写操作" class="headerlink" title="start() 前的写操作"></a>start() 前的写操作</h3><ul><li><p>线程 start() 前对变量的写，对该线程开始后对该变量的读可见</p><p>线程还没启动时, 修改变量的值, 在启动线程后, 获取的变量值, 肯定是修改过的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">   System.out.println(x);</span><br><span class="line">  &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="t1-isAlive-或-t1-join-等待结束"><a href="#t1-isAlive-或-t1-join-等待结束" class="headerlink" title="t1.isAlive() 或 t1.join()等待结束"></a>t1.isAlive() 或 t1.join()等待结束</h3><ul><li><p>线程结束前 对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><p>主线程获取的x值, 是线程执行完对x的写操作之后的值。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure><h3 id="interrupt打断"><a href="#interrupt打断" class="headerlink" title="interrupt打断"></a>interrupt打断</h3><ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后, 对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(x); <span class="comment">// 10, 打断了, 读取的也是打断前修改的值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);<span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><ul><li>对变量默认值（0，false，null）的写，对其它线程对该变量的 读可见 (最基本)</li><li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</li><li>因为x加了volatile, 所以在volatile static int x 代码的上面添加了读屏障, 保证读到的x和y的变化是可见的(包括y, 只要是读屏障下面都OK); 通过传递性, t2线程对x,y的写操作, 都是可见的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">y = <span class="number">10</span>;</span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span> ).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">//x=20对t2可见，同时y=10 也对t2可见</span></span><br><span class="line">    system.out. print1n(x);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span> ).start();</span><br></pre></td></tr></table></figure><p><strong><code>volatile</code>主要用在<code>一个线程改,多个线程读时的来保证可见性</code>，和<code>double-checked locking模式中保证synchronized代码块外的共享变量的</code>指令重排序<code>问题</code></strong></p><h2 id="五种单例模式"><a href="#五种单例模式" class="headerlink" title="五种单例模式"></a><strong>五种单例模式</strong></h2><p>单例模式有<strong>饿汉式、懒汉式、枚举类(饿汉)、静态内部类</strong></p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：为什么<strong>类要加 final</strong></p><ul><li>防止子类继承后重写方法破坏单例</li></ul><p>问题2：如果实现了序列化接口，还要做什么来<strong>防止反序列化破坏单例</strong></p><ul><li>反序列化时候生成的对象可能会破坏单例，直接在类里加一个**public Object readResolve() {}**方法，可以让反序列化的时候调用这个方法返回单例的实例</li></ul><p>问题3：为什么<strong>构造方法设置为私有</strong>?</p><ul><li>避免其他类使用new生成新的实例，并不能防止反射创建新的实例，因为反射可以打破封装</li></ul><p>问题4：这样初始化是否能保证单例对象创建时的线程安全？</p><ul><li>可以保证，因为实例在<strong>类加载</strong>的时候就<strong>初始化</strong>，JVM会保证其线程安全性</li></ul><p>问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</p><ul><li>1.提供更好的<strong>封装性</strong>；2.提供<strong>泛型</strong>的支持</li></ul></blockquote><h3 id="饿汉式之枚举"><a href="#饿汉式之枚举" class="headerlink" title="饿汉式之枚举"></a>饿汉式之枚举</h3><p>饿汉式：因为枚举的变量，底层是通过public static final来修饰的，类加载就创建了，所以是饿汉式</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220122210404242.png" alt="image-20220122210404242"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：枚举单例是如何限制实例个数的</p><ul><li><strong>创建枚举类的时候就已经定义好了</strong>，每个枚举常量其实就是枚举类的一个静态成员变量</li></ul><p>问题2：枚举单例在创建时是否有并发问题</p><ul><li>没有并发问题，是线程安全的，因为枚举单例底层是一个静态成员变量，它是通过类加载器的加载而创建的，确保了线程安全</li></ul><p>问题3：枚举单例能否被反射破坏单例</p><ul><li><p><strong>反射无法破坏枚举单例</strong>, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">this</span>.clazz.getModifiers() &amp; <span class="number">16384</span>) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(“Cannot reflectively create <span class="class"><span class="keyword">enum</span> <span class="title">objects</span>”)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>问题4：枚举单例能否被反序列化破坏单例</p><ul><li><strong>反序列化不能破坏</strong>，枚举类默认也实现了序列号接口。但枚举类考虑到了这个问题，不会破坏单例。</li></ul><p>问题 5：枚举单例属于懒汉式还是饿汉式</p><ul><li>属于<strong>饿汉式</strong>, 静态成员变量, 通过类加载器的时候就加载了。</li></ul><p>问题 6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</p><ul><li>加构造方法，枚举也可以写构造方法，普通方法等</li></ul></blockquote><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点：</span></span><br><span class="line">    <span class="comment">// synchronized加载静态方法上，可以保证线程安全。缺点就是锁粒度大，效率低。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h3><p>DCL：double-check-locking</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：解释为什么要加 volatile</p><ul><li>因为在synchronized外部使用到了共享变量INSTANCE，可能存在一个线程先初始化了instance，但是别的线程没有从主存中获取instance，而是从工作内存中获取instance，仍然为空，volatile保证了可见性，保证读取变量的时候都从主存中去获取，这样就不会存在已经创建了实例，但读取到实例仍然为空的情况</li></ul><p>问题2：对比上面的懒汉式，说出这样做的意义</p><ul><li>增加了双重判断，如果存在了单例对象，别的线程再进来就无需加锁判断，<strong>提升效率</strong></li></ul><p>问题3：为什么还要加为空判断, 之前不是判断过了吗</p><ul><li>主要原因还是因为并发的时候产生线程不安全的问题</li><li>考虑这么一种情况：<ul><li>线程1第一次进入了synchronized代码，获取到了锁，判断到instance为null，然后就去创建实例</li><li>线程2此时已经进行了第一次判断为空，然后等待线程1释放锁。</li><li>如果不加判断，线程1创建完后释放锁，线程2进入同步代码块，此时没有了第二重为空判断，就会直接创建实例，此时就重复创建了实例，破坏了单例</li></ul></li></ul></blockquote><h3 id="懒汉式之静态内部类"><a href="#懒汉式之静态内部类" class="headerlink" title="懒汉式之静态内部类"></a>懒汉式之静态内部类</h3><p>通过静态内部类来创建单例，对外不可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：属于懒汉式还是饿汉式</p><ul><li>懒汉式，因为这是个静态内部类，类加载本身就是懒惰的，在没有用到这个类的时候，是不会进行类加载的，因此没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul><p>问题2：在创建时是否有并发问题</p><ul><li>没有并发问题，仍然是单例的。因为类加载是懒惰的，没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">原子性、可见性、volatile原理，读写屏障、单例设计，双重检查锁DCL</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/AQS%20ReentrantLock%E5%8E%9F%E7%90%86/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/AQS%20ReentrantLock%E5%8E%9F%E7%90%86/</id>
    <published>2022-02-09T14:53:07.569Z</published>
    <updated>2022-03-08T12:45:23.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h3><p>AQS全称<strong>AbstractQueueSynchronizer</strong>，抽象的队列的同步器，是JDK1.5提供的一套实现阻塞锁和一系列依赖FIFO等待队列的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类的实现都依赖于它，比如常用的ReentrantLock/ Semaphore/ CountDownLatch等。具体用法是通过<strong>继承AQS</strong>，<strong>实现</strong>其模板<strong>方法</strong>，来达到同步状态的管理。</p><h3 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h3><p>AQS在功能上可以分为</p><ul><li><strong>独占锁</strong>：每次只能有一个线程持有锁，比如ReentrantLock</li><li><strong>共享锁</strong>：允许多个线程同时获得锁，并发访问共享资源，比如ReentrantReadWriteLock中的读锁、CountDownLatch</li></ul><p>特点：</p><ul><li><p>用state属性来表示资源的状态（分独占模式和共享模型），子类需要定义如何维护这个状态，控制如何获取锁和释放锁，比如state为0就是没有线程持有锁，把state改为1就是有线程持有锁</p><ul><li>getState：获取state状态</li><li>setState：设置state状态</li><li>compareAndSetState：cas机制设置state状态，这里的cas只是原子性的来修改state的值，AQS仍然是一个阻塞式的，尝试设置失败后会进入阻塞的队列里去</li><li>独占模式是只有一个线程能访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li><p>提供了基于FIFO的等待队列，类似Monitor的EntryList</p></li><li><p>条件变量来实现等待，唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</p></li></ul><p>子类主要需要实现下面一些方法</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared：获取共享锁</li><li>tryReleaseShared：释放共享锁</li><li>isHeldExclusively：是否用于独占锁</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取锁的姿势</span></span><br><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁的姿势</span></span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承AQS自定义不可重入锁"><a href="#继承AQS自定义不可重入锁" class="headerlink" title="继承AQS自定义不可重入锁"></a>继承AQS自定义不可重入锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;TestAQS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            <span class="comment">// 不可重入锁</span></span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;locking...&quot;);</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占锁  同步器类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 确保原子性</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里不需要保证原子性, 因为是持锁者进行释放</span></span><br><span class="line">            <span class="comment">// 在setState(0)上面设置Owner为null, 防止指令重排序带来的问题</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// state是volatile修饰的, 在setState(0)前面的属性修改, 对于其他线程也是可见的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><p>ReentrantLock实现了Lock接口，同步内部还有一个自定义的抽象同步器Sync，Sync又包含了公平和非公平同步器，FairSync和NonfairSync都是ReentrantLock的static final 内部类，Sync是抽象的static 内部类继承自AQS</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129101733186.png" alt="image-20220129101733186"></p><h3 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h3><p>从构造方法来看，<strong>默认是非公平锁NonfairSync</strong>实现，NonfairSync继承了AQS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其lock方法调用的是同步器的lock方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看非公平同步器的lock方法，加锁流程就是现在cas机制原子性设置state值从0变为1，如果成功，就把独占锁Owner设置为当前线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有竞争时，Thread0进来加锁，把state变量为1，同时把独占锁Owner线程设置为Thread0</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129102122337.png" alt="image-20220129102122337"></p><p>第一个竞争出现时，假设已经有Thread0加锁成功，那么当前线程Thread1就<strong>加锁失败</strong>。</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129103843420.png" alt="image-20220129103843420"></p><p>加锁失败则进入AQS的acquire方法，会再一次尝试去获取锁，调用tryAcquire()，如果仍然获取失败，就尝试加入到等待队列里去，加入返回true就调用selfInterrupt把该线程打断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的addWaiter就是构造一个Node 双向链表队列</p><ol><li>下图中黄色三角表示该 Node 的<strong>waitStatus</strong>状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li><strong>第一次创建其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</strong></li></ol><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129104152327.png" alt="image-20220129104152327"></p><p>然后进入acquireQueued方法，这个方法内部是一个死for循环，获取当前线程关联节点的前驱节点p，<strong>如果p等于head，也就是说如果自己是紧邻着head（注意看图上的箭头，head指向的是node）</strong>，讲道理下一个就可以获得锁，那么Thread1就再一次的tryAcquire尝试去加锁；如果这次加锁成功了就把自己设置为Head节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果这次加锁失败或者p!=head，那么就应该在加锁失败后park住<strong>shouldParkAfterFailedAcquire</strong>，这个方法会将前驱节点即<strong>head</strong>的<strong>waitStatus</strong>修改为-1，**-1表示前面线程有责任唤醒后面的线程，也就是Thread1获取失败了，进入阻塞，把waitStatus设为-1 即将进入阻塞那么Thread0，就要有责任将Thread1唤醒<strong>，然后</strong>返回false**。</p><p>返回false后结束判断又进入for循环去尝试获取一次，假设<strong>又失败</strong>，那么又进入shouldParkAfterFailedAcquire方法，<strong>因为之前已经将waitStatus的值设置为-1了，这次肯定设置失败了，所以就返回了true</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">    * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>返回true后就进入<strong>parkAndCheckInterrupt</strong>方法，把当前线程park阻塞住</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129110313691.png" alt="image-20220129110313691"></p><p>假设有多个线程经历上述过程加锁失败，变成下图：</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129110452722.png" alt="image-20220129110452722"></p><h3 id="释放锁的流程"><a href="#释放锁的流程" class="headerlink" title="释放锁的流程"></a>释放锁的流程</h3><p>Thread0释放锁，进入tryRelease流程，将OwnerThread设置为null，state设置为0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后判断head是否为空，并且waitStatus==-1，进入unparkSuccessor方法，会找到离head最近的一个node(没取消的)，unpark唤醒。因此就是Thread1会被唤醒，然后Thread1继续执行acquireQueued方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Thread1加锁成功，设置</p><ol><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ol><p>如果有Thread4前来竞争，Thread1又加锁失败，Thread1再次进入acquireQueued流程，获取锁失败，重新进入park阻塞</p><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>以非公平锁NonfairSync的源码为例，NonfairSync在进行获取锁nonfairTryAcquire的时候，其实就是对state的值做一个判断，如果state的值为0，说明没线程加过锁；如果state的值不是0，说明已经有线程加过锁了，那就判断一下这个加锁的线程是不是当前线程，如果是当前线程那就<strong>把state的值再加1</strong>，<strong>表示当前线程又加了一次锁</strong></p><p>释放锁的时候相反，先让获取state的值，然后减去1，看看值是不是为0，为0才表示这个线程没有锁了，如果不为0，那就更新一下state的值就ok</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是Sync 继承过来的方法，实际上NonfairSync的tryAcquire里面也就是直接调用的这个nonfairTryAcquire方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 正常加锁流程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p>ReentrantLock默认是不可打断的，不可打断指的是，某个线程在尝试获取锁，然后获取锁失败了会进入parkAndCheckInterrupt()方法被park阻塞，这个时候是不可打断的。</p><h4 id="不可打断"><a href="#不可打断" class="headerlink" title="不可打断"></a>不可打断</h4><p>当在parkAndCheckInterrupt方法中park阻塞住，然后被打断后，会<strong>Thread.interrupted()清除打断标记</strong>，让下次park仍然可以阻塞。当被打断后，线程醒过来会接着执行return Thread.interrupted()，这个时候就会<strong>返回true</strong>，但同时会清除<strong>打断标记</strong>，也就是<strong>置为false</strong>，这样下次<strong>仍可以park</strong>阻塞住。</p><p>返回为true后，执行interrupted = true，然后<strong>又进入循环</strong>，看能否获取锁，不能获取又进入park阻塞。如果这次能获取锁了，interrupted = true，最后acquireQueued方法返回的就是interrupted=true。也就是说需要获取到锁之后，才能返回打断状态。</p><p>然后就从acquireQueued方法出来，<strong>也就是获取到锁之后进行一次selfInterrupt()，重新打断一次，如果是正常运行状态不是sleep中就不会抛打断异常</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        <span class="comment">// 被park阻塞的线程, 可以被别的线程调用它的interrupt方法打断该park阻塞</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted会返回是否被打断过，同时会清除打断标记; 下次park仍然可以阻塞</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)&amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>可打断则是在park方法被打断之后，执行完了parkAndCheckInterrupt方法，进入if内部，<strong>直接抛出异常，不会再次执行for循环</strong>，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入可打断的获取锁流程</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><p>与非公平锁的区别主要在tryAcquire方法里，公平锁并不会直接cas 去设置state的值，它会先去检查一下AQS队列中有不有前驱节点，也就是说还有不有线程在等待，如果有就退出if，获取锁失败，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">           <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(current);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                (<span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">            (s = h.next) == <span class="keyword">null</span> || <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">                                s.thread != Thread.currentThread()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>在AQS中ConditionObject是一个实现了Condition的公共内部类，每个条件变量其实就对应着一个ConditionObject，ConditionObject维护了一个等待队列</p><h4 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a>await流程</h4><p>下面是ConditionObject中的await方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>开始 Thread0 持有锁，conditionObject对象调用 await</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145922395.png" alt="image-20220129145922395"></p><p>进入 ConditionObject 的 addConditionWaiter方法，这个方法会将Thread0在ConditionObject 的等待队列中关联一个节点，首先创建新的Node状态为 -2(Node.CONDITION)，关联 Thread-0，加入等待队列尾部。</p><p>然后fullyRelease()，释放掉Thread0的所有锁，因为是可重入的</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145830741.png" alt="image-20220129145830741"></p><p>内部调用release(args)方法，unparkSuccessor(h)，唤醒AQS队列中的下一个节点，竞争锁</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145906453.png" alt="image-20220129145906453"></p><p>最后会进入await方法中的while循环，park阻塞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h4 id="signal流程"><a href="#signal流程" class="headerlink" title="signal流程"></a>signal流程</h4><p>下面是ConditionObject的<strong>signal</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>假设Thread1要来唤醒Thread0</p><p>首先判断Thread1是否持有独占锁if (!<strong>isHeldExclusively</strong>())，只有持有锁，才能去唤醒条件变量里的线程</p><p>然后<strong>每次都取条件变量中等待队列的第一个</strong><code>Node first = firstWaiter</code>，如果存在等待线程，就dosignal方法</p><p><strong>dosignal</strong> 先做些事后处理，判断是否还有下一个node，并且端口thread0的节点</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129151114179.png" alt="image-20220129151114179"></p><p>然后<strong>transferForSignal</strong>()，这个方法会将要唤醒Node加入到AQS的等待队列里去，并且将等待队列中最后一个node(即是图上的Thread3)的waitStatus修改为-1，因为要唤醒的node加入到它后面了</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129151221485.png" alt="image-20220129151221485"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">AbstractQueueSynchronizer，ReentrantLock实现原理，公平锁非公平锁实现原理，条件变量实现原理</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/CAS/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/CAS/</id>
    <published>2022-02-09T14:52:57.069Z</published>
    <updated>2022-03-08T12:45:23.057Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Java中 <strong>synchronized</strong> 和 <strong>ReentrantLock</strong> 等独占锁是 <strong>悲观锁</strong> 思想的实现</li><li>在Java中<strong>java.util.concurrent.atomic包下面的原子变量类</strong>是使用了乐观锁的一种实现方式 <strong><code>CAS</code></strong> 实现</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li>有如下需求，保证account.withdraw()取款方法的线程安全, 下面使用<code>synchronized</code>保证线程安全</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> AccountUnsafe(<span class="number">10000</span>));</span><br><span class="line">        Account.demo(<span class="keyword">new</span> AccountCas(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountUnsafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java8之后接口新特性, 可以添加默认方法、静态方法</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 1000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(thread -&gt; thread.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end - start) / <span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS解决"><a href="#CAS解决" class="headerlink" title="CAS解决"></a>CAS解决</h2><ul><li>上面的代码中使用synchronized加锁操作来保证线程安全，但是 **synchronized加锁操作太耗费资源 (线程上下文切换)**，我们还可以使用 <strong>无锁CAS</strong> 来解决此问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountCas</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用原子整数</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AccountCas</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//得到原子整数的值</span></span><br><span class="line"><span class="keyword">return</span> balance.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//获得修改前的值</span></span><br><span class="line"><span class="keyword">int</span> prev = balance.get();</span><br><span class="line"><span class="comment">//获得修改后的值</span></span><br><span class="line"><span class="keyword">int</span> next = prev - amount;</span><br><span class="line"><span class="comment">//比较并设置值</span></span><br><span class="line">            <span class="comment">//一个原子操作，比较并设置。会先去比较一下线程当前知道的值prev和主存中的balance</span></span><br><span class="line">            <span class="comment">//比较发现如果相等就设置balance的值为next，然后返回true，不相等就直接返回false</span></span><br><span class="line"><span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h2><p>使用原子操作CAS来保证线程访问共享资源的安全性，需要保证共享变量的可见性</p><h3 id="保证账户余额线程安全原理"><a href="#保证账户余额线程安全原理" class="headerlink" title="保证账户余额线程安全原理"></a>保证账户余额线程安全原理</h3><p><strong>compareAndSet</strong> 保证共享变量安全性：</p><ul><li>调用compareAndSet方法, 会先去比较一下线程当前知道的值prev和主存中的balance，比较发现如果相等就设置balance的值为next，然后返回true，不相等就直接返回false<br>如果不相同，表示其他线程也修改了balance值，此时就设置next值失败，然后进入while循环，重新获取balance.get()的值，计算出next值。并判断本次的prev和balnce的值是否相同</li></ul><p>其实 <strong>CAS</strong> 的底层是 <strong>lock cmpxchg 指令（X86 架构）</strong>，在单核 CPU 和多核 CPU 下都能够保证比较-交换的原子性。<br>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p><h3 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h3><p>在上面代码中的<strong>AtomicInteger</strong>类，内部的<strong>value</strong>属性使用了<strong>volatile</strong> 修饰。获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰，这样能保证线程对属性的修改对其他线程可见。(volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>使用<strong>CAS</strong>+重试无锁情况下，即使重试失败，<strong>线程</strong>始终在<strong>高速运行</strong>，没有停歇，而 <strong>synchronized</strong>会让线程在没有获得锁的时候，发生<strong>上下文切换</strong>，进入<strong>阻塞</strong>。</p><p>打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</p><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p><p>因此，CAS这种方式也比较依靠CPU核心数，如果CPU核心数不够，即使有再多的线程，线程分不到时间片，一样会阻塞住，一样会上下文切换，所以最好线程数不要大于CPU核心数。</p><h3 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，<strong>适用于线程数少、多核 CPU</strong> 的场景下。</p><p><strong>CAS</strong> 是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，那就再尝试一次。<br><strong>synchronized</strong>是基于<strong>悲观锁</strong>的思想：最悲观的估计，保证不让其它线程来修改共享变量，上了锁其他线程都不能操作，修改完了解开锁，其他线程才有机会。<br><strong>CAS 体现的是无锁并发、无阻塞并发</strong>，因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一，**但如果竞争激烈(写操作多)**，可以想到重试必然频繁发生，反而效率会受影响</p><h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p><strong>java.util.concurrent.atomic</strong>提供的是一些原子类，</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p>上面三个类提供的方法几乎相同，以 <strong>AtomicInteger</strong>为例。<br>通过观察源码可以发现AtomicInteger 内部是通过cas的来实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">    System.out.println(i.getAndIncrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">    System.out.println(i.incrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">    System.out.println(i.decrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">    System.out.println(i.getAndDecrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">    System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    <span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line">    <span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">    System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i.getAndAccumulate(10, (p, x) -&gt; p + x)</code>：函数式编程接口，(p, x) -&gt; p + x做为一个参数可以理解为实现了某一种方法，这种方式就是返回p+x的值</p><p><code>updateAndGet</code>方法的实现：实际上是相当于把匿名内部类简化了一下，以函数式的风格就可以调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    updateAndGet(i, <span class="keyword">new</span> IntUnaryOperator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(<span class="keyword">int</span> operand)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> operand / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i.get()); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateAndGet</span><span class="params">(AtomicInteger i, IntUnaryOperator operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = i.get(); <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">int</span> next = operator.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span> (i.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子引用-AtomicReference"><a href="#原子引用-AtomicReference" class="headerlink" title="原子引用 (AtomicReference)"></a>原子引用 (AtomicReference)</h2><p>原子引用保证引用类型的共享变量是线程安全的，刚才的是规定了数据类型比如为Integer</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicMarkableReference</code>：原子更新带有版本号的引用类型。用版本号一般是整型来标识是否被修改过，用来解决 ABA 问题。</li><li><code>AtomicStampedReference</code> 原子更新带有标记的引用类型。该类并不关心中途修改了多少次，只关心有没有修改过，所以只需要用一个 boolean 标记与引用关联起来，可以解决ABA 问题。</li></ul><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>ABA问题就是说在采用原子类型操作的时候，比如如果用上面的AtomicInteger，一个线程想把1改为3，但这个线程成功之前，线程2先把1改为了2，然后某个线程又把2改回了1，这时候想改为3的线程虽然也能改成功，因为它从主存中获取到的值仍然为1，但是实际上已经被其他线程修改过了，这就是ABA问题，简单点来说就是A修改到B后又修改回了A，但是其他线程并不知道修改过了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String pre = ref.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//把ref中的A改为C，也会修改成功，这就是ABA问题 仍然是true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C &quot;</span> + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 线程start后主线程sleep了，所以这个线程把A-&gt;B，并且能改成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 再将B-&gt;A，同样也能修改成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicStampedReference-版本号解决ABA问题"><a href="#AtomicStampedReference-版本号解决ABA问题" class="headerlink" title="AtomicStampedReference (版本号解决ABA问题)"></a>AtomicStampedReference (版本号解决ABA问题)</h3><p><strong>AtomicStampedReference</strong> 可以加一个版本号，来解决ABA问题，在构造的时候初始化一个版本号，如果有线程修改了就版本号加1，这样其他线程就能根据这个版本号来判断是否被修改过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String pre = ref.getReference();</span><br><span class="line">            <span class="comment">//获得版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp(); <span class="comment">// 此时的版本号还是第一次获取的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把ref中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C stamp &quot;</span> + stamp + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicMarkableReference-boolean解决ABA问题"><a href="#AtomicMarkableReference-boolean解决ABA问题" class="headerlink" title="AtomicMarkableReference (boolean解决ABA问题)"></a>AtomicMarkableReference (boolean解决ABA问题)</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; </p><p>A -&gt;C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，就可以使用<strong>AtomicMarkableReference</strong></p><h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><p><strong>原子数组用来保证数组内的元素的线程安全，使用原子的方式更新数组里的某个元素</strong></p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><p>下面<strong>不安全的示例</strong>中采用了函数式编程，可以理解为demo(…)方法里的参数，都是一种方法，在调用demo方法的时候实现好方法的内容，然后直接返回给参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo(</span><br><span class="line">                () -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">                array -&gt; array.length,</span><br><span class="line">                (array, index) -&gt; array[index]++,</span><br><span class="line">                array -&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment">     * 参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment">     * 参数3，自增方法，回传 array, index</span></span><br><span class="line"><span class="comment">     * 参数4，打印数组的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line">    <span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line">    <span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;void</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;T, Integer&gt; putConsumer, </span></span></span><br><span class="line"><span class="function"><span class="params">        Consumer&lt;T&gt; printConsumer)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        T array = arraySupplier.get();</span><br><span class="line">        <span class="keyword">int</span> length = lengthFun.apply(array);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建10个线程, 每个线程对数组作 10000 次操作</span></span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    putConsumer.accept(array, j % length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ts.forEach(t -&gt; t.start()); <span class="comment">// 启动所有线程</span></span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 等所有线程结束</span></span><br><span class="line"></span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安全的实现只需要用AtomicIntegerArray数组来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">        ()-&gt; <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>),</span><br><span class="line">        (array) -&gt; array.length(),</span><br><span class="line">        (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">        array -&gt; System.out.println(array)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><p><strong>保证多线程访问同一个对象的成员变量时，成员变量的线程安全性。</strong></p><ul><li>AtomicReferenceFieldUpdater：引用类型</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>注意：利用字段更新器，可以针对对象的某个域或者叫属性（Field）进行原子操作，但是<strong>属性需要被volatile 修饰</strong>，否则会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be <span class="keyword">volatile</span> type</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">// 获得原子更新器</span></span><br><span class="line">      <span class="comment">// 泛型</span></span><br><span class="line">      <span class="comment">// 参数1 newUpdater(类的字节码对象,被更新的属性的字节码对象,属性的名称)</span></span><br><span class="line">        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//最初为null，想要修改为&quot;张三&quot;</span></span><br><span class="line">        System.out.println(updater.compareAndSet(stu, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(updater.compareAndSet(stu, stu.name, <span class="string">&quot;王五&quot;</span>));</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子累加器-LongAddr"><a href="#原子累加器-LongAddr" class="headerlink" title="原子累加器 (LongAddr)"></a>原子累加器 (LongAddr)</h2><p>原子累加器是jdk8的新的几个类，它优化了原始原子整数的方法，能够得到更快的效率</p><ul><li>LongAddr</li><li>LongAccumulator</li><li>DoubleAddr</li><li>DoubleAccumulator</li></ul><p><strong>AtomicLong和LongAddr的性能比较</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----AtomicLong----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----LongAdder----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> LongAdder(), adder -&gt; adder.increment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">        T adder = adderSupplier.get();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                    action.accept(adder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(t -&gt; t.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start) / <span class="number">1000_000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LongAddr性能提升的原因"><a href="#LongAddr性能提升的原因" class="headerlink" title="LongAddr性能提升的原因"></a><strong>LongAddr性能提升的原因</strong></h3><ul><li>就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 失败的次数，从而提高性能。</li></ul><p>AtomicLong等都是在一个共享资源变量上进行竞争, while(true)循环进行CAS，性能没有LongAdder高</p><h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><ul><li><strong>Unsafe</strong> 对象提供了非常底层的操作内存和线程的方法，Unsafe 对象<strong>不能直接调用</strong>，<strong>只能</strong>通过<strong>反射</strong></li><li>可以发现AtomicInteger以及其他的原子类, 底层都会使用一个Unsafe的属性</li></ul><h3 id="使用Unsafe实现原子操作"><a href="#使用Unsafe实现原子操作" class="headerlink" title="使用Unsafe实现原子操作"></a>使用Unsafe实现原子操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射获得Unsafe对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Person对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获得其属性 name 的偏移量（相对于类的属性值的地址偏移量）</span></span><br><span class="line">        <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="keyword">long</span> ageOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过unsafe的CAS操作改变值</span></span><br><span class="line">        unsafe.compareAndSwapObject(person, nameOffset, <span class="keyword">null</span>, <span class="string">&quot;guizy&quot;</span>);</span><br><span class="line">        unsafe.compareAndSwapInt(person, ageOffset, <span class="number">0</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配合CAS操作，必须用volatile修饰</span></span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CAS，原子整数，原子引用，原子数组，累加器，Unsafe类</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://ins1mn1a.github.io/2022/02/09/JUC/ReentrantLock/"/>
    <id>http://ins1mn1a.github.io/2022/02/09/JUC/ReentrantLock/</id>
    <published>2022-02-09T14:20:56.592Z</published>
    <updated>2022-03-08T12:45:23.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><p>一个并发应用程序能及时执行的能力称为活跃性</p><ul><li>活跃性相关的一系列问题都可以用 ReentrantLock 进行解决。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br>如：线程1获取A对象锁, 线程2获取B对象锁; 此时线程1又想获取B对象锁, 线程2又想获取A对象锁; 它们都等着对象释放锁, 此时就称为死锁</p><h3 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h3><ol><li>互斥条件<br>在一段时间内，一种资源只能被一个进程所使用</li><li>请求和保持条件<br>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进阻塞状态，并且不释放自己已有的资源</li><li>不可抢占条件<br>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li><li>循环等待条件<br>发生死锁时，必然存在一个进程——资源的循环链</li></ol><h3 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h3><h4 id="JPS-JStack进程ID"><a href="#JPS-JStack进程ID" class="headerlink" title="JPS+JStack进程ID"></a>JPS+JStack进程ID</h4><p>首先JPS找到JVM进程，JStack +进程ID查看进程状态</p><h4 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h4><p>jconsole连接进程，检测死锁</p><h4 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h4><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li><li>当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。</li></ul><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁出现在两个线程互相改变对方的结束条件，谁也无法结束。</p><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><ul><li>某些线程因为优先级太低，导致一直无法获得资源的现象。</li></ul><ul><li>在使用顺序加锁时，可能会出现饥饿现象</li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock特点：</p><ul><li>可中断</li><li>可设置超时时间</li><li>可设置为公平锁</li><li>支持多个条件变量，根据不同条件加锁</li></ul><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//需要执行的代码</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//需要执行的代码</span></span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>ReentrantLock是可以中断的，调用reentrantLock. lockInterruptibly()，那么这个reentrantLock就是一个可打断的锁；如果这个锁没有竞争，那么它跟正常的lock方法是没有区别的。但是如果发生了竞争并且线程进入了阻塞队列，那么这个阻塞状态是可以被其他线程打断的。避免了一直阻塞。</p><ul><li><strong>synchronized</strong>是获得了锁以后，可以进行打断，<strong>打断正在运行的线程或者说打断在sleep，wait，join的线程</strong></li><li><strong>ReentrantLock</strong>的可<strong>打断</strong>的意思是没获得锁，前往阻塞队列，可以<strong>打断它的阻塞</strong>，<strong>避免一直获取不到锁而阻塞，可以用来避免死锁</strong>，**<code>防止死锁的思想还是避免一直等待</code>**</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//lockInterruptibly方法表示是可中断的</span></span><br><span class="line">            <span class="comment">// 也就是说reentrantLock还没获得锁，竞争后进入了阻塞队列，别的线程可以打断reentrantLock的阻塞</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有竞争这个方法跟lock()是一样的</span></span><br><span class="line">                <span class="comment">//如果有竞争进入阻塞队列，可以被其他线程打断</span></span><br><span class="line">                System.out.println(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">                reentrantLock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有获取锁，返回&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在t1线程获取到锁前先锁住</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打断t1&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">尝试获取锁</span><br><span class="line">打断t1</span><br><span class="line">没有获取锁，返回</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly (AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly( AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">at com.zc.reentrantlock.Test.lambda$main$<span class="number">0</span>(Test.java:<span class="number">22</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>如果是reentrantLock.lock()方法，则是不可打断的；会发现先尝试获取锁，获取不到，然后就阻塞，接下来主线程打断t1，但是没有打断成功，程序一直运行。</li></ul><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p><strong>锁超时</strong>是指用ReentrantLock的**tryLock()**方法上锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>tryLock()<strong>方法返回boolean值，会</strong>先判断能否成功获取锁</strong>，不能则返回false。</li><li>**tryLock(long timeout, TimeUnit unit)**表示在一定timeout时间内去尝试获取锁，在这时间段仍获取不到锁则返回false。同样这个方法同lockInterruptibly()方法一样，也是一个可打断的方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!reentrantLock.tryLock()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取不到锁，返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reentrantLock.lock();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trylock-解决哲学家就餐问题"><a href="#trylock-解决哲学家就餐问题" class="headerlink" title="trylock()解决哲学家就餐问题"></a>trylock()解决哲学家就餐问题</h3><p>哲学家在拿到左边的筷子的时候也就是左边筷子加锁，然后准备给右边筷子加锁，采用trylock()保证其不会一直占着左边的筷子不放，如果没能成功给右边筷子加锁，那么就会释放左边的筷子。</p><p>原来采用synchronized会产生死锁是因为synchronized给左边的的筷子加锁后，又想给右边筷子加锁，右边筷子加锁要是不成功，就不会继续往下执行，也就是不会释放左边筷子的锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哲学家就餐问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;PhilosopherEatingProblem.class&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhilosopherEatingProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Chopstick left;</span><br><span class="line">    <span class="keyword">final</span> Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//获得左手边筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//获得成功，获取右边筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承ReentrantLock, 让筷子类成为锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock<strong>默认</strong>是<strong>非公平锁</strong>，可以在<strong>构造方法</strong>的时候指定其为<strong>公平锁</strong>；</p><p>在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。一般不设置ReentrantLock为公平的, 会降低并发度。</p><p>Synchronized底层的Monitor锁就是不公平的, 和谁先进入阻塞队列是没有关系的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>公平锁可以解决饥饿问题，也就是说不会存在某个线程一直获取不到锁。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li>synchronized中也有条件变量，当条件不满足的时候，进入waitSet集合，但是它的waitSet只有一个</li><li>ReentrantLock可以有多个条件变量，也就是说可以有多个waitSet，不同条件的进入不同的waitSet等待，这样可以<strong>避免虚假唤醒</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">//条件变量一</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Condition condition1= lock.newCondition();</span><br><span class="line">   <span class="comment">//条件变量2</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Condition condition2= lock.newCondition();</span><br></pre></td></tr></table></figure><ul><li>condition.await()方法进入对应条件的waitSet</li><li>condition.signal()方法唤醒对应条件的waitSet中的一个线程</li><li>condition.signalAll()方法唤醒对应条件的waitSet中的所有线程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 等待烟的休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitCigaretteSet = lock.newCondition();</span><br><span class="line">    <span class="comment">// 等外卖的休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitTakeoutSet = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小南进入到等烟的休息室</span></span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;烟来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小女进入到等外卖的休息室</span></span><br><span class="line">                        waitTakeoutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送外卖的来咯~&quot;</span>);</span><br><span class="line">                hasTakeout = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等外卖的小女线程</span></span><br><span class="line">                waitTakeoutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送烟的来咯~&quot;</span>);</span><br><span class="line">                hasCigarette = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等烟的小南线程</span></span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="顺序打印"><a href="#顺序打印" class="headerlink" title="顺序打印"></a>顺序打印</h3><ul><li>要求两个线程先打印2，再打印1</li></ul><h4 id="wait-notify实现"><a href="#wait-notify实现" class="headerlink" title="wait-notify实现"></a>wait-notify实现</h4><p>设置一个标记变量，只有2还没打印，就wait，2打印完了，唤醒1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSeqPrint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> has2Printed=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!has2Printed) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)</span><br><span class="line">            &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">                has2Printed=<span class="keyword">true</span>;</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock的await-signal实现"><a href="#ReentrantLock的await-signal实现" class="headerlink" title="ReentrantLock的await/signal实现"></a>ReentrantLock的await/signal实现</h4><p>不满足条件去其条件变量中等待</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (!has2Printed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">        has2Printed=<span class="keyword">true</span>;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="LockSupport的park和unpark实现"><a href="#LockSupport的park和unpark实现" class="headerlink" title="LockSupport的park和unpark实现"></a>LockSupport的park和unpark实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();;</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><ul><li>要求线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。</li></ul><h4 id="wait-notify实现-1"><a href="#wait-notify实现-1" class="headerlink" title="wait-notify实现"></a>wait-notify实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;a线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;b线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;c线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出内容    等待标记    下一个标记</span></span><br><span class="line"><span class="comment">        a           1          2</span></span><br><span class="line"><span class="comment">        b           2          3</span></span><br><span class="line"><span class="comment">        c           3          1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, <span class="keyword">int</span> waitFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (waitFlag != <span class="keyword">this</span>.flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="keyword">this</span>.flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：abcabcabcabcabc</p><h4 id="condition-await-signal实现"><a href="#condition-await-signal实现" class="headerlink" title="condition.await/signal实现"></a>condition.await/signal实现</h4><p>设置3个条件变量，去各自的waitSet中等待，先让3个线程都阻塞，然后开始唤醒a，直接a唤醒b，b唤醒c</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAwaitSignal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a_condition = awaitSignal.newCondition();</span><br><span class="line">        Condition b_condition = awaitSignal.newCondition();</span><br><span class="line">        Condition c_condition = awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a_condition, b_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b_condition, c_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c_condition, a_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==========开始=========&quot;</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a_condition.signal();  <span class="comment">//首先唤醒a线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Condition condition, Condition next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.out.print(str);</span><br><span class="line">                    next.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LockSupport的park-unpark实现"><a href="#LockSupport的park-unpark实现" class="headerlink" title="LockSupport的park/unpark实现"></a>LockSupport的park/unpark实现</h4><p>先全部阻塞，然后唤醒a，接着a唤醒b，b唤醒c，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread a;</span><br><span class="line">    <span class="keyword">static</span> Thread b;</span><br><span class="line">    <span class="keyword">static</span> Thread c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark parkUnpark = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;a&quot;</span>, b);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;b&quot;</span>, c);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;c&quot;</span>, a);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h2><p><img src="/../../img/markdown_img/ReentrantLock.assets/image-20220118111830515.png" alt="image-20220118111830515"></p>]]></content>
    
    
    <summary type="html">ReentrantLock、条件变量Condition、LockSupport Park，unPark</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程的安全性问题</title>
    <link href="http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2022-01-17T10:35:35.045Z</published>
    <updated>2022-03-08T12:45:23.047Z</updated>
    
    <content type="html"><![CDATA[<ul><li>线程安全问题</li><li>synchronized保证线程安全</li><li>private或final的重要性</li><li>线程八锁问题分析</li><li>变量的线程安全分析</li></ul><h2 id="临界区与竞态条件"><a href="#临界区与竞态条件" class="headerlink" title="临界区与竞态条件"></a>临界区与竞态条件</h2><p>一个程序运行多线程本身是没有问题的，问题出现在多个线程共享资源(临界资源)的时候</p><p>多个线程同时对共享资源进行读操作本身也没有问题 - 对读操作没问题</p><p>问题出现在对对共享资源同时进行读写操作时就有问题了 - 同时读写操作有问题</p><p>先定义一个叫做临界区的概念：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为<strong>临界区</strong>; 共享资源也成为<strong>临界资源</strong></p><ul><li>多个线程在<code>临界区</code>执行，那么由于<strong>代码指令的执行不确定而导致的结果问题</strong>，称为<code>竞态条件</code></li></ul><p>为了避免临界区中的竞态条件发生，由多种手段可以达到</p><ul><li>阻塞式解决方案： synchronized , Lock (ReentrantLock)</li><li>非阻塞式解决方案： 原子变量 (CAS)</li></ul><p>使用synchronized来进行解决，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><p>注意: 虽然Java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码。同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</p><h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><ul><li>其实就是考察<code>synchronized 锁住的是哪个对象</code>, 如果锁住的是<code>同一对象</code>, 就不会出现<code>线程安全</code>问题</li></ul><h3 id="锁住同一个对象都是this，结果为：1-2或者2-1"><a href="#锁住同一个对象都是this，结果为：1-2或者2-1" class="headerlink" title="锁住同一个对象都是this，结果为：1,2或者2,1"></a>锁住同一个对象都是this，结果为：1,2或者2,1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1/2 或 2/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁住同一个对象都是this，结果为：1s后1-2-2-1s后1"><a href="#锁住同一个对象都是this，结果为：1s后1-2-2-1s后1" class="headerlink" title="锁住同一个对象都是this，结果为：1s后1,2 || 2,1s后1"></a>锁住同一个对象都是this，结果为：1s后1,2 || 2,1s后1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1s后1,2 || 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a，b锁住同一个对象都是this，c没有上锁。"><a href="#a，b锁住同一个对象都是this，c没有上锁。" class="headerlink" title="a，b锁住同一个对象都是this，c没有上锁。"></a>a，b锁住同一个对象都是this，c没有上锁。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会出现安全问题, 因为前两个线程, 执行run方法时, 都对相同的对象加锁;</span></span><br><span class="line"><span class="comment"> *              而第三个线程,调用的方法c, 并没有加锁, 所以它可以同前两个线程并行执行;</span></span><br><span class="line"><span class="comment"> *  打印结果顺序为: 分析: 因为线程3和线程1,2肯定是并行执行的, 所以有以下情况</span></span><br><span class="line"><span class="comment"> *               3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1</span></span><br><span class="line"><span class="comment"> *               至于 1,3,2的情况是不会发生的, 可以先调用到1,但需要sleep一秒.3肯定先执行了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                e1.a();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.c()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住对象this，b锁住对象this"><a href="#a锁住对象this，b锁住对象this" class="headerlink" title="a锁住对象this，b锁住对象this"></a>a锁住对象this，b锁住对象this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会出现安全问题, 线程1的锁对象为e1, 线程2的锁对象为e2. 所以他们会同一时刻执行1,2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是e2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住的是类-b锁住的是this"><a href="#a锁住的是类-b锁住的是this" class="headerlink" title="a锁住的是类, b锁住的是this"></a>a锁住的是类, b锁住的是this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是e2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-b锁住的是类-会发生互斥"><a href="#a-b锁住的是类-会发生互斥" class="headerlink" title="a,b锁住的是类, 会发生互斥"></a>a,b锁住的是类, 会发生互斥</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span></span><br><span class="line"><span class="comment"> *              结果: 2,1s后1 || 1s后1,2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住的是类-b锁住的是this-1"><a href="#a锁住的是类-b锁住的是this-1" class="headerlink" title="a锁住的是类, b锁住的是this"></a>a锁住的是类, b锁住的是this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是this,e2对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-b锁住的是类-会发生互斥-1"><a href="#a-b锁住的是类-会发生互斥-1" class="headerlink" title="a,b锁住的是类, 会发生互斥"></a>a,b锁住的是类, 会发生互斥</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1 || 1s后1,2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><h3 id="成员变量和静态变量的线程安全分析"><a href="#成员变量和静态变量的线程安全分析" class="headerlink" title="成员变量和静态变量的线程安全分析"></a>成员变量和静态变量的线程安全分析</h3><p>如果变量没有在线程间共享，那么变量是安全的<br>如果变量在线程间共享<br>如果只有读操作，则线程安全<br>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p><h3 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h3><p>局部变量【局部变量被初始化为基本数据类型】是安全的<br>但<strong>局部变量引用的对象</strong>则未必线程安全 （要看该对象是否被共享且被执行了读写操作）</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul><li>如果<code>局部变量引用的对象逃离方法的范围</code>，那么<code>要考虑线程安全问题</code>的，代码示例如下</li></ul><blockquote><p>循环创建了100个线程, 在线程体里面都调用了method1方法, 在method1方法中又循环调用了100次method2,method3方法，也即是arrayList 的add和remove；这里的arrayList 是多线程中共享的变量，因为都是unsafeTest，对于这个共享的变量，虽然arrayList 的操作是加了同步代码块的，但是arrayList.add()和arrayList.remove()并不能保证也是同步的，这样必然会出现线程安全问题，最后以异常的形式抛出。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeTest unsafeTest = <span class="keyword">new</span> UnsafeTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                unsafeTest.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;线程1&quot;</span> Exception in thread <span class="string">&quot;线程2&quot;</span> java.lang.ArrayIndexOutOfBoundsException: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>解决方法就是可以将arrayList作为局部变量，放在method1内部，这样arrayList就可以认为是一个线程私有的。局部变量存放在<strong>栈帧</strong>中, 栈帧又存放在<code>虚拟机栈</code>中, <strong>虚拟机栈是作为线程私有的;</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            method2(arrayList);</span><br><span class="line">            method3(arrayList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(List&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(List&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private-或-final的作用"><a href="#private-或-final的作用" class="headerlink" title="private 或 final的作用"></a><code>private</code> 或 <code>final</code>的作用</h3><p>使用这两个修饰符可以提高线程的安全性，private和final让子类不能重写父类的方法，当我们的方法如果是public，也即是上面的代码method2,method3都是public时，虽然上面代码不会出现线程安全问题，如果有一个子类继承了这个UnsafeTest类，然后又因为是public方法，就可以重写覆盖父类的方法，此时在子类中开多线程操作list对象，就有可能造成线程安全问题：子类和父类共享了list对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSafe threadSafe = <span class="keyword">new</span> ThreadSafeSubClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                threadSafe.method1(<span class="number">10</span>);</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见线程安全类-1"><a href="#常见线程安全类-1" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类 JUC</li></ul><p>这里说它们是线程安全的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong> , 也可以理解为 <strong>它们的每个方法是原子的</strong>，因为方法都被加上了synchronized</p><p>但注意它们的<code>多个方法的组合不是原子的</code>，所以可能<strong>会出现线程安全问题</strong></p>]]></content>
    
    
    <summary type="html">临界区与竞态条件、线程八锁问题</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-01-17T10:26:55.204Z</published>
    <updated>2022-03-08T12:43:57.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程、并行并发、同步异步概念"><a href="#线程与进程、并行并发、同步异步概念" class="headerlink" title="线程与进程、并行并发、同步异步概念"></a>线程与进程、并行并发、同步异步概念</h2><ul><li>线程创建</li><li>线程重要api，如start，run，sleep, join，interrupt等</li><li>线程状态</li><li>应用方面<ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li>原理方面<ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式的源码</li></ul></li><li><font color="green">模式方面</font><ul><li>两阶段终止</li></ul></li></ul><h2 id="进程与进程"><a href="#进程与进程" class="headerlink" title="进程与进程"></a>进程与进程</h2><p>进程: 资源分配的最小单位</p><p>进程是线程的容器, 一个进程中包含多个线程, 真正执行任务的是线程<br>线程: 资源调度的最小单位</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序由指令和数据组成，但是这些 指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令,管理内存,管理IO的<br>当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程<br>进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程之内可以分为多个线程。<br>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行<br>Java 中，线程作为资源的最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。</p><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集<br>进程拥有共享的资源，如内存空间等，供其内部的线程共享; 进程间通信较为复杂<br>同一台计算机的进程通信称为 IPC（Inter-process communication）<br>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP<br>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<br>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>并发: 在单核CPU下, 一定是并发执行的, 也就是在同一个时间段内一起执行. 实际还是串行执行, CPU的时间片切换非常快, 给人一种同时运行的感觉。</p><p>并行: 在多核CPU下, 能真正意义上实现并行执行, 在同一个时刻, 多个线程同时执行; 比如说2核cpu, 同时执行4个线程. 理论上同时可以有2个线程是并行执行的. 此时还是存在并发, 因为2个cpu也会同时切换不同的线程执行任务罢了</p><h3 id="并发-concurrent"><a href="#并发-concurrent" class="headerlink" title="并发 (concurrent)"></a>并发 (concurrent)</h3><p>微观串行, 宏观并行<br>在单核 cpu下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu 在线程间（时间片很短）的切换非常快，给人的感觉是同时运行的 。一般会将这种线程轮流使用 CPU的做法称为并发（concurrent）<br>将线程轮流使用cput称为并发(concurrent)</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p><h3 id="二者对比-1"><a href="#二者对比-1" class="headerlink" title="二者对比"></a>二者对比</h3><p>引用 Rob Pike 的一段描述：<br>并发（concurrent）: 是同一时间应对（dealing with）多件事情的能力<br>并行（parallel）: 是同一时间动手做（doing）多件事情的能力<br>例子</p><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发<br>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）<br>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是 并行</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>以调用方的角度讲</p><ul><li>如果需要等待结果返回才能继续运行的话就是同步</li><li>如果不需要等待就是异步</li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这5秒cpu什么都做不了，其它代码都得暂停</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>UI 程序中，开线程进行其他操作，避免阻塞 UI 线程</li></ul><h2 id="线程的创建-重点"><a href="#线程的创建-重点" class="headerlink" title="线程的创建 (重点)"></a>线程的创建 (重点)</h2><h3 id="创建一个线程（非主线程）"><a href="#创建一个线程（非主线程）" class="headerlink" title="创建一个线程（非主线程）"></a>创建一个线程（非主线程）</h3><h4 id="通过继承Thread创建线程"><a href="#通过继承Thread创建线程" class="headerlink" title="通过继承Thread创建线程"></a>通过继承Thread创建线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">myThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用继承方式的好处是，在run()方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread()方法；不好的地方是<strong>Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</strong></li></ul><h4 id="使用Runnable配合Thread-推荐"><a href="#使用Runnable配合Thread-推荐" class="headerlink" title="使用Runnable配合Thread (推荐)"></a>使用Runnable配合Thread (推荐)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread2</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;my runnable running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">      thread.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</li></ul><h5 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h5><ul><li><p>当一个接口带有**@FunctionalInterface**注解时，是可以使用lambda来简化操作的</p></li><li><p>所以方法二中的代码可以被简化为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="comment">//直接写方法体即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Thread-与-Runnable的关系"><a href="#Thread-与-Runnable的关系" class="headerlink" title="Thread 与 Runnable的关系"></a>Thread 与 Runnable的关系</h5><p>分析 Thread 的源码，查看与 Runnable 的关系，可以发现采用Runnable的方式最终new Thread的时候最终就是把实现Runnable作为Thread中的target成员，然后判断如果target不为null，就运行target的run()方法，也就是Runnable的run方法。</p><ul><li>继承Thread方式: 是把线程和任务合并在了一起</li><li>实现Runnable方式: 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h4 id="使用FutureTask与Thread结合"><a href="#使用FutureTask与Thread结合" class="headerlink" title="使用FutureTask与Thread结合"></a>使用FutureTask与Thread结合</h4><p>使用<strong>FutureTask可以用泛型指定线程的返回值类型</strong>（Runnable的run方法没有返回值），FutureTask实现了RunnableFuture，FutureRunable继承了Runnable接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread r1 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">r1.start();</span><br><span class="line"><span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseFutureTask</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">      FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCall());</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">      thread.start();</span><br><span class="line">      <span class="comment">// 获得线程运行后的返回值</span></span><br><span class="line">      System.out.println(futureTask.get());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用线程池来创建线程"><a href="#使用线程池来创建线程" class="headerlink" title="使用线程池来创建线程"></a>使用线程池来创建线程</h4><p>创建线程的方式四：使用线程池</p><p>好处：</p><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p></li></ol><ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？四种！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：创建多线程有几种方式？四种！"><a href="#面试题：创建多线程有几种方式？四种！" class="headerlink" title="面试题：创建多线程有几种方式？四种！"></a>面试题：创建多线程有几种方式？四种！</h4><p>总结</p><ul><li>使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</li><li>开发中一般使用线程池的方式</li></ul><h2 id="三、Linux-Windows命令查看进程和线程"><a href="#三、Linux-Windows命令查看进程和线程" class="headerlink" title="三、Linux Windows命令查看进程和线程"></a>三、Linux Windows命令查看进程和线程</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul><li>任务管理器查看进程和线程，杀死进程</li><li> <code>tasklist</code> 查看进程</li><li><code>taskkill /F /PID 进程号</code> 杀死进程</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><code>ps -fe </code>查看所有进程</li><li><code>ps -ft -p &lt;PID&gt;</code> 查看某个进程的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>pkill -9 &lt;PID&gt;</code> 杀死进程，-9代表一类操作，杀死进程</li><li><code>top</code> 查看进程信息</li><li><code>top -H -P &lt;PID&gt;</code> 查看某个进程PID的所有线程</li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><code>jps</code> 查看所有Java进程</li><li><code>jstack &lt;PID&gt;</code> 查看某个Java进程的所有线程状态</li><li><code>jconsole</code> 连接查看某个Java进程中线程的运行情况（Windows直接win+r 输入jconsole，图形界面）</li></ul><h2 id="线程运行原理-重点"><a href="#线程运行原理-重点" class="headerlink" title="线程运行原理 (重点)"></a>线程运行原理 (<code>重点</code>)</h2><h3 id="虚拟机栈与栈帧"><a href="#虚拟机栈与栈帧" class="headerlink" title="虚拟机栈与栈帧"></a>虚拟机栈与栈帧</h3><ul><li>虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法被执行</strong>的时候都会同时创建一个<strong>栈帧(stack frame)<strong>用于</strong>存储局部变量表</strong>、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。当Java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧(在栈顶)，<strong>对应着当前正在执行的那个方法</strong>。</li><li>每个线程都拥有自己的一个栈内存，里面对应着多个栈帧。可以用IDEA开启线程模式的调试功能。</li></ul><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101108334.png" alt="image-20220115101108334"></p><p>t1线程的多个栈帧：</p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115100910857.png" alt="image-20220115100910857"></p><p>主线程的多个栈帧：</p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101011097.png" alt="image-20220115101011097"></p><h3 id="线程上下文切换（Thread-Context-Switch"><a href="#线程上下文切换（Thread-Context-Switch" class="headerlink" title="线程上下文切换（Thread Context Switch)"></a>线程上下文切换（Thread Context Switch)</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程</p><ul><li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当Thread Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>线程的状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能，所以线程数也不能过多，如果线程数大于CPU核心数，可能并不会提升性能</li></ul><h3 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h3><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111642378.png" alt="image-20220115111642378"></p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111913619.png" alt="image-20220115111913619"></p><h4 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h4><h5 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h5><p>调用 sleep() 会让当前线程从 Running(运行状态) 进入 Timed Waiting 状态（阻塞）<br>其它线程可以使用interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 InterruptedException异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】<br>睡眠结束后的线程未必会立刻得到执行 (需要分配到cpu时间片)<br>建议用 TimeUnit 的 sleep() 代替 Thread 的 sleep()来获得更好的可读性</p><h5 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h5><p>调用 yield 会让当前线程从Running 进入 Runnable 就绪状态，然后调度执行其它线程</p><p>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</p><p>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>线程<code>优先级</code>会<code>提示（hint）调度器优先调度该线程</code>，但它仅仅是一个提示，调度器可以忽略它, 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><ul><li>在<code>主线程</code>中调用<code>t1.join</code>，则<code>主线程</code>会<code>等待t1线程执行完之后</code>再<code>继续执行</code></li></ul><h4 id="interrupt-方法详解"><a href="#interrupt-方法详解" class="headerlink" title="interrupt 方法详解"></a>interrupt 方法详解</h4><p>该方法用于打断 sleep，wait，join的线程, 在阻塞期间cpu不会分配给时间片</p><ul><li><p>如果一个线程在在运行中被打断，打断标记会被置为true</p></li><li><p>如果是打断因sleep wait join方法而被阻塞的线程，只是会抛出一个Interrupted 异常，以这个异常来表示线程被打断了，打断标记仍然是false</p></li></ul><p>sleep，wait，join的线程，这几个方法都会让线程进入阻塞状态，join方法底层就是用的wait方法，以 sleep 为例，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>); <span class="comment">// wait, join</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;iterrupt..&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.isInterrupted()); <span class="comment">// 如果是打断sleep,wait,join的线程, 即使打断了, 标记也为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sleep...</span><br><span class="line">iterrupt..</span><br><span class="line">打断标记为:<span class="keyword">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.zc.ThreadPrintDemo.lambda$main$<span class="number">0</span>(ThreadPrintDemo.java:<span class="number">14</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h5><ul><li>调用Interrupt方法去打断一个正在运行的线程，就好比是一个打断请求，只是把其打断标记记为True，实际上是不是要被打断由线程自己决定，线程并不会直接暂停。我们可以判断<code>Thread.currentThread().isInterrupted();</code>的值来手动停止线程</li><li>这样可以方便当线程被打断时做一些后续的操作，料理线程后事</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被打断了, 退出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;打断标记为: &quot;</span>+t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interrupt</span><br><span class="line">被打断了, 退出循环</span><br><span class="line">打断标记为: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="终止模式之两阶段终止模式-多线程设计模式"><a href="#终止模式之两阶段终止模式-多线程设计模式" class="headerlink" title="终止模式之两阶段终止模式(多线程设计模式)"></a>终止模式之两阶段终止模式(多线程设计模式)</h4><p>当我们在执行线程一时，想要终止线程二，这时就需要使用interrupt方法来优雅的停止线程二。</p><h5 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h5><ul><li><p>使用线程对象的stop()方法停止线程</p><p>stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p></li><li><p>使用System.exit(int)方法停止线程</p><p>目的仅是停止一个线程，但这种做法会让整个程序都停止</p></li></ul><p>如下所示：那么线程的isInterrupted()方法可以取得线程的打断标记</p><p>如果线程在睡眠sleep期间被打断，打断标记是不会变的，为false，但是sleep期间被打断会抛出异常，我们据此手动设置打断标记为true；<br>如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为true。处理好这两种情况那我们就可以放心地来料理后事啦！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">monitor.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">monitor.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置线控器线程，用于监控线程状态</span></span><br><span class="line">monitor = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//开始不停的监控</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">//判断当前线程是否被打断了</span></span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;处理后续任务&quot;</span>);</span><br><span class="line">                        <span class="comment">//终止线程执行</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;监控器运行中...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//线程休眠</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span></span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">monitor.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于停止监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//打断线程</span></span><br><span class="line">monitor.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sleep，yiled，wait，join-对比"><a href="#sleep，yiled，wait，join-对比" class="headerlink" title="sleep，yiled，wait，join 对比"></a>sleep，yiled，wait，join 对比</h4><ul><li>sleep，join，yield，interrupted是Thread类中的方法</li><li>wait/notify是object中的方法</li><li>sleep 不释放锁、释放cpu</li><li>join 释放锁、抢占cpu</li><li>yiled 不释放锁、释放cpu</li><li>wait 释放锁、释放cpu</li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>当Java进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，Java进程才会结束。但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</p><p>注意:</p><p>垃圾回收器线程就是一种守护线程<br>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会继续等待</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即Thread thread = new Thread();，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行</p><ul><li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li><p>阻塞状态<br>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】<br>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p><p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h3 id="Java-API层面"><a href="#Java-API层面" class="headerlink" title="Java API层面"></a>Java API层面</h3><p>根据<code>Thread.State 枚举，分为六种状态</code></p><ul><li><strong><code>新建状态</code>、<code>运行状态</code>(就绪状态, 运行中状态)、<code>阻塞状态</code>、<code>等待状态</code>、<code>定时等待状态</code>、<code>终止状态</code></strong></li></ul><ul><li><strong>NEW (新建状态)</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE (运行状态)</strong> 当调用了 start() 方法之后，注意，Java API 层面的<strong>RUNNABLE 状态</strong>涵盖了操作系统层面的 <strong>【就绪状态】、【运行中状态】和【阻塞状态】</strong>（由于 BIO 导致的线程阻塞，比如在读取文件时的操作系统层面的阻塞，也认为是运行状态，在 Java 里无法区分，仍然认为是可运行）</li><li><strong>BLOCKED (阻塞状态)</strong> ， <strong>WAITING (等待状态)</strong> ， <strong>TIMED_WAITING(定时等待状态)</strong> 都是 Java API 层面对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。</li><li><strong>TERMINATED (结束状态)</strong> 当线程代码运行结束</li></ul>]]></content>
    
    
    <summary type="html">线程的几种创建方式，线程设计原理，线程常用方法，多线程设计模式之两阶段终止模式</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized底层原理</title>
    <link href="http://ins1mn1a.github.io/2022/01/17/JUC/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/"/>
    <id>http://ins1mn1a.github.io/2022/01/17/JUC/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</id>
    <published>2022-01-17T10:26:55.173Z</published>
    <updated>2022-03-08T12:45:23.057Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Synchronized底层原理</li><li>Monitor 监视器、管程</li><li>轻量级锁</li><li>重量级锁</li><li>偏向锁</li></ul><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p><strong>对象头</strong>包含两部分：Mark Word和<strong>类型指针</strong> (Klass Word)</p><ol><li>Mark Word<ul><li>哈希值（HashCode），可以看作是堆中对象的地址</li><li>GC分代年龄（年龄计数器） (用于新生代from/to区晋升老年代的标准, 阈值为15)</li><li>锁状态标志 (用于JDK1.6对synchronized的优化 -&gt; 轻量级锁)</li><li>线程持有的锁</li><li>偏向线程ID (用于JDK1.6对synchronized的优化 -&gt; 偏向锁)</li><li>偏向时间戳</li></ul></li><li>类型指针<ul><li>确定该对象所属的类型。指向的其实是方法区中存放的类元信息<code>Class</code>字节码信息</li></ul></li></ol><p>说明：<strong>如果对象是数组，还需要记录数组的长度</strong></p><ul><li>以 <strong>32 位虚拟机</strong>为例,普通对象的对象头结构如下，其中的Klass Word为类型指针，指向方法区`对应的Class对象；</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230503852.png" alt="image-20220115230503852"></p><ul><li>数组对象</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230515921.png" alt="image-20220115230515921"></p><ul><li><strong>其中 Mark Word 结构为: 无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)</strong></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230553563.png" alt="image-20220115230553563"></p><ul><li>所以一个对象的结构如下：</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230631675.png" alt="image-20220115230631675"></p><h2 id="Monitor-原理-Synchronized底层实现-重量级锁"><a href="#Monitor-原理-Synchronized底层实现-重量级锁" class="headerlink" title="Monitor 原理 (Synchronized底层实现-重量级锁)"></a>Monitor 原理 (Synchronized底层实现-重量级锁)</h2><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p><strong>多线程同时访问临界区: 使用重量级锁</strong></p><ul><li>JDK6对Synchronized的优先状态：<code>偏向锁–&gt;轻量级锁–&gt;重量级锁</code></li></ul><p>每个Java对象都可以关联一个(操作系统的)<strong>Monitor</strong>。如果使用synchronized给对象上锁（<strong>重量级</strong>），该对象头的MarkWord中就被设置为指向Monitor对象的指针。</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115231347421.png" alt="image-20220115231347421"></p><p>上图是关联Monitor的原理图，可以理解为：</p><ul><li>Thread2最初执行到<strong>锁对象synchronized(obj)<strong>，会尝试让锁对象synchronized(obj)<strong>关联Monitor</strong>，如果</strong>关联成功</strong>，则将obj对象头的<strong>MarkWord</strong>字段<strong>指向Monitor的地址</strong>，同时将其后两位从<strong>00</strong>设置为10，<strong>Thread2</strong>会成为对应Monitor的<strong>Owner</strong>；</li><li>后续有<strong>Thread1</strong>也执行到了synchronized(obj)，会检查发现obj<strong>已经</strong>有了一个关联的monitor，其<strong>Owner为Thread2</strong>，然后Thread1也会同Monitor关联起来，只不过是<strong>和EntryList关联</strong>，会进入Monitor的EntryList<strong>阻塞（BLOCKED）</strong>起来，等待；</li><li>当<strong>Thread2执行完</strong>临界区代码后，Monitor的Owner就会空出来，此时就会<strong>通知EntryList阻塞队列</strong>的线程，这些线程经过<strong>竞争</strong>，得出新的<strong>Owner</strong>；</li><li>图中 WaitSet 中的线程是之前获得过锁，但条件不满足调用锁对象的wait方法进入 WAITING 状态的线程</li></ul><p><strong>注意：</strong></p><ul><li>synchronized 必须是进入同一个锁对象的 Monitor 才有上述的效果；也就要使用同一把锁</li><li>不加 synchronized的锁对象不会关联监视器，不遵从以上规则</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>它加锁就是依赖底层操作系统的 <code>mutex</code>相关指令实现, 所以会造成<code>用户态和内核态之间的切换</code>, 非常耗性能 !</p><ul><li>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗。</li></ul><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反编译的字节码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">stack&#x3D;2，locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">0: getstatic#2&#x2F;&#x2F; &lt;- lock引用( synchronized开始)</span><br><span class="line">3: dup</span><br><span class="line">4: astore_1&#x2F;&#x2F; lock引用-&gt; slot 1</span><br><span class="line">5: monitorenter&#x2F;&#x2F; 将lock对象Markword置为Monitor指针</span><br><span class="line">6: getstatic#3&#x2F;&#x2F; &lt;- i</span><br><span class="line">9: iconst_1&#x2F;&#x2F; 准备常数1</span><br><span class="line">10: iadd&#x2F;&#x2F; +1</span><br><span class="line">11: putstatic#3&#x2F;&#x2F; -&gt; i</span><br><span class="line">14: aload_1&#x2F;&#x2F; &lt;- lock引用</span><br><span class="line">15: monitorexit&#x2F;&#x2F; 将lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">16: goto24</span><br><span class="line">19: astore_2&#x2F;&#x2F; e -&gt; slot 2</span><br><span class="line">20: aload_1&#x2F;&#x2F; &lt;- lock引用</span><br><span class="line">21: monitorexit&#x2F;&#x2F; 将lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">22: aload_2&#x2F;&#x2F; &lt;- slot 2 (e)</span><br><span class="line">23: athrow&#x2F;&#x2F; throw e</span><br><span class="line">24: return</span><br><span class="line">    Exception table:</span><br><span class="line">        fromtotargettype</span><br><span class="line">            61619any</span><br><span class="line">            192219any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 6</span><br><span class="line">        line 10: 14</span><br><span class="line">        line 11: 24</span><br><span class="line">    LocalVariableTable:</span><br></pre></td></tr></table></figure><p>上面除了体现了正常执行的代码以外，还体现了异常情况。在16的时候goto到24。Exception table描述了异常的情况处理从19到22。</p><p>方法级别的 synchronized 不会在字节码指令中有所体现</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗。所以MarkWord对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁</p><p>轻量级锁用于优化重量级锁</p><p>通过<code>锁记录</code>的方式, 场景 : <strong>多个线程交替进入临界区</strong></p><ul><li><strong><code>轻量级锁的使用场景</code>: 如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用<code>轻量级锁来进行优化</code>。</strong></li></ul><ul><li>轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code> (jdk6对synchronized的优化)，假设有两个方法同步块，利用同一个对象加锁</li></ul><p>在method1加完锁的同时，调用了method2又会加锁synchronized(obj)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 B</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次执行到synchronized代码块时，都会在<code>栈帧中</code>创建<code>锁记录（Lock Record）对象</code>，锁记录内部最开始储存的是<code>lock record的地址 00</code>和<code>锁对象引用reference</code>。还有一个Object锁对象，锁对象头中存储的<strong>MarkWord</strong>（MarkWord包含了HashCode，分代年龄，偏向锁，加锁状态位），Klass Word表示是哪一类的对象。</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092015889.png" alt="image-20220116092015889"></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092231673.png" alt="image-20220116092231673"></p><ul><li>让锁记录中的<strong>Object reference</strong>指向<strong>锁对象地址</strong>，并且尝试用<strong>CAS(compare and swap)<strong>将栈帧中的</strong>锁记录的的地址</strong>(lock record 地址 00)替换Object对象的<strong>Mark Word</strong>，将Mark Word 的值存入锁记录原先存地址的地方(lock record地址 00)，这个交换是一个原子性的操作。这两个字段的后两位标识着一个状态，起到一个标志作用。01表示无锁，00表示轻量级锁，所以在交换成功后，Object存Mark Word的地方后两位就变成了00，就是一个轻量级锁的状态</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092637419.png" alt="image-20220116092637419"></p><p>如果cas<strong>替换成功</strong>，那么对象的对象头储存的就是锁记录的地址和状态00，表示由该线程给对象加锁</p><ul><li>线程中锁记录，记录了锁对象的锁状态标志；锁对象的对象头中存储了锁记录的地址和状态, 标志哪个线程获得了锁</li><li>此时栈帧中存储了对象的对象头中的锁状态标志,年龄计数器,哈希值等; 对象的对象头中就存储了栈帧中锁记录的地址和状态00, 这样的话对象就知道了是哪个线程锁住自己。</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116093326551.png" alt="image-20220116093326551"></p><p>如果cas<strong>替换失败</strong>，有两种情况 : ① 锁膨胀 ② 重入锁失败</p><p>1、如果是其它线程已经持有了该Object的轻量级锁（观察到Object对象头中已经存储了别的线程的锁记录地址 00,指向了其他线程），表示有竞争，将进入锁膨胀阶段</p><p>2、如果是自己的线程已经执行了synchronized进行加锁，那么再添加一条 Lock Record 作为重入锁的计数，同样按照正常的流程去cas交换，但这次交换肯定是失败的，发现这个锁是自己这个线程加的，其中记录锁地址的地方为null。（线程多次加锁, <strong>锁重入</strong>）</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116093748640.png" alt="image-20220116093748640"></p><p>在上面代码中,临界区中又调用了method2，method2中又进行了一次synchronized加锁操作， 此时就会在虚拟机栈中再开辟一个method2方法对应的栈帧(栈顶)， 该栈帧中又会存在一个独立的Lock Record，此时它发现对象的对象头中指向的就是自己线程中栈帧的锁记录; 加锁也就失败了。这种现象就叫做<strong>锁重入</strong>，线程中有多少个锁记录，就能表明该线程对这个对象加了几次锁 (锁重入计数)</p><ul><li><p>当<code>线程退出synchronized代码块</code>的时候，如果获取的是取值为 null 的锁记录，表示有<code>锁重入</code>，这时重置锁记录，表示重入计数减一</p></li><li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null；那么使用cas将Mark Word的值恢复给对象，将直接替换的内容还原。</p><ul><li>成功则解锁成功 (轻量级锁解锁成功)</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程 (Monitor流程)</li></ul></li></ul><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>锁膨胀就是当Thread0已经让某个对象加了轻量级锁，Thread0里的锁记录存着对象的MarkWord，锁对象obj的MarkWord又存着锁记录的地址，这个时候有一个Thread1也执行到了synchronized，也想对obj进行加锁，但是肯定是加锁失败的，Thread1发现锁对象的MarkWord里已经是00了，即已经是轻量级锁了。</p><ul><li><p><strong>因为轻量级锁没有阻塞队列的概念，因此会进入锁膨胀的过程，让锁成为一个重量级锁。</strong>这时Thread1就会为锁对象obj申请一个monitor，让obj的MarkWord执行monitor的地址，并且后两位为01表示重量级锁，monitor将Owner设为Thread0，Thread1则进入Monitor的EntryList阻塞起来</p></li><li><p>在<strong>Thread0执行完毕</strong>后，想要恢复锁记录的地址和MarkWord的时候，肯定会恢复失败，发现原来obj的MarkWord已经是<strong>01重量级锁</strong>了，即进行了<strong>锁膨胀</strong>，因此Thread0<strong>进入重量级锁的解锁流程</strong>，会根据<strong>obj的MarkWord</strong>（这时指向的是对象obj的Monitor）找到对应的monitor，将monitor的Owner设为空，<strong>唤醒EntryList</strong>中的<strong>Thread1</strong>。</p></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116100043133.png" alt="image-20220116100043133"></p><h2 id="自旋锁优化（优化重量级锁竞争）"><a href="#自旋锁优化（优化重量级锁竞争）" class="headerlink" title="自旋锁优化（优化重量级锁竞争）"></a>自旋锁优化（优化重量级锁竞争）</h2><ul><li>发生<strong>重量级锁竞争</strong>的时候，还可以使用<strong>自旋</strong>来进行优化 (不加入Monitor的阻塞队列EntryList中)，如果当前线程<strong>自旋成功</strong>（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以<strong>不用进行上下文切换</strong>(持锁线程执行完synchronized同步块后，释放锁，Owner为空，唤醒阻塞队列来竞争，胜出的线程得到cpu执行权的过程) 就获得了锁</li><li>优化的点: <strong>不用将线程加入到阻塞队列, 减少cpu切换</strong>。</li></ul><p><strong>自旋成功的情况：</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116101816612.png" alt="image-20220116101816612"></p><p><strong>自旋失败的情况：</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116101902140.png" alt="image-20220116101902140"></p><ul><li><p><strong>自旋会<code>占用 CPU 时间</code>，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势</strong>。</p></li><li><p>在 <code>Java 6 之后自旋锁是自适应</code>的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能。</p></li></ul><h2 id="偏向锁-biased-lock-用于优化轻量级锁重入"><a href="#偏向锁-biased-lock-用于优化轻量级锁重入" class="headerlink" title="偏向锁 (biased lock) (用于优化轻量级锁重入)"></a>偏向锁 (biased lock) (用于优化轻量级锁重入)</h2><ul><li>场景: 没有竞争的时候, 一个线程中多次使用synchronized需要重入加锁的情况; (只有一个线程进入临界区)</li></ul><p>在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭，将进入临界区的线程的ID, 直接设置给锁对象的Mark Word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了。</p><ul><li>在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行CAS替换操作，这是有点耗时。</li><li>那么java6开始引入了偏向锁，将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了</li><li><strong>升级为轻量级锁</strong>的情况 (会进行偏向锁撤销)：获取偏向锁的时候, 发现线程ID不是自己的, 此时通过<strong>CAS替换操作, 操作成功</strong>了, 此时该线程就获得了锁对象。( <strong>此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁</strong>)</li><li><strong>升级为重量级锁</strong>的情况 (会进行偏向锁撤销) : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过<strong>CAS替换操作, 操作失败</strong>了, 此时说明发生了锁竞争。( <strong>此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁</strong>)</li></ul><h2 id="偏向、轻量级、重量级锁关系"><a href="#偏向、轻量级、重量级锁关系" class="headerlink" title="偏向、轻量级、重量级锁关系"></a>偏向、轻量级、重量级锁关系</h2><p>最开始synchronized锁只有重量级锁，依赖操作系统的mutex指令，需要用户态和内核态切换，性能损耗明显。重量级锁需要用到monitor对象，而偏向锁则是MarkWord中记录线程的ID，如果某个线程发现Mark Word线程的ID是自己，就不需cas交换锁记录地址和MarkWord。如果不是发现对象的MarkWord中线程ID不是自己，此时就需要通过CAS替换操作，如果<strong>操作成功</strong>，就说明有<strong>多个线程访问临界区</strong>，但是是<strong>交替进行</strong>的，就<strong>撤销偏向锁</strong>，<strong>升级为轻量级锁</strong>，如果<strong>操作失败</strong>，就说明有<strong>多个线程方法临界区</strong>，并且存<strong>在锁竞争</strong>，就撤销偏向锁，<strong>升级为重量级锁</strong>。</p><p><strong>偏向锁</strong>是将锁对象<strong>MarkWord的线程ID</strong>和自己的线程<strong>ID比对</strong>，<strong>轻量级锁</strong>则是将MarkWord和Lock Record进行交换，采用<strong>CAS+自旋</strong>的方式判断是否存在竞争，然后加重量级锁，<strong>重量级锁</strong>则是采用<strong>Monitor</strong>，用<strong>阻塞队列</strong>的形式，将后续线程阻塞起来。</p><ol><li>只有一个线程进入临界区—&gt;偏向锁</li><li>多个线程交替进入临界区—&gt;轻量级锁</li><li>多个线程竞争进入临界区—&gt;重量级锁</li></ol><h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p><strong>64bit虚拟机</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116112754583.png" alt="image-20220116112754583"></p><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</li></ul><ul><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，最后2位为状态（00）</li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，最后2位为状态(10)</li></ul><p>如果开启了<strong>偏向锁</strong>（<strong>默认开启偏向锁</strong>），在创建对象时，对象的Mark Word后三位应该是101</p><p>但是偏向锁<strong>默认是有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态。如果想避免延迟，可以添加虚拟机参数来禁用延迟：</p><p><strong><code>-XX:BiasedLockingStartupDelay=0</code></strong></p><p>打印出101，这时它的hashcode、age都为0，表示它现在是一种<strong>可以偏向的状态</strong>，或者叫匿名偏向锁的状态，也就是说biased_lock位是1，可以偏向，要<strong>真正加锁</strong>还**需要加上synchronized(obj)**。</p><p>这加了synchronized(obj)之后，才是真正加了偏向锁的状态。</p><p>可以用org.openjdk.jol包打印信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">log.debug( classLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">synchronized</span> (d)&#123;</span><br><span class="line">log.debug( ClassLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">log.debug( classLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="撤销偏向锁-hashcode方法-了解"><a href="#撤销偏向锁-hashcode方法-了解" class="headerlink" title="撤销偏向锁-hashcode方法 (了解)"></a>撤销偏向锁-hashcode方法 (了解)</h3><ul><li>测试 <code>hashCode</code>：当<code>调用对象的hashcode方法</code>的时候就会<code>撤销这个对象的偏向锁</code>，<strong>因为使用偏向锁时没有位置存<code>hashcode</code>的值了</strong></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116115419509.png" alt="image-20220116115419509"></p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>在下面的代码中，b方法采用了synchronized，但可以发现它加的对象锁其实并没有启到作用。</p><p>JIT即时编译器会优化热点代码，JIT借助<strong>逃逸分析</strong>发现对象o不能逃离这个方法，对这样的对象加锁是没有意义的，因此JIT即时编译器会把synchronized优化掉，进行锁消除。</p><p>我们也可以在测试的时候加上JVM参数，让它不进行锁消除，<code>-XX:-EliminateLocks</code></p><p>字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，**<code>同步省略（锁消除）操作是在解释运行时发生的</code>**</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">            x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="wait、notify"><a href="#wait、notify" class="headerlink" title="wait、notify"></a>wait、notify</h2><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220117094637795.png" alt="image-20220117094637795"></p><p>Thread0线程<strong>获取到了对象Obj的锁</strong>，成为Monitor的Owner时候，发现自己执行synchronized代码块条件不满足，这时它就会调用**obj.wait()**方法，进入到Monitor的WaitSet集合，此时Thread0处于WAITING状态。</p><ul><li>处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。</li><li>但是有所区别：<ul><li>BLOCKED状态的线程是在竞争锁对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身的原因无法执行synchroized的临界区资源需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li><li><strong>BLOCKED线程</strong>会在<strong>Owner线程释放锁</strong>的时候被<strong>唤醒</strong></li><li><strong>WATITING线程</strong>会在Owner线程调用锁对象的<strong>notify</strong>或者<strong>notifyALL</strong>方法时唤醒，但唤醒后并不意味着立刻获得锁，仍需<strong>进入EntryList重新竞争</strong></li></ul></li></ul><h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><p>下面的三个方法都是Object中的方法; 通过锁对象来调用</p><p>**wait()**：让获得对象锁的线程到waitSet中一直等待</p><p>**wait(long n)**：当该等待线程没有被notify, 等待时间到了之后, 也会自动唤醒</p><p>**notify()**：让获得对象锁的线程, 使用锁对象调用notify去waitSet的等待线程中挑一个唤醒</p><p>**notifyAll()**：让获得对象锁的线程, 使用锁对象调用notifyAll去唤醒waitSet中所有的等待线程</p><p>它们都是线程之间进行协作的手段, 都属于Object对象的方法, 必须获得此对象的锁, 才能调用这些方法</p><p><strong>注：只有当对象被锁以后(成为Owner)，才能调用wait和notify方法</strong></p><p>拥有锁才能wait</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">LOCK.wait();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sleep-long-n-和-Wait-long-n-的区别"><a href="#Sleep-long-n-和-Wait-long-n-的区别" class="headerlink" title="Sleep(long n) 和 Wait(long n)的区别"></a>Sleep(long n) 和 Wait(long n)的区别</h3><ul><li><p>不同点</p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li><strong>Sleep</strong>在阻塞的时候<strong>不会释放锁</strong>，而<strong>Wait</strong>在阻塞的时候会<strong>释放锁</strong> (不释放锁的话, 其他线程就无法唤醒该线程了)</li><li>Sleep方法不需要与synchronized一起使用，而Wait方法需要与synchronized一起使用（wait/notify等方法, <strong>必须要使用对象锁来调用</strong>）</li></ul></li><li><p>相同点</p><ul><li>阻塞状态都为TIMED_WAITING (限时等待)</li></ul></li></ul><h3 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3><p>对象的WaitSet中有多个等待线程，而<strong>notify只能挑一个唤醒</strong>，并<strong>不能指定唤醒线程</strong>，所以有可能会出现<strong>虚假唤醒的状态</strong>。采用notifyAll会唤醒所有线程，但是这样会把其他条件可能仍然不满足的线程唤醒。对于那些线程来说也是一个虚假唤醒。</p><p>因此，那些线程必须得把<strong>If(条件)+wait的方法</strong>改为<strong>while(条件)+wait</strong>的方法，避免采用if判断语句被虚假唤醒后直接结束了，让其<strong>被虚假唤醒后</strong>发现仍然条件不满足，会<strong>继续调用wait方法</strong>再次等待。</p><h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><p>这是一种多线程设计模式，rpc框架的调用中就使用到了这种模式。</p><p>一个线程等待另一个线程的执行结果，一对一的情况，也就是一个生产者对应一个消费者。</p><p>线程2等待线程1执行完毕，线程1执行完后会改变它俩共享变量的状态，线程2据此来判断消费。同时还可以设置超时时间，线程2等到一定时间后就不再等待，退出while循环。</p><p>**join(long millis)**方法和future的原理都用到了这种模式</p><p>join方法设置了超时时间millis，判断是否isAlive()，如果线程还存活，就最多等待millis，<strong>注意每次循环等待时间为delay而不是millis</strong>，防止被虚假唤醒后，下次的等待时间仍然是millis，这显然不对</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多任务版的保护性暂停就需要把公共的锁对象GuardedObject，抽象出来到一个整体，比如一个邮箱，然后里面的每一个对应的信件GuardedObject就是一个锁。</strong></p><h2 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h2><p>这种生产者/消费者模式<strong>不需要一一对应</strong>，也就是说不需要一个生产者对应一个消费者，可以是多个生产者生产，只要生产了，消费者都能用。</p><p>左边三个生产者，生产了就put进中间的<strong>消息队列</strong>，消息队列存放生产者生产出的产品，那右边就一个消费者，只要消息队列里面有产品，那就可以消费。</p><p>这样生产者只关注自己能不能产生结果，消费者只关注自己能不能消费结果。</p><p>消息队列是有容量限制的，不能消费空数据，容量满也不能产生新数据。</p><p>RabbitMQ的原理也类似，但是MQ是实现进程之间的通信。</p><h2 id="park和unpark方法"><a href="#park和unpark方法" class="headerlink" title="park和unpark方法"></a>park和unpark方法</h2><ul><li>park和unpark是LockSupport的方法，可以<strong>指定线程</strong>唤醒。</li><li>park方法是让当前线程进入WAITING状态，unpark方法是让指定线程唤醒</li></ul><p><strong>但是unpark方法可以先执行，后再进行park</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Thread t1 start&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure><h3 id="park、unpark原理"><a href="#park、unpark原理" class="headerlink" title="park、unpark原理"></a>park、unpark原理</h3><p>每一个线程都有自己的<strong>Parker对象</strong>，由三部分组成：</p><ul><li>_counter：相当于一个信号量，只有0和1的状态</li><li>_cond：条件变量，相当于线程的阻塞队列</li><li>_mutex：互斥锁，关联一个 _cond</li></ul><h4 id="先调用park再调用unpark"><a href="#先调用park再调用unpark" class="headerlink" title="先调用park再调用unpark"></a>先调用park再调用unpark</h4><p>调用<strong>park</strong>方法：</p><ul><li><strong>线程t1</strong>，先<strong>调用park方法</strong>，检查_counter的值，发现为0，这时会获得一个互斥锁 _mutex，然后线程进入cond等待队列阻塞，同时还需要<strong>再设置counter为0</strong></li></ul><p>调用**unpark(t1)**方法：</p><ul><li><strong>设置counter为1</strong>，<strong>唤醒</strong>cond中的<strong>线程t1</strong>，t1恢复运行，设置counter为0</li></ul><h4 id="先调用unpark再调用park"><a href="#先调用unpark再调用park" class="headerlink" title="先调用unpark再调用park"></a>先调用unpark再调用park</h4><ul><li>设置counter为1，当前线程调用park方法，检查counter，无需阻塞继续运行，设置counter为0</li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2>]]></content>
    
    
    <summary type="html">Java对象MarkWord，偏向锁、轻量级锁、重量级锁、锁膨胀、</summary>
    
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="http://ins1mn1a.github.io/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ins1mn1a.github.io/2022/01/11/Bug%E4%B9%8B%E7%8E%8B/log4j%E7%9A%84mave%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>http://ins1mn1a.github.io/2022/01/11/Bug%E4%B9%8B%E7%8E%8B/log4j%E7%9A%84mave%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-11T14:18:59.692Z</published>
    <updated>2022-01-11T14:38:18.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ClassNotFoundException：org-apache-log4j-logger"><a href="#ClassNotFoundException：org-apache-log4j-logger" class="headerlink" title="ClassNotFoundException：org.apache.log4j.logger"></a>ClassNotFoundException：org.apache.log4j.logger</h3><p>最初的问题是报错ClassNotFoundException：org.apache.log4j.logger</p><p>说明在maven依赖中有某个依赖用到了org.apache.log4j.logger，而maven依赖中又没有引入log4j</p><p>我的项目中是有一个dubbo的依赖，排除了servlet-api防止依赖冲突，没有排除log4j，并且没有引入log4j</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dubbo.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，解决方法有两种</p><ol><li>直接把dubbo依赖中的log4j排除</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.dubbo.springboot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>不排除dubbo中的log4j，增加一个log4j依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="IllegalArgumentException-LoggerFactory-is-not-a-Logback-LoggerContext-but-Logback-is-on-the-classpath"><a href="#IllegalArgumentException-LoggerFactory-is-not-a-Logback-LoggerContext-but-Logback-is-on-the-classpath" class="headerlink" title="IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath."></a>IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath.</h3><p>完整报错信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;ASUS&#x2F;.m2&#x2F;repository&#x2F;org&#x2F;slf4j&#x2F;slf4j-log4j12&#x2F;1.7.30&#x2F;slf4j-log4j12-1.7.30.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;ASUS&#x2F;.m2&#x2F;repository&#x2F;ch&#x2F;qos&#x2F;logback&#x2F;logback-classic&#x2F;1.2.3&#x2F;logback-classic-1.2.3.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing implementation</span><br></pre></td></tr></table></figure><p>这个问题是因为slf4j的依赖冲突，spring-boot-starter正常打印日志是采用的logback，在引入了slf4j-log4j12的情况下会有两个绑定，</p><p>根据提示信息就可以发现，有两种解决方案：</p><ol><li>移除slf4j-log4j12</li><li>把spring-boot-starter-logging移除</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ClassNotFoundException：org-apache-log4j-logger&quot;&gt;&lt;a href=&quot;#ClassNotFoundException：org-apache-log4j-logger&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>经典排序算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.212Z</published>
    <updated>2022-03-08T12:49:10.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="部分排序算法"><a href="#部分排序算法" class="headerlink" title="部分排序算法"></a>部分排序算法</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆是一种数据结构，一种叫做完全二叉树的数据结构。</p><p>大顶堆：每个节点的值都大于或者等于它的左右子节点的值。</p><p>小顶堆：每个节点的值都小于或者等于它的左右子节点的值。</p><h3 id="最大堆的构建过程"><a href="#最大堆的构建过程" class="headerlink" title="最大堆的构建过程"></a>最大堆的构建过程</h3><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110195006939.png" alt="image-20211110195006939"></p><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110194953869.png" alt="image-20211110194953869"></p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ol><li>将待排序的序列构建成一棵树，然后最大堆化，形成一个大顶堆。这样，大顶堆的根结点一定是当前序列中最大的一个元素。</li><li>将根结点取出，将堆的最后一个元素换到根结点处，然后重新构建成一个大顶堆，同样使得最大的元素位于根结点。</li><li>重复步骤2，每次都能获得一个最大值，这样就排成了一个有序的序列。</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">&#123;</span><br><span class="line">l&lt;-LEFT(i)</span><br><span class="line"> r&lt;-RIGHT(i)</span><br><span class="line"><span class="keyword">if</span> l &lt;= heap-size[A] and A[l]&gt;A[i]</span><br><span class="line">then largest&lt;-l</span><br><span class="line"><span class="keyword">else</span> largest&lt;-i</span><br><span class="line"><span class="keyword">if</span> r &lt;= heap-size[A] and A[r]&gt;A[largest]</span><br><span class="line">then largest&lt;-r</span><br><span class="line"><span class="keyword">if</span> largest ≠ i</span><br><span class="line">then exchange A[i]&lt;-&gt;A[largest]</span><br><span class="line">MAX-HEAPIFY(A,largest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">&#123;</span><br><span class="line">heap-size[A] &lt;- length [A]</span><br><span class="line"> <span class="keyword">for</span> i &lt;- length[A]/<span class="number">2</span> downto <span class="number">1</span></span><br><span class="line"><span class="keyword">do</span> MAX-HEAPIFY(A,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HEAPSORT(A)</span><br><span class="line">&#123;</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line"><span class="keyword">for</span> i length[A] downto <span class="number">2</span></span><br><span class="line"><span class="keyword">do</span> exchange A[<span class="number">1</span>] A[i]</span><br><span class="line">heap-size[A]  heap-size[A]-<span class="number">1</span></span><br><span class="line">MAX-HEAPIFY(A,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>计数排序不基于比较，它只适用于待排序序列数值范围相差不大的情况下，否则，会造成大量的数组空间的浪费。</p><p>待排序序列A[1:n]，将辅助空间数组C[1:k]初始化为0，其中k为A[1:n]的最大取值，也可以直接设为n。对数组A的每一个数遍历一次，将数作为数组C[1:k]的的下标值，将对应值加1，这样，数组C[1:k]就记录了数组A[1:n]中每个数的出现次数，即A[i]的出现次数为C[ A[i] ]。然后，只需要对数组C遍历，每次遍历到C[i]用一个while循环，做C[i]–，直到C[i]=0。</p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110204919521.png" alt="image-20211110204919521"></p><p>插入排序    稳定</p><p>快速排序    不稳定    在位</p><p>归并排序    稳定        不在位</p><p>堆排序        不稳定    在位</p><p>计数排序    稳定        不在位</p><p>基数排序    稳定        不在位</p>]]></content>
    
    
    <summary type="html">包括堆排序，计数排序等</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.180Z</published>
    <updated>2022-03-08T12:49:10.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="回溯法的基本思想"><a href="#回溯法的基本思想" class="headerlink" title="回溯法的基本思想"></a>回溯法的基本思想</h2><p>回溯法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。</p><p>回溯法从开始结点（根结点）出发，以深度优先方式搜索整个解空间。这个开始结点成为活结点，同时也成为当前的扩展结点。在当前扩展结点处，搜索向纵深方向移至一个新结点，同时，也成为当前的扩展结点。</p><h2 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h2><p>当所给的问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间树称为子集树。</p><p>例如：n个物品的0-1背包问题所相应的解空间树是一棵子集树，这类子集树通常有2^n个叶结点，其结点总数为2^(n+1)-1。遍历子集树的算法需要Ω(2^n)计算时间。但是，回溯法我们一般可以通过一种剪枝策略对这棵树进行剪枝，从而减少遍历的时间。</p><p>用回溯法搜索子集树的一般算法可以描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        output(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=i;</span><br><span class="line">        <span class="keyword">if</span>(constraint(t)&amp;&amp;bound(t))</span><br><span class="line">            backtrack(t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h2><p>当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。</p><p>排列树通常有n!个叶结点，因此遍历需要Ω(n!)计算时间。同样，我们可以通过一种剪枝策略对这棵树进行剪枝，从而减少遍历的时间。</p><p>用回溯法搜索排列树的一般算法可以描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        output(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x[t],x[i]);</span><br><span class="line">        <span class="keyword">if</span>(constraint(t)&amp;&amp;bound(t))</span><br><span class="line">            backtrack(t+<span class="number">1</span>);</span><br><span class="line">        swap(x[t],x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P和NP问题"><a href="#P和NP问题" class="headerlink" title="P和NP问题"></a>P和NP问题</h1><p>如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。</p><p>NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。</p>]]></content>
    
    
    <summary type="html">回溯法，包括子集树和排列树</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.178Z</published>
    <updated>2022-03-08T12:49:11.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>二分搜索算法是分治法的一个典型策略。</p><p>给定已经排好序的n个元素a[0 : n-1]，现在要从中找出一个特定的元素x。</p><p>首先容易想到的是用顺序搜索方法，逐个比较a[0 : n-1]中元素，直到找到x或者搜索遍整个数组后确定x不在其中。这个方法没有很好地利用n个元素已经排好序这个条件，因此在最坏的情况下，顺序搜索方法需要O(n)次比较。</p><p>二分搜索方法充分利用了元素间的次序关系，采用分治策略，可以在最坏情况下用O(log n)时间找到元素x。</p><p>它的基本思想是：将这n个元素分成个数大致相同的两半，取a[n/2]与x进行比较，如果a[n/2]==x，则程序结束；如果x&lt;a[n/2]，只需要在a[0 : n/2]中再利用这种方法进行搜索；如果x&gt;a[n/2]，只需要在a[n/2 : n]中再利用这种方法进行搜索；</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==a[middle]) <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;a[middle]) right=middle-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left=middle+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易看出，每执行一次算法的while循环，待搜索的数组就将减少一半。因此，在最坏的情况下，while循环被执行O(log n)次。循环体内运算需要O(1)时间，因此整个算法在最坏的情况下时间复杂性为O(log n)。</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>合并排序算法是用分治策略实现对n个元素进行排序的算法。</p><p>其基本思想是：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并为所要求排好序的集合。下图可以很好的理解合并算法的分治思想。</p><blockquote><p>注：图源网络(dreamcatcher-cx)</p></blockquote><p><img src="/../../img/markdown_img/%E7%AE%97%E6%B3%95.assets/image-20211106093310191.png" alt="image-20211106093310191"></p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(a,left,mid-<span class="number">1</span>);</span><br><span class="line">        mergeSort(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(a,b,left,mid,right);<span class="comment">//合并到数组b</span></span><br><span class="line">        copy(a,b,left,right);<span class="comment">//复制回数组a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">                b[t++] = a[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b[t++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//左边剩余元素</span></span><br><span class="line">            b[t++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//右边剩余元素</span></span><br><span class="line">            b[t++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的merge方法，就是将一组一组子集合递归的合并到数组b。合并排序算法对n个元素进行排序，在最坏情况下所需的计算时间为T(n)满足：<strong>T(n)=2T(n/2)+O(n)  n&gt;1</strong></p><p>求解递归方程可知T(n)=O(n log n)。但是排序算法的时间下界为Ω(n log n)，故合并排序算法是渐进最优算法。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>快速排序算法是基于分治算法的另一个排序算法。</p><p>对于输入的子数组a[p : r]，按以下步骤进行排序：</p><ol><li>分解：以a[p]为基准元素将a[p : r]划分为3段a[p : q-1]，a[q]和a[q+1 : r]，并且让a[p : q-1]中的任何元素都小于等于a[q]，a[q+1 : r]中的任何元素都大于等于a[q]。通俗的来说就是，小于基准的放左边，大于基准的放右边。</li><li>递归求解：通过递归的调用快排算法，分别对a[p : q-1]，a[q+1 : r]两段递归调用算法。</li><li>合并：对于a[p : q-1]，a[q+1 : r]的排序是就地进行的，所以在a[p : q-1]，a[q+1 : r]排好序后不需要执行任何计算，原数组就排好序。</li></ol><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=partition(p,r);</span><br><span class="line">        qSort(p,q-<span class="number">1</span>);</span><br><span class="line">        qSort(q+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=p;</span><br><span class="line">    <span class="keyword">int</span> right=r;</span><br><span class="line">    <span class="keyword">int</span> x=a[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=x)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            a[left]=a[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;=x)</span><br><span class="line">            left--; </span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            a[right]=a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    a[left]=x;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的关键在于partition中以确定的基准元素a[p]进行划分。partition方法每次都以x=a[p]为基准，然后左边left和右边right移位，右边开始，如果a[right]比基准元素x大或者等于，那么right继续移位；如果a[right]&lt;x，那么则将当前的a[right]赋值到a[left]，因为left此时并未开始移位，未动，因此是就地排序。赋值完成后left就开始移动，同理。</p><p>快速排序最差情况划分过程产生的两个区域分别包含n-1个元素和1个元素，并且每一次都出现这种不对称的划分，则有T(n)=T(n-1)+O(n)；解得最坏情况下T(n)=O(n^2)；</p><p>快排最好和平均情况下的时间复杂度都是O(n log n)；</p><p>快速排序算法是不稳定的算法。</p><h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>元素选择的问题一般是：给定线性序列有n个元素，一个整数k，找到这n个元素中第k小的元素。</p><p>线性时间选择算法实际上是模仿快速排序算法设计出来的。其基本思想也是对输入数组进行递归划分。随机选择一个下标 i 作为基准 a[i]，将小于 a[i] 的放左边，大于 a[i] 的放在右边。j 为划分后左边有的元素个数，这样只需要比较k和j的大小，如果k &lt;= j，那么说明第k小的元素一定在基准左边，接下来就只需要对左半部分递归找第 k 小的元素即可；同理，如果<strong>k&gt;j</strong>，说明，第k小的元素在基准右边，那么就对右半部分递归找第<strong>k-j</strong>小的元素即可。</p><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomizedSelect</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=randomizedPartition(p,r);</span><br><span class="line">    <span class="keyword">int</span> j=i-p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=j)</span><br><span class="line">        <span class="keyword">return</span> randomizedSelect(p,i,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> randomizedSelect(i+<span class="number">1</span>,r,k-j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=random(p,r);</span><br><span class="line">    MyMath.swap(a,i,p);</span><br><span class="line">    <span class="keyword">return</span> partiton(p,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，最坏情况下randomizedSelect需要Ω(n^2)计算时间，这里的partition函数同快速排序算法的partition函数是一致的。由于随机划分算法randomizedPartition使用了随机数产生器random，它能随机的产生p和r之间的一个随机整数，因此，randomizedPartition产生的划分基准是随机的，在这个条件下，可以证明，算法randomizedSelect可以在O(n)平均时间内找出n个输入元素中第k小的数。</p><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>问题描述：</p><p>给定由n个整数(可负)组成的序列a1 ,a2 ,…,an，求该序列形如∑ak的子段和的最大值。当所有整数均为负整数时定义其最大子段和为0。 依此定义，所求的最优值为<img src="/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B../../img/markdown_img/%E7%AE%97%E6%B3%95.assets/image-20211106133058064.png" alt="image-20211106133058064"></p><p>例如,当(a1 ,a2 ,…,a6 ）= (-2, 11, -4, 13, -5, -2)时，最大子段和为 20 ( 11, -4, 13)。</p><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p>如果将所给的序列a[1 :  n]分为长度相同的两段a[1 : n/2]、a[n/2+1 : n]，分别求出这两段的最大子段和，则a[1 : n]的最大子段和分为三种情况：</p><ol><li>a[1 : n]的最大子段和同a[1 : n/2]的最大子段和相同。</li><li>a[1 : n]的最大子段和同a[n/2 : n]的最大子段和相同。</li><li>a[1 : n]的最大子段和等于位于a[1 : n/2]的子段和和位于a[n/2+1 : n]的子段和的和</li></ol><p>1和2的情况可以直接递归求得，第3种情况，a[n/2]和a[n/2+1]在最优子序列之中，我们只需要计算出左边a[1 : n/2]从n/2开始的最大子段和s1，右边a[ n/2+1 : n]从n/2+1开始的最大子段和，然后将两者相加s=s1+s2；s即为第3种情况的最优值。</p><h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubSum</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)</span><br><span class="line">        <span class="keyword">return</span> a[left]&gt;<span class="number">0</span>?a[left]:sum;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftSum=MaxSubSum(a,left,mid);</span><br><span class="line">        <span class="keyword">int</span> rightSum=MaxSubSum(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempS=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=left;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tempS+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(tempS&gt;s1)</span><br><span class="line">                s1=tempS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s2=<span class="number">0</span>;</span><br><span class="line">        tempS=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempS+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(tempS&gt;s2)</span><br><span class="line">                s2=tempS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回三者中最大的</span></span><br><span class="line">        <span class="keyword">return</span> max(leftSum,rightSum,s1+s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(n)=2T(n/2)+O(n)，因此时间复杂度为O(n log n)</p>]]></content>
    
    
    <summary type="html">分治法，包括二分搜索算法，合并排序，快排，线性时间选择，最大字段和</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-09T02:45:48.176Z</published>
    <updated>2022-03-08T12:49:10.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适用于动态规划法求解的问题，经分解得到的子问题往往不是相互独立的。在用分治法求解的时候，有些子问题被重复计算了许多次。如果能够保存已解决的子问题的答案，而在需要的时候再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间的算法。</p><p>动态规划算法适用于解最优化问题，通常可以按以下步骤设计的动态规划算法：</p><ol><li>找出最优解的性质，并刻画其结果特征。</li><li>递归地定义最优值。</li><li>以自底向上的方式计算出最优值。</li><li>根据计算最优值时得到的信息，构造最优解。</li></ol><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>先来看一下最大子段和用分治法思想的分析：</p><p>如果将所给的序列a[1 :  n]分为长度相同的两段a[1 : n/2]、a[n/2+1 : n]，分别求出这两段的最大子段和，则a[1 : n]的最大子段和分为三种情况：</p><ol><li>a[1 : n]的最大子段和同a[1 : n/2]的最大子段和相同。</li><li>a[1 : n]的最大子段和同a[n/2 : n]的最大子段和相同。</li><li>a[1 : n]的最大子段和等于位于a[1 : n/2]的子段和和位于a[n/2+1 : n]的子段和的和</li></ol><p>1和2的情况可以直接递归求得，第3种情况，a[n/2]和a[n/2+1]在最优子序列之中，我们只需要计算出左边a[1 : n/2]从n/2开始的最大子段和s1，右边a[ n/2+1 : n]从n/2+1开始的最大子段和，然后将两者相加s=s1+s2；s即为第3种情况的最优值。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>从上述分治法思想注意到，我们可以记b[ j ]为1 ~ j 中的最大子段和，其中j∈[1，n]；<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106135813232.png" alt="image-20211106135813232"></p><p>这样，那么所求的1 ~ n 中的最大子段和就为 i~j 的和可以表示为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106135834099.png" alt="image-20211106135834099"></p><p>意思就是，j从1到n，依次找到最大子段和。</p><p>由b[ j ]的定义易知，当b[ j-1 ]&gt;0 时b[ j ]= b[ j-1 ] +a[j]，否则 b[ j ]=a[ j ]。 由此可得计算b[j]的动态规划递归式：</p><p><strong>b[j] = max {b[j-1] +a[j], a[j] } ，1≤j ≤ n</strong></p><p>当前的最优解，就等于前一个最优解加上当前值和当前值中的较大者。</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106141924973.png" alt="image-20211106141924973"></p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">            b+=a[i];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            b=a[i];</span><br><span class="line">        <span class="keyword">if</span>(b&gt;sum)</span><br><span class="line">            sum=b;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><p>给定n个矩阵{A1，A2……An} ， 其中Ai与Ai+1可乘，i=1,2,3…n-1 。 如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。</p><p>考察这n个矩阵的连乘积     A1A2…An</p><p>由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。 </p><p>若一个矩阵连乘积的计算次序完全确定，也就是说该连乘积已完全加括号，则可以依此次序反复调用2个矩阵相乘的标准算法计算出矩阵连乘积。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>将矩阵连乘积 AiAi+1…Aj简记为A[i:j] ，这里i ≤ j  考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵 Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106143929876.png" alt="image-20211106143929876"></p><p>计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上 A[i:k]和A[k+1:j]相乘的计算量。</p><p><strong>最优解结构</strong>：</p><ul><li><p>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。 </p></li><li><p>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。</p></li></ul><p><strong>建立递归关系</strong>：</p><ol><li><p>设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]</p></li><li><p>当i=j时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n</p></li><li><p>当i&lt;j时，m[i , j]=m[i , k] + m[k+1 , j] + pi-1 * pk * pj ，这里Ai的维数为pi-1 * pi</p></li><li><p>递归的定义m[i , j]为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106144514820.png" alt="image-20211106144514820"></p><p>k的位置只有j-i种可能。</p></li></ol><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150225461.png" alt="image-20211106150225461"></p><p>计算的时候是斜着对角进行计算的，这样再计算下一轮的时候就可以用到前面已经求得的值。</p><p>计算过程：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150353882.png" alt="image-20211106150353882"></p><p>比如m[2] [5]就可以表示为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150243929.png" alt="image-20211106150243929"></p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matrixChain</span><span class="params">(<span class="keyword">int</span> []p,<span class="keyword">int</span> n,<span class="keyword">int</span> [][]m,<span class="keyword">int</span> [][]s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化对角线全为0 因为当i=j时，A[i:j]=Ai，因此，m[i,i]=0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) m[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">2</span>;r&lt;=n;r++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-r+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//这是把 m[i][j]分成i-&gt;i i+1-&gt;j的情形，m[i][i]=0</span></span><br><span class="line">            <span class="comment">//m[i , j]=m[i , k] + m[k+1 , j] + pi-1 * pk * pj</span></span><br><span class="line">            m[i][j]= m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="comment">//这里就是除了i-&gt;i i+1-&gt;j的情形以外的情况，要找到最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析： 算法matrixChain的主要计算量取决于算法中对r，i 和 k 的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n^3 )。因此算法的计算时间上界为O(n^3 )。算法所占用的空间显然为O(n^2 )。</p><h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><p>若给定序列X={x1 ,x2 ,…,xm}，则另一序列 Z={z1 ,z2 ,…,zk }，是X的子序列是指存在一个严格递增 下标序列{i1 ,i2 ,…,ik }使得对于所有j=1,2,…,k有：zj=xi。 例如，序列Z={B，C，D，B}是序列X={A，B，C，B， D，A，B}的子序列，相应的递增下标序列为{2，3，5， 7}。</p><p>给定2个序列X和Y，当另一序列Z既是X的子序列又是 Y的子序列时，称Z是序列X和Y的公共子序列。</p><p>给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，找 出X和Y的最长公共子序列。</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>设序列X={x1 ,x2 ,…,xm}和Y={y1 ,y2 ,…,yn }的最长公共子序列为 Z={z1 ,z2 ,…,zk } ，则</p><ul><li>若xm==yn，则zk=xm=yn。X与Y的最长公共子序列为{x1 ,x2 ,…,x(m-1)}，{y1 ,y2 ,…,y(n-1) }的最长公共子序列+xm</li><li>若xm!=yn且zk!=xm，则X与Y的最长公共子序列为{x1 ,x2 ,…,x(m-1)}，{y1 ,y2 ,…,yn }的最长公共子序列</li><li>若xm!=yn且zk!=yn，则X与Y的最长公共子序列为{x1 ,x2 ,…,xm}，{y1 ,y2 ,…,y(n-1) }的最长公共子序列</li></ul><p>由此可见，2个序列的最长公共子序列包含了这2个序列的前缀 的最长公共子序列。因此，最长公共子序列问题具有最优子结 构性质。</p><p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用c[i] [j]记录序列和的最长公共子序列的长度。其中，Xi={x1 ,x2 ,…,xi }；Yj={y1 ,y2 ,…,yj }。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时C[i] [j]=0。其它情况下，由最优子结构性质可建立递归关系如下：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106152638761.png" alt="image-20211106152638761"></p><p>Algorithms和alchemist：</p><p>i=0和j=0，则c[i] [j]为0；然后，首先X1  A 和Y1  A相同，那么就取左上方c[i-1] [j-1]+1 ；接下来，X1 A和Y2 L不同，则c[i] [j] 就等于左边c[i] [j-1] 和 上边 c[i-1] [j] 中的较大者。</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106155347486.png" alt="image-20211106155347486"></p><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LCSLength</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">char</span> []x,<span class="keyword">char</span> []y,<span class="keyword">int</span> [][]c,<span class="keyword">int</span> [][]b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//i=0或者j=0，空序列为最长公共子序列，因此c[i][j]=0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (x[i]==y[j]) </span><br><span class="line">            &#123; </span><br><span class="line">c[i][j]=c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>; </span><br><span class="line">                <span class="comment">//记录</span></span><br><span class="line">                b[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c[i-<span class="number">1</span>][j]&gt;=c[i][j-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i-<span class="number">1</span>][j];</span><br><span class="line">            b[i][j]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i][j-<span class="number">1</span>]; </span><br><span class="line">                b[i][j]=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造最长公共子序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LCS</span><span class="params">(<span class="keyword">int</span> i，<span class="keyword">int</span> j，<span class="keyword">char</span> []x，<span class="keyword">int</span> []b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i ==<span class="number">0</span> || j==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (b[i][j]== <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        LCS(i-<span class="number">1</span>，j-<span class="number">1</span>，x，b); </span><br><span class="line">        System.out.print(x[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b[i][j]== <span class="number">2</span>) </span><br><span class="line">        LCS(i-<span class="number">1</span>，j，x，b);</span><br><span class="line"><span class="keyword">else</span> LCS(i，j-<span class="number">1</span>，x，b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法LCSLength耗时O(m*n)，算法LCS的计算时间为O(m+n)。</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>设所给0-1背包问题的子问题<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106191015562.png" alt="image-20211106191015562"></p><p>的最优值为m[i] [j]，即m(i,j)是背包容量为j，可选择物品为i，i+1，…，n时0-1背包问题的最优值。</p><p>由0-1背包问题的最优子结构性质，可以建立如下计算m(i，j)的递归式：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106191335277.png" alt="image-20211106191335277"></p><p>递归式的意思就是：如果当前背包容量小于当前物品的重量，那么就是不能装下，这样就等于下一个到m(i+1 , j)。如果当前背包容量能大于当前物品的重量，那么就是能装下，这样就只需要比较装下该物品（如果选择装下该物品，那么前面物品的总价值就会被压缩，因为该物品占了重量所以要去找m(i+1 , j-wi)然后再加上刚装下物品的价值）或者不装该物品，哪一个得到的价值更大。</p><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> []v,<span class="keyword">int</span> []w,<span class="keyword">int</span> c,<span class="keyword">int</span> [][]m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=v.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">        m[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        m[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&gt;=c;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">                m[i][j]=max(m[i-<span class="number">1</span>][j],m[i-<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[i][j]=m[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用m[i] [j]=max(m[i-1] [j],m[i-1] [j-w[i]]+v[i]);同上方i+1意思是一样的，只不过初始化不同。</p><p>时间复杂度O(nc)；</p>]]></content>
    
    
    <summary type="html">算法之动态规划，包括最大字段和，矩阵连乘，最长公共子序列问题，01背包问题</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    <id>http://ins1mn1a.github.io/2022/01/09/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-09T02:45:48.174Z</published>
    <updated>2022-03-08T12:50:25.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优 解。如单源最短路经问题，最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p><h2 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h2><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式 作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</p><h2 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h2><p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。</p><p>对于一个具体问题，要确定它是否具有贪心选择性质， 必须证明每一步所作的贪心选择最终导致问题的整体最优解。</p><h3 id="贪心选择性质证明"><a href="#贪心选择性质证明" class="headerlink" title="贪心选择性质证明"></a>贪心选择性质证明</h3><h4 id="货币系统"><a href="#货币系统" class="headerlink" title="货币系统"></a>货币系统</h4><p>设某种货币系统为(1, 5, 10, 25)四种币值（单位：元），要用最少的币数找出n元钱，问：能否用贪心算法进行求解，并证明。（不要求写算法）</p><p>贪心性质（最大面额优先选最多）证明：</p><p>对n&lt;=25的情况，易由穷举得证。</p><p>当n&gt;25时，设n=1<em>a1+5</em>a2+10<em>a3+25</em>a4</p><p>为了使a1+a2+a3+a4最小，易知：</p><p>a1&lt;5，若a1&gt;=5，可将5个1元兑换为1个5元，币数减少。</p><p>a2&lt;2，若a2&gt;=2，可将2个5元兑换为1个10元，币数减少。</p><p>当a2=0时，a3&lt;3，若a3&gt;=3，可将3个10元兑换为1个5元和1个25元，币数减少。</p><p>当a2&gt;0时，a3&lt;2，若a2&gt;=2，可将1个5元和2个10元兑换为1个25元，币数减少。</p><p>即，为了使a1+a2+a3+a4最小，所使用的1、5、10元币的币数的上限为：</p><p>a1=4, a2=0, a3=2 或 a1=4, a2=1, a3=1</p><p>则所使用的1、5、10元币的币值上限为：</p><p>4<em>1+0</em>5+2<em>10 = 24 或 4</em>1+1<em>5+1</em>10 = 19</p><p>均不超过25，因此，为了使a1+a2+a3+a4最小，应使a4达到最大。贪心选择性质得证。</p><p>最优子结构性质证明：</p><p>当a4的值确定后，为了使a1+a2+a3+a4达到最小，须使a1+a2+a3达到最小，仍为同型的最优问题。</p><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p>算法思想：先将所有物品按其单位重量的价值进行排序，然后，按照贪心策略，将尽可能多的单位重量价值最高的物品装入；若装入后，背包内的物品总重量未超过C，则选择单位重量价值次高的物品尽可能多地装入。依此策略一直进行下去，直到背包装满或物品装完为止。</p><p>贪心性质证明：</p><p>不失一般性，只要对第一个步骤进行证明即可。</p><p>设按以上方法第一个步骤装入地重量为w1’。（对单位价值最大的物品）</p><p>若存在一种装入方式，单位价值最大的物品装入数为w1‘’&lt;w1’ ，且得到了最优结果。</p><p>不妨设其他的物品被装入重量为w2’’,…,wn’’。</p><p>现对该方案作部分调整，将单位价值最高的物品的装入量改为w1’，而将由此产生的超重w1’-w1’’在后面的各物品上分摊（减少），这样的方案获得的价值必然超过原方案价值且不超重，与假设矛盾。故单位价值最大的物品的装入数必然为w1’ 。</p><h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><p>活动安排问题就是要在所给的活动集合中选出 最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。</p><p>设有n个活动的集合E={1,2,…,n}，其中每个活动都要 求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资 源的起始时间si和一个结束时间fi,且si&lt;fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>输入的活动以其完成时间的非减序排列， 算法每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。</p><h3 id="贪心选择性质-1"><a href="#贪心选择性质-1" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h3><p>假设有一个最大相容活动集，Ei1,Ei2,…,Eik**(**已按结束时间排序)<strong>，</strong>活动数为K。现在证明按照贪心策略一定可以找到同样数量的相容活动集。</p><p>假设i1&gt;1，则将活动Ei1换成E1后依然是相容的（因为E1更早结束）；</p><p>依次类推，只要不符合贪心策略，就可按贪心策略进行活动替换，得到数量相等的相容基。这说明按照贪心策略一定可以得到最大相容集。因此，按照以上贪心策略，进行局部最优选择，一定可以导致最终得到整体最优解。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>各活动的起始时间和结束时间存储于数组s和f中且按结束时间的非减序排列。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="keyword">int</span> n, T s[], T f[], bool A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A[<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (s[i]&gt;=f[j]) </span><br><span class="line"> &#123; </span><br><span class="line"> A[i]=<span class="keyword">true</span>; </span><br><span class="line"> j=i; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> A[i]=<span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法greedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。</p><h2 id="背包问题-1"><a href="#背包问题-1" class="headerlink" title="背包问题"></a>背包问题</h2><p>与0-1背包问题类似，所不同的是在选择物品i装入背包时，可以选择物品i的一部分，而不一定要全部装 入背包，1≤i≤n。 这2类问题都具有最优子结构性质，极为相似，但背 包问题可以用贪心算法求解，而0-1背包问题却不能用贪心算法求解。</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先计算每种物品单位重量的价值Vi/Wi，然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。 若将这种物品全部装入背包后，背包内的物品总重量未超过 C，则选择单位重量价值次高的物品并尽可能多地装入背包。 依此策略一直地进行下去，直到背包装满为止。</p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">float</span> M,<span class="keyword">float</span> v[],<span class="keyword">float</span> w[],<span class="keyword">float</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按照单位重量的价值从大到小排序</span></span><br><span class="line">    sort(n,v,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        x[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> c=M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&gt;c)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        x[i]=<span class="number">1</span>;</span><br><span class="line">        c-=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;n)</span><br><span class="line">        x[i]=c/w[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先计算每种物品单位重量的价值Vi/Wi，然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。 若将这种物品全部装入背包后，背包内的物品总重量未超过C，则选择单位重量价值次高的物品并尽可能多地装入背包。 依此策略一直地进行下去，直到背包装满为止。如果到最后装入某物品后背包内的物品总重量超过C，则选择将物品不全部装入，但占用背包剩余的全部容量。</p><p>对于0-1背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。事实上， 在考虑0-1背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。由此就导出许多互相重叠的子问题。这正是该问题可用动态规划算法-求解的另一重要特征。 </p><p>实际上也是如此，动态规划算法的确可以有效地解0- 1背包问题。</p>]]></content>
    
    
    <summary type="html">贪心算法，最优子结构性质、贪心选择性质证明，活动安排问题与背包问题</summary>
    
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://ins1mn1a.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SHA-1算法的Java实现</title>
    <link href="http://ins1mn1a.github.io/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/SHA-1/"/>
    <id>http://ins1mn1a.github.io/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/SHA-1/</id>
    <published>2022-01-05T13:37:14.246Z</published>
    <updated>2022-03-08T12:49:10.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>SHA-1把长度小于2^64次方的输入进行分组，512bit为一组。</p><p>采用Merkle提出的安全Hash模型</p><p><img src="/../../img/markdown_img/SHA-1.assets/image-20220104084936990.png" alt="image-20220104084936990"></p><h2 id="填充方案"><a href="#填充方案" class="headerlink" title="填充方案"></a>填充方案</h2><p>先在后面补一个1，然后补0一直到448bit，最后加上64bit的原始x长度的二进制表示</p><p>举例：</p><ol><li><p>原始消息为”abc”，则其bit序列为01100001 01100010 01100011</p></li><li><p>补位，最高位补1，其余补0，补位到448bit</p><ul><li>原始序列：01100001 01100010 01100011</li><li>补位序列：01100001 01100010 01100011 10000000 00000000 … 00000000 （共448bit）</li></ul></li><li><p>原始数据长度的二进制补位</p><ul><li><p>换为16进制：61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000</p></li><li><p>原始消息的长度为24，补位</p><p>61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000018 </p></li></ul></li></ol><p>至此填充完毕，|y|=|x|+1+(447-|x|)+|l|=512</p><h2 id="初始化缓冲区"><a href="#初始化缓冲区" class="headerlink" title="初始化缓冲区"></a>初始化缓冲区</h2><p>缓冲区由5个32位的寄存器（A,B,C,D,E）组成，用于保存160位的中间结果和最终结果</p><p>寄存器初始化为：</p><ul><li>A：67452301</li><li>B：EFCDAB89</li><li>C：98BADCFE</li><li>D：10325476</li><li>E：C3D2E1F0</li></ul><h2 id="主处理"><a href="#主处理" class="headerlink" title="主处理"></a>主处理</h2><p>主处理是SHA-1的核心，每次处理一个512bit分组，链接迭代处理所有L个分组数</p><p>压缩函数是主处理的核心，它由4层运算，每层20步迭代，共80步迭代组成，4层运算结构相同。</p><p>每轮的输入是当前512bit分组BLK和160bit缓冲区ABCDE的内容，并且每轮都对ABCDE的内容更新，而且每轮使用的逻辑函数f不相同，分为f1,f2,f3,f4</p><p>第四轮的输出与第一轮的输入相加得到压缩函数的输出</p><p><img src="/../../img/markdown_img/SHA-1.assets/image-20220104090917830.png" alt="image-20220104090917830"></p><p>&lt;&lt;s 表示32位的变量循环左移s位</p><p>Wt 表示从当前分组BLK导出的32位的字</p><p>Kt 表示加法常量，共使用4个不同的加法常量，每一层一个</p><p>ft 逻辑函数</p><h2 id="逻辑函数ft"><a href="#逻辑函数ft" class="headerlink" title="逻辑函数ft"></a>逻辑函数ft</h2><p>每一轮使用一个逻辑函数，共4个，其输入均为B,C,D(每个32位)，输出为一个32位的字。</p><ul><li>0 ≤ t ≤ 19    f1=ft(B,C,D) = (B ∧C) ∨((¬ B) ∧ D)</li><li>20 ≤ t ≤ 39 f2=ft(B,C,D) = B ⊕ C ⊕ D</li><li>40 ≤ t ≤ 59 f3=ft(B,C,D) = (B ∧ C) ∨(B ∧ D) ∨ (C∧D)</li><li>60≤ t ≤ 79 f4=ft(B,C,D) = B ⊕ C ⊕ D</li></ul><p>f2和f4都是线性函数</p><h2 id="加法常量Kt"><a href="#加法常量Kt" class="headerlink" title="加法常量Kt"></a>加法常量Kt</h2><p>每层使用一个加法常量，各轮使用的加法常量：</p><p>K1 0 ≤ t ≤ 19    5A827999</p><p>K2 20 ≤ t ≤ 39    6ED9EBA1</p><p>K3 40 ≤ t ≤ 59    8F1BBCDC</p><p>K4 60≤ t ≤ 79    CA62C1D6</p><p>压缩字Kt的作用范围太小，只影响输出A，不影响B,C,D,E。</p><h2 id="压缩字Wt"><a href="#压缩字Wt" class="headerlink" title="压缩字Wt"></a>压缩字Wt</h2><p>每步迭代都需要用到一个字，共有80个步，需要80个字。因此将输入BLK（512位，16个字）扩展成80个32位的字。消息M共16个字。</p><p>扩展过程：</p><ul><li>0 ≤ t ≤ 15 Wt=Mt</li><li>16 ≤ t ≤ 79 Wt=（Wt-16 ⊕ Wt-14 ⊕ Wt-8 ⊕ Wt-3）&lt;&lt;1</li></ul><p>压缩字的扩展函数为线性函数</p><p>Wt作用范围太小，只影响输出A，不影响B,C,D,E。</p><h2 id="主处理过程"><a href="#主处理过程" class="headerlink" title="主处理过程"></a>主处理过程</h2><h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h3><p>填充后的消息M，共16个字</p><p>61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000018 </p><p>对M扩展成80个字</p><p>Wt = S1(Wt-3 ⊕Wt-8 ⊕Wt-14 ⊕Wt-16) (16  ≤ t ≤ 79)</p><h3 id="初始化缓冲区-1"><a href="#初始化缓冲区-1" class="headerlink" title="初始化缓冲区"></a>初始化缓冲区</h3><p>初始化MD缓冲区{Hi}，160bit(5个32的寄存器)。</p><p>A=H0= 0x67452301 </p><p>B=H1 = 0xEFCDAB89 </p><p>C=H2= 0x98BADCFE </p><p>D=H3= 0x10325476 </p><p>E=H4= 0xC3D2E1F0</p><p>每轮的常数K为：  </p><p>Kt = 5A827999 ( 0 ≤ t ≤ 19) </p><p>Kt = 6ED9EBA1 (20 ≤ t ≤ 39) </p><p>Kt = 8F1BBCDC (40 ≤ t ≤ 59) </p><p>Kt = CA62C1D6 (60 ≤ t ≤ 79)</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ul><li><p>TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt</p></li><li><p>E = D ; D = C ; C = S30(B) ; B = A ; A = TEMP</p></li><li><p>H0 = H0 + A  H1 = H1 + B H2 = H2 + C  H3 = H3 + D H4 = H4 + E</p></li></ul>]]></content>
    
    
    <summary type="html">密码学Hash算法中的SHA-1实现，SHA-1把长度小于2^64次方bit的输入，转为固定长度160bit的消息摘要</summary>
    
    
    
    <category term="java小功能实现" scheme="http://ins1mn1a.github.io/categories/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="java小功能实现" scheme="http://ins1mn1a.github.io/tags/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java实现文件监控系统</title>
    <link href="http://ins1mn1a.github.io/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <id>http://ins1mn1a.github.io/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-05T13:36:07.619Z</published>
    <updated>2022-03-08T12:49:10.992Z</updated>
    
    <content type="html"><![CDATA[<p>用Java实现文件监控一般有三种方式，第一种是使用WatchService，但是WatchService只能监视当前目录下的文件和目录，不能监视子目录，如果需要监视，则需要遍历根目录下的所有目录，第二种就是利用commons-io监控，最后还可以用JNofiy实现，这里只使用了前两种</p><h2 id="WatchService实现文件监控"><a href="#WatchService实现文件监控" class="headerlink" title="WatchService实现文件监控"></a>WatchService实现文件监控</h2><p>WatchService是jdk7之后nio包中的新功能。可以看作是文件监控器，通过操作系统原生文件系统来运行。 针对单点多appkey的情况，可以注册开启多个监控器。 每个监控器可看作是后台线程，通过监控文件发出的信号来实现监控。</p><p>应用场景：可以监控配置文件的变化，修改配置文件内容即时生效，无需重启服务；监控磁盘文件的变化</p><p>WatchService监控目录文件操作的流程大致如下：</p><ol><li>获取WatchService</li><li>注册指定目录的监视器</li><li>开启线程，等等目录下的文件发生变化</li><li>对发送变化的文件进行记录</li></ol><h3 id="获取WatchService实例"><a href="#获取WatchService实例" class="headerlink" title="获取WatchService实例"></a>获取WatchService实例</h3><p>WatchService是对原生操作系统文件监视器的封装，因为不需要遍历文件所以整体效率上会高很多。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService = FileSystems.getDefault().newWatchService();</span><br></pre></td></tr></table></figure><p>FileSystems.getDefault().newWatchService();直接封装了WatchService的获取方法。</p><p>可以查看它的源码，getDefault()方法的返回值是一个FileSystem，FileSystem提供一个访问文件系统的接口，是对象访问文件系统中的文件和其他对象的工厂，进入getDefault()方法，看看它default了个啥。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileSystem <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultFileSystemHolder.defaultFileSystem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用了DefaultFileSystemHolder，DefaultFileSystemHolder是FileSystems中的一个静态内部类，而defaultFileSystem是DefaultFileSystemHolder的一个用static修饰的属性，然后调用了defaultFileSystem()方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> FileSystem defaultFileSystem = defaultFileSystem();</span><br></pre></td></tr></table></figure><p>defaultFileSystem方法里面用匿名内部类的形式返回了一个FileSystemProvider，它是文件系统的服务提供者类，用它可以获取由provider创建的一个FileSystem。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// returns default file system</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FileSystem <span class="title">defaultFileSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// load default provider</span></span><br><span class="line">    FileSystemProvider provider = AccessController</span><br><span class="line">        .doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;FileSystemProvider&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileSystemProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getDefaultProvider();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return file system</span></span><br><span class="line">    <span class="keyword">return</span> provider.getFileSystem(URI.create(<span class="string">&quot;file:///&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类中，获取了一个defaultProvider，WindowsFileSystemProvider，然后由这个provider获取了一个文件系统，WindowsFileSystemProvider中初始化文件系统。然后调用newWatchService方法就可以获取到WindowsWatchService对象了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WindowsFileSystem theFileSystem = <span class="keyword">new</span> WindowsFileSystem(<span class="keyword">this</span>, System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br></pre></td></tr></table></figure><p>实际上调用此方法后也就是WindowsWatchService的构造方法中，程序会新开一个线程，监视文件变化发出的信号，此时线程尚未就绪。Poller是WindowsWatchService中的一个内部类，WindowsWatchService也有一个poller属性，Poller继承了AbstractPoller，AbstractPoller是实现了Runnable接口，创建了一个守护线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread var1 = <span class="keyword">new</span> Thread(AbstractPoller.<span class="keyword">this</span>);</span><br><span class="line">            var1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            var1.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册目录监视器"><a href="#注册目录监视器" class="headerlink" title="注册目录监视器"></a>注册目录监视器</h3><p>注册监视器需要用到 Path 实例，该实例对应的必须是一个目录，不允许是一个文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要监视的文件目录</span></span><br><span class="line">        String strPath=<span class="string">&quot;D:/FileSystemMonitorTest&quot;</span>;</span><br><span class="line">        <span class="comment">//Path继承了Watchable接口，因此才可以通过Path类来对文件目录进行监听</span></span><br><span class="line">        Path path= Paths.get(strPath);</span><br><span class="line">        <span class="comment">//注册监控服务，监控新增、修改、删除事件，也可以只监控一个事件</span></span><br><span class="line">        path.register(watchService,StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br></pre></td></tr></table></figure><p>StandardWatchEventKinds是文件对应的操作事件，包括修改，创建，删除，它看起来像是枚举类型，但实际上并不是。WatchEvent.Kind<T>是一个接口，对应事件种类名和WatchEvent#context的类型，StdWatchEventKind是它的实现类，StdWatchEventKind<T>也是StandardWatchEventKinds中的内部静态类，StandardWatchEventKinds中的属性调用StdWatchEventKind的构造创建对应的观察事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> WatchEvent.Kind&lt;Path&gt; ENTRY_CREATE =</span><br><span class="line">    <span class="keyword">new</span> StdWatchEventKind&lt;Path&gt;(<span class="string">&quot;ENTRY_CREATE&quot;</span>, Path.class);</span><br></pre></td></tr></table></figure><h3 id="获取目录下的变化"><a href="#获取目录下的变化" class="headerlink" title="获取目录下的变化"></a>获取目录下的变化</h3><p>获取目录的变化需要使用 WatchService 的 take() 方法或 poll() 方法。</p><p>take() 是一个阻塞方法，会等待监视器发出的信号才返回。</p><p>poll() 是一个非阻塞方法，会立即返回当时监视器中是否有信号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    WatchKey watchKey = watchService.take();</span><br><span class="line">    <span class="comment">//轮询</span></span><br><span class="line">    List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">    <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">        System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">    &#125;</span><br><span class="line">    watchKey.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 WatchKey 对象，实际上是一个单例，和之前 path.register() 方法返回的实例是同一个。它只能保存某一时间点的文件变化信息。在AbstractPoller中可以看到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">awaitResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> var1 = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!<span class="keyword">this</span>.completed) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException var5) &#123;</span><br><span class="line">                        var1 = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (var1) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>pollEvents() 用于获取文件变化事件，只能获取一次，不能重复获取，类似队列的形式。</p><p>context() 返回触发该事件的那个文件或目录的路径(相对路径)</p><p>reset() 每次调用 WatchService 的 take() 或 poll() 方法时需要通过本方法重置。</p><h3 id="文件变化记录"><a href="#文件变化记录" class="headerlink" title="文件变化记录"></a>文件变化记录</h3><p>开启一个线程一直监控文件的变化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建监视服务类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService=FileSystems.getDefault().newWatchService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainMonitor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//需要监视的文件目录</span></span><br><span class="line">        String strPath=<span class="string">&quot;D:/FileSystemMonitorTest&quot;</span>;</span><br><span class="line">        <span class="comment">//Path继承了Watchable接口，因此才可以通过Path类来对文件目录进行监听</span></span><br><span class="line">        Path path= Paths.get(strPath);</span><br><span class="line">        <span class="comment">//注册监控服务，监控新增、修改、删除事件，也可以只监控一个事件</span></span><br><span class="line">        path.register(watchService,StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">        WatchServiceRunnable watchServiceRunnable = <span class="keyword">new</span> WatchServiceRunnable(watchService, strPath);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(watchServiceRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.FileMonitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchEvent;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchService;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控线程重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchServiceRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchServiceRunnable</span><span class="params">(WatchService watchService,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.watchService=watchService;</span><br><span class="line">        <span class="keyword">this</span>.path=path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                WatchKey watchKey = watchService.take();</span><br><span class="line">                <span class="comment">//轮询</span></span><br><span class="line">                List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">                <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">                    System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                            <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">                &#125;</span><br><span class="line">                watchKey.reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WatchService监控根目录以及子目录"><a href="#WatchService监控根目录以及子目录" class="headerlink" title="WatchService监控根目录以及子目录"></a>WatchService监控根目录以及子目录</h3><p>这样的话就需要遍历子目录，每个目录都注册一个监控事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历根目录及其子目录，全都注册监听服务</span></span><br><span class="line">LinkedList&lt;File&gt; fileLinkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加根目录到链表尾</span></span><br><span class="line">fileLinkedList.addLast(file);</span><br><span class="line"><span class="comment">//去除并且链表头的文件对象，查看其子目录下文件，能注册服务就注册WatchService</span></span><br><span class="line"><span class="keyword">while</span> (fileLinkedList.size()&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    File f=fileLinkedList.removeFirst();</span><br><span class="line">    File[] files1 = f.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file1 : files1) &#123;</span><br><span class="line">        <span class="comment">//如果是目录，则可以注册监听服务</span></span><br><span class="line">        <span class="keyword">if</span> (file1.isDirectory())&#123;</span><br><span class="line">            fileLinkedList.addLast(file1);</span><br><span class="line">            file1.toPath().register(watchService, StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                    StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在使用Junit测试的时候会遇到Junit测试多线程的限制，不能直接测试，可以看另一篇，Junit测试多线程的问题。</p><h2 id="Commons-IO实现文件监控"><a href="#Commons-IO实现文件监控" class="headerlink" title="Commons-IO实现文件监控"></a>Commons-IO实现文件监控</h2><p>Commons-IO是一个针对开发IO流功能的工具库，主要包括6个部分</p><ol><li>Utility classes：工具类，包括一些静态方法来执行常用任务</li><li>Input：输入，InputStream 和 Reader 实现</li><li>Output：输出，OutputStream 和 Writer 实现</li><li>Filters：过滤器，多种文件过滤器实现(定义了 IOFileFilter接口,同时继承了 FileFilter 和 FilenameFilter 接口)</li><li>Comparators： 比较器，用于文件比较的多种java.util.Comparatot实现</li><li>File Monitor： 文件监控</li></ol><p>使用Commons-IO来实现文件监控主要就是基于观察者模式，也叫发/布订阅模式。</p><p>主要的类有：</p><p>FileAlterationObserver：观察者，观察文件的变化</p><p>FileAlterationListener：文件变化的通知对象，监听器</p><p>FileAlterationListenerAdaptor：FileAlterationListener的实现类，里面方法都没仅仅有个方法体，没有具体的实现，我们一般需要继承FileAlterationListenerAdaptor，然后做具体的实现，比如监控到文件变化打印日志等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File system observer started checking event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> observer The file system observer (ignored)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileAlterationMonitor ：线程监控，实现了Runnable接口，可以以一个固定的时间间隔监听注册到观察者FileAlterationObserver的事件</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>首先由文件监控类FileAlterationMonitor中的线程不停的扫描文件观察器FileAlterationObserver</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> FileAlterationObserver observer : observers) &#123;</span><br><span class="line">            observer.checkAndNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(interval);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FileAlterationObserver中，有一个无参的checkAndNotify()方法，就是用来检查文件和它的子文件有没有变化。</p><p>在该方法中，首先将Observer的所有listener开启onStart方法，表示开始Observer开始检查事件了。然后调用checkAndNotify()的重载方法，根据文件的Comparators比较器，判断文件发生哪种变化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAndNotify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAndNotify</span><span class="params">(<span class="keyword">final</span> FileEntry parent, <span class="keyword">final</span> FileEntry[] previous, <span class="keyword">final</span> File[] files)</span></span></span><br><span class="line"><span class="function"><span class="title">doCreate</span><span class="params">(current[c])</span></span>;<span class="comment">//创建</span></span><br><span class="line">doMatch(entry, files[c]);<span class="comment">//修改</span></span><br><span class="line">doDelete(entry);<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><h3 id="自定义监听器FileAlterationListener"><a href="#自定义监听器FileAlterationListener" class="headerlink" title="自定义监听器FileAlterationListener"></a>自定义监听器FileAlterationListener</h3><p>通过实现FileAlterationListener或者说继承FileAlterationListenerAdaptor来自定义一个监听器，重写其中文件或者目录发生改变的方法，记录日志。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.commons_io_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationListenerAdaptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationObserver;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListener</span> <span class="keyword">extends</span> <span class="title">FileAlterationListenerAdaptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger=Logger.getLogger(FileListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;新建文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;修改文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;删除文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryCreate</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;新建目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryChange</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;修改目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryDelete</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;删除目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建监听器FileAlterationMonitor"><a href="#创建监听器FileAlterationMonitor" class="headerlink" title="创建监听器FileAlterationMonitor"></a>创建监听器FileAlterationMonitor</h3><p>首先给定一个需要监听的文件目录，配置一个观察者FileAlterationObserver，添加观察者的监听器，最后再new一个线程监控FileAlterationMonitor。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.commons_io_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.FileFilterUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.HiddenFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.IOFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationMonitor;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListenerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String dir=<span class="string">&quot;D:\\FileSystemMonitorTest&quot;</span>;</span><br><span class="line">    <span class="comment">//设置轮询间隔 1s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = TimeUnit.SECONDS.toMillis(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileAlterationMonitor <span class="title">getMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//装配过滤器</span></span><br><span class="line">        FileAlterationObserver observer = <span class="keyword">new</span> FileAlterationObserver(<span class="keyword">new</span> File(dir));</span><br><span class="line">        <span class="comment">//添加监听器</span></span><br><span class="line">        observer.addListener(<span class="keyword">new</span> FileListener());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileAlterationMonitor(interval,observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileMonitorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileAlterationMonitor monitor = <span class="keyword">new</span> FileListenerFactory().getMonitor();</span><br><span class="line">            monitor.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">采用jdk的WatchService和Commons-IO工具类库两种方法实现了对某文件目录下的文件监控，WatchService源码分析</summary>
    
    
    
    <category term="java小功能实现" scheme="http://ins1mn1a.github.io/categories/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
    
    <category term="java小功能实现" scheme="http://ins1mn1a.github.io/tags/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Junit测试多线程的问题</title>
    <link href="http://ins1mn1a.github.io/2022/01/04/Bug%E4%B9%8B%E7%8E%8B/%E5%85%B3%E4%BA%8EJunit%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B5%8B%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://ins1mn1a.github.io/2022/01/04/Bug%E4%B9%8B%E7%8E%8B/%E5%85%B3%E4%BA%8EJunit%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B5%8B%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-01-04T11:15:54.233Z</published>
    <updated>2022-03-08T12:49:10.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Junit测试多线程的问题"><a href="#Junit测试多线程的问题" class="headerlink" title="Junit测试多线程的问题"></a>Junit测试多线程的问题</h1><p>今天在用写一个用WatchService做文件监控的时候使用Junit测试，实现Runnable接口，重写run方法，明明run方法里写的死循环，使用Junit一测试，啥都没干，自动给我执行完了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainMonitor mainMonitor = <span class="keyword">new</span> MainMonitor();</span><br><span class="line">        mainMonitor.monitor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控线程重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchServiceRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchServiceRunnable</span><span class="params">(WatchService watchService,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.watchService=watchService;</span><br><span class="line">        <span class="keyword">this</span>.path=path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                WatchKey watchKey = watchService.take();</span><br><span class="line">                List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">                <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">                    System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                            <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">                &#125;</span><br><span class="line">                watchKey.reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我直接重新写一个for循环，打印数字，也不能正常输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">                Thread.currentThread().setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在输出&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整了半天，发现Junit并不能直接测试多线程。Junit单元测试当主线程执行完毕时，主线程会关闭，并且关闭子线程。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>使用join()等待子线程执行完毕</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    thread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainMonitor mainMonitor = <span class="keyword">new</span> MainMonitor();</span><br><span class="line">        mainMonitor.monitor();</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>还可以使用CountDownLatch类</li></ol><p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Junit测试多线程</summary>
    
    
    
    <category term="bug" scheme="http://ins1mn1a.github.io/categories/bug/"/>
    
    
    <category term="Bug" scheme="http://ins1mn1a.github.io/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>软件系统安全</title>
    <link href="http://ins1mn1a.github.io/2021/12/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    <id>http://ins1mn1a.github.io/2021/12/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</id>
    <published>2021-12-26T14:39:00.240Z</published>
    <updated>2022-03-08T12:49:10.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件、程序、软件工程、软件系统、软件质量"><a href="#1-软件、程序、软件工程、软件系统、软件质量" class="headerlink" title="1.   软件、程序、软件工程、软件系统、软件质量"></a>1.   软件、程序、软件工程、软件系统、软件质量</h3><p>软件：程序+文档 程序：算法+数据结构</p><p>软件工程包含的研究内容：软件开发模型、软件开发方法，软件支持过程，软件管理过程。</p><p>软件系统是指由系统软件、支撑软件和应用软件组成的计算机软件系统，它是计算机系统中由软件组成的部分。</p><p>软件质量是指软件符合</p><ul><li>明确定义的功能和性能需求</li><li>明确规定的开发标准和准则</li><li>满足隐含要求的其它特性的程度</li></ul><p>软件质量是反映软件产品满足规定和潜在需求能力的特性的总和，描述和评价软件产品质量的一组属性常称为软件质量特性。</p><h3 id="2-软件构造过程存在哪些安全隐患"><a href="#2-软件构造过程存在哪些安全隐患" class="headerlink" title="2.   软件构造过程存在哪些安全隐患"></a>2.   软件构造过程存在哪些安全隐患</h3><p>软件安全主要包括的三个方面：</p><p>软件自身安全(软件缺陷与漏洞)：软件在开发时可能由于不安全编码等因素造成的软件在特定方面的缺陷与漏洞</p><p>恶意软件攻击：攻击者会利用软件的漏洞植入恶意代码，或者通过恶意的软件病毒比如木马，后门，蠕虫等等对系统进行攻击</p><p>软件逆向分析(软件破解)：通过对软件进行逆向分析，发现软件的注册机制，从而破解软件</p><h3 id="3-软件系统存在安全问题的本因"><a href="#3-软件系统存在安全问题的本因" class="headerlink" title="3.   软件系统存在安全问题的本因"></a>3.   软件系统存在安全问题的本因</h3><p>在软件设计之处，并没有结合到实际完全考虑到软件自身运行情况和可能面临的互联网环境下的复杂性，导致软件开发后存在不少的漏洞与缺陷，在面临异常环境时无法按照正常的预期的流程运行，降低了软件的动态行为可信性。</p><h3 id="4-从软件工程的视角如何预防软件系统安全缺陷"><a href="#4-从软件工程的视角如何预防软件系统安全缺陷" class="headerlink" title="4.   从软件工程的视角如何预防软件系统安全缺陷"></a>4.   从软件工程的视角如何预防软件系统安全缺陷</h3><p>强化软件工程思想，将安全问题融入到软件的开发管理流程之中，在软件开发阶段尽量减少软件缺陷和漏洞的数量。采用标准的软件工程开发模型与流程，合理的风险评估，严格要求整个开发生命周期，做到软件缺陷与漏洞的最小化。</p><h3 id="5-软件危机"><a href="#5-软件危机" class="headerlink" title="5.   软件危机"></a>5.   软件危机</h3><p>计算机软件的开发和维护过程中遇到的一系列严重问题。</p><ul><li>主要表现：<ul><li>开发成本和进度估计不准确</li><li>用户对已完成的软件不满意</li><li>软件产品质量不高</li><li>软件常常不可维护</li><li>软件没有文档资料</li><li>软件成本在总成本中占比上升</li><li>软件开发生产率赶不上硬件的发展速度也跟不上计算机应用普及的速度。</li></ul></li></ul><h3 id="6-可信软件"><a href="#6-可信软件" class="headerlink" title="6.可信软件"></a>6.可信软件</h3><p>软件系统的运行行为及其结果总是符合人们的预期，在受到干扰时仍能提供连续的服务。</p><p>包含安全性(safety，security)、可靠性、可用性、可维护性、机密性、完整性、可控性等等。</p><ul><li>safety：软件运行不引起危险、灾难的能力</li><li>security：软件系统对数据和信息提供保密性、 完整性、可用性、真实性保障的能力</li><li>reliability：在给定的环境下特定的时间内软件无失效运行的概率</li><li>maintainability：软件系统或部件修改错误、提高性能和属性，或是适应新环境的难易程度</li><li>survivability：（网络）软件在受到攻击或失效时提供基本服务并在规定时间内恢复所有服务的能力</li></ul><h3 id="7-软件安全"><a href="#7-软件安全" class="headerlink" title="7.软件安全"></a>7.软件安全</h3><p>软件规模的扩大，软件开发集成和演化越来越复杂，导致软件产品推出时会有已知或者未知的缺陷。就好比现在操作系统都是先推出使用后续再慢慢维护，更新。</p><p>软件的运行和开发环境从传统的静态转换到了动态的互联网环境下，安全风险更大。</p><p>计算机病毒和黑客地下产业链活动，软件漏洞增多，传播速度加大。</p><h3 id="8-信息与信息安全"><a href="#8-信息与信息安全" class="headerlink" title="8.信息与信息安全"></a>8.信息与信息安全</h3><p>信息以物质介质为载体，传递和反映世界各种事物存在的方式和运动状态的特征。信息是比较抽象的，有人说具有价值的消息就是信息，总之关键词就是价值、消除不确定性。</p><p>信息安全是对信息的保密性、完整性和可用性的保持。</p><h3 id="9-软件安全威胁及其来源；"><a href="#9-软件安全威胁及其来源；" class="headerlink" title="9.软件安全威胁及其来源；"></a>9.软件安全威胁及其来源；</h3><ul><li>软件缺陷与漏洞：软件开发时对软件自身运行环境和外部因素考虑不周导致出现的缺陷和漏洞。</li><li>恶意软件攻击：为了实现一些恶意目的的软件程序，比如计算机病毒、特洛伊木马、后门等等。</li><li>软件破解：对软件的逆向分析，破解软件的使用。</li></ul><h3 id="10-如何加强软件安全保护"><a href="#10-如何加强软件安全保护" class="headerlink" title="10.如何加强软件安全保护"></a>10.如何加强软件安全保护</h3><ul><li>从<strong>软件工程</strong>的角度来说，加强软件工程思想，让软件开发走标准的软件工程过程，将安全问题融入到软件的开发流程管理之中，在软件开发阶段尽量减少软件缺陷和漏洞的数量。</li><li>保证软件自身运行环境，加强系统自身的<strong>数据完整性校验</strong>。</li><li>加强系统自身软件的行为认证——<strong>软件动态可信认证</strong></li><li>恶意软件检测与查杀</li><li>黑客攻击防护——主机防火墙，HTPS</li><li>系统还原</li><li>虚拟机、沙箱技术</li></ul><h3 id="11-计算机的引导过程（简答）"><a href="#11-计算机的引导过程（简答）" class="headerlink" title="11.计算机的引导过程（简答）"></a>11.计算机的引导过程（简答）</h3><p>主要可分为四个阶段</p><ul><li>BIOS：首先进行硬件自检(POST power on self test)，如果发现有硬件故障会通过喇叭发声，然后按照启动顺序选择从哪个设备启动。</li><li>主引导记录(MBR)：读取设备的前512字节，判断设备能否启动，不能启动则按启动顺序尝试启动下一个设备。然后BIOS会一次遍历主分区找到激活分区。</li><li>硬盘启动：计算机会读取激活分区的第一个扇区即卷引导记录(VBR)，VBR告诉计算机操作系统位于该分区的哪个位置，然后计算机就可以开始加载操作系统了。</li><li>操作系统：首先载入操作系统的内核，然后加载各个模块，驱动程序以及服务启动，最后系统自启动程序。</li></ul><h3 id="12-PE文件格式"><a href="#12-PE文件格式" class="headerlink" title="12.PE文件格式"></a>12.PE文件格式</h3><p>PE是Win32环境自身所带的可执行的文件格式。它的一些特性继承自UNIX的COFF文件格式。</p><p>可移植的执行体意味着此文件格式是跨Win32平台的，即使Windows运行在非Intel的CPU上，任何Win32平台的PE装载器都能识别和使用该文件格式。</p><p>移植到不同的CPU上PE执行体必须得有一些改变。除了VxD和16位的DLL外，所有Win32执行文件都使用PE文件格式。因此，研究PE文件格式是我们洞悉 Windows结构的良机。</p><h3 id="13-软件漏洞成因分析"><a href="#13-软件漏洞成因分析" class="headerlink" title="13.软件漏洞成因分析"></a>13.软件漏洞成因分析</h3><p>软件脆弱性成因即形成软件脆弱性的原因。<strong>软件脆弱性成因</strong>包括导致软件脆弱性形成的<strong>内部因素</strong>和<strong>外部因素</strong>两个方面。</p><ul><li>内部因素主要是软件本身的<strong>不安全编码</strong>导致的内部安全缺陷，数据校验不当，类型初始化不当，空指针使用不当</li><li>外部环境因素指的是<strong>软件运行所在的外部环境因素</strong>，其主要包括接口参数(IP)，机器内存(M)，进程(PRS)，注册信息(REG)，代码(CD)，网络(NET)，磁盘文件系统(DF)等方面。因此外部环境因素可以进一步表示为以下形式：EM = {IP，M，DF，PRS，NET，REG，CD}。</li></ul><h3 id="14-漏洞按照成因分类"><a href="#14-漏洞按照成因分类" class="headerlink" title="14.漏洞按照成因分类"></a>14.漏洞按照成因分类</h3><p>按照漏洞的成因分类：输入验证错误、访问验证错误、竞争条件错误、意外情况处理错误、设计错误、配置错误以及环境错误。</p><h3 id="15-漏洞的一般特征及其描述"><a href="#15-漏洞的一般特征及其描述" class="headerlink" title="15.漏洞的一般特征及其描述"></a>15.漏洞的一般特征及其描述</h3><ol><li>脆弱性是软件系统中一个隐藏的弱点（Fault，F），它本身并不会造成错误，但被攻击者利用之后可能会产生严重的安全后果（Result，R），形式化的表示为：F→R</li><li>在软件开发过程中，开发人员自觉或不自觉的引入的逻辑错误（LF）是大多数脆弱性（SV）的根本来源，形式化的表示为：LF→SV</li><li>脆弱性的特征还与系统本身运行时的环境（EM）有关，不同的运行环境也有可能造成不同的脆弱性问题，形式化的表示为：EM→SV</li><li>旧的脆弱性（FSV）遭到修复后也有可能引入新的脆弱性（CSV）问题，形式化的表示为：FSV→CSV</li></ol><h3 id="16-漏洞分类及其标准"><a href="#16-漏洞分类及其标准" class="headerlink" title="16.漏洞分类及其标准"></a>16.漏洞分类及其标准</h3><ul><li>按漏洞可能对系统造成的直接威胁划分<ul><li>获取访问权限漏洞、权限提升漏洞、拒绝服务攻击漏洞、恶意软件植入漏洞、数据丢失或泄露漏洞</li></ul></li><li>按漏洞的成因划分<ul><li>输入验证错误、访问验证错误、竞争条件错误、意外情况处理错误、设计错误、配置错误、环境错误</li></ul></li><li>按漏洞的严重等级<ul><li>高级漏洞：远程和本地管理员权限</li><li>中级漏洞：普通用户权限、权限提升、读取受限文件以及远程和本地拒绝服务</li><li>低级漏洞：服务器信息泄露</li></ul></li><li>按漏洞被利用的方式<ul><li>本地攻击、远程主动攻击、远程被动攻击</li></ul></li></ul><h3 id="17-常见的软件漏洞分类"><a href="#17-常见的软件漏洞分类" class="headerlink" title="17.常见的软件漏洞分类"></a>17.常见的软件漏洞分类</h3><p>常见的软件漏洞大概分为8类：</p><ul><li><strong>代码注入</strong>：恶意代码的注入</li><li>缓冲错误：缓冲区溢出</li><li>跨站脚本：XSS攻击，植入代码脚本，保存型XSS漏洞：先把脚本存在数据库，等读取出来的时候有可能执行脚本</li><li>权限许可和访问控制：未检查返回值导致空指针解引用，空指针异常</li><li>SQL注入：攻击者输入携带可能被执行的危险指令或者恒成立条件进入数据库做正常的查询等操作，导致数据库错误的执行命令。</li><li>输入验证：没有做校验工作，比如没有校验生成的值为0导致0除异常</li><li>格式化字符串：输出非法格式化字符串导致输出了内存中的数据</li><li>竞争条件：并发编程对资源的共享可能造成内存泄露、系统崩溃</li></ul><h3 id="18-不安全编码分类"><a href="#18-不安全编码分类" class="headerlink" title="18.不安全编码分类"></a>18.不安全编码分类</h3><p>数据校验不当DO、类型初始化不当TI、空指针引用不当NP、返回操作不当RV、数字操作不当NO、类与方法操作不当CM、异常处理不当EO、多线程处理不当MT、IO操作不当IO、序列化操作不当SO、权限控制不当RC</p><h3 id="19-典型的软件漏洞机理分析（成因图分析法）"><a href="#19-典型的软件漏洞机理分析（成因图分析法）" class="headerlink" title="19.典型的软件漏洞机理分析（成因图分析法）"></a>19.典型的软件漏洞机理分析（成因图分析法）</h3><p>漏洞成因影响因素表：</p><p><img src="/../../img/markdown_img/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8.assets/image-20211224211315230.png" alt="image-20211224211315230"></p><p>软件脆弱性成因图由两部分构成：内因和外因。</p><ul><li><p>内因：指系统本身的不安全编码。如数据校验不当、类型初始 化不当、空指针使用不当、返回值操作不当、数字操作不当等。</p></li><li><p>外因：主要考虑的是接口参数（IP）、内存(M)、磁盘文件系统(DF)、进程(PRS)、 网络(NET)、注册环境信息(REG)和外部代码(ED)等影响因素。</p></li></ul><p>软件脆弱性的成因复杂，一部分脆弱性是内因作用的结果，另 一部分则是内因和外因共同作用的结果。</p><p>软件漏洞成因影响因素及其简称：</p><p><img src="/../../img/markdown_img/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8.assets/image-20211224212016072.png" alt="image-20211224212016072"></p><h3 id="20-软件漏洞的利用和发现"><a href="#20-软件漏洞的利用和发现" class="headerlink" title="20.软件漏洞的利用和发现"></a>20.软件漏洞的利用和发现</h3><h4 id="Exploit漏洞利用程序"><a href="#Exploit漏洞利用程序" class="headerlink" title="Exploit漏洞利用程序"></a>Exploit漏洞利用程序</h4><p>Exploit(漏洞利用程序)是针对某一特定漏洞或一组漏洞而精心编写的漏洞利用程序。其可以触发特定漏洞从而获得系统的控制权。</p><p>分为两个部分：被注入到目标进程触发漏洞获得执行权限的二进制串，以及代表攻击者意图的代码。</p><h4 id="漏洞利用的具体技术"><a href="#漏洞利用的具体技术" class="headerlink" title="漏洞利用的具体技术"></a>漏洞利用的具体技术</h4><ul><li>修改内存变量</li><li>修改代码逻辑</li><li>修改函数返回地址</li><li>修改函数指针</li><li>攻击异常处理机制</li><li>修改P.E.B中线程同步函数的入口地址</li></ul><h3 id="21-软件漏洞检测方法"><a href="#21-软件漏洞检测方法" class="headerlink" title="21.软件漏洞检测方法"></a>21.软件漏洞检测方法</h3><p>目前主流的软件漏洞挖掘方法有Fuzzing技术、安全扫描技术、静态分析、动态分析、基于二进制的检测分析技术等。</p><p>UltraEdit可以用于打开任意类型的文件，可以以二进制的形式查看文件的内容。可以用UltraEdit来检测文件的类型，包括未知文件类型。</p><p>OllyDBG是一个程序调试器，OllyDBG结合了静态和动态调试的方法，通过实时的反应出内存和程序执行的关系来进行程序的调试，可以用来检测漏洞，比如缓冲区溢出、内存泄露等等。可以编写好带有缓冲区溢出的程序，编译链接成exe文件，然后放到OllyDBG中执行，设置断点，实时观察内存地址、反汇编窗口，信息窗口以及堆栈信息等可以分析出程序的漏洞。</p><h4 id="静态漏洞挖掘工具"><a href="#静态漏洞挖掘工具" class="headerlink" title="静态漏洞挖掘工具"></a>静态漏洞挖掘工具</h4><ol><li>cppcheck<ul><li>静态的C/C++代码分析工具，用以检查内存泄露、缓冲区溢出以及更多问题</li></ul></li><li>SPLINT<ul><li>使用规则检查技术，支持对C/C++使用规则找到大规模程序故障，由于给定规则的限制，也就只能找到给定的故障</li></ul></li><li>FindBugs<ul><li>根据词汇分析和数据流分析，支持对Java的静态代码漏洞挖掘。该工具自带检测器Detector，开发者还可以根据自己的需求设计编写特定的缺陷检测器</li></ul></li><li>PMD<ul><li>也是Java的静态代码分析工具</li></ul></li></ol><h4 id="动态漏洞挖掘工具"><a href="#动态漏洞挖掘工具" class="headerlink" title="动态漏洞挖掘工具"></a>动态漏洞挖掘工具</h4><ol><li>MiniFuzz<ul><li>模糊测试技术(fuzzing)，简单易用，原理清晰</li></ul></li><li>AFL<ul><li>动态二进制插桩技术，比较高效</li></ul></li><li>Hodor<ul><li>污点跟踪技术，应用范围广</li></ul></li><li>Boofuzz<ul><li>模糊测试技术，简单易用，发生错误更少。内置多个模块，比如会话(Session)模块，Session对象是fuzz会话的中心；连接模块，Connection可以选择TCP、UDP等多种套接字连接。运行http用例，boofuzz通过事前约定好的数据进行测试，最后同时也可以在localhost的26000端口网页端查看检测日志。</li></ul></li></ol><h3 id="22-恶意代码分类及各自特点"><a href="#22-恶意代码分类及各自特点" class="headerlink" title="22.恶意代码分类及各自特点"></a>22.恶意代码分类及各自特点</h3><p>恶意代码也叫恶意软件，广义上的计算机病毒。可以分为以下几种：</p><ul><li><p>计算机病毒、蠕虫</p><ul><li><strong>计算机病毒</strong>是一种可以自我传播、需要用户干预（或者说不能独立运行、需要宿主程序激活）来触发执行的破坏性程序或者代码</li><li><strong>网络蠕虫</strong>是一种可以自我传播、但不需要用户干预（或者说可以独立运行）就可以触发执行的破坏性程序或代码</li></ul></li><li><p>木马、后门</p><ul><li><strong>特洛伊木马</strong>指看起来具有正常功能，但实际上却隐藏得有用户不希望的功能程序。通常由控制端和被控制端两端组成</li><li><strong>后门</strong>是使得攻击者可以非法获取到系统的权限来操作系统的一类程序。后门程序包括了木马程序，后门主要是获取到系统的权限就像给攻击者开了一个后门一样，以方便随时利用这个系统，木马就是隐藏在正常程序中的一段有恶意目的的代码或者文件，可以用来记录密码、记录键盘、删除文件等功能。</li></ul></li><li><p>Rootkit</p><ul><li><strong>Rootkit</strong>通过修改现有的操作系统软件，使得攻击者获取访问权并隐藏在计算机中的程序</li></ul></li><li><p>僵尸程序(bot)</p><ul><li><strong>僵尸程序</strong>通过聊天室，文件共享网络感染存在漏洞的计算机，这些感染的计算机就相当于被攻击者控制。</li></ul></li><li><p>流氓软件、间谍软件</p><ul><li><strong>流氓软件</strong>就是具有一定的实用价值但是具备电脑病毒和黑客软件的部分特征的软件（特点就是难以卸载）</li><li><strong>间谍软件</strong>是会收集用户计算机上的信息、机密文件或者隐私数据上报到服务器</li></ul></li><li><p>广告软件、Exploit、黑客工具等</p><ul><li><strong>广告软件</strong>未经过用户允许，直接下载并且安装或者说与其他软件以捆绑软件一起下载下来，一直弹出广告并且难以根除的程序</li><li><strong>Exploit</strong>是精心设计的用于特定漏洞利用来对目标系统实施攻击的程序</li><li><strong>黑客工具</strong>是各类直接或间接用于网络和主机渗透的软件，比如各种扫描器、后门植入工具、密码嗅探器、提权工具等</li></ul></li></ul><h3 id="23-如何更加科学地对恶意软件进行分类和命名"><a href="#23-如何更加科学地对恶意软件进行分类和命名" class="headerlink" title="23.如何更加科学地对恶意软件进行分类和命名"></a>23.如何更加科学地对恶意软件进行分类和命名</h3><p>目前互联网的发展，各种恶意软件层出不穷，防不胜防，一步小心就会给计算机带来麻烦。恶意软件的行为日益泛化，我们要进行分类可以分析软件的原理或者说按照恶意软件的功能就行划分，比如提权类的恶意软件、给普通计算机用户仅仅是造成不良好体验的流氓软件等类似这种功能的方面进行一个分类。其次，我们还可以建立一个恶意软件的标准危险等级，按照它对于计算机的一个威胁程度进行分类，威胁越大的等级越高。最后我们还可以用魔法打败魔法，采用人工智能，基于深度学习来进行恶意代码分类。</p><h3 id="24-流氓软件及其特点"><a href="#24-流氓软件及其特点" class="headerlink" title="24.流氓软件及其特点"></a>24.流氓软件及其特点</h3><p>流氓软件是属于恶意软件中的一种。流氓软件它本身其实是具有一定的实用价值，比如某2345，它本身可以给你提供一些压缩文件或者防病毒的功能，但是它会安装它的全家桶让你实在是难以接受，通常还会类似一个广告软件弹出各种广告。所以流氓软件就是具有一定实用价值具备电脑病毒和黑客软件部分特征的软件。其最大的特点就是对于普通用户来说难以卸载。</p><h3 id="25-网络蠕虫功能结构及工作机制"><a href="#25-网络蠕虫功能结构及工作机制" class="headerlink" title="25.网络蠕虫功能结构及工作机制"></a>25.网络蠕虫功能结构及工作机制</h3><p>蠕虫的功能模型包含有基本功能模块和扩展功能模块。</p><ul><li>基本功能模块包含有：<ul><li>信息收集模块：完成对本地和目标节点主机的信息汇集，为发现易感染目标提供支持</li><li>扫描探测模块：发现易感染主机群体</li><li>攻击渗透模块：利用已发现的服务漏洞实施攻击</li><li>自我推进模块：完成对目标节点的感染</li></ul></li><li>扩展功能模块主要取决于攻击者的目的，通常有：<ul><li>实体隐藏模块：主要提供蠕虫的生存能力。对蠕虫各个实体组成部分的隐藏、加密、变形</li><li>宿主破坏模块：破坏被感染主机网络正常运行，在被感染主机上植入后门</li><li>信息通信模块：使蠕虫间、蠕虫同黑客间进行通信</li><li>远程控制模块：控制被感染主机，执行攻击者下达的指令</li><li>自动升级模块：随时更新模块功能，实现持续攻击</li></ul></li></ul><h3 id="26-蠕虫的检测与防治"><a href="#26-蠕虫的检测与防治" class="headerlink" title="26.蠕虫的检测与防治"></a>26.蠕虫的检测与防治</h3><p>对于网络管理者和安全厂商比较典型的检测技术有流量监测与分析技术、安全软件监测等。当检测出蠕虫后进行防治可以采用网关阻断，补丁下发，网络安全设备阻断，利用客户端安全软件清除蠕虫个体并进行补丁修补。</p><p>对于个人用户来说，检测与防治蠕虫还是通过一些安全防护软件来进行，及时修护漏洞补丁，使用防火墙软件阻断等。</p><h3 id="27-木马的通信方式、连接方式及各自优缺点"><a href="#27-木马的通信方式、连接方式及各自优缺点" class="headerlink" title="27.木马的通信方式、连接方式及各自优缺点"></a>27.木马的通信方式、连接方式及各自优缺点</h3><p>木马的通信方式：传输通道构建信息，IP地址、端口等信息、第三方网站地址等。</p><p>建立通信连接的方式主要有正向连接和反向连接两种，反向连接又分为两种方式</p><ul><li><p>正向连接</p><ul><li><p>控制端（客户端）主动连接被控端（服务端）。创建服务器端TCP套接字，打开端口监听，连接服务器端口，采用TCP建立连接</p></li><li><p>优点：由控制端主动连接被控端，因此攻击者无需外部的IP地址；木马样本不会泄露攻击者的IP地址</p></li><li><p>缺点：可能会被防火墙阻断，被攻击者必须具备外部IP地址，定位被攻击者相对困难</p></li></ul></li><li><p>反向连接-1</p><ul><li>被控端直接连接控制端</li><li>优点：通过防火墙相对容易；攻击目标随时上线、随时控制；可以控制局域网内的目标</li><li>缺点：样本会暴露控制服务器信息(域名或者IP)，攻击者通常要具有外部IP</li></ul></li><li><p>反向连接-2</p><ul><li>被控端通过一个第三方肉鸡(傀儡机，受黑客远程控制的电脑)或者Web服务器和控制端间接的通信。</li><li>优点：可以绕过防火墙，自动连接上线，不易被发现</li><li>缺点：第三方服务器的稳定性需要保证</li></ul></li></ul><h3 id="28-PE病毒感染关键技术及实现过程"><a href="#28-PE病毒感染关键技术及实现过程" class="headerlink" title="28.==PE病毒感染关键技术及实现过程=="></a>28.==PE病毒感染关键技术及实现过程==</h3><ol><li><p>病毒感染重定位</p><p>由于病毒要用到变量（或常量），病毒感染HOST程序后，由于病毒代码的各个变量在内存中的位置会随HOST程序的大小不同而发生变化，因此病毒必须对病毒代码中的变量进行重定位。病毒代码目标寄生位置不固定。</p></li><li><p>获取API函数地址</p><p>病毒代码没有引入函数机制的支持，所以病毒必须自己获取API函数的地址。首先获取Kernel32的基地址，再从Kernel32中得到API函数的地址</p></li><li><p>目标程序遍历搜索</p><p>通常以PE文件格式的文件作为感染目标，进行搜索时调用FindFirstFile和FindNextFile两个API</p></li><li><p>文件感染</p><p>主要包括使病毒代码能够得到运行，并且原程序的正常功能不能被破坏。这就需要感染时记录原始“程序控制点位置”，病毒代码执行完毕后返回控制权。避免重复感染：感染标记</p></li></ol><h3 id="30-Windows-PE病毒的常用感染方式及优缺点"><a href="#30-Windows-PE病毒的常用感染方式及优缺点" class="headerlink" title="30.Windows PE病毒的常用感染方式及优缺点"></a>30.Windows PE病毒的常用感染方式及优缺点</h3><p>添加新节感染：增加新节存放病毒代码，要事先检查节表空间是否足够</p><p>碎片式感染：代码分解插入到节之间的填充部分</p><p>插入式感染：病毒代码插入到HOST文件的代码节，这样会增加HOST程序大小，并且可能会修改HOST程序中的数据导致HOST程序运行失败</p><p>伴随式感染：备份HOST程序，用自身替换HOST程序，病毒代码执行完毕再把控制权交回HOST程序。</p><h3 id="31-宏病毒传播过程"><a href="#31-宏病毒传播过程" class="headerlink" title="31.宏病毒传播过程"></a>31.宏病毒传播过程</h3><p>宏病毒将代码放到数据文件或者模板的宏中，由于这些宏会自动执行，因此获取控制权。宏病毒在单机情况下就是Office文档模板传播，在网络情况下也可能通过邮件进行传播。通过让宏在数据文档和文档模板两类文件之间互相感染进行传播。自我保护、代码导出（到本地文件）、代码导入（到当前活动文档）。</p><h3 id="32-常见的病毒检测技术及优缺点"><a href="#32-常见的病毒检测技术及优缺点" class="headerlink" title="32.常见的病毒检测技术及优缺点"></a>32.常见的病毒检测技术及优缺点</h3><ol><li>特征值检测技术<ul><li>从病毒中提取病毒特征值进行检测，通常是病毒中的一段或者多段字符串或二进制串</li><li>优点：检测速度快，误报率低，技术成熟</li><li>缺点：只能检测已知的恶意代码，容易被免杀绕过</li></ul></li><li>校验和检测技术<ul><li>检查检测对象的实际校验和与预期的是否一致，判断是否感染</li><li>优点：方法简单，能发现未知病毒，目标文件的细微变化也能发现</li><li>缺点：必须预先记录正常文件的校验和才能做对比，误报率高，不能识别病毒名称，效率低</li></ul></li><li>启发式扫描技术<ul><li>恶意代码检测经验和知识的软件实现</li><li>优点：能发现未知病毒</li><li>缺点：误报率高</li></ul></li><li>虚拟机检测技术<ul><li>在内存中模拟一个小的封闭程序执行环境，所有待查的文件在其中被虚拟执行</li><li>优点：有效处理加密类病毒；虚拟机技术+特征值扫描，准确率更高；虚拟机技术+启发式扫描，有利于检测未知变形病毒</li></ul></li><li>主动防御技术<ul><li>也叫行为监控技术，动态监视API接口的调用，判断其程序执行的合法，监控敏感行为</li><li>优点：可发现未知恶意软件，可准确的发现未知恶意软件的恶意行为</li><li>缺点：误报率高，不能识别恶意软件名称，实现困难</li></ul></li></ol><h3 id="33-恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性"><a href="#33-恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性" class="headerlink" title="33.恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性"></a>33.恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性</h3><h4 id="特征值检测技术对抗方式"><a href="#特征值检测技术对抗方式" class="headerlink" title="特征值检测技术对抗方式"></a>特征值检测技术对抗方式</h4><ol><li><p>事后对抗，手工修改自身特征：</p><ul><li>首先利用反病毒软件定位特征值，然后做针对性修改。原理就是定位到检测软件检测到的特征值然后做针对性修改来逃过检测。不同的特征值检测方式可能不同，并且也不止一处特征值。需要灵活的使用特征码定位工具。</li></ul></li><li><p>事前对抗，自动修改自身特征：</p><ul><li>通过加密、多态、变形等，对病毒代码进行加密混淆，使其逃过特征值检测软件。编写这种代码非常的耗时，并且仅仅适用于恶意程序自我复制的情况。但现在因为基于行为的反病毒检测手段出现后，这种对抗的有效性也降低了。</li><li>加壳处理，通过对代码加壳实现数据特征的变化，体积的压缩，实现程序的免杀</li></ul></li></ol><h4 id="人工分析对抗"><a href="#人工分析对抗" class="headerlink" title="人工分析对抗"></a>人工分析对抗</h4><ol><li><p>在病毒代码编写过程中加入自我保护手段(反汇编、反调试代码等)</p></li><li><p>直接采用第三方软件（加壳软件）增强病毒程序的人工分析难度。</p><p>所谓加壳就是加入一段程序，专门负责保护其不被非法修改或者反编译的程序。但是采用的加壳软件也可能会有对应的脱壳软件，会反对抗到加壳，使得加壳无效。</p></li></ol><h3 id="34-面对恶意软件样本，分析目标，分析方法"><a href="#34-面对恶意软件样本，分析目标，分析方法" class="headerlink" title="34.面对恶意软件样本，分析目标，分析方法"></a>34.面对恶意软件样本，分析目标，分析方法</h3><ol><li>恶意软件样本分析的分析目标：<ul><li>理解恶意软件的工作原理和行为特征</li><li>实现或完善相应的安全检测机制</li><li>实现对已有恶意软件和未知恶意软件的防御、检测</li></ul></li><li>恶意软件样本分析的分析方法：<ul><li>在线分析：<strong>在线病毒扫描</strong>、<strong>在线行为分析</strong></li><li>本地静态分析：<strong>加壳检测与脱壳</strong>、<strong>反汇编/反编译</strong>、资源分析</li><li>本地动态分析：快照对比分析、<strong>行为监控分析</strong>、<strong>调试跟踪</strong>、<strong>网络监控分析</strong>、<strong>运行环境仿真</strong></li><li>网络交互的动态分析：网络连接选择、网络交互环境仿真、<strong>数据包捕获分析</strong></li></ul></li></ol><h3 id="35-常见的加壳类型检测工具"><a href="#35-常见的加壳类型检测工具" class="headerlink" title="==35.常见的加壳类型检测工具=="></a>==35.常见的加壳类型检测工具==</h3><h3 id="36-针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？"><a href="#36-针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？" class="headerlink" title="36.针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？"></a>36.针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？</h3><p>对于已知病毒我们可以先查看病毒是否进行过加壳处理，如果加壳了则需要用脱壳技术进行解密，然后可以利用特征值检测技术，或者用虚拟机检测技术进行检测，然后虚拟机检测+特征值结合可以提高检测效率。</p><p>对于未知病毒的检测方法有校验和检测技术，可以发现未知的恶意代码，但是这样的方法需要提前对文件有一个校验和的预期，才能同被植入了恶意代码的文件做对比。其次还可以采用启发式扫描结合虚拟机技术来实现对未知病毒的检测，提高检测的准确率。也可以用主动防御技术，监控程序API接口调用，进行逻辑分析，识别出恶意软件，但是这样的实现有些复杂，比较困难。</p>]]></content>
    
    
    <summary type="html">软件，软件危机，软件缺陷与漏洞，软件漏洞的发现与利用，软件漏洞检测方法，代码分析工具，恶意代码</summary>
    
    
    
    <category term="软件系统安全" scheme="http://ins1mn1a.github.io/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="软件系统安全" scheme="http://ins1mn1a.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络安全协议基本问题</title>
    <link href="http://ins1mn1a.github.io/2021/12/24/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"/>
    <id>http://ins1mn1a.github.io/2021/12/24/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-12-24T14:35:34.968Z</published>
    <updated>2022-03-08T12:49:11.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Http和Https协议的端口号："><a href="#Http和Https协议的端口号：" class="headerlink" title="Http和Https协议的端口号："></a>Http和Https协议的端口号：</h3><p>Http：80  Https：443</p><h3 id="网络监听："><a href="#网络监听：" class="headerlink" title="网络监听："></a>网络监听：</h3><p>网络监听是一种监视网络状态、数据流程以及网络上信息传输的工具，它可以将网络界面设定成监听模式，并且可以截获网络上所传输的信息。但是网络监听只能应用于连接同一网段的主机，通常被用来获取用户密码等。也就是说，当黑客登录网络主机并取得超级用户权限后，若要登录其它主机，使用网络监听便可以有效地截获网络上的数据，这是黑客使用最好的方法。</p><h3 id="非对称密码算法："><a href="#非对称密码算法：" class="headerlink" title="非对称密码算法："></a>非对称密码算法：</h3><p>RSA（密钥分配，也能用于加解密数据，“私钥加密，公钥解密”和“公钥加密，私钥解密”）、DH（密钥分配，不能用于加解密）、DSA、ECC算法建立在有限域上椭圆曲线的离散对数问题的难解性。</p><h3 id="攻击行为："><a href="#攻击行为：" class="headerlink" title="攻击行为："></a>攻击行为：</h3><p>窃听 篡改 重放攻击 预重放 反射 类型缺陷攻击 协议交互攻击 拒绝服务攻击 密码分析 协议交互。</p><p>主动攻击是指攻击者对某个连接中通过的协议数据、单元进行各种处理。</p><p>被动攻击是指攻击者通过窃听消息来达到攻击目的；</p><p>选择出主动攻击</p><ul><li><p>被动攻击：截获</p></li><li><p>主动攻击：中断、篡改、伪造</p></li></ul><h3 id="防止用户被冒名所欺骗的方法："><a href="#防止用户被冒名所欺骗的方法：" class="headerlink" title="防止用户被冒名所欺骗的方法："></a>防止用户被冒名所欺骗的方法：</h3><p>对信息源进行身份验证 </p><h3 id="Kerberos认证支持的加密算法："><a href="#Kerberos认证支持的加密算法：" class="headerlink" title="Kerberos认证支持的加密算法："></a>Kerberos认证支持的加密算法：</h3><p>Kerberos采用的加密算法是DES</p><h3 id="ISAKMP安全关联和密钥管理协议："><a href="#ISAKMP安全关联和密钥管理协议：" class="headerlink" title="ISAKMP安全关联和密钥管理协议："></a>ISAKMP安全关联和密钥管理协议：</h3><p>一种协议框架，定义了<strong>有效负载的格式、实现密钥交换协议的机制以及SA协商</strong>。使用<strong>UDP的端口500</strong>，一般使用UDP。</p><p>从宏观上来看，ISAKMP主要做了三件事情：</p><ol><li><p><strong>SA协商</strong></p><p> SA协商的目的是为了在通信双方间协商出一组双方都认可的安全参数。比如两端采用相同的加密算法和完整性算法。</p></li><li><p><strong>密钥交换</strong>  </p><p>密钥交换的目的是为已经协商好的算法生成必要的密钥信息。</p></li><li><p><strong>对等端身份认证</strong></p><p>认证的目的是鉴别对方的身份，保证自己不是在跟一个伪造的对象通信。</p></li></ol><p>这样，通过一系列的消息交互，通信的双方既鉴别了对方的身份，也保证了后继通信的安全性。</p><h3 id="IPSEC的典型应用："><a href="#IPSEC的典型应用：" class="headerlink" title="IPSEC的典型应用："></a>IPSEC的典型应用：</h3><ul><li>端到端安全</li><li>基本VPN支持</li><li>保护移动用户访问内部网</li><li>嵌入式隧道</li></ul><h3 id="Kerberos实体认证采用的身份凭证："><a href="#Kerberos实体认证采用的身份凭证：" class="headerlink" title="Kerberos实体认证采用的身份凭证："></a>Kerberos实体认证采用的身份凭证：</h3><p>口令，票据；虹膜，指纹</p><h3 id="网络安全需求有哪些："><a href="#网络安全需求有哪些：" class="headerlink" title="网络安全需求有哪些："></a>网络安全需求有哪些：</h3><p>机密性、完整性、可控性、不可否认性、可用性</p><h3 id="IPSEC规定的2个组件："><a href="#IPSEC规定的2个组件：" class="headerlink" title="IPSEC规定的2个组件："></a>IPSEC规定的2个组件：</h3><ol><li>SAD（安全关联数据库）</li><li>SPD（安全策略数据库）</li></ol><h3 id="网络安全协议的基础："><a href="#网络安全协议的基础：" class="headerlink" title="网络安全协议的基础："></a>网络安全协议的基础：</h3><p>密码学</p><h3 id="SSL报文最终封装在什么环境："><a href="#SSL报文最终封装在什么环境：" class="headerlink" title="SSL报文最终封装在什么环境："></a>SSL报文最终封装在什么环境：</h3><ul><li>在SSL协议中，所有的传输数据都被封装在<strong>记录</strong>中进行投递</li><li>而对于总体而言，封装在<strong>传输层报文</strong>中传递</li></ul><h2 id="什么是以破坏认证协议为目标的实体"><a href="#什么是以破坏认证协议为目标的实体" class="headerlink" title="什么是以破坏认证协议为目标的实体"></a>什么是以破坏认证协议为目标的实体</h2><p>攻击者是以破坏认证协议为目标的实体</p><h2 id="Kerberos用什么来进行认证"><a href="#Kerberos用什么来进行认证" class="headerlink" title="Kerberos用什么来进行认证"></a>Kerberos用什么来进行认证</h2><p>票据</p><h3 id="IPSec、AH、ESP、IKE："><a href="#IPSec、AH、ESP、IKE：" class="headerlink" title="IPSec、AH、ESP、IKE："></a>IPSec、AH、ESP、IKE：</h3><p>IKE：互联网密钥交换协议，对应IPSec的协商阶段</p><p>AH：认证首部，对应IPSec的数据交互阶段，规定了报文格式以及对报文的处理方式和处理过程。AH只提供认证功能，不加密，仅计算消息验证码（ICV，完整性校验值）</p><p>ESP：封装安全载荷，对应IPSec的数据交互阶段。ESP同时提供机密性和完整性保护，这意味着ESP会加密报文，同时计算ICV。</p><h4 id="AH提供的三类安全服务："><a href="#AH提供的三类安全服务：" class="headerlink" title="AH提供的三类安全服务："></a>AH提供的三类安全服务：</h4><ul><li>数据完整性</li><li>数据源发认证</li><li>抗重放攻击</li></ul><h4 id="ESP提供的五类安全服务："><a href="#ESP提供的五类安全服务：" class="headerlink" title="ESP提供的五类安全服务："></a>ESP提供的五类安全服务：</h4><ul><li>数据完整性</li><li>抗数据源发认证</li><li>抗重放攻击</li><li>机密性</li><li>有限的传输流机密</li></ul><h1 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h1><h3 id="重放攻击："><a href="#重放攻击：" class="headerlink" title="重放攻击："></a>重放攻击：</h3><p>重放攻击是针对安全协议的最常见攻击，重放攻击指的是攻击者参与到协议的交互过程，利用窃听到的已经发送过的部分或全部消息，在交互过程中重新发送，来干涉协议的正常运行。</p><h3 id="前向安全："><a href="#前向安全：" class="headerlink" title="前向安全："></a>前向安全：</h3><p>一个协议具备前向安全，是指即便安全协议中使用的长期密钥被攻击者破获，而由这些长期密钥所建立（通过安全协议建立）的<strong>会话密钥</strong>仍然是安全的。如果对于协议中的任何主体，都能保证他们长期密钥的前向安全，那么这个协议提供了前向安全。</p><h3 id="类型缺陷攻击："><a href="#类型缺陷攻击：" class="headerlink" title="类型缺陷攻击："></a>类型缺陷攻击：</h3><p>消息最终是由一系列的二进制比特串组成的，类型缺陷攻击使得诚实主体对它所接收的消息发送了错误的理解，使得诚实主体把一次性随机数，时间戳或者身份等信息嵌入到某个密钥中去，进而导致协议安全性被破坏。</p><h3 id="并行会话攻击："><a href="#并行会话攻击：" class="headerlink" title="并行会话攻击："></a>并行会话攻击：</h3><p>是指攻击者安排协议的一个或多个会话并行地执行，使得自己能够从一个会话中获得消息，并通过重放到其他并行的会话中以达到自己的目的，如针对NSPK的并行会话攻击。</p><h3 id="中间人攻击："><a href="#中间人攻击：" class="headerlink" title="中间人攻击："></a>中间人攻击：</h3><p>中间人攻击就是攻击者在协议参与者双方分别进行冒充通信。攻击者先冒充参与方A与参与方B进行协议的运行，然后又冒充参与方B与参与方A进行协议的运行，但事实上参与者双方并没有感受到。</p><h3 id="IPSec："><a href="#IPSec：" class="headerlink" title="IPSec："></a>IPSec：</h3><p>TLS（安全传输层协议）可以对应用层的协议加密，并传递给传输层，但在IP层并不做任何安全性处理。IP作为其他高层协议的载体，本身并未考虑安全性问题。IPSec就是用来在IP层进行安全处理，对于高层数据，只要是通过IP传输，都会在IP层进行安全防护，实现IP数据包的机密性、完整性等安全特性，为上层协议提供“透明”的安全服务。</p><h3 id="IPSec协议的组件（什么是IPSec协议，从协议组件上回答）"><a href="#IPSec协议的组件（什么是IPSec协议，从协议组件上回答）" class="headerlink" title="IPSec协议的组件（什么是IPSec协议，从协议组件上回答）"></a>IPSec协议的组件（什么是IPSec协议，从协议组件上回答）</h3><p>IPSec是一个协议套件，<strong>核心协议是IKE、AH和ESP</strong>。其中<strong>IKE</strong>完成通信<strong>对等端身份验证、SA协商和密钥交换功能</strong>，是一个<strong>协商协议</strong>；<strong>AH和ESP是数据通信协议</strong>，他们规定了IPSec的报文格式和报文的处理过程。</p><h3 id="SSL协议："><a href="#SSL协议：" class="headerlink" title="SSL协议："></a>SSL协议：</h3><p>SSL（安全套接字协议）协议是一种增强传输层安全的协议，其协议套件由握手，更改密码规范，警告和记录协议组成。</p><ul><li>握手提供算法协商、密钥生成和身份验证功能。</li><li>更改密码规范协议用以通告对等端用新的安全参数来保护数据。</li><li>警告则同时具备安全断连和错误通告功能。</li><li>记录协议是SSL的数据承载层。</li></ul><h3 id="SSH协议的解释（SSH会话安全）："><a href="#SSH协议的解释（SSH会话安全）：" class="headerlink" title="SSH协议的解释（SSH会话安全）："></a>SSH协议的解释（SSH会话安全）：</h3><p>SSH是一个应用层安全协议，端口号为22。可以对数据进行加密，身份认证，完整性校验等。SSH由传输层协议，用户认证协议和连接协议构成，主要用于远程登录会话和为其他网络服务提供安全性的协议。</p><h3 id="Kerberos协议："><a href="#Kerberos协议：" class="headerlink" title="Kerberos协议："></a>Kerberos协议：</h3><p>Kerberos是一项认证服务。它提供一种验证用户身份的方法。它的实现不依赖于主机操作系统的认证，不基于主机的地址，也不需要有主机物理安全性的保证，并假设网络上传输的包都可以被任意地读取、修改和插入。</p><h3 id="散列函数的特征："><a href="#散列函数的特征：" class="headerlink" title="散列函数的特征："></a>散列函数的特征：</h3><ol><li>映射分布均匀性和差分分布均匀性</li><li>单向性</li><li>抗冲突性</li></ol><h3 id="数据认证性："><a href="#数据认证性：" class="headerlink" title="数据认证性："></a>数据认证性：</h3><p>数据认证性保证数据来源的合法性，通常也包含了对数据完整性的保证，这是因为修改数据相当于改变数据的来源。尽管在理论上，可以在不保证数据认证性的情况下保证数据的完整性，它们仍常通过相同的机制实现。</p><h3 id="密钥建立的目标："><a href="#密钥建立的目标：" class="headerlink" title="密钥建立的目标："></a>密钥建立的目标：</h3><p>密钥建立是一个过程，通过这个过程，可以使得两个或者多个主体拥有良好的共享秘密，以用于后继的密码学运算。</p><h3 id="针对SSL攻击方法："><a href="#针对SSL攻击方法：" class="headerlink" title="针对SSL攻击方法："></a>针对SSL攻击方法：</h3><blockquote><p><strong>中间人攻击，野兽攻击，罪恶攻击，溺水攻击，降级攻击</strong><br>主要是围绕通讯过程，加密方式，旧版本漏洞展开攻击。</p></blockquote><ol><li>中间人攻击：</li></ol><ul><li>SSL sniffing攻击解释为伪装攻击，一般结合ARP欺骗构成一个中间人攻击。它是一种针对ssl协议的应用发起的攻击。</li><li>SSL stripping攻击：是在客户端和服务器端，利用ARP欺骗等技术进行的一个中间人攻击（重定向网址）</li></ul><ol start="2"><li><p>BEAST（野兽攻击）<br>BEAST是一种明文攻击，通过从SSL/TLS加密的会话中获取受害者的COOKIE值（通过进行一次会话劫持攻击），进而篡改一个加密算法的 CBC（密码块链）的模式以实现攻击目录，其主要针对TLS1.0和更早版本的协议中的对称加密算法CBC模式。</p></li><li><p>CRIME（罪恶攻击）<br>CRIME(CVE-2012-4929)，全称Compression Ratio Info-leak Made Easy，<strong>这是一种因SSL压缩造成的安全隐患</strong>，通过它可窃取启用数据压缩特性的HTTPS或SPDY协议传输的私密Web Cookie。在成功读取身份验证Cookie后，攻击者可以实行会话劫持和发动进一步攻击。</p></li><li><p>DROWN（溺水攻击/溺亡攻击）<br>即利用过时的、<strong>弱化的一种RSA加密算法</strong>来解密破解TLS协议中被该算法加密的会话密钥。 具体说来，DROWN漏洞可以利用过时的SSLv2协议来解密与之共享相同RSA私钥的TLS协议所保护的流量。 DROWN攻击依赖于SSLv2协议的设计缺陷以及知名的Bleichenbacher攻击。</p></li><li><p>Downgrade（降级攻击）<br>降级攻击是一种对计算机系统或者通信协议的攻击，在降级攻击中，攻击者故意使系统放弃新式、安全性高的工作方式，反而使用为向下兼容而准备的老式、安全性差的工作方式，降级攻击常被用于中间人攻击，将加密的通信协议安全性大幅削弱，得以进行原本不可能做到的攻击。 在现代的回退防御中，使用单独的信号套件来指示自愿降级行为，需要理解该信号并支持更高协议版本的服务器来终止协商，该套件是TLS_FALLBACK_SCSV(0x5600)</p></li></ol><h3 id="Kerberos的票据和认证符的功能："><a href="#Kerberos的票据和认证符的功能：" class="headerlink" title="Kerberos的票据和认证符的功能："></a>Kerberos的票据和认证符的功能：</h3><ol><li>进行身份认证（用户及服务器）</li><li>防止IP地址伪造和重放攻击</li><li>加密数据</li><li>保护子会话密钥</li></ol><p>票据提供服务器（TGS）</p><p>认证服务器（AS）</p><ul><li>票据：为避免口令认证的缺陷，Kerberos引入票据许可服务，它只向已由AS（认证服务器）认证了身份的客户端颁发票据，避免了明文口令的传输。</li><li>认证符：认证符的作用是验证客户的身份，客户不仅要传输票据，还需要发送额外的信息来证明自己确实是票据的合法拥有者，这个信息就是认证符（authenticator），它使用会话密钥加密，并包含了用户名和时间戳。</li></ul><h1 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h1><h3 id="windows下的IPSec实验："><a href="#windows下的IPSec实验：" class="headerlink" title="windows下的IPSec实验："></a>windows下的IPSec实验：</h3><ol><li>安装Wireshark软件</li><li>操作机配置IPsec加密策略</li><li>目标机配置同样的IPsec加密策略，操作机和目标机同时指派策略，查看之间通信</li><li>用Wireshark查看密钥交换过程</li></ol><h3 id="Windows下的SSL实验："><a href="#Windows下的SSL实验：" class="headerlink" title="Windows下的SSL实验："></a>Windows下的SSL实验：</h3><ol><li>搭建证书服务器</li><li>搭建web服务器端SSL证书应用</li><li>搭建Https的网站</li><li>目标机用Sniffer监测两者间的SSL连接</li></ol><p>优点</p><p>SSL在应用层协议通信前就<strong>已完成加密算法</strong>，<strong>通信密钥的协商</strong>及<strong>服务器认证</strong>工作，此后应用层协议所传送的<strong>所有数据都会被加密</strong>，从而保证通信的安全性。</p><p>缺点</p><p>SSL除了<strong>传输过程外不能提供任何安全保证</strong>；<strong>不能提供交易的不可否认性</strong>；客户认证是可选的，所以无法保证购买者就是该信用卡合法拥有者；SSL不是专为信用卡交易而设计，在多方参与的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。</p><p>工作原理<br>　　客户机向服务器发送SSL版本号和选定的加密算法；服务器回应相同信息外还回送一个含RSA公钥的数字证书；客户机检查收到的证书足否在可信任CA列表中，若在就用对应CA的公钥对证书解密获取服务器公钥，若不在，则断开连接终止会话。客户机随机产生一个DES会话密钥，并用服务器公钥加密后再传给服务器，服务器用私钥解密出会话密钥后发回一个确认报文，以后双方就用会话密钥对传送的报交加密。</p><h1 id="协议分析："><a href="#协议分析：" class="headerlink" title="协议分析："></a>协议分析：</h1><h3 id="NSPK协议的攻击："><a href="#NSPK协议的攻击：" class="headerlink" title="NSPK协议的攻击："></a>NSPK协议的攻击：</h3><p>NSPK协议提供了对主体双方的双向认证。主体A和B交换各自的随机数Na、Nb，从而共享Na和Nb，并将其结合以生成一个新的会话密钥。PKa和PKb分别为A和B的公开密钥。</p><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152024386.png" alt="image-20211105152024386"></p><blockquote><p><strong>并行会话攻击：攻击者Z首先使A发起一个会话，然后在另一个会话中，攻击者成功地冒充了A。</strong></p></blockquote><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152120732.png" alt="image-20211105152120732"></p><h3 id="大嘴青蛙协议的攻击："><a href="#大嘴青蛙协议的攻击：" class="headerlink" title="大嘴青蛙协议的攻击："></a>大嘴青蛙协议的攻击：</h3><p>会话密钥由主体产生，可信第三方将这个会话密钥传送给另外的主体，Ta、Ts分别为A、S根据各自的本地时钟产生的时间戳。S通过Ta来检查Msg1的新鲜性。如果Msg1是新鲜的，S则将密钥Kab连同自己产生的时间戳Ts发送给B。B 收到Msg2后，检查其中的Ts，若Ts位于时间窗口内，B则认为Kab是新鲜的。5</p><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152228421.png" alt="image-20211105152228421"></p><blockquote><p>并行会话攻击：</p><ul><li><p>攻击者冒充B，向S重放S刚刚发送给B的消息。S收到后，由于Ts在时间窗口内，故认可Msg1，并产生 一个新的时间戳Ts‘，发送消息Msg2’。</p></li><li><p>接着，攻击者再冒充A，S会产生一个更新的时间戳 Ts‘’，并发送消息Msg2‘’。</p></li><li><p>这最终导致攻击者能够从S得到一个“时间戳足够新，但Kab足够老”的消息，并将其发送给B，使B接受一个老的密钥</p></li></ul><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152250491.png" alt="image-20211105152250491"></p></blockquote>]]></content>
    
    
    <summary type="html">网络安全协议基础，包括IPSec、Kerberos、网络安全协议形式化表示等</summary>
    
    
    
    <category term="网络安全" scheme="http://ins1mn1a.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Security" scheme="http://ins1mn1a.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>SDN的TopoGuard解决方案</title>
    <link href="http://ins1mn1a.github.io/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/TopoGuard/"/>
    <id>http://ins1mn1a.github.io/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/TopoGuard/</id>
    <published>2021-12-24T14:18:32.448Z</published>
    <updated>2021-12-24T14:32:58.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SDN攻击和对策"><a href="#SDN攻击和对策" class="headerlink" title="SDN攻击和对策"></a>SDN攻击和对策</h1><h2 id="SDN攻击"><a href="#SDN攻击" class="headerlink" title="SDN攻击"></a>SDN攻击</h2><h3 id="1-主机位置劫持攻击"><a href="#1-主机位置劫持攻击" class="headerlink" title="1. 主机位置劫持攻击"></a>1. 主机位置劫持攻击</h3><p>对于主机位置的改变，由于SDN控制器缺乏对传输的数据包认证步骤，无法保证拓扑信息的真实性，攻击者通过发送伪装的主机消息，就可以实现对网络中的主机的伪装。如下图所示，攻击者向SDN交换机发送一个全新的数据包，交换机会上报到控制器，因为无法认证数据包的真实性，控制器会依据这个数据包默认网络服务器位置发生移动，然而实际上由于拓扑管理信息中该服务器的位置已经变更为攻击者所在的位置，导致后续正常主机无法访问该服务器。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211118094512908.png" alt="image-20211118094512908"></p><h3 id="2-链路伪造攻击"><a href="#2-链路伪造攻击" class="headerlink" title="2. 链路伪造攻击"></a>2. 链路伪造攻击</h3><p>由于目前广泛使用的SDN控制器源码是开源的，因此任何人都可以获取LLDP包格式和每个字段的语义，并且交换机每个端口都可以发送链路层发现协议（LLDP）包，包括连接着主机的端口。</p><h4 id="伪造LLDP包"><a href="#伪造LLDP包" class="headerlink" title="伪造LLDP包"></a>伪造LLDP包</h4><p>攻击者可以通过监控SDN交换机的流量然后伪造出相应的LLDP包，后续伪造的LLDP将会被发送到控制器，因此控制器便更新一条攻击者伪造的链路。</p><h4 id="重放LLDP包"><a href="#重放LLDP包" class="headerlink" title="重放LLDP包"></a>重放LLDP包</h4><p>从一个目标交换机接收到一个LLDP数据包时，攻击者将直接重放到另一目标交换机，而无需进行任何修改。如下图，攻击者将收到的LLDP包通过隧道、物理链路等方式将LLDP包发送给另一目标交换机，这样攻击者便构造了一个虚假的拓扑视图。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211118094555756.png" alt="image-20211118094555756"></p><h3 id="3-拒绝服务攻击"><a href="#3-拒绝服务攻击" class="headerlink" title="3. 拒绝服务攻击"></a>3. 拒绝服务攻击</h3><p>为了避免boardcast strom，OpenFlow控制器提供生成树服务。当网络拓扑更新时，会触发生成树服务来阻止冗余端口。这种能力可能会被攻击者利用，以发动拒绝服务攻击。比如通过给现有拓扑注入一个虚假的链接，攻击者就可以借用生成树服务来杀死正常开关端口。</p><p>生成树算法总是排除连接最大DPID交换机的链接。攻击者拥有几个连接到入口交换机的几个受损主机，通过收听LLDP数据包，对手就可以获得两个入口交换机的的DPID。然后，攻击控制受损主机通过较低的DPID连接到入口交换机，并注入假LLDP以与目标交换机宣布链接。</p><p>最终将导致两种情况：如果聚合交换机的DPID小于所选交换机的DPID，则攻击者可以关闭目标交换机的任意端口，如图a所示；如果所选择的交换机具有最小的DPID，则目标交换机和聚合交换机之间的链路被排除在生成树之外，并且相应端口也会被阻塞，如图b所示。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211118095722939.png" alt="image-20211118095722939"></p><h3 id="4-中间人攻击"><a href="#4-中间人攻击" class="headerlink" title="4. 中间人攻击"></a>4. 中间人攻击</h3><p>虚假的链路可以干扰最短路径路由服务。攻击者可以构建一个LLDP channel来欺骗OpenFlow控制器，让控制器感觉在两个目标交换机之间还存在一个内部链路（实际上并不存在）。一旦控制器注意到了链路，它就会根据这个受到污染的拓扑信息来重新计算最短路径。这样所有与虚假链路有连接的路线都被攻击者进行了污染。但是，OpenFlow与传统的以太网交换机不同，它并不会修改数据包的源MAC地址。因此为了规避可能的异常检测，我们必须在重放LLDP和普通数据包的时保留源MAC地址。</p><h2 id="防御策略"><a href="#防御策略" class="headerlink" title="防御策略"></a>防御策略</h2><h3 id="1-静态防御策略"><a href="#1-静态防御策略" class="headerlink" title="1. 静态防御策略"></a>1. 静态防御策略</h3><p>静态防御策略是预先手动配置/管理主机位置和链路信息（比如，将主机标识符（比如MAC地址）分配给一个特定的交换机端口），然后每当有新的改变时（new addition or removal）手动验证和修改。显然，静态防御策略并不是一个很好的选择，因为手动的去管理是特别繁琐的，容易出错，并且在实践中也不好扩展。特别地，它并不适用于动态的并且有可扩展性的需求的SDN网络。</p><h3 id="2-动态防御策略TopoGuard"><a href="#2-动态防御策略TopoGuard" class="headerlink" title="2. 动态防御策略TopoGuard"></a>2. 动态防御策略TopoGuard</h3><h4 id="2-1-主机位置劫持攻击的动态防御策略"><a href="#2-1-主机位置劫持攻击的动态防御策略" class="headerlink" title="2.1 主机位置劫持攻击的动态防御策略"></a>2.1 主机位置劫持攻击的动态防御策略</h4><p>主机位置劫持攻击的问题主要在于，当主机位置更新的时候，OpenFlow控制器缺乏了对主机标识符的验证。</p><h5 id="2-1-1-主机实体认证"><a href="#2-1-1-主机实体认证" class="headerlink" title="2.1.1 主机实体认证"></a>2.1.1 主机实体认证</h5><p>这是一个密码学的加密解决方案：添加额外的公钥来验证主机。当一个主机需要改变它的位置的时候，它就把新的位置信息通过私钥加密到数据包中没使用的部分（比如VLAN ID or ToS）。</p><p>这个方案理论上确实是可行的，可以解决恶意主机的profile伪造，因为攻击者无法获取目标主机的私钥。但是在现实上，这种方案需要增加额外的存储开销来保存OpenFlow控制器的公钥，以及用于处理每个Packet-In数据包的计算开销。并且，所有主机的密钥管理和动态添加/修改也会带来额外的开销和成本。此外，这种方法需要在每个主机上修改实现，实际部署上非常的繁琐和困难。</p><h5 id="2-1-2-主机迁移合法性的验证"><a href="#2-1-2-主机迁移合法性的验证" class="headerlink" title="2.1.2 主机迁移合法性的验证"></a>2.1.2 主机迁移合法性的验证</h5><blockquote><p>主机迁移完成的条件：</p></blockquote><ul><li>主机迁移的前置条件是OpenFlow控制器必须接收到一个Port_Down信号在主机迁移完成之前</li><li>主机迁移的后置条件是主机在完成迁移之后，对先前位置的主机实体的访问是不可达的。</li></ul><p>因此，基于上述两种情况，我们可以通过检查前置条件和后置条件来验证主机迁移的合法性。若有一个条件不满足，那么可能原主机位置被劫持，与控制器进行通信的主机是攻击者伪造的主机，这样就会被检测到。这个方法也增加了额外的开销，但是比较上面基于公私钥的实体认证相比，显然此方法更加轻量级。</p><p>在面向SDN的车载边缘计算中我们也可以利用这种模型，来对抗主机位置劫持的攻击。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222850617.png" alt="image-20211224222850617"></p><h4 id="2-2-链路伪造攻击的动态防御策略"><a href="#2-2-链路伪造攻击的动态防御策略" class="headerlink" title="2.2 链路伪造攻击的动态防御策略"></a>2.2 链路伪造攻击的动态防御策略</h4><blockquote><p>链路伪造的攻击主要在两个方面：</p></blockquote><ul><li><p>在OpenFlow网络的链路发现过程中，LLDP包的完整性/来源可能遭到破坏</p></li><li><p>受损主机参与LLDP传播路径</p><h5 id="2-2-1-LLDP数据包的身份验证"><a href="#2-2-1-LLDP数据包的身份验证" class="headerlink" title="2.2.1 LLDP数据包的身份验证"></a>2.2.1 LLDP数据包的身份验证</h5><p>解决这个问题的一个方案是在LLDP数据包中添加额外的身份验证器TLVs。比如，我们可以在LLDP数据包中添加一个有控制器签名的TLV，并在接收到LLDP数据包时检查签名。签名TLV是通过LLDP数据包中的DPID和端口号都计算的。这样，攻击者很难操纵LLDP数据包。然而这种方法，无法抵抗基于LLDP重放/隧道的方式的链路伪造攻击。</p><h5 id="2-2-2-交换机端口属性的验证"><a href="#2-2-2-交换机端口属性的验证" class="headerlink" title="2.2.2 交换机端口属性的验证"></a>2.2.2 交换机端口属性的验证</h5><p>如果OpenFlow链路发现过程中没有主机参与到LLDP的传播，那么就可以判断没有攻击者进行链路伪造。因此可以检查是否有主机驻留在LLDP的链路传播中从而检测是否有攻击者参与。</p><p>我们可以增加一些额外的逻辑来跟踪来自不同交换机端口的流量，已决定哪个设备连接到哪个端口。如果 OpenFlow 控制器从特定的交换机端口检测到主机生成的流量（例如DNS），则我们将该端口的设备类型设置为 HOST。否则，当从这些端口接收到 LLDP 数据包时，我们将这些交换机端口指定为交换机。在 OpenFlow 网络中，这两个类型是相互排斥的，因为 LLDP 只能在交换机内部链路端口和连接到OpenFlow控制器的端口上传输。</p><p>这种方法的一个假设是：受损的主机不是一个实际的交换机，因此将生成常规的主机生成的流量（如ARP，DNS）。这假设也确实是合理的，在实践中大多数情况下也成立。虽然攻击者也可以禁用受损主机或者虚拟机中的所有主机生成流量，但它这样多少页破坏了主机的正常网络活动功能，无异于暴露自己，使得正常机器用户注意到。</p></li></ul><h2 id="TopoGuard"><a href="#TopoGuard" class="headerlink" title="TopoGuard"></a>TopoGuard</h2><p>TopoGuard的基本思想是通过修复上一节所提到的安全漏洞来确保控制器的安全。</p><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>下图展示了TopoGuard防御系统的体系结构。The Topology Update Checker在探测到拓扑更新后会去验证主机迁移的合法性，LLDP数据包的完整性和来源以及交换机端口属性。具体来说，Port Manager监视 OpenFlow 消息，以跟踪存储在Port Property（端口属性）中的交换机端口动态。然后，Port Property将用于推理拓扑更新的可信性。Host Prober（主机探测）用来测试在OpenFlow网络中特点位置的主机的活动性，并且判断主机迁移的合法性。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222838902.png" alt="image-20211224222838902"></p><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="端口属性管理"><a href="#端口属性管理" class="headerlink" title="端口属性管理"></a>端口属性管理</h4><p>为了推断拓扑更新的有效性，给OpenFlow控制器中每个交换机端口增加了额外属性。包括：</p><p>设备类型（Device Type）、主机列表（HOST List）和标识（SHUT_DOWN_FLAG）。</p><ol><li><p>设备类型</p><p>设备类型指的是一个特定交换机端口连接到的设备类型。该值可以是任意值ANY，交换机SWITCH，主机HOST。初始值是ANY，它将根据后续流量切换到SWITCH或者HOST。当端口管理器从具有设备类型为ANY的交换机端口接收LLDP数据包时，它会将其类型更改为SWITCH。同样，若接收到任何 first-hop 主机流量时，交换机端口的设备类型被设置为HOST。相反，当接收到端口状态信息中指示的Port_Down信号时，HOST和交换机端口值被设置为ANY。如果端口管理器检测到HOST端口的LLDP包或者交换机端口的first-hop主机流量包，则会引发攻击警报并通知拓扑更新检查器以防止相关拓扑更新。这种防御方法的认为LLDP数据包仅被设计为通过数据平面上的交换机内部链路端口。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222829755.png" alt="image-20211224222829755"></p></li></ol><ul><li><p>设备类型被判定为HOST说明交换机端口所连接到的设备类型是一个主机，而当端口管理器检测到主机端口发送的是LLDP数据包，那么可以认定发生了链路伪造的攻击。</p></li><li><p>设备类型被判定为SWITCH说明交换机端口所连接到的设备类型是一个交换机，而当端口管理器检测到主机端口发送的是主机流量数据包，那么就可以认为在链路发现的过程中有主机的参与，即是发生了攻击。</p></li></ul><ol start="2"><li><p>主机列表</p><p>端口属性管理的一个挑战是<strong>如何确定端口的设备类型为HOST。</strong>尽管上述中我们认为若接收到任何first-hop 主机流量时，交换机端口的设备类型被设置为HOST。但是在实际上，发现不同的OpenFlow交换机可能会为特定的主机流发出多个包内消息的副本，即<strong>OpenFlow控制器将从交换机内部链路端口接收主机流量。</strong></p><p>为了解决这个问题，在每个交换机端口的端口属性中维护<strong>主机列表</strong>，其中包含主机实体（MAC地址形式）。当接收到Packet-In消息时，端口管理器<strong>在现有端口属性的主机列表中定位主机实体。如果没有找到，则将流量视为first-hop流量，并将源MAC地址记录在入口交换机端口的端口属性的主机列表中。</strong></p></li><li><p>SHUT_DOWN_FLAG</p><p>主机列表的另一个作用是验证主机迁移的可信度。主机迁移的前置条件是控制器在主机迁移完成之前接收到一个Port_Down信号。此时一旦检测到该<strong>端口关闭</strong>，我们将为交换机端口的主机列表中的主机<strong>设置SHUT_DOWN_FLAG</strong>。当端口管理器从该端口接收到相关的主机流量时，可以禁用SHUT_DOWN_FLAG。此外，我们还可以验证主机列表中的SHUT_DOWN_FLAG，以验证主机迁移。</p></li></ol><h4 id="主机探测"><a href="#主机探测" class="headerlink" title="主机探测"></a>主机探测</h4><p>我们还可以利用主机探测器（Host Prober）来验证主机迁移的后置条件，即主机迁移完成后在前一个位置无法访问主机。</p><p>主机探测器向主机的前一个位置发出一个主机探测数据包，例如：IMCPEcho请求，并且设置一个合理的timeout（1s）等待响应。为了确保响应的成功交付，主机探测器还安装了一个流规则，以将 ICMP 响应引导回 OpenFlow 控制器。</p><h4 id="拓扑更新验证"><a href="#拓扑更新验证" class="headerlink" title="拓扑更新验证"></a>拓扑更新验证</h4><p>拓扑更新检查器将验证拓扑更新的正确性，包括主机迁移和新的链路发现。</p><ul><li><p><input disabled="" type="checkbox">  检测到主机迁移</p><p>检查器将引用<strong>端口属性</strong>来检查该<strong>前置条件</strong>，并指示<strong>主机探测</strong>程序验证该<strong>后置条件</strong>。</p></li><li><p><input disabled="" type="checkbox">  验证链路发现</p><p>第一个任务是确保 LLDP 的完整性/来源。为此，我们在一个LLDP 数据包中放置一个签名 TLV，这是一个 DPID 和端口号的加密哈希值。一旦发现一个新链路，拓扑更新检查器就会对已签名的哈希值 TLV 执行额外的验证逻辑。然后，拓扑更新检查器检测主机是否位于 LLDP 传播的路径上。通过检查新链路的交换机端口的设备类型来完成。因此，HOST 端口中涉及的任何内部链接更新都将被拒绝，并触发攻击警报。</p></li></ul><h2 id="传统网络的具体攻击方式"><a href="#传统网络的具体攻击方式" class="headerlink" title="传统网络的具体攻击方式"></a>传统网络的具体攻击方式</h2><h3 id="主机位置劫持"><a href="#主机位置劫持" class="headerlink" title="主机位置劫持"></a>主机位置劫持</h3><p>一个臭名昭著的主机位置劫持攻击是以太网网络中的 <strong>ARP 缓存毒化攻击</strong>。即攻击者发送伪造的 ARP 消息，以将目标主机的 IP 地址与恶意主机 的 MAC 地址关联起来。通过这样做，对手可以劫持目标主机的实体，这通常是一个网关。但是，ARP 缓存中毒攻击与主机位 置劫持攻击有几个不同，如下表所示。首先，ARP 高速缓存中 毒的攻击范围仅限于一个广播域，即对手必须与其目标保持在 同一广播域内。相比之下，对手可以在 OpenFlow 网络的任何位置发起主机位置劫持攻击。第二，除了 ARP 应答数据包外，主 机位置劫持攻击还可以利用几乎各种数据包，如 ICMPEcho、UDP 和 TCP，来篡夺目标主机的位置。在这一点上，主机位置劫持攻击可以隐藏在正常流量中，以避开 NIDS（网络入侵检测）。同样从防御的角度来看，传统的 ARP 缓存中毒缓解策略， 如静态 ARP 条目，可能不适合直接应用于 SDN 网络，因为其静态配置破坏了 OpenFlow 网络的动态处理能力。例如，跟踪各种 OpenFlow 访问点之间的主机迁移。为了抵御主机位置劫持攻击以及跟踪网络动态，在本文中，我们利用 OpenFlow 的特定功能来动态验证主机迁移。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222820222.png" alt="image-20211224222820222"></p><h3 id="链路伪造"><a href="#链路伪造" class="headerlink" title="链路伪造"></a>链路伪造</h3><p>在传统网络中，类似于链路伪造攻击的攻击是 <strong>STP 破坏</strong>（即 BPDU 伪造），即对手用最小的桥 ID 伪造 BPDUs，以抢占生成树的根。在伪造根之后，对手有可能精心策划拒绝服务或中间攻击。然而，STP 破坏攻击只会扰乱STP 的运行，而不是向网络拓扑中注入一个假的链路，以毒害整个网络操作。</p>]]></content>
    
    
    <summary type="html">针对软件定义网络SDN的主机位置劫持攻击、链路伪造攻击等攻击的TopoGuard体系架构</summary>
    
    
    
    <category term="SDN软件定义网络" scheme="http://ins1mn1a.github.io/categories/SDN%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="SDN" scheme="http://ins1mn1a.github.io/tags/SDN/"/>
    
  </entry>
  
  <entry>
    <title>Mininet的环境安装</title>
    <link href="http://ins1mn1a.github.io/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/SDN/"/>
    <id>http://ins1mn1a.github.io/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/SDN/</id>
    <published>2021-12-24T14:17:39.120Z</published>
    <updated>2021-12-25T14:37:08.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mininet"><a href="#Mininet" class="headerlink" title="Mininet"></a>Mininet</h1><h3 id="安装Mininet"><a href="#安装Mininet" class="headerlink" title="安装Mininet"></a>安装Mininet</h3><p><a href="http://mininet.org/download/#option-2-native-installation-from-source">http://mininet.org/download/#option-2-native-installation-from-source</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> git://github.com/mininet/mininet</span><br><span class="line">sudo mininet/util/install.sh -n3v<span class="comment">#-a基本不会成功</span></span><br><span class="line">sudo install.sh -h <span class="comment">#安装OpenFlow Wireshark分解器</span></span><br></pre></td></tr></table></figure><h3 id="Mininet命令"><a href="#Mininet命令" class="headerlink" title="Mininet命令"></a>Mininet命令</h3><h4 id="网络建构启动参数"><a href="#网络建构启动参数" class="headerlink" title="网络建构启动参数"></a>网络建构启动参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--topo自定义拓扑结构（最常用）</span><br><span class="line">--custom加载脚本拓扑</span><br><span class="line">--switch自定义要使用的交换机</span><br><span class="line">--controller自定义要使用的控制器</span><br><span class="line">--mac自动配置设备的MAC地址</span><br></pre></td></tr></table></figure><h5 id="–topo"><a href="#–topo" class="headerlink" title="–topo"></a>–topo</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --topo=single,3<span class="comment">#单一拓扑：交换机只有一个，下挂一个或多个主机</span></span><br><span class="line">sudo mn --topo=linear,4<span class="comment">#线性拓扑：交换机连接为线性排列，每个交换机所连接的主机数目只有一个</span></span><br><span class="line">sudo mn --topo=tree,depth=2,fanout=2<span class="comment">#树形拓扑：交换机连接成树形，depth为深度，叶子结点为主机，fanout为广度，即一个交换机下有多少个设备</span></span><br><span class="line">sudo mn --custom file.py --topo mytopo<span class="comment">#file.py最好替换成绝对路径 mytopo为file.py中的类名</span></span><br><span class="line">sudo mn --protocol=openflow13<span class="comment">#最小化拓扑，一个交换机，两个主机</span></span><br></pre></td></tr></table></figure><h5 id="–swicth"><a href="#–swicth" class="headerlink" title="–swicth"></a>–swicth</h5><p>默认使用OpenVSwitch交换机</p><h5 id="–controller"><a href="#–controller" class="headerlink" title="–controller"></a>–controller</h5><p>定义要使用的控制器，如果没有则使用mininet中默认的控制器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --controller=remote,--ip=[controller IP],--port=[port]<span class="comment">#remote表示远程控制器</span></span><br></pre></td></tr></table></figure><h5 id="–mac"><a href="#–mac" class="headerlink" title="–mac"></a>–mac</h5><p>自动设置设备的MAC地址，设置交换机的MAC、主机MAC及IP地址从小到大排序</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --topo=tree,depth=2,fanout=2,--mac<span class="comment">#直接在正常命令后面添加--mac即可</span></span><br></pre></td></tr></table></figure><h5 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --switch ovsk,protocols=OpenFlow13 --controller=remote,ip=192.168.31.139,port=6653 --topo=tree,depth=2,fanout=3</span><br><span class="line"><span class="comment">#交换机为Open vSwitch Kernel Mode，支持的协议为OpenFlow1.3，控制器为远程控制器，远程控制器的ip地址为192.168.31.139，端口为6653，拓扑为树形拓扑，深度为2，广度为3</span></span><br></pre></td></tr></table></figure><h4 id="内部交互命令"><a href="#内部交互命令" class="headerlink" title="内部交互命令"></a>内部交互命令</h4><h5 id="设备查看："><a href="#设备查看：" class="headerlink" title="设备查看："></a>设备查看：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump查看节点信息</span><br><span class="line">net查看链路信息</span><br><span class="line">nodes查看总共的节点</span><br><span class="line">links查看链路是否连通（不代表能ping通）</span><br><span class="line">intfs   查看网络接口信息</span><br><span class="line">pingpair只验证前两个主机的连通性</span><br><span class="line">pingall验证所有主机间的通信</span><br></pre></td></tr></table></figure><h5 id="设备操作："><a href="#设备操作：" class="headerlink" title="设备操作："></a>设备操作：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf两节点间进行iperftcp带宽测试</span><br><span class="line">iperfudp两节点间进行iperfudp带宽测试</span><br><span class="line">link禁用或开启节点间链路</span><br><span class="line">dpctl所有交换机上的流表</span><br><span class="line">xterm进入某个节点终端</span><br><span class="line">py执行python表达式</span><br></pre></td></tr></table></figure><h6 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf h1 h2</span><br></pre></td></tr></table></figure><h6 id="iperfudp"><a href="#iperfudp" class="headerlink" title="iperfudp"></a>iperfudp</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperfudp bw h1 h2</span><br></pre></td></tr></table></figure><h6 id="link"><a href="#link" class="headerlink" title="link"></a>link</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">link h1 s1 up<span class="comment">#禁用链路</span></span><br><span class="line">link h1 s1 down<span class="comment">#开启链路</span></span><br></pre></td></tr></table></figure><h6 id="dpctl"><a href="#dpctl" class="headerlink" title="dpctl"></a>dpctl</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpctl dump-flows</span><br><span class="line">dpctl dump-flows -O Openflow13  <span class="comment">#如果指定了使用openflow1.3协议则应这样输入</span></span><br></pre></td></tr></table></figure><h6 id="xterm"><a href="#xterm" class="headerlink" title="xterm"></a>xterm</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xterm h1</span><br></pre></td></tr></table></figure><h6 id="py"><a href="#py" class="headerlink" title="py"></a>py</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">py <span class="built_in">help</span>(s1)</span><br><span class="line">py dir(s1)</span><br><span class="line">添加主机的命令：<span class="comment">#原拓扑中为（h1，s1）（h2，s1）</span></span><br><span class="line">py net.addHost(<span class="string">&quot;h3&quot;</span>)<span class="comment">#添加h3主机</span></span><br><span class="line">py net.addLink(s1,net.get(<span class="string">&quot;h3&quot;</span>))<span class="comment">#添加s1与h3之间的链路</span></span><br><span class="line">py s1.attach(<span class="string">&quot;s1-eth3&quot;</span>)<span class="comment">#添加s1的eth3的接口</span></span><br><span class="line">py net.get(<span class="string">&quot;h3&quot;</span>).cmd(<span class="string">&quot;ifconfig h3-eth0 10.3&quot;</span>)  <span class="comment">#给h3添加ip地址（10.0.0.3）</span></span><br><span class="line">之后其他主机就可以ping通h3</span><br></pre></td></tr></table></figure><h4 id="外部运行参数"><a href="#外部运行参数" class="headerlink" title="外部运行参数"></a>外部运行参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c  清除配置</span><br><span class="line">-h  帮助</span><br></pre></td></tr></table></figure><h1 id="RYU"><a href="#RYU" class="headerlink" title="RYU"></a>RYU</h1><h3 id="安装RYU"><a href="#安装RYU" class="headerlink" title="安装RYU"></a>安装RYU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip python-dev build-essential</span><br><span class="line">sudo pip install --upgrade pip</span><br><span class="line">sudo apt-get install python-eventlet</span><br><span class="line">sudo apt-get install python-routes</span><br><span class="line">sudo apt-get install python-webob</span><br><span class="line">sudo apt-get install python-paramiko</span><br><span class="line">sudo pip install ryu</span><br></pre></td></tr></table></figure><h3 id="测试RYU"><a href="#测试RYU" class="headerlink" title="测试RYU"></a>测试RYU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ryu-manager</span><br><span class="line"><span class="comment">#如果出现 DistributionNotFound: webob&gt;=1.2 类似问题则输入sudo pip install --upgrade webob 即可，缺少什么就将“webob”替换成什么</span></span><br></pre></td></tr></table></figure><h3 id="启动RYU"><a href="#启动RYU" class="headerlink" title="启动RYU"></a>启动RYU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ryu-manager simple_switch_13.py  <span class="comment">#适用于OpenFlow 1.3协议</span></span><br></pre></td></tr></table></figure><h1 id="验证OpenFlow-1-3"><a href="#验证OpenFlow-1-3" class="headerlink" title="验证OpenFlow 1.3"></a>验证OpenFlow 1.3</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --switch ovs,protocols=OpenFlow13 --controller=remote,ip=192.168.31.139,port=6633  <span class="comment">#Mininet连接支持OpenFlow1.3的控制器</span></span><br><span class="line">sudo ovs-ofctl dump-flows -O openflow13 s1  <span class="comment">#查看交换机S1的流表</span></span><br></pre></td></tr></table></figure><p>也可用Wireshark对any端口进行抓包，可以捕捉到OpenFlow 1.3协议（需要筛选）</p>]]></content>
    
    
    <summary type="html">软件定义网络基于RYU控制器Mininet环境安装及测试</summary>
    
    
    
    <category term="SDN软件定义网络" scheme="http://ins1mn1a.github.io/categories/SDN%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="SDN" scheme="http://ins1mn1a.github.io/tags/SDN/"/>
    
  </entry>
  
</feed>
