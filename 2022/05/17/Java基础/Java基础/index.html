<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java总结 | ins1mn1a</title><meta name="keywords" content="Java基础"><meta name="author" content="ins1mnia"><meta name="copyright" content="ins1mnia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM,JUC，IO总结">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结">
<meta property="og:url" content="http://ins1mn1a.github.io/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="ins1mn1a">
<meta property="og:description" content="JVM,JUC，IO总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ins1mn1a.github.io/img/background_img/1/8.jpg">
<meta property="article:published_time" content="2022-05-17T02:47:08.163Z">
<meta property="article:modified_time" content="2022-05-17T03:01:27.560Z">
<meta property="article:author" content="ins1mnia">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ins1mn1a.github.io/img/background_img/1/8.jpg"><link rel="shortcut icon" href="/img/background_img/%E7%8E%89%E5%AD%90.icon.png"><link rel="canonical" href="http://ins1mn1a.github.io/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-17 11:01:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="ins1mn1a" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tvax1.sinaimg.cn/crop.0.0.996.996.180/007RWaeLly8gr7p82e9e6j30ro0rognd.jpg?KID=imgbed,tva&amp;Expires=1639625304&amp;ssig=yn%2FY%2BCtxLO" onerror="onerror=null;src='/img/background_img/error_page.jpeg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background_img/1/8.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ins1mn1a</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-17T02:47:08.163Z" title="发表于 2022-05-17 10:47:08">2022-05-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-17T03:01:27.560Z" title="更新于 2022-05-17 11:01:27">2022-05-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>115分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>byte short int long float double boolean char</p>
<p>1      2      4   8      4        8        1        2</p>
<h3 id="为什么要有包装类"><a href="#为什么要有包装类" class="headerlink" title="为什么要有包装类"></a>为什么要有包装类</h3><p>Java 本身就一个面向对象的语言，这些基本数据类型是比较基础的数据类型，但又不是面向对象的。为了让基本数据类型也有对象的特征，就给每个基本数据类型都创建了包装类型，使得这些基本数据类型都有了对象的性质，并且添加了属性和方法</p>
<p>并且向集合中添加元素的时候，放入基本数据类型是放不进去的，容器都是装Object的，所以就使用包装类型，然后提供自动拆箱装箱完成转换</p>
<h3 id="int-和-Integer的区别-new-Integer-127-new-Integer-127-是true还是false"><a href="#int-和-Integer的区别-new-Integer-127-new-Integer-127-是true还是false" class="headerlink" title="int 和 Integer的区别 new Integer(127) == new Integer(127) 是true还是false"></a>int 和 Integer的区别 new Integer(127) == new Integer(127) 是true还是false</h3><p>int 是基本数据类型，Integer 是引用数据类型，属于int 的包装类型，可以通过自动拆箱和装箱转换。</p>
<p> new Integer(127) == new Integer(127) 返回false 比较地址值，属于不同对象</p>
<p>Integer c1 = 127;     Integer c2 = Integer.valueOf(127);  <strong>c1==c2 返回true</strong>，Java对**-128到127进行了缓存**，故相等</p>
<p>Integer d1 = 128;     Integer d2 = 128;  <strong>d1==d2 返回false</strong> <strong>128不适用于缓存</strong>，不相等</p>
<h3 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h3><p>String内的成员变量char数组 value是用final修饰的，并且是private，value的引用是不可变的，但是value内的值是可以通过反射改变的，String本身也是个final类，是不能被继承的，也保证了没有子类对其修改</p>
<p>其次，String内的一些方法，返回的值也是String，但是这些个String都是在返回的时候重新new出来的一个String，而不是原来那个了</p>
<p>String 的不可变，首先可以保证一定的线程安全性，它不可变，那他可以被多个线程共享</p>
<p>其次String 的不可变，String的hashcode在创建的时候被缓存了，像map中键一般采用String类型也就是这个原因，这样通过key做hash的时候速度就比较快</p>
<h3 id="Math-round-11-5-和Math-round-11-5"><a href="#Math-round-11-5-和Math-round-11-5" class="headerlink" title="Math.round(11.5)和Math.round(-11.5)"></a>Math.round(11.5)和Math.round(-11.5)</h3><p>Math.round()函数就是取整四舍五入，然后在参数的基础上加0.5然后再做向下取整，所以结果就是12，-11</p>
<h3 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h3><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化） 会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p>
<h3 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗</h3><p> 对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。 而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p>
<h3 id="关于boolean的默认值"><a href="#关于boolean的默认值" class="headerlink" title="关于boolean的默认值"></a>关于boolean的默认值</h3><p>局部变量boolean没有默认值，打印编译不通过没有初始化，</p>
<p>静态变量有默认值，为false</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306165357708.png" alt="image-20220306165357708"></p>
<h3 id="Cloneable，深拷贝、浅拷贝、零拷贝"><a href="#Cloneable，深拷贝、浅拷贝、零拷贝" class="headerlink" title="Cloneable，深拷贝、浅拷贝、零拷贝"></a>Cloneable，深拷贝、浅拷贝、零拷贝</h3><p><strong>深拷贝</strong>：把内存对象完全复制了一份，也就是说内存中存在有两份一模一样的对象</p>
<p><strong>浅拷贝</strong>：相当于多一个引用指向同一个堆中的对象，两个引用实际上还是一样的</p>
<p>在 Object 中有一个本地方法 clone()，一个对象想要调用这个 clone 方法，必须实现 Cloneable 接口，重写 clone() 方法，里面先调用 父类 Object 的clone方法 <code>Person clone = (Person) super.clone();</code></p>
<p>这样拷贝出来的对象是一个新的对象，但是对象里面的各种属性等等和原来的都是一样的。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final就是一个关键字，可以用来修饰类，属性，变量，方法，表示的意思就是最终的意思，不可变的意思在里面，修饰类，那么类就不能被继承，修饰属性，那么属性就不能再改变（引用），</p>
<p>修饰符（关键字）如果一个<strong>类</strong>被声明<strong>为final</strong>，意味着它<strong>不能再派生出新的子类</strong>，<strong>不能</strong>作为父类<strong>被继承</strong>。因此一个类<strong>不能</strong>既被声明<strong>为 abstract</strong>的，<strong>又</strong>被声明<strong>为final</strong>的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为<strong>final的变量</strong>必须在声明时<strong>给定初值</strong>，而在以后的<strong>引用中只能读取</strong>，<strong>不可修改</strong>。被声明为<strong>final的方法</strong>也同样<strong>只能使用</strong>，<strong>不能重载</strong>。</p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>finally是在异常中<strong>try catch finally</strong>中用到的，finally表示无论是否捕获到异常都会去执行finally语句块里面的代码，守护线程除外，主要用于做一些<strong>事后处理的操作</strong>，比如<strong>释放锁</strong>等</p>
<p>异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。一般异常处理块需要。</p>
<p>如果在try 里面使用了return 语句，finally里的语句还是照样会执行的，在return语句把控制权转移给其他的方法前会执行finally语句</p>
<p><strong>try</strong> 有 <strong>return</strong> 语句，会执行 try 里的 return 语句，然后将<strong>返回结果保存到栈</strong>中，接着执行 <strong>finally</strong> 里的语句块，如果 <strong>finally</strong> 里有 <strong>return</strong> 语句，则会 <strong>返回 finally 里 return 的结果</strong>，并终止方法，<strong>栈中的 return 不会被完成</strong></p>
<h3 id="fianlize"><a href="#fianlize" class="headerlink" title="fianlize"></a>fianlize</h3><p><strong>方法名</strong>，<strong>fianlize()<strong>是</strong>Object中</strong>的一个<strong>方法</strong>，当垃圾回收器将要释放一个对象的内存的时候，它会调用该对象的finalize()方法</p>
<p>这个方法是由<strong>垃圾收集器</strong>在确定<strong>这个对象没有被引用时</strong>对这个对象<strong>调用的</strong>。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p>
<p>在Java中很不幸，<strong>如果内存总是充足的</strong>，那么<strong>垃圾回收可能永远不会进行</strong>，也就是说<strong>finalize()可能永远不被执行</strong>，显然指望它做收尾工作是靠不住的。</p>
<h3 id="public、protected、缺省、private范围"><a href="#public、protected、缺省、private范围" class="headerlink" title="public、protected、缺省、private范围"></a>public、protected、缺省、private范围</h3><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220412091654001.png" alt="image-20220412091654001"></p>
<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>throw是主动抛出某个异常，throw后面跟一个异常对象，表示程序什么什么情况下，比如参数为null，if判断到后，就throw一个NullPointerException。</p>
<p>throws则是跟在方法后面，表示这个方法可能会抛出某个异常，处理方式只是往上抛，抛到调用这个方法的地方。否则就直接try catch捕获住，然后直接throw某个异常</p>
<h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>我们不能强制java中的garbage collection进程，它只是一个守护线程。将System.gc()方法视为垃圾收集应该运行的 VM 的”提示”。显示调用只能说程序员建议System.gc()，但是JVM并不一定真正gc。</p>
<h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p><strong>static</strong> 关键字主要是为了能够<strong>创建独立与对象之外的方法或者属性</strong>，以至于可以使得没有创建对象，也能使用属性和调用方法。此外还可以使用 static 关键字用来形成静态代码块来做些初始化工作，因为静态代码块只会在类加载的时候执行一次。</p>
<p>被static修饰的变量，表示是一个静态变量，这个静态变量不属于某一个对象，而是所有对象共享的变量。</p>
<p>被static修饰的方法，表示是一个静态方法，这个静态方法可以看做类级别的，直接通过类点方法名调用。</p>
<p>静态方法只能方法静态变量，非静态方法都可以访问</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类可以分为：</p>
<ol>
<li><p>成员内部类</p>
<ul>
<li><p>成员内部类中的方法可以访问外部类中所有的变量，不受控制符的影响</p>
</li>
<li><p>必须使用外部类的对象才能创建内部类的对象，不能直接 new 一个内部类对象</p>
</li>
<li><p>```java<br>public class InternalClass {</p>
<pre><code>private int a=1;

private class InnerClazz&#123;
    int b=2;
    public void test()
    &#123;
        System.out.println(&quot;a：&quot;+a);
        System.out.println(&quot;b：&quot;+b);
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 静态内部类</span><br><span class="line"></span><br><span class="line">   * 静态内部类就是用static修饰过的成员内部类</span><br><span class="line"></span><br><span class="line">   * 静态内部类不能直接访问外部类的非static成员，只能通过new对象的方式访问对象的非static</span><br><span class="line"></span><br><span class="line">   * 创建静态内部类的对象时，可以直接创建，不需要通过外部类的对象来创建</span><br><span class="line"></span><br><span class="line">   * &#96;&#96;&#96;java</span><br><span class="line">     public class InternalClass2 &#123;</span><br><span class="line">     </span><br><span class="line">         private int a&#x3D;1;</span><br><span class="line">     </span><br><span class="line">         static class InnerClazz&#123;</span><br><span class="line">             int b&#x3D;2;</span><br><span class="line">             public void test()</span><br><span class="line">             &#123;</span><br><span class="line">                 System.out.println(&quot;a：&quot;+new InternalClass2().a);</span><br><span class="line">                 System.out.println(&quot;b：&quot;+b);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方法内部类</p>
<ul>
<li><p>方法内部类就是定义在外部类的方法里面的类，只能在对应方法里面去访问到</p>
</li>
<li><p>```java<br>public class Outer {</p>
<pre><code>private int out_a=1;

private static int static_b=2;

void outMethod()
&#123;
    final int a=10;
    class Inner&#123;
        void innerMethod()&#123;
            System.out.println(a);
            System.out.println(out_a);
            System.out.println(static_b);
        &#125;
    &#125;
    new Inner().innerMethod();
    System.out.println(a);
&#125;

public static void main(String[] args) &#123;
    Outer outer = new Outer();
    outer.outMethod();
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 匿名内部类</span><br><span class="line"></span><br><span class="line">   * 匿名内部类必须继承一个抽象类或者实现一个接口</span><br><span class="line">   * 匿名内部类不能定义任何静态成员和静态方法</span><br><span class="line">   * 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final</span><br><span class="line">   * 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</span><br><span class="line"></span><br><span class="line">   * 对于某个接口的实现，可以在new的时候直接创建一个匿名内部类，实现对应的方法</span><br><span class="line"></span><br><span class="line">### 多态</span><br><span class="line"></span><br><span class="line">**多态**就是指在程序中定义的**引用变量**，具体**所指向的具体类型**以及通过**该引用变量调用的方法**在**编译**的**时**候并**不确定**，而是**在程序运行时期去确定的**。即一个**引用变量**到底是**什么类型**，调用的对应的方法到底是哪个实现类对应的方法编译的时候是无法确定的。</span><br><span class="line"></span><br><span class="line">**多态**分为**编译时多态**和**运行时多态**：</span><br><span class="line"></span><br><span class="line">* 编译时多态：主要指的是方法的重载，它根据参数列表的不同来区分不同的函数调用</span><br><span class="line">* 运行时多态：运行时多态就是常说的多态，在程序运行时才能确定的。父类或者接口定义的引用可以指向子类或者实现类的实例对象</span><br><span class="line"></span><br><span class="line">实现多态：</span><br><span class="line"></span><br><span class="line">* **方法重写**</span><br><span class="line">* **继承或者实现关系**</span><br><span class="line"></span><br><span class="line">## 排序算法</span><br><span class="line"></span><br><span class="line">![image-20220419083720096](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220419083720096.png)</span><br><span class="line"></span><br><span class="line">1. 堆排序</span><br><span class="line">   * 按照给定的数组，构建一个完全二叉树</span><br><span class="line">   * 从最后一个非叶子节点 树中索引 n&#x2F;2 -1 开始，大顶堆就把它这个节点和它的子树进行比较交换，选择一个最大的</span><br><span class="line">   * 接着选定下一个非叶子节点，一直到根节点</span><br><span class="line">   * 排序：取出根节点，根节点就是最大值，然后把最后一个叶子节点取出来放到根节点，维护成一个大顶堆</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## JVM</span><br><span class="line"></span><br><span class="line">### Java代码执行过程理解JVM内存划分</span><br><span class="line"></span><br><span class="line">**结合一段Java代码的执行理解内存划分**</span><br><span class="line"></span><br><span class="line">![image-20220217220809311](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220217220809311.png)</span><br><span class="line"></span><br><span class="line">* 执行javac命令编译源代码为字节码</span><br><span class="line">* 执行java命令</span><br><span class="line">  1. 创建JVM，调用类加载子系统**加载class**，将类的信息存入**方法区**</span><br><span class="line">  2. 创建main线程，使用的内存区域是**JVM虚拟机栈**，开始执行main方法代码</span><br><span class="line">  3. 如果遇到了未见过的类，会继续触发类加载过程，同样会存入**方法区**</span><br><span class="line">  4. 需要创建**对象**，会使用**堆内存**来存储对象</span><br><span class="line">  5. 不再使用的对象，会由**垃圾回收器**在内存不足时回收其内存</span><br><span class="line">  6. 调用方法时，**方法内的局部变量、方法参数**所使用的是**JVM虚拟机栈**中的**栈帧内存**</span><br><span class="line">  7. 调用方法时，先要到**方法区**获得到该方法的字节码指令，由**解释器**将**字节码指令解释为机器码**执行</span><br><span class="line">  8. 调用方法时，会将要执行的指令行号读到**程序计数器**，这样当**发生了线程切换**，**恢复**时就可以从中断的位置继续</span><br><span class="line">  9. 对于非Java实现的方法调用，使用内存称为**本地方法栈**</span><br><span class="line">  10. 对于**热点方法调用**，或者**频繁的循环代码**，由**JIT即使编译器**将这些代码编译成机器码缓存，提高执行性能</span><br><span class="line"></span><br><span class="line">说明</span><br><span class="line"></span><br><span class="line">* 对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</span><br><span class="line"></span><br><span class="line">**会发生内存溢出的区域**</span><br><span class="line"></span><br><span class="line">* 不会出现内存溢出的区域 - 程序计数器</span><br><span class="line">* 出现OOM（OutOfMemoryError）的情况</span><br><span class="line">  * **堆内存耗尽** — 对象越来越多，又一直在使用，不能被垃圾回收</span><br><span class="line">  * **方法区内存耗尽** — 加载的类越来越多，很多框架都会在运行期间动态产生新的类</span><br><span class="line">  * **虚拟机栈累积** — 每个线程最多会占用1M内存，线程个数越来越多，而又长时间运行不销毁时</span><br><span class="line">* 出现 **StackOverflowError** 的区域</span><br><span class="line">  * **JVM虚拟机栈**，原因有**方法递归调用未正确结束**，**反序列化 json 时循环引用**</span><br><span class="line"></span><br><span class="line">### JVM常量池</span><br><span class="line"></span><br><span class="line">JVM的常量池，实际上划分为两种形态：静态常量池和动态常量池</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 字符串常量池</span><br><span class="line"></span><br><span class="line">字符串常量池存在堆内存中</span><br><span class="line"></span><br><span class="line">**字符串常量池为什么要移动到堆空间中？**</span><br><span class="line">个人的理解：对于字符串常量这种创建完成用几次就不被使用的对象，是很容易被回收的。而要进行频繁垃圾回收的地方是堆空间， 这样在JDK7就把字符串[常量池](https:&#x2F;&#x2F;so.csdn.net&#x2F;so&#x2F;search?q&#x3D;常量池&amp;spm&#x3D;1001.2101.3001.7020)移动到堆空间中就是很明智和有必要的选择了。</span><br><span class="line"></span><br><span class="line">**字符串常量池的设计思想**：</span><br><span class="line"></span><br><span class="line">* 字符串的分配，和其他对象一样，频繁的分配字符串的内存也需要消耗大量的资源</span><br><span class="line">* JVM 为了提高性能和减小内存开销，在实例化字符串常量的时候进行了一些优化</span><br><span class="line">  * 为字符串开辟一个字符串常量池，类似于缓冲区</span><br><span class="line">  * 创建字符串常量时，首先判断字符串常量池是否存在该字符串</span><br><span class="line">  * 存在该字符串，返回引用实例，不存在，就实例化该字符串并放入常量池</span><br><span class="line">* 实现基础</span><br><span class="line">  * 因为String 是不可变的，因此不用担心字符串共享产生的问题</span><br><span class="line">  * 运行时，实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JVM的几个组成部分</span><br><span class="line"></span><br><span class="line">JVM包含两个子系统和两个组件，共4个组成部分，**两个子系统**分别为：**类加载器**(ClassLoader)、**执行引擎**(Execution Engine)、**两个组件**分别为：**运行时数据区**(Runtime Data Area)、**本地接口**(Native interface)</span><br><span class="line"></span><br><span class="line">![image-20220214145053735](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220214145053735.png)</span><br><span class="line"></span><br><span class="line">**类加载器**：就是把字节码文件加载到运行时数据区的method area 方法区中</span><br><span class="line"></span><br><span class="line">**运行时数据区**：也就是常说的JVM的内存</span><br><span class="line"></span><br><span class="line">**执行引擎**：就是执行classes中的指令，包括有JIT即使编译器、GC垃圾回收器</span><br><span class="line"></span><br><span class="line">**本地接口**：就是底层和不同语言交互的接口，同一些本地库相关联</span><br><span class="line"></span><br><span class="line">执行流程就是：先把Java代码编译成字节码文件，然后类加载器就加载字节码文件到Method Area中，而字节码只是JVM的一套指令集规范，并不能直接交给底层的操作系统去执行，因此就需要特点的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由CPU执行，而这个过程中需要调用其他语言的本地接口（Native Interface）来实现整个程序的功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JVM类加载机制</span><br><span class="line"></span><br><span class="line">#### 简述java类加载机制</span><br><span class="line"></span><br><span class="line">虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的java类型。类加载器负责读取Java字节码，并转换成Java.lang.Class类的一个实例</span><br><span class="line"></span><br><span class="line">#### JVM加载Class文件的原理机制</span><br><span class="line"></span><br><span class="line">Java中的所有**类**，都需要**被类加载器加载**到**JVM的方法区**中，然后由**执行引擎去解析**最终被底层操作系统执行。**类加载器本身也是一个类**，**加载类**就是把**Class文件**从**硬盘**中**加载到内存**中去。</span><br><span class="line"></span><br><span class="line">加载的方式一般有两种：</span><br><span class="line"></span><br><span class="line">* 隐式加载：就是在程序中使用new关键字等方式创建出来的对象，隐式的调用类加载器加载对应的类到JVM中</span><br><span class="line">* 显式加载：通过Class.forname()、类.class或者说 对象.getClass()方法获取到字节码对象，显式加载所需要的类</span><br><span class="line"></span><br><span class="line">Java**类的加载**是动态（**懒惰**）的，**它并不会一次性将所有类全部加载后再运行**，而是保证程序运行的基础类完全加载到JVM中，至于其他类，则是在需要的时候才加载，从而节省内存开销</span><br><span class="line"></span><br><span class="line">#### 类加载器及其种类</span><br><span class="line"></span><br><span class="line">实现通过类的全限定类名来获取该类的二进制字节流的代码块叫做类加载器。</span><br><span class="line"></span><br><span class="line">主要有四种类加载器：</span><br><span class="line"></span><br><span class="line">1. 启动类加载器（Bootstrap ClassLoader）用来加载Java核心类库，无法被Java程序直接引用。是虚拟机自身的一部分，用来加载 Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库</span><br><span class="line">2. 扩展类加载器（Extensions ClassLoader）用来加载Java的扩展库，Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载Java类。如读取JRE&#x2F;lib&#x2F;ext&#x2F;*.jar中的包等</span><br><span class="line">3. 应用程序类加载器（Application ClassLoader）根据Java应用的类路径（CLASSPATH）来加载Java类。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它</span><br><span class="line">4. 用户自定义类加载器，通过继承java.lang.ClassLoader类的方式实现</span><br><span class="line"></span><br><span class="line">#### 类加载的执行过程</span><br><span class="line"></span><br><span class="line">类加载的执行过程分为加载、链接、初始化。链接又分为验证、准备、解析</span><br><span class="line"></span><br><span class="line">* **加载**：将class字节码文件加载到内存中</span><br><span class="line">* **链接**：</span><br><span class="line">  * **验证**：**检查**加载的class文件的**正确性**，确保没有问题</span><br><span class="line">  * **准备**：给类中的**静态变量分配内存空间**</span><br><span class="line">  * **解析**：虚拟机将**常量池**中的**符号引用**替换成**直接引用**（地址引用）的过程。符号引用就理解为一个标识，而在直接引用直接指向内存中的地址</span><br><span class="line">    * 符号引用：符号引用就是一个字符串，他给出一个名字，就好比类的全限定类名，必须要求通过这个字符串能唯一找到对应的引用</span><br><span class="line">    * 直接引用：直接引用就是指向类、方法、字段的指针或者偏移量</span><br><span class="line">* **初始化**：对静态变量和静态代码块执行初始化工作</span><br><span class="line"></span><br><span class="line">#### 双亲委派模型</span><br><span class="line"></span><br><span class="line">![image-20220214161654695](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220214161654695.png)</span><br><span class="line"></span><br><span class="line">如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类</span><br><span class="line"></span><br><span class="line">当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">双亲委派模型的具体实现主要在ClassLoader的loadClass()方法中，首先检查父类有没有去加载过，没有则让父类去加载，当父类抛出ClassNotFoundException的时候才让自己去加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### java类加载为什么采用双亲委派模型</span><br><span class="line"></span><br><span class="line">如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载（因为它在jdk8&#x2F;lib&#x2F;rt.jar中），因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。这样，会委派给启动类加载器去加载到rt.jar中的Object类</span><br><span class="line"></span><br><span class="line">#### 如何打破双亲委派机制</span><br><span class="line"></span><br><span class="line">1. 重写loadClass()方法破坏双亲委派模型</span><br><span class="line"></span><br><span class="line">   类加载器的加载方法的逻辑主要就在loadClass()方法中，里面的逻辑就是先判断当前类是否已经被加载过，如果没有加载过就将委派给父类加载器，如果父类加载器无法加载则向下传递，回来由自己进行加载。如果我们把这个方法重写了就能实现自定义的加载逻辑，就可以打破双亲委派模型</span><br><span class="line"></span><br><span class="line">2. 线程上下文加载器破坏双亲委派机制</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### new 一个对象发生了什么</span><br><span class="line"></span><br><span class="line">![image-20220405094342381](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220405094342381.png)</span><br><span class="line"></span><br><span class="line">**一、类加载**</span><br><span class="line"></span><br><span class="line">1. 看new 的那个类是否加载，没有加载则采用双亲委派模型进行类加载。</span><br><span class="line">2. 类加载过程：把字节码加载到方法区，验证字节码文件的正确性，为静态变量分配内存空间，将符号引用替换为直接引用，初始化为静态变量赋值、加载静态代码块</span><br><span class="line"></span><br><span class="line">**二、创建对象**</span><br><span class="line"></span><br><span class="line">1. 在堆区给**对象分配**需要的**空间**</span><br><span class="line">   * 分配的内存包括本类和父类的实例变量，静态变量不分配</span><br><span class="line">2. 对所有**实例变量设置默认值**</span><br><span class="line">   * 将方法区中对实例变量的定义拷贝一份，然后赋默认值</span><br><span class="line">3. **设置对象头**</span><br><span class="line">   * 设置新对象的哈希码、GC分代年龄、锁信息、对象所属类元信息</span><br><span class="line">4. 执行实例**初始化**代码</span><br><span class="line">   * 初始化成员变量，执行实例化代码块，调用构造方法，并将堆内对象的首地址赋值给引用变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Java内存</span><br><span class="line"></span><br><span class="line">![image-20220214163528925](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220214163528925.png)</span><br><span class="line"></span><br><span class="line">Java 虚拟机规范规定的区域分为以下 5 个部分： </span><br><span class="line"></span><br><span class="line">* **程序计数器**（Program Counter Register）：用于**保存当前线程执行的内存地址**。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。</span><br><span class="line">* **Java 虚拟机栈**（Java Virtual Machine Stacks）：用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息，是**每个线程所私有**的，每个**线程创建的同时会创建JVM栈**，栈中是**基本数据类型**和**堆中对象的引用**</span><br><span class="line">* **本地方法栈**（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而**本地方法栈**是**为虚拟机调用 Native 方法服务**的； </span><br><span class="line">* **Java 堆**（Java Heap）：Java 虚拟机中内存最大的一块，是**被所有线程共享**的，几乎所有的对象实例都在这里分配内存； 它是JVM用来**存储对象实例以及数组**值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收，Heap在32位的操作系统上最大为2G，在64位的操作系统上则没有限制，其大小通过-Xms和-Xmx来控制</span><br><span class="line">* **方法区**（Methed Area）：用于**存储**已被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译后的代码**等数据</span><br><span class="line"></span><br><span class="line">### 栈帧</span><br><span class="line"></span><br><span class="line">**栈帧** Stack Frame 是用来支持虚拟机进行**方法调用**和**方法执行**的数据结构，它是虚拟机运行时数据区中的**虚拟机栈的栈元素**。</span><br><span class="line"></span><br><span class="line">栈帧 Stack Frame 存储了方法的局部变量表、操作数栈、动态连接、和方法返回地址、额外的附加信息。</span><br><span class="line"></span><br><span class="line">每个方法在执行的同时，都会创建一个栈帧(Stack Frame)。**每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。**</span><br><span class="line"></span><br><span class="line">### 堆栈的区别</span><br><span class="line"></span><br><span class="line">1. 物理地址</span><br><span class="line"></span><br><span class="line">   堆的物理地址是不连续的，因此性能相对会比较慢，这样在GC的时候需要考虑的就更多，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记-压缩）</span><br><span class="line"></span><br><span class="line">2. 内存分配时期</span><br><span class="line"></span><br><span class="line">   堆中的内存因为是不连续的，所以需要在**运行期**确认大小，因此大小不固定。一般堆大小远大于栈。而栈的内存是连续分配的，所以一般在**编译时**就已经确定了内存大小，大小是固定的</span><br><span class="line"></span><br><span class="line">3. 存放的内容</span><br><span class="line"></span><br><span class="line">   **堆中更关注内存的存储**，因此堆中一般存放的是**对象实例**，或者**数组**</span><br><span class="line"></span><br><span class="line">   **栈更关注程序方法的执行**，因此栈内存中一般存放：**局部变量**，操作数栈，返回结果，对象的引用地址等。</span><br><span class="line"></span><br><span class="line">4. 可见性</span><br><span class="line"></span><br><span class="line">   栈中的数据线程之间是不共享的，堆中的内存线程之间是共享的</span><br><span class="line"></span><br><span class="line">### OOM，Java会存在内存泄漏吗？请简单描述 </span><br><span class="line"></span><br><span class="line">**会发生内存溢出的区域**</span><br><span class="line"></span><br><span class="line">* 不会出现内存溢出的区域 - 程序计数器</span><br><span class="line"></span><br><span class="line">* **出现OOM（OutOfMemoryError）的情况**</span><br><span class="line">  * **堆内存耗尽** — 对象越来越多，又一直在使用，不能被垃圾回收</span><br><span class="line">  </span><br><span class="line">    &#96;&#96;&#96;java</span><br><span class="line">    比如使用了Executors工具类中创建线程池的方法，比如newFixedThreadPool和newSingleThreadPool这些线程池的阻塞队列都是无界的，很有可能让阻塞队列拉满，导致内存溢出</span><br></pre></td></tr></table></figure></li>
<li><p>*解决方法**：</p>
</li>
</ul>
<p> 不要用这种new线程池，可以修改堆内存的大小-Xmx，扩大最大堆内存</p>
</li>
</ol>
<ul>
<li><strong>方法区内存耗尽</strong> — 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li>
<li><strong>虚拟机栈累积</strong> — 每个线程最多会占用1M内存，线程个数越来越多，而又长时间运行不销毁时<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比如使用了Executors工具类中创建线程池的方法，比如newScheduledThreadPool和newCachedThreadPool这些线程池的能创建的线程都是无限的，很有可能创建很多线程，导致内存溢出</span><br></pre></td></tr></table></figure></li>
<li>出现 <strong>StackOverflowError</strong> 的区域<ul>
<li><strong>JVM虚拟机栈</strong>，原因有<strong>方法递归调用未正确结束</strong>，<strong>反序列化 json 时循环引用</strong></li>
</ul>
</li>
</ul>
<p><strong>内存泄漏</strong>是指<strong>不再被使用的对象或者变量一直被占据在内存中</strong>。理论上来说， Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。 但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：<strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>， 尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导 致不能被回收，这就是java中内存泄露的发生场景</p>
<h3 id="JVM-server模式-和-client模式"><a href="#JVM-server模式-和-client模式" class="headerlink" title="JVM server模式 和 client模式"></a>JVM server模式 和 client模式</h3><p>JVM 有两种运行模式 Server 和 Client 模式</p>
<p><strong>Client</strong> 模式：采用较为轻量级的虚拟机来启动程序，<strong>采用代号为C1的轻量级编译器</strong>，因此 程序<strong>启动较快</strong>，<strong>内存占用少</strong>，<strong>编译快</strong>，<strong>针对桌面应用程序优化</strong>，为在客户端环境中<strong>减少启动时间</strong>而优化 </p>
<p><strong>Server</strong> 模式：采用较为重量级的虚拟机来启动程序，<strong>采用相对重量级代号为C2的编译器</strong>，因此 程序<strong>启动较慢</strong>，但是 <strong>编译得更完全</strong>，<strong>针对服务器应用优化</strong>，<strong>整个程序跑起来以后，性能会很高</strong></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="简述垃圾回收机制"><a href="#简述垃圾回收机制" class="headerlink" title="简述垃圾回收机制"></a>简述垃圾回收机制</h3><p>Java程序一般是不需要我们去管理其内存的回收，对象的释放，也就是垃圾回收。JVM中的垃圾回收线程是一个守护线程，它是低优先级的，正常情况下是不会执行的，它只有在虚拟机空闲或者当前堆内存不足的时候才会触发执行，扫描那些没有被引用的对象，并将它们添加到回收的集合中，进行回收。</p>
<h3 id="对象引用的类型强、软、弱、虚"><a href="#对象引用的类型强、软、弱、虚" class="headerlink" title="对象引用的类型强、软、弱、虚"></a><strong>对象引用的类型强、软、弱、虚</strong></h3><p><strong>强引用</strong>：</p>
<ul>
<li><p>普通变量赋值就是强引用，<code>A a=new A();</code></p>
</li>
<li><p>通过GC Root的引用链，如果强引用找不到该对象，该对象才能被回收</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307135659131.png" alt="image-20220307135659131"></p>
</li>
</ul>
<p><strong>软引用</strong>：</p>
<ul>
<li><p><code>SoftReference a = new SoftReference(new A())</code></p>
</li>
<li><p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍然不足，再次回收的时候才会释放对象</p>
</li>
<li><p>回收的时候只是回收后面的A对象，软引用本身不会释放，软引用自身需要配合引用队列来释放</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307135945240.png" alt="image-20220307135945240"></p>
</li>
</ul>
<p><strong>弱引用</strong>：</p>
<ul>
<li><p><code>WeakReference a = new WeakReference(new A())</code></p>
</li>
<li><p>如果仅有弱引用引用该对象，只要发生垃圾回收，就会释放该对象</p>
</li>
<li><p>同样，弱引用本身要配合引用队列来释放</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307140118825.png" alt="image-20220307140118825"></p>
</li>
</ul>
<p><strong>虚引用</strong>：</p>
<ul>
<li><p><code>PhantomReference a =new PhantomReference(new A())</code></p>
</li>
<li><p>必须配合引用队列一起使用，当虚引用引用的对象被回收时，会将虚引用对象入队，有Reference Handler线程释放其关联的外部资源</p>
</li>
<li><p>除了释放a、b对象以外，还要将虚引用对象入队，找出哪些对象被回收了，然后由Reference Handler线程释放掉其关联的外部资源</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307140553303.png" alt="image-20220307140553303"></p>
</li>
</ul>
<h3 id="什么是GC，为什么要GC"><a href="#什么是GC，为什么要GC" class="headerlink" title="什么是GC，为什么要GC"></a>什么是GC，为什么要GC</h3><p>GC就是Garbage Collection，垃圾回收，内存处理是程序员最容易出现问题的地方，忘记或者错误的内存回收将会导致程序或系统的不稳定甚至是崩溃，Java提供GC功能，不需要程序员去关注内存的回收，这些都由JVM中的垃圾回收线程去处理，这极大的方便了开发，提高了开发效率，也正是这样，因此Java对内存的控制，其实是比较粗糙的</p>
<h3 id="怎么判断对象是否可以回收"><a href="#怎么判断对象是否可以回收" class="headerlink" title="怎么判断对象是否可以回收"></a>怎么判断对象是否可以回收</h3><p>垃圾收集器必须完成的两件事就是：垃圾检测、垃圾回收。首先需要判定哪些内存是需要被回收的，哪些对象是存活的，不可以被回收；哪些对象已经死掉了，需要被回收</p>
<p>一般有两种方法来判断垃圾是否可回收</p>
<ul>
<li><p>引用计数法</p>
<p>为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0的时候就可以被回收。但是其有一个明显的缺点：<strong>不能解决循环引用的问题</strong>。也就是说我有两个对象，他们之间互相引用，除此之外没有其他对象引用它们，实际上这两个对象已经无法访问，也就是说是垃圾对象，但又因为是相互引用，计数不为0，导致无法回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> A();</span><br><span class="line">B b=<span class="keyword">new</span> B();</span><br><span class="line">a.setB(b);</span><br><span class="line">b.setA(a);</span><br></pre></td></tr></table></figure></li>
<li><p>可达性分析算法：从根集对象（GC Roots）出发向下搜索，搜索所走过的路径称为引用链。当<strong>一个对象到GC Roots没有任何引用链相连</strong>时候（<strong>也就是说这个对象不可达</strong>），则证明此对象是可以被回收的</p>
</li>
</ul>
<h3 id="哪些对象可以作为GC-ROOTS对象"><a href="#哪些对象可以作为GC-ROOTS对象" class="headerlink" title="哪些对象可以作为GC ROOTS对象"></a>哪些对象可以作为GC ROOTS对象</h3><p>主要是有四种对象：</p>
<ol>
<li>虚拟机栈中的对象</li>
<li>本地方法栈中<strong>Native方法引用的对象</strong></li>
<li>方法区中类<strong>静态属性引用的对象</strong></li>
<li>方法区中<strong>常量引用的对象</strong></li>
</ol>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><ol>
<li><p><strong>标记-清除</strong>（Mark-Sweep）</p>
<p>算法和名字一样，分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的</p>
<p>不足：标记、清除效率低；标记清除之后会<strong>产生大量不连续的内存碎片</strong></p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220214203643235.png" alt="image-20220214203643235"></p>
</li>
<li><p><strong>复制</strong></p>
<p>此算法把内存空间划分为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现<strong>“内存碎片”</strong>问题。</p>
<p>不足：这样就<strong>需要两倍的内存空间</strong></p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220214203937400.png" alt="image-20220214203937400"></p>
</li>
<li><p><strong>标记-整理</strong>（Mark-Compact）</p>
<p>在<strong>新生代</strong>中可以使用复制算法，但是在<strong>老年代</strong>就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除 算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片</p>
<p>因此算法结合了“标记清除”和“复制”算法的优点。同样的，分两个阶段，第一个阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220214204425385.png" alt="image-20220214204425385"></p>
</li>
<li><p><strong>分代收集算法</strong></p>
<p>这是当前商业虚拟机常用的垃圾收集算法。分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不<strong>同生命周期的对象可以采取不同的收集方式</strong>，以便提高回收效率。一般包括<strong>年轻代</strong>、<strong>老年代</strong>、<strong>永久代</strong></p>
<ul>
<li>对新生代的对象的收集称为Minor GC</li>
<li>对旧生代的对象的收集称为Full GC</li>
<li>程序中主动调用System.gc()或者Runtime.gc()强制执行的GC为Full GC</li>
</ul>
</li>
</ol>
<h3 id="为什么要运用分代垃圾回收策略"><a href="#为什么要运用分代垃圾回收策略" class="headerlink" title="为什么要运用分代垃圾回收策略"></a>为什么要运用分代垃圾回收策略</h3><p>GC 大都采用了<strong>分代回收思想</strong></p>
<ul>
<li>理论依据是<strong>大部分对象朝生夕灭</strong>，<strong>用完立刻就可以回收</strong>，另有<strong>少部分对象</strong>会<strong>长时间存活</strong>，每次很难回收</li>
<li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，<strong>新生代</strong>采用<strong>标记复制</strong>法、<strong>老年代</strong>一般采用<strong>标记整理</strong>法</li>
</ul>
<p>在Java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同，所具有的<strong>生命周期</strong>也<strong>不同</strong>；有的对象<strong>生命周期较长</strong>，比如Http请求中的<strong>Session</strong>对象，<strong>线程</strong>，<strong>Socket连接</strong>等；有的对象<strong>生命周期较短</strong>，比如<strong>String对象</strong>，由于其<strong>不变类</strong>的特性，有的在使用一次后即可回收。如果不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在不同的代上使用不同的垃圾回收方式</p>
<p>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h3><ol>
<li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li>
</ol>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213622704.png" alt="image-20210831213622704"></p>
<ol start="2">
<li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213640110.png" alt="image-20210831213640110"></p>
<ol start="3">
<li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213657861.png" alt="image-20210831213657861"></p>
<ol start="4">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213708776.png" alt="image-20210831213708776"></p>
<ol start="5">
<li>经过一段时间后伊甸园的内存又出现不足</li>
</ol>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213724858.png" alt="image-20210831213724858"></p>
<ol start="6">
<li>标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213737669.png" alt="image-20210831213737669"></p>
<ol start="7">
<li>将存活对象采用复制算法复制到 to 中</li>
</ol>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213804315.png" alt="image-20210831213804315"></p>
<ol start="8">
<li>复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213815371.png" alt="image-20210831213815371"></p>
<ol start="9">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213826017.png" alt="image-20210831213826017"></p>
<ol start="10">
<li>老年代 old，当<strong>幸存区对象熬过几次回收（最多15次）</strong>，晋升到老年代（<strong>幸存区内存不足</strong>或<strong>大对象</strong>会导致提前晋升）</li>
</ol>
<h3 id="什么时候对象进入老年代"><a href="#什么时候对象进入老年代" class="headerlink" title="什么时候对象进入老年代"></a>什么时候对象<strong>进入老年代</strong></h3><ol>
<li><p><strong>大对象提前晋升</strong>：虚拟机提供了一个阈值参数，大于这个参数的对象的内存就直接到老年代中去分配。如果大对象进入到了新生代，采用 复制 算法去做垃圾回收的时候，就会导致在 eden 和 survivor 区中进行 大量的内存复制</p>
<p><strong>CMS(老年代） 配合 Serial 和 ParNew(年轻代)<strong>：可以</strong>参数设置</strong> 进入老年代。</p>
<p><strong>G1</strong>：当一个对象<strong>大小超过 Region 区的一半</strong>的时候，会是大对象，堆中会分配连续的（Homongous Region）区来存放 </p>
</li>
<li><p><strong>长期存活的对象进入老年代</strong>：通过 JVM 参数：<code>-XX:MaxTenuringThreshold</code> 来设置，默认是15岁，eden 到 survivor 中超过了 <strong>15</strong> 次就进入老年代</p>
</li>
<li><p><strong>动态对象年龄判断</strong>：在 Survivor 区中，<strong>年龄相同的对象</strong>，<strong>大小总和大于 Survivor 区总空间大小的一半</strong>，那么<strong>大于等于这个年龄的对象都会进入老年代</strong></p>
</li>
<li><p><strong>空间分配担保</strong>：当 <strong>Survivor 区空间不够</strong>的时候，就会通过 <strong>分配担保机制</strong>，将多出来的<strong>对象提前转移到老年代</strong>。为了 <strong>确保老年代的空间还有容纳这些对象的剩余空间</strong>，就取之前每次晋升到老年代的<strong>对象的大小的平均值</strong>作为经验值，与老年代的<strong>剩余空间做对比</strong>（因为无法提前知道会有多少对象存活下来）</p>
</li>
</ol>
<h3 id="Minor-GC、Mixed-GC、Full-GC"><a href="#Minor-GC、Mixed-GC、Full-GC" class="headerlink" title="Minor GC、Mixed GC、Full GC"></a>Minor GC、Mixed GC、Full GC</h3><p><strong>GC 规模</strong></p>
<ul>
<li><strong>Minor GC</strong> 发生在<strong>新生代的垃圾回收</strong>，<strong>Eden区空间不足的时候就会触发一次</strong>，<strong>暂停时间短</strong><ul>
<li><strong>触发时机</strong><ol>
<li>Eden区空间不足</li>
</ol>
</li>
</ul>
</li>
<li><strong>Mixed GC</strong> 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</li>
<li><strong>Full GC</strong> <strong>新生代 + 老年代完整垃圾回收</strong>，暂停时间长，<strong>应尽力避免</strong><ul>
<li><strong>触发时机</strong>：<ol>
<li><strong>旧生代空间不足</strong></li>
<li>显式调用 System.gc()</li>
<li>统计得到的 <strong>Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="并发标记算法——三色标记与并发漏标问题"><a href="#并发标记算法——三色标记与并发漏标问题" class="headerlink" title="并发标记算法——三色标记与并发漏标问题"></a>并发标记算法——三色标记与并发漏标问题</h3><p><strong>三色标记</strong></p>
<p>即用三种颜色记录对象的标记状态</p>
<ul>
<li>黑色 – 已标记</li>
<li>灰色 – 标记中</li>
<li>白色 – 还未标记</li>
</ul>
<ol>
<li>起始的三个对象还未处理完成，用灰色表示</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;" />

<ol start="2">
<li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;" />

<ol start="3">
<li>依次类推</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;" />

<ol start="4">
<li>沿着引用链都标记了一遍</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;" />

<ol start="5">
<li>最后为标记的白色对象，即为垃圾</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;" />

<p><strong>并发漏标问题</strong></p>
<p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p>
<ol>
<li>如图所示标记工作尚未完成</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;" />

<ol start="2">
<li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;" />

<ol start="3">
<li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;" />

<ol start="4">
<li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;" />

<p>因此对于<strong>并发标记</strong>而言，必须解决<strong>漏标问题</strong>，也就是要记录标记过程中的变化。有两种解决方法：</p>
<ol>
<li><strong>Incremental Update 增量更新法</strong>，<strong>CMS 垃圾回收器采用</strong><ul>
<li><strong>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</strong></li>
</ul>
</li>
<li><strong>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用</strong><ul>
<li>思路也是拦截每次赋值动作，不过<strong>记录的对象不同，记录的不再是黑色对象，而是新加对象或者被删除引用的对象</strong>，也需要在重新标记阶段对这些对象二次处理</li>
<li><strong>新加对象会被记录</strong></li>
<li><strong>被删除引用关系的对象也被记录</strong></li>
</ul>
</li>
</ol>
<h3 id="有哪些垃圾回收器"><a href="#有哪些垃圾回收器" class="headerlink" title="有哪些垃圾回收器"></a><strong>有哪些垃圾回收器</strong></h3><p><strong>垃圾回收器 - SerialGC</strong></p>
<ul>
<li><strong>串行</strong>垃圾回收器</li>
<li><strong>新生代</strong>采用<strong>复制算法</strong>，<strong>老年代</strong>采用 <strong>标记整理算法</strong></li>
<li><strong>单线程执行</strong>，一条垃圾回收线程进行垃圾回收</li>
<li>工作的时候都会 <strong>STW</strong>，直到收集结束</li>
</ul>
<p><strong>垃圾回收器 - Parallel Scavenge GC</strong></p>
<ul>
<li><strong>eden 内存</strong>不足发生 Minor GC，采用<strong>标记复制</strong>算法，需要暂停用户线程</li>
<li><strong>old 内存</strong>不足发生 Full GC，采用<strong>标记整理</strong>算法，需要暂停用户线程</li>
<li><strong>虽然会暂停用户线程，但是它会启动多个线程来一起回收，注重吞吐量</strong></li>
<li>可以使用参数 <code>-XX:ParallelGCThreads</code> 指定收集线程数，默认和CPU核心数相同</li>
</ul>
<p><strong>垃圾回收器 - ParNew收集器(-XX:+UseParNewGC)</strong></p>
<ul>
<li><strong>ParNew收集器</strong>其实<strong>跟Parallel收集器</strong>很<strong>类似</strong>，区别主要在于它可以和CMS收集器配合使用</li>
<li><strong>新生代</strong>采用<strong>复制</strong>算法，<strong>老年代</strong>采用<strong>标记-整理</strong>算法</li>
<li>运行在<strong>Server模式</strong>下的虚拟机的首要选择，除了Serial收集器外，只有它<strong>能与CMS收集器配合工作</strong></li>
</ul>
<h3 id="CMS-和-G1-的区别"><a href="#CMS-和-G1-的区别" class="headerlink" title="CMS 和 G1 的区别"></a>CMS 和 G1 的区别</h3><ol>
<li>CMS 工作于老年代，G1 适用于新生代，也适用于老年代</li>
<li>CMS 主要基于 标记-清除 算法，G1 则采用 标记-整理 算法</li>
<li>回收过程不同</li>
</ol>
<h3 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h3><p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p>
<ul>
<li>它是工作在 <strong>old 老年代</strong>，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法<ul>
<li>并发标记时不需暂停用户线程</li>
<li>重新标记时仍需暂停用户线程</li>
</ul>
</li>
<li>如果<strong>并发失败</strong>（即回收速度赶不上创建新对象速度），<strong>会触发 Full GC</strong></li>
<li><strong>注重响应时间</strong></li>
</ul>
<p><strong>回收过程</strong></p>
<ol>
<li>初始化标记：标记一些GC ROOTS对象，这个过程会STW(Stop The World)</li>
<li>并发标记：根据GC ROOTS对象并发的标记回收对象</li>
<li>重新标记：解决漏标问题</li>
<li>并发清理：并发清理</li>
<li>重置：CMS重置内部状态，准备下一并发回收期。重置CMS收集器的数据结构，等待下一次回收</li>
</ol>
<p><strong>优点</strong>： 并发收集低停顿</p>
<p><strong>缺点</strong>： 并发执行，对CPU资源压力大， 采用的<strong>标记清除算法</strong>会导致大量碎片</p>
<h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h3><p><strong>垃圾回收器 - G1 GC</strong></p>
<ul>
<li><strong>响应时间与吞吐量兼顾</strong></li>
<li><strong>划分</strong>成多个<strong>区域Region</strong>，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li>
<li>分成三个阶段：<ol>
<li><strong>新生代回收</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>混合收集</strong></li>
</ol>
</li>
<li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li>
</ul>
<p><strong>回收过程</strong></p>
<h4 id="G1-回收阶段-新生代回收"><a href="#G1-回收阶段-新生代回收" class="headerlink" title="G1 回收阶段 - 新生代回收"></a><strong>G1 回收阶段 - 新生代回收</strong></h4><ol>
<li>初始时，所有区域都处于空闲状态</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222639754.png" alt="image-20210831222639754" style="zoom:50%;" />

<ol start="2">
<li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222653802.png" alt="image-20210831222653802" style="zoom:50%;" />

<ol start="3">
<li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222705814.png" alt="image-20210831222705814" style="zoom:50%;" />

<ol start="4">
<li>复制完成，将之前的伊甸园内存释放</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222724999.png" alt="image-20210831222724999" style="zoom:50%;" />

<ol start="5">
<li>随着时间流逝，伊甸园的内存又有不足</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222737928.png" alt="image-20210831222737928" style="zoom:50%;" />

<ol start="6">
<li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222752787.png" alt="image-20210831222752787" style="zoom:50%;" />

<ol start="7">
<li>释放伊甸园以及之前幸存区的内存</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222803281.png" alt="image-20210831222803281" style="zoom:50%;" />

<h4 id="G1-回收阶段-并发标记与混合收集"><a href="#G1-回收阶段-并发标记与混合收集" class="headerlink" title="G1 回收阶段 - 并发标记与混合收集"></a><strong>G1 回收阶段 - 并发标记与混合收集</strong></h4><ol>
<li>当<strong>老年代占用内存超过阈值后</strong>，触发<strong>并发标记</strong>，这时无需暂停用户线程</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222813959.png" alt="image-20210831222813959" style="zoom:50%;" />

<ol start="2">
<li><p><strong>并发标记</strong>之后，会有<strong>重新标记</strong>阶段<strong>解决漏标</strong>问题，此时需要<strong>暂停用户线程</strong>。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（<strong>存活对象少</strong>）的区域（这也是 Gabage First 名称的由来）。</p>
<p>回收价值：回收该region<strong>所获空间</strong>和<strong>所需时间</strong>的<strong>价值</strong></p>
</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222828104.png" alt="image-20210831222828104" style="zoom:50%;" />

<ol start="3">
<li>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222841096.png" alt="image-20210831222841096" style="zoom:50%;" />

<ol start="4">
<li>下图显示了老年代和幸存区晋升的存活对象的复制</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222859760.png" alt="image-20210831222859760" style="zoom:50%;" />

<ol start="5">
<li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li>
</ol>
<img src="../../img/markdown_img/Java基础.assets/image-20210831222919182.png" alt="image-20210831222919182" style="zoom:50%;" />



<h3 id="划分方式"><a href="#划分方式" class="headerlink" title="划分方式"></a>划分方式</h3><p>将对象按照生命周期的不同划分为：年轻代、年老代、永久代。其中永久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代</p>
<h3 id="JVM内存参数"><a href="#JVM内存参数" class="headerlink" title="JVM内存参数"></a><strong>JVM内存参数</strong></h3><p>对于JVM内存配置参数：-Xmx10240m -Xms10240m -Xmn5120m -XX:SurvivorRatio=3 其最小内存值和Survivor区总大小分别是</p>
<ul>
<li><strong>-Xms</strong> 最小堆内存（包括新生代和老年代）</li>
<li><strong>-Xmx</strong> 最大堆内存（包括新生代和老年代）</li>
<li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li>
<li><strong>-Xmn</strong> 新生代的内存</li>
<li><strong>-XX:SurvivorRatio</strong>=3 Eden区占3份，from和to各占1份</li>
<li><strong>-XX:NewSize</strong> 与 <strong>-XX:MaxNewSize</strong> 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li>
</ul>
<h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><p><strong>JVM调优的重点</strong>是<strong>垃圾回收</strong>（gc）和<strong>内存管理</strong>，垃圾回收的时候会导致整个虚拟机暂停服务。因此，应该尽可能地缩短垃圾回收的处理时间</p>
<p>在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置,让JVM获得最佳性能</p>
<ol>
<li><p><strong>开启-server模式</strong>，（启动虽然慢，但是运行效率高）</p>
</li>
<li><p>针对<strong>JVM堆的设置</strong>一般，可以通过-Xms -Xmx 限定其最小，最大值，为了防止垃圾收集器在最小、最大之间收缩而产生额外的时间，我们通常把最大、最小设置为相同的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms2g: 初始化堆大小为2g；</span><br><span class="line">-Xmx2g：堆最大内存为2g；</span><br></pre></td></tr></table></figure></li>
<li><p>年轻代和年老代将根据<strong>默认</strong>的比例<strong>（1：2）</strong>分配堆内存。年轻代和年老代设置多大才算合理，<strong>原则是减少GC的频率和Full GC的次数</strong></p>
</li>
<li><p>在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法：</p>
<p>-XX：+UserParalleloldGC，默认为Serial收集</p>
</li>
<li><p>-XX:SurvivorRatio=8；默认是8，表示新生代Eden占8份，Survivor区的from和to各占1份，8:1:1</p>
</li>
<li><p><strong>线程堆栈的设置</strong>：<strong>每个线程默认会开启1M</strong>的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，<strong>一般256K就足用</strong>。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统</p>
</li>
</ol>
<h3 id="怎么获取Java程序使用的内存？堆使用的百分比？"><a href="#怎么获取Java程序使用的内存？堆使用的百分比？" class="headerlink" title="怎么获取Java程序使用的内存？堆使用的百分比？"></a>怎么获取Java程序使用的内存？堆使用的百分比？</h3><p>可以通过java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存以及最大堆内存。通过这些方法你也可以获取到堆使用的百分比以及堆内存的剩余空间。Runtime.freeMemory()方法返回剩余空间的字节数，Runtime.totalMemory()方法返回总内存的字节数，Runtime.maxMemory()返回最大内存的字节数</p>
<h3 id="JVM常用调试工具"><a href="#JVM常用调试工具" class="headerlink" title="JVM常用调试工具"></a>JVM常用调试工具</h3><p>jconsole 和 jvisualvm 两款视图监控工具：</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220416151404690.png" alt="image-20220416151404690"></p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220217095213698.png" alt="image-20220217095213698"></p>
<h3 id="集合的fail-fast和fail-safe机制"><a href="#集合的fail-fast和fail-safe机制" class="headerlink" title="集合的fail-fast和fail-safe机制"></a>集合的fail-fast和fail-safe机制</h3><p>fail-fast和fail-safe是集合的一种错误检测机制，当集合的迭代器正在遍历集合的同时又对集合进行结构上的改变的操作，就有可能引起fail-fast机制</p>
<p>比如：线程1通过iterator正在遍历集合A中的元素，线程2修改了集合A的结构（<strong>是结构上面的修改，而不是简单的修改集合元素的内容</strong>），那么这个时候就会抛出异常<strong>ConcurrentModificationException</strong>，从而产生fail-fast机制</p>
<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量来记录在遍历期间集合是否发生改变。在每次迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为期望的expectedModCount，是的话则遍历，否则抛出异常，终止遍历</p>
<p>可以使用写时复制数组代替普通数组CopyOnWriteArrayList代替ArrayList。CopyOnWriteArrayList是Fail-Safe的，遍历的同时可以修改，原理是读写分离</p>
<h3 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h3><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。 </p>
<p>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。 </p>
<p>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
<h3 id="ArrayList-扩容"><a href="#ArrayList-扩容" class="headerlink" title="ArrayList 扩容"></a>ArrayList 扩容</h3><p>当我们添加第一个元素的时候，首次扩容为10，再次扩容为上次容量的1.5倍，实际上是上次容量右移1位后再加上上次的容量。接下来再判断扩容后的容量是不是大于期望的最小容量，选择两者中大的作为新容量，最后Arrays.copyOf()完成扩容</p>
<p><strong>扩容因子1.5的原因</strong>：</p>
<h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><p><strong>LinkedList</strong></p>
<ol>
<li>基于双向链表，无需连续的内存</li>
<li>随机访问慢，需要沿着链表进行遍历</li>
<li>头尾插入删除性能高</li>
<li>占用内存多，因为节点还要存一些prev，next的指向信息</li>
</ol>
<p><strong>ArrayList</strong></p>
<p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p>
<ol>
<li>基于数组，需要连续的内存空间</li>
<li>随机访问快，因为内存空间连续，直接通过下标访问</li>
<li>尾部插入和删除性能高，其他部分的插入删除都会引起数组的移动，性能低</li>
<li>可以利用CPU缓存，局部性原理，访问到某一个下标时，把附近的也加载进入</li>
</ol>
<h3 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h3><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。 transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>
<p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>
<h3 id="HashSet如何检查重复？HashSet如何保证数据是不可重复的？"><a href="#HashSet如何检查重复？HashSet如何保证数据是不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet如何保证数据是不可重复的？"></a>HashSet如何检查重复？HashSet如何保证数据是不可重复的？</h3><p>HashSet底层就是一个HashMap实现的，调用HashSet的添加add(E e)方法就是调用的HashMap的put()方法，将HashSet中要添加的元素e作为HashMap的key，因为HashMap的key是不重复的，所以HashSet的的值也是不重复的</p>
<h3 id="为什么重写了equals还要重写hashcode"><a href="#为什么重写了equals还要重写hashcode" class="headerlink" title="为什么重写了equals还要重写hashcode"></a>为什么重写了equals还要重写hashcode</h3><p>对于基本数据类型equals比较的是值，对于引用数据类型，equals是比较的地址的引用是否相等。我们一般要比较对象是否相等的时候要重写equals方法，但是这还不够，因为java中会先进行hash运算，也即是hashcode方法得到哈希码来判断对象应该位于哪个桶里，如果位于不同桶里，也就是说hashcode的值不同的，这两个对象一定不同，如果hashcode相同，则还要去后续的链表中用equals方法去比较两个对象是否相等。如果没有重写hashcode方法，那么一开始两个相同的对象的hashcode值就不同，这样咋比也不会相同了。所以重写hashcode，就是确保我们认为相同的对象的hashcode也要相同</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet实现了Set接口，而HashMap实现的是Map接口。但是HashSet内部维护了一个map，HashSet调用add就是调用的map的put方法。但是HashSet不允许有重复的值，map中的put方法在判断出有重复值的时候不会添加元素，而是把旧值设置为新值后直接返回，最后并没有添加节点</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable可以说是就是线程安全版的Hashmap，因为它的方法都加了synchronized关键字，<strong>Hashtable不允许有null的key和value</strong>，put的时候就会检查value是否为null，key为空的话当key.hashcode方法的时候就会报错，都采用fail-fast机制，就是说在iterator遍历的时候，如果做了结构上的修改操作，那么就会抛出异常</p>
<p>Hashtable的初始容量是11，装载因子是0.75，扩容每次2n+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>计算hash值的方法不同</strong></p>
<p><strong>Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。</strong><br><strong>HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。</strong></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>初始容量16</strong>  负载因子<strong>0.75</strong>  <strong>扩容2倍</strong></p>
<h4 id="HashMap-每次扩容两倍的原因"><a href="#HashMap-每次扩容两倍的原因" class="headerlink" title="HashMap 每次扩容两倍的原因"></a>HashMap 每次扩容两倍的原因</h4><p>HashMap 每次保证 map 的大小为2的倍数，目的则是为了能够更好的计算hash 值，让其元素分布均匀，并且2的倍数的话 可以采用位运算来代替取模运算，这样计算就会很方便，性能也会好很多</p>
<h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><ul>
<li>1.7 数组 + 链表</li>
<li>1.8 数组 + （链表 | 红黑树）</li>
</ul>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>Hashmap可以采用keyset和entryset遍历以及values()方法获取所有的值</p>
<p>在用迭代器方法遍历的同时，如果调用hashmap自身的remove方法去删除一个key，将会引出fail-fast机制</p>
<p>调用nextNode方法的时候报错</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220305100357140.png" alt="image-20220305100357140"></p>
<p>但是如果用<strong>迭代器的remove()方法去删除一个key，则不会抛出异常</strong>，这是因为迭代器的remove()方法在删除的时候，会同时更新modCount和expectedModCount;这样就不会出现fail-fast，而hashmap的remove方法最终会修改modCount的值，而不会同步更新expectedModCount</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220305100331579.png" alt="image-20220305100331579"></p>
<h4 id="树化与退化"><a href="#树化与退化" class="headerlink" title="树化与退化"></a>树化与退化</h4><p><strong>树化意义</strong></p>
<ul>
<li>红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然情况才树化为红黑树，是保底策略</li>
<li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 O(log_2⁡n )，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li>
<li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li>
</ul>
<p><strong>树化规则</strong></p>
<ul>
<li>当<strong>链表长度超过</strong>树化阈值<strong>8</strong>时，先尝试扩容来减少链表长度，如果<strong>数组容量</strong>已经**&gt;=64**，才会进行树化</li>
</ul>
<p><strong>退化规则</strong></p>
<ul>
<li>情况1：在扩容时如果拆分树时，树元素个数 &lt;= 6 则会退化链表</li>
<li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li>
</ul>
<h4 id="put与扩容"><a href="#put与扩容" class="headerlink" title="put与扩容"></a>put与扩容</h4><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220302204906775.png" alt="image-20220302204906775"></p>
<p><strong>put流程</strong></p>
<ol>
<li>HashMap 是懒惰创建数组的，首次使用才创建数组，首先看table是否为null，为null就去初始化table</li>
<li>table初始化完后，就看对应的table[i]是不是有不有值，没有值，直接插入</li>
<li>table[i]有值，就看table[i]的key是不是和要插入的重复了，重复了直接覆盖值</li>
<li>没有重复，就判断是不是treenode，是treenode就走红黑树的put流程</li>
<li>不是treenode，就准备插入到链表尾，判断链表需不需要转为红黑树</li>
<li>不需要转为红黑树，判断key是否存在，存在直接覆盖value</li>
<li>最后看需不需要扩容</li>
</ol>
<h4 id="Hashmap-并发死链的问题"><a href="#Hashmap-并发死链的问题" class="headerlink" title="Hashmap 并发死链的问题"></a>Hashmap 并发死链的问题</h4><p>Hashmap在多线程的情况还有可能发生死链的问题：</p>
<ul>
<li>JDK1.7在调用resize()方法的时候，会调用其中的transfer()方法，因为JDK1.7采用<strong>头插</strong>的方式，比如现在一个桶下的链有元素a，b。当线程1来的时候先指向这个引用，这个时候线程切换，线程2进行扩容，正常扩容完后因为头插法元素的顺序就b，a了，但是线程1这个时候之前已经拿到了这个两的引用，先把a头插，然后next原来指向的b，接着b头插，next又是a，头插a，这个时候a的next又指向的b，next指向null。这个就形成了一个死链，a的next是b，b的next又是a</li>
</ul>
<h4 id="HashMap初始容量10000，插入10000条数据，会不会扩容"><a href="#HashMap初始容量10000，插入10000条数据，会不会扩容" class="headerlink" title="HashMap初始容量10000，插入10000条数据，会不会扩容"></a>HashMap初始容量10000，插入10000条数据，会不会扩容</h4><p>不会扩容，因为带有初始容量的构造方法并不是直接把初始容量参数设置为threshold，而是经过一个tableSizeFor()方法，将阈值要设置为2的多少次方，10000的话应该是2^14次方=16384，所以16384*0.75=12288&gt;10000，所以能存</p>
<h4 id="HashMap-1-8-和-1-7区别，做了哪些优化"><a href="#HashMap-1-8-和-1-7区别，做了哪些优化" class="headerlink" title="HashMap 1.8 和 1.7区别，做了哪些优化"></a>HashMap 1.8 和 1.7区别，做了哪些优化</h4><ol>
<li>JDK 1.7 头插法，存在并发死链问题</li>
<li>JDK 1.8 采用的hash 算法不同，hashcode ^ (hashcode &gt;&gt;&gt; 16)</li>
</ol>
<h4 id="HashMap-table的初始化"><a href="#HashMap-table的初始化" class="headerlink" title="HashMap table的初始化"></a>HashMap table的初始化</h4><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="红黑树的引入"><a href="#红黑树的引入" class="headerlink" title="红黑树的引入"></a>红黑树的引入</h4><p><strong>有了二叉搜索树，为什么还要二叉平衡树</strong></p>
<ul>
<li>二叉搜索树是一棵排了序的二叉树，可以方便我们做一个数据的查找，二叉搜索树的中序遍历的结果就是一个排好序的结果，我们查找数据沿着根结点遍历，小于这个节点的就到左子树中去查找，大于这个节点的就到右子树中查找。</li>
<li>二叉搜索树的查找时间复杂度平均 O（log n），但是当这个二叉树退化为链表的，时间复杂度就退化为了O（n）</li>
<li>所以为了<strong>防止它退化为链表</strong>，就采用了二叉平衡树，<strong>二叉平衡树</strong>确保左右子树的<strong>高度差不超过1</strong>，在插入节点的时候，还需要去平衡二叉树的高度。保证最坏情况下其查找性能也是O（log n）</li>
</ul>
<p><strong>有了二叉平衡树，为什么还要红黑树</strong></p>
<ul>
<li>AVL 的严格要求左右子树高度差不能超过1，每次进行 插入/删除操作的时候，几乎都需要通过 旋转 操作保持平衡</li>
<li>所以在<strong>频繁插入/删除</strong>的场景中，<strong>二叉平衡树</strong>的<strong>平衡也严重影响了其性能</strong></li>
<li>红黑树通过牺牲严格的平衡，换取 插入/删除 时少量的旋转操作，整体性能高于 AVL<ul>
<li>红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决</li>
</ul>
</li>
<li>红黑树的红黑规则，保证最坏的情况下，也能在O ( log N ) 时间复杂度</li>
</ul>
<h4 id="红黑树规则"><a href="#红黑树规则" class="headerlink" title="红黑树规则"></a>红黑树规则</h4><p><strong>红黑树的规则：</strong></p>
<ul>
<li><strong>节点不是黑色</strong>，<strong>就是红色</strong></li>
<li><strong>根节点是黑色</strong></li>
<li><strong>叶子节点</strong>都是<strong>黑色</strong>（<strong>NIL</strong> / <strong>NULL</strong>）</li>
<li>从根路径到任意节点，<strong>不能连续出现两个红色节点</strong>（一个节点要是红色，其子节点都要是黑色）</li>
<li><strong>每个节点到叶子节点的所有路径</strong>，都<strong>包含相同数目的黑色节点</strong></li>
</ul>
<p>红黑树的红黑规则，保证最坏的情况下，也能在O ( log N ) 时间复杂度</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Hashtable是synchronized版的HashMap，但是它性能太低了，所以有了ConcurrentHashMap</p>
<ol>
<li><p>JDK 7</p>
<p>在JDK 7的时候，它的设计是采用<strong>Segment分段锁</strong>去实现的，有多个Segment，一个<strong>Segment</strong>就是一个<strong>ReentrantLock</strong>，因为它继承了ReentrantLock，加锁的时候就是<strong>对Segment进行加锁</strong>，这样<strong>不同Segment的操作</strong>就可以<strong>不用加锁</strong>，达到并发的效果。</p>
<p>它的put流程就是说先根据<strong>SegmentShift</strong>和<strong>SegmentMask</strong>计算出<strong>Segment</strong>的<strong>下标</strong>，然后拿着这个下标先去判断，<strong>Segment</strong>是不是null，在<strong>确保为null</strong>之后就采用<strong>CAS去创建Segment对象</strong>，然后<strong>进入segment的put流程</strong>，首先<strong>尝试给segment加锁tryLock()<strong>，加锁</strong>不成功</strong>，就进入scanAndLockForPut方法<strong>多次尝试加锁</strong>，在<strong>尝试期间</strong>，还会去看<strong>节点</strong>有没有创建出来，如果没有则还会去<strong>创建</strong>出来。</p>
<p><strong>加锁成功</strong>后，就可以安全的执行后续的put操作了，看<strong>有没有这个key</strong>，就看<strong>要不要覆盖值</strong>，没有就是新增，<strong>判断节点有没有被创建出来</strong>，因为刚才说了有可能在循环获取锁的时候可能会去创建出节点，然后看<strong>要不要扩容</strong></p>
</li>
<li><p>JDK 8</p>
<p>JDK 8采用的是<strong>CAS+synchronized</strong>来实现线程安全性，它的put流程主要如下，</p>
<p>获取到key的<strong>hash值</strong>，然后<strong>看tab有没有创建出来</strong>，tab<strong>没创建</strong>出来就走<strong>initTable()创建tab</strong>，initTable()里面会先去判断有不有其他线程正在创建tab，如果有就当前线程循环yield，让出CPU的使用权，否则就使用CAS替换sizeCtl的值尝试获取锁然后创建tab；如果tab创建出来了，就去判断对应tab[]下面的<strong>头节点有没有创建出来</strong>，如果<strong>没有</strong>，则<strong>新增的节点</strong>直接就是作为<strong>头结点</strong>，否则就看头结点<strong>是不是被搬迁过 MOVED</strong>，如果是说明<strong>正在扩容</strong>，那么就要去<strong>帮忙扩容helpTransfer()</strong></p>
<p>最后else说明<strong>tab创建完了</strong>，<strong>头结点也不为null</strong>，并且<strong>也不是forwarddingNode正在扩容</strong>，那么就加锁，<strong>synchronized锁住头结点</strong>，再次判断节点是否被移动，如果是<strong>链表</strong>，就走链表的put，<strong>遍历链表</strong>，找有不有重复，记录链表元素个数，如果是<strong>红黑树</strong>，走红黑树的put，最后<strong>看需不需要去树化</strong>，然后增加size计数</p>
</li>
</ol>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="流的划分"><a href="#流的划分" class="headerlink" title="流的划分"></a>流的划分</h3><ul>
<li>按照流的流向：输入流和输出流</li>
<li>按照流的操作单元：字符流和字节流</li>
<li>按照流的角色：节点流和处理流</li>
</ul>
<p><strong>字节流：</strong></p>
<ul>
<li>字节流就是每次处理单元是一个字节，主要用于二进制数据的读取，实际上它可以读取任意类型的数据，但是它不支持直接写入或者读取Unicode码元。<strong>字节流默认不使用缓冲区</strong>。字节输入流和输出流分别对应InputStream和OutputStream</li>
</ul>
<p><strong>字符流：</strong></p>
<ul>
<li>字符流每次处理单元是两个字节的一个Unicode字符。<strong>字符流使用缓冲区</strong>。字符输入流和输出流分别对应InputReader和OutputWriter</li>
</ul>
<p>节点流：可以从或向一个特定的地方（节点）读写数据。直接对数据源（文件，数组之类存放数据的地方）进行操作。常见的有 FileReader，FileWriter，FileInputStream，FileOutputStream</p>
<p>处理流：对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。处理流的构造方法总是要带一个其他的流对象做参数。常见的有 BufferedReader，BufferedWriter，BufferedInputStream，BufferedOutputStream。</p>
<p>比如<code>BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath))</code></p>
<p>Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的</p>
<ul>
<li><strong>InputStream/Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流</li>
<li> <strong>OutputStream/Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流</li>
</ul>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220215183701632.png" alt="image-20220215183701632"></p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220215183940215.png" alt="image-20220215183940215"></p>
<h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul>
<li>Files. exists()：检测文件路径是否存在</li>
<li>Files. createFile()：创建文件 </li>
<li>Files. createDirectory()：创建文件夹</li>
<li>Files. delete()：删除一个文件或目录</li>
<li>Files. copy()：复制文件</li>
<li>Files. move()：移动文件</li>
<li>Files. size()：查看文件个数</li>
<li>Files. read()：读取文件</li>
<li>Files. write()：写入文件</li>
</ul>
<h3 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO,NIO,AIO"></a>BIO,NIO,AIO</h3><ul>
<li>BIO：Block IO 同步阻塞式IO，就是我们平时使用的传统IO，它的特点是模式简单使用方便，但并发处理能力低</li>
<li>NIO：Non IO 同步非阻塞IO，是传统IO的升级，客户端和服务端通过Channel（通道）通讯，实现了多路复用</li>
<li>AIO：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>在Unix系统中，一切都是文件。文件就是流的概念，在进行信息的交流过程中，对这些流进行数据的收发操作就是IO操作</p>
<blockquote>
<p>我们都知道unix(like)世界里，一切皆文件，而文件是什么呢？文件就是一串二进制流而已，不管socket，还是FIFO、管道、终端，对我们来说，一切都是文件，一切都是流。在信息交换的过程中，我们都是对这些流进行数据的收发操作，简称为 <strong>I/O 操作</strong>(input and output)，往<strong>流中读出数据</strong>，系统调用<strong>read</strong>，<strong>写入数据</strong>，系统调用<strong>write</strong>。不过话说回来了 ，计算机里有这么多的流，我怎么知道要操作哪个流呢？对，就是<strong>文件描述符</strong>，即通常所说的 <strong>fd</strong> ，一个 **fd **就是一个整数，所以，对这个整数的操作，就是对这个文件（流）的操作。我们创建一个socket，通过系统调用会返回一个文件描述符，那么剩下对socket的操作就会转化为对这个描述符的操作。不能不说这又是一种分层和抽象的思想。</p>
</blockquote>
<h3 id="磁盘IO为什么慢"><a href="#磁盘IO为什么慢" class="headerlink" title="磁盘IO为什么慢"></a>磁盘IO为什么慢</h3><p>我们要到磁盘上查找数据的话，内核会给磁盘映射一个地址，然后磁盘定位到盘片上，就让磁头去寻找具体数据读取出来。</p>
<p>磁盘IO的速度主要在于两个方面：</p>
<ol>
<li><strong>让磁头定位到指定位置的时间</strong></li>
<li><strong>磁头从盘片上读出数据的时间</strong></li>
</ol>
<h3 id="同步-与-异步"><a href="#同步-与-异步" class="headerlink" title="同步 与 异步"></a>同步 与 异步</h3><p>同步： 执行一个操作后，进程<strong>触发IO操作</strong>（其中要么就是等待数据的到达，也就是阻塞模式；要么通过轮询去查看数据是否到达也就是非阻塞忙轮询模式的）等待或者轮询 IO 操作是否就绪。</p>
<p>异步： 执行一个操作后，<strong>触发IO操作后不会导致请求进程阻塞</strong>。也就是说数据从内核到用户缓冲区的整个过程都是交给内核去完成的，用户进程无需阻塞一直等到IO操作完成，它只要执行一个操作<strong>触发IO操作后</strong>就可以继续<strong>执行其他操作</strong>，直到IO操作结束后，<strong>等到被通知</strong>就可以了。所以从根本来说异步从等待数据到把数据从内核空间拷贝到用户空间的过程中没有阻塞，只有发起该操作，和被通知该操作完成。所以异步是真正的没有阻塞在IO操作上的</p>
<h3 id="IO-阻塞-与-非阻塞"><a href="#IO-阻塞-与-非阻塞" class="headerlink" title="IO 阻塞 与 非阻塞"></a>IO 阻塞 与 非阻塞</h3><p><strong>阻塞</strong>：阻塞就是说在执行 IO 操作的时候，调用者一直等待请求结果返回，当前线程一直等待无法从事其他工作，只有当条件就绪时，才可以继续执行</p>
<p><strong>非阻塞</strong>：非阻塞则相反，不用一直等待请求结果返回，可以先去做别的事情</p>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO 也就是 Blocking IO，<strong>同步阻塞I/O模式</strong>，数据的读取写入<strong>必须阻塞在一个线程内等待其完成</strong>。</p>
<p>就是我们平时使用的传统IO，它的特点是模式简单使用方便，但并发处理能力低</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO 同时支持 阻塞和非阻塞</p>
<p><strong>同步非阻塞</strong>指的是：一个线程进行数据的读取写入的时候，<strong>不必一直阻塞等待</strong>，可以去做别的任务，只<strong>需要</strong>不停的<strong>轮询</strong>一下数据处理情况，如果数据处理完毕，也就可以执行下一步任务了。</p>
<p><strong>缺点</strong>：<strong>服务端</strong>要<strong>轮询</strong>所有连接的客户端拿数据（<code>recv</code>调用），很多调用是无意义的，这样会导致频繁的<strong>用户态切换成内核态</strong>，导致性能变差。</p>
<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>AIO （Asynchronous I/O）：异步非阻塞IO，异步IO肯定就是非阻塞的IO，只需要执行一个操作触发IO就可以去执行其他操作了，也不用一直轮询IO操作的状态，等IO操作结束后，只需要等待IO通知。</p>
<p>无论NIO，SELECT还是POLL，<strong>都是要遍历所有IO，询问状态,只不过遍历这件事到底是内核来做还是应用程序来做而已</strong></p>
<h3 id="Java-NIO-底层实现"><a href="#Java-NIO-底层实现" class="headerlink" title="Java NIO 底层实现"></a>Java NIO 底层实现</h3><p>Java  NIO 底层基于 epoll 的多路复用技术实现，与 select poll 不同的是，select poll 都是每次调用 select、poll 就把文件描述符从用户态拷贝到内核态，供修改，然后select 采用数组的形式 遍历数组作为一个监听，poll 采用链表的形式 作为监听 解决了select 的数组大小限制问题，但是他们都面临着一个遍历问题，就是都要遍历一次数组或者链表，来查看对应的 fd，时间复杂度O（n），epoll 则是在调用 epoll_ctl 的时候进行 fd 的拷贝，并且给每个 fd 注册指定一个回调函数，当准备就绪的时候，回调函数就会把 就绪的 fd 放到 就绪链表中去，epoll_wait 就等待 就绪链表有 就绪的fd 的时候。这样不用遍历，复杂度 O（1）</p>
<h3 id="多路-IO复用"><a href="#多路-IO复用" class="headerlink" title="多路 IO复用"></a>多路 IO复用</h3><p><strong>多路IO复用</strong>采用 select、poll、epoll 的三种方式，这个三个函数本质上都是同步I/O，因为他们都需要在读写事件就绪后再自己进行读写，也就是说这个读写过程是阻塞的</p>
<p>select 先阻塞，有活动套接字才返回，只不过 <strong>select</strong> 采用<strong>数组</strong>存文件描述符 <strong>fd</strong>，<strong>poll</strong> 采用<strong>链表</strong>存 文件描述符，和 阻塞IO 不相同的是，这个几个函数可以阻塞多个IO操作，而且可以同时对多个读操作，多个写操作的IO函数进行检测，修改 fd 来表示数据的准备情况</p>
<p>正因为 <strong>阻塞IO</strong> 只能<strong>阻塞 一个 IO 操作</strong>，而 <strong>IO复用模型</strong> 能<strong>阻塞多个 IO 操作</strong>，所以叫多路复用。</p>
<p>也就是说，<strong>IO 多路复用并不是非阻塞</strong>，<strong>只是它可以同时处理多个请求</strong>，<strong>原本的 单路IO 是一个处理完才能接入新的连接</strong>，多路复用就是<strong>可以同时接入多个连接</strong>。</p>
<p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程</strong></p>
<p>多路复用技术可以<strong>解决 NIO 的需要轮询客户端状态</strong>，<strong>造成用户态到内核态切换的问题</strong>。多个IO通过一个系统调用获得其中的IO状态，然后由程序对有状态的IO进行读写操作。在Linux系统中，多路复用的实现有：</p>
<ul>
<li><p><strong>select</strong></p>
<p><strong>select 监控</strong> 三类文件描述符，<strong>writefds</strong>、<strong>readfds</strong>、<strong>exceptfds</strong>，select 采用数组的形式存储这三类描述符，select 一直遍历这个描述符数组，内核在将数据准备好后或者应该说修改对应的描述符为1后，select 遍历到有描述符就绪，就知道这些数据是准备好的，然后将函数返回，返回后再接收数据</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>文件描述符的数量，默认 <strong>1024</strong> 个</li>
<li><strong>开销会随着文件描述符线性增长</strong>，O（n）</li>
</ul>
</li>
<li><p><strong>poll</strong></p>
<p>poll 是为了解决 select 的数组数量有限的情况，所以 poll 采用<strong>链表</strong>的形式，这样在大小上就不会存在限制</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>仍然存在开销随着文件描述符线性增长</strong>，O（n）</li>
</ul>
</li>
<li><p><strong>epoll</strong></p>
<p>epoll 就解决了开销随文件描述符增长的情况。epoll 采用<strong>监听回调的机制</strong>，<strong>每当 fd 就绪</strong>，系统注册的<strong>回调函数</strong>就会被<strong>调用</strong>，就<strong>将就绪 fd 放到 就绪链表</strong>，<strong>epoll_wait</strong> 就去<strong>就绪链表中查看</strong>有不有就绪的fd（不用遍历所有的 fd，直接找到哪些 fd 就绪），<strong>epoll_ctl</strong> 注册监听对应的事件，拷贝fd到内核，epoll_wait 不拷贝</p>
<p>时间复杂度 O（1）</p>
<p>epoll对文件描述符的操作有两种模式：<strong>LT</strong>（level trigger）和<strong>ET</strong>（edge trigger），LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<p>LT模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></p>
<p>ET模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</strong></p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</p>
</li>
</ul>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220408104126857.png" alt="image-20220408104126857"></p>
<p>Select</p>
<p>基于 Select 调用的 I/O 复用模型如下：</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220408091713550.png" alt="image-20220408091713550"></p>
<p>应用进程 select 调用，没有数据报准备好，到数据报准备完毕，进程一直阻塞等待，等待可能多个套接字中的任一个变为可读状态。等待内核返回可读条件的时，应用进程 recvfrom 再次发送系统调用拷贝数据报（将数据从内核拷贝到用户空间），拷贝完成返回成功，然后应用进程就可以继续执行操作了。</p>
<p><strong>select poll epoll的区别</strong></p>
<p>Nginx实现网络通讯时使用的是异步网络模型：<strong>epoll模型</strong></p>
<p><strong>select、poll、epoll都是I/O多路复用机制</strong>，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪，就能够通过程序进行相应的读写操作</p>
<p>select、poll、epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后再自己进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无须自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间</p>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><ul>
<li><p>select()函数监视的文件描述符分为三类，分别是writefds、readfds、exceptfds，调用后select()函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可）函数就会返回</p>
</li>
<li><p>首先会将多个文件描述符标志位存入一个数组中，当函数返回时，该数组中<strong>就绪的文件描述符便会被内核修改标志位</strong>，使得进程可以获得这些文件描述符从而进行后续的读写操作</p>
</li>
<li><p>然后select函数就会遍历文件描述符数组，如果读到标志位为1，则知道这些数据是准备好了的，然后对其进行读写</p>
<p><strong>缺点：</strong></p>
</li>
<li><p>文件描述符的数量默认为1024个</p>
</li>
<li><p>开销会随着文件描述符线性增长（遍历一遍需要很长时间 O(n)）</p>
</li>
</ul>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><ul>
<li><p>和select的执行过程是差不多的，但是数据结构改变了，poll机制中将select机制的文件描述符数组改善为了链表，将文件描述符标志位存入链表中</p>
</li>
<li><p>因为链表是可以无限延伸的，因此poll对于select来说，使得文件描述符的数量不再被限制</p>
<p><strong>缺点：</strong></p>
<p>开销会随着文件描述符线性增长（同样需要和select机制一样遍历一遍 O(n)）</p>
</li>
</ul>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ul>
<li><p>epoll是select和poll的增强版本，相对于select和poll来说，epoll更加灵活，没有描述符限制</p>
</li>
<li><p>当调用epoll_wait()函数获得就绪文件描述符的时候，返回的不是实际的文件描述符，而是一个代表就绪描述符数量的值，<strong>这个时候只需要去epoll指定的一个准备就绪链表中遍历一遍这些文件描述符就可以了</strong></p>
</li>
<li><p>epoll提供了三个函数：<code>epoll_create、epoll_ctl、epoll_wait</code></p>
<p>epoll_create是创建一个epoll句柄</p>
<p>epoll_ctl是注册要监听的事件类型</p>
<ul>
<li>在调用epoll_ctl()时把所有fd拷贝进内核，并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表（<strong>此处去掉了遍历文件描述符，而是通过监听回调的的机制</strong>，这正是epoll的魅力所在）</li>
<li>epoll_wait则是等待事件的产生，它的实际工作就是在查看在就绪链表中有没有就绪的fd</li>
</ul>
</li>
</ul>
<p>epoll的开销对于select和poll来说省下了许多，<strong>时间复杂度只需要O(1)</strong></p>
<h5 id="LT-ET"><a href="#LT-ET" class="headerlink" title="LT/ET"></a>LT/ET</h5><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger），LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<p>LT模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></p>
<p>ET模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</strong></p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；<strong>这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制</strong></p>
<p>静态编译：在编译时确定类型，绑定对象</p>
<p>动态编译：在运行时确定类型，绑定对象</p>
<h3 id="反射优缺点"><a href="#反射优缺点" class="headerlink" title="反射优缺点"></a>反射优缺点</h3><ul>
<li>优点：运行期类型的判断，动态加载类，提高代码的灵活度</li>
<li>缺点：性能瓶颈，反射相当于一系列解释操作，通知JVM要做的事，性能比直接的Java代码要慢</li>
</ul>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>反射的框架设计的灵魂</p>
<p>我在项目中采用Redis用Hash的结构存入一个用户的授权对象，然后调用<code>redisTemplate.boundHashOps(uuid).entries()</code>取出来的时候需要将其从Map集合转换为一个对象，这个时候就编写了一个工具类就是运用反射将Map中的entry转换为一个实例对象</p>
<ol>
<li>在采用JDBC连接数据库的时候采用Class.forName()通过反射加载数据库的驱动</li>
<li>Spring中运用到的反射，最经典的就是xml的配置，Spring通过XML配置解析装载Bean<ul>
<li>将程序内所有XML或Properties配置文件加载入内存中</li>
<li>Java类里面解析XML或者Properties里面的内容，得到对应实体类的字节码字符串以及相关属性信息</li>
<li>使用反射机制，根据这个字符串获得某个类的实例</li>
<li>动态配置实例的属性</li>
</ul>
</li>
</ol>
<h3 id="反射的三种方法"><a href="#反射的三种方法" class="headerlink" title="反射的三种方法"></a>反射的三种方法</h3><p>假设有一个com.zc.test包下有类Student</p>
<ol>
<li>Class.forName(“com.zc.test.student”);</li>
<li>student.getClass();</li>
<li>Student.class;</li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解的三种保留策略"><a href="#注解的三种保留策略" class="headerlink" title="注解的三种保留策略"></a>注解的三种保留策略</h3><p><strong>SOURCE</strong>：此类会被编译器丢弃，不将它保留到编译后的class文件</p>
<p><strong>CLASS</strong>：将注解保留到编译后的class文件，但是在运行时忽略它</p>
<p><strong>RUNTIME</strong>：将注解保留到编译后的class文件，并且会在第一次类加载的时候读取它</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220405185705147.png" alt="image-20220405185705147"></p>
<h3 id="注解的使用范围"><a href="#注解的使用范围" class="headerlink" title="注解的使用范围"></a>注解的使用范围</h3><p>@Traget 注解中的<code>ElementType[] value();</code>，ElementType 描述了注解的修饰范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任何类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol>
<li>形式上：字符常量是单引号引出来的一个字符，字符串是双引号引出的</li>
<li>含义上：字符串是相当于一个整型值（ASCII值），可以参加表达式运算，字符串常量代表一个地址值（该字符串在内存中存放位置）</li>
<li>占内存大小：字符常量只占一个字节，字符串常量占若干个字节（至少一个字符结束标志）</li>
</ol>
<h4 id="什么是字符串常量池"><a href="#什么是字符串常量池" class="headerlink" title="什么是字符串常量池"></a>什么是字符串常量池</h4><p><strong>字符串常量池</strong>位于<strong>堆内存</strong>中，专门用来<strong>存储字符串常量</strong>，可以提高内存的利用率，<strong>避免开辟多块空间存储相同的字符串</strong>，在<strong>创建字符串</strong>时<strong>JVM</strong>会首先<strong>检查字符串常量池</strong>，如果该<strong>字符串已经存在池中</strong>，则<strong>返回它的引用</strong>，如果<strong>不存在</strong>，则<strong>实例化</strong>一个<strong>字符串</strong>放到池中，并返回其引用。</p>
<h4 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h4><ol>
<li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据 的一致性。</li>
<li>常量池优化：：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li>
<li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li>
</ol>
<h4 id="String真的是不可变的吗"><a href="#String真的是不可变的吗" class="headerlink" title="String真的是不可变的吗"></a>String真的是不可变的吗</h4><ol>
<li><p>String不可变但不代表引用不可以变 </p>
<p>String str =”Hello”;str = str +” World”; System.out.println(“str=”+ str);</p>
<p>结果：str=Hello World</p>
<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已， 也就是说多开辟了一块内存区域给”Hello World”字符串。</p>
</li>
<li><p>通过反射可以修改所谓的“不可变”对象</p>
<p>通过反射打破封装，访问String对象的<code>char[] value</code>属性，修改其值</p>
</li>
</ol>
<h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 =<span class="string">&quot;hello&quot;</span>;<span class="comment">//str1指向静态区</span></span><br><span class="line">String str2 =<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);<span class="comment">//str2指向堆上的对象</span></span><br><span class="line">String str3 =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str4=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str4));<span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2 ==<span class="string">&quot;hello&quot;</span>);<span class="comment">//false</span></span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 ==<span class="string">&quot;hello&quot;</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h4><p>使用StringBuilder或者StringBuffer的reverse()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>

<h4 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h4><ul>
<li>indexOf()：返回指定字符的索引</li>
<li>charAt()：返回指定索引处的字符</li>
<li>replace()：字符串替换</li>
<li>trim()：去除字符串两端空白</li>
<li>split()：分割字符串，返回一个分割后的字符串数组</li>
<li>getBytes()：返回字符串的byte类型数组</li>
<li>length()：返回字符串长度</li>
<li>toLowerCase()：字符串转成小写字母</li>
<li>toUpperCase()：将字符串转成大写字母</li>
<li>substring()：截取字符串</li>
<li>equals()：字符串比较</li>
</ul>
<h3 id="在使用HashMap的时候，用String做Key有什么好处"><a href="#在使用HashMap的时候，用String做Key有什么好处" class="headerlink" title="在使用HashMap的时候，用String做Key有什么好处"></a>在使用HashMap的时候，用String做Key有什么好处</h3><p>HashMap内部实现是通过Key的hashcode来确定value的存储位置的，因为字符串是不可变的，所有当创建字符串时，它的<strong>hashcode被缓存下来，不需要再次计算，所以相比于其他对象更快</strong></p>
<h3 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h3><ol>
<li><p>可变性</p>
<p>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与 StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p>
</li>
<li><p>线程安全性</p>
<p>String中的对象是不可变的，也就可以理解为常量，线程安全。<strong>AbstractStringBuilder</strong>是<strong>StringBuilder</strong>与<strong>StringBuffer</strong> 的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。 StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p>StringBuilder非线程安全，StringBuffer线程安全</p>
</li>
<li><p>性能</p>
<p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer 每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
</li>
</ol>
<p>对于三者使用的总结：</p>
<p><strong>如果要操作少量的数据用</strong> = String </p>
<p><strong>单线程操作字符串缓冲区 下操作大量数据</strong> = StringBuilder </p>
<p><strong>多线程操作字符串缓冲区 下操作大量数据</strong> = StringBuffer</p>
<h2 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h2><p>Date、SimpleDateFormat、LocalDate、LocalTime、LocalDateTime、Calendar抽象类，Calendar.getInstance()获取一个实例</p>
<p>LocalDateTime可以用来获取指定时间的时间，里面封装一些方法，可以做一些时间的运算，比如加1周，等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如何让每周四18:00:00 定时执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    LocalDateTime now= LocalDateTime.now();</span><br><span class="line">    <span class="comment">//获取当前周的周四时间</span></span><br><span class="line">    LocalDateTime time = now.withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.THURSDAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前时间大于本周周四，必须找到下周的周四</span></span><br><span class="line">    <span class="keyword">if</span> (now.compareTo(time)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialDelay 代表当前时间和周四的时间差</span></span><br><span class="line">    <span class="comment">// period 一周的间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算两个时间的差值</span></span><br><span class="line">    <span class="keyword">long</span> initialDelay = Duration.between(now, time).toMillis();</span><br><span class="line">    <span class="keyword">long</span> period = <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>;</span><br><span class="line">    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    &#125;,initialDelay,period, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Duration表示一个连续的时间段，可以用来做时间上的计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration.between(now, time).toMillis();</span><br><span class="line"><span class="comment">// 3 s 和 5 ns 的 Duration </span></span><br><span class="line">Duration duration = Duration.ofSeconds(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">Duration oneDay = Duration.between(today, yesterday);</span><br><span class="line"><span class="comment">// A duration of 3 seconds and 5 nanoseconds</span></span><br><span class="line">Duration duration = Duration.ofSeconds(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">Duration oneDay = Duration.between(today, yesterday);</span><br></pre></td></tr></table></figure>

<h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p>装箱：将基本类型用它们对应的引用类型包装起来；</p>
<p>拆箱：将包装类型转换为基本数据类型；</p>
<p>对于<strong>对象引用类型</strong>：==比较的是对象的<strong>内存地址</strong>。 </p>
<p>对于<strong>基本数据类型</strong>：==比较的是<strong>值</strong>。</p>
<p> 如果整型字面量的值在**-128到127<strong>之间，那么自动装箱时</strong>不会new新的Integer对象**，而是直接引用常量池中的Integer 对象，超过范围。</p>
<p>a1==b1的结果是false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">    Integer b =<span class="number">3</span>;<span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">    <span class="keyword">int</span> c =<span class="number">3</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">// false 两个引用没有引用同一对象 </span></span><br><span class="line">    System.out.println(a == c);<span class="comment">// true a自动拆箱成int类型再和c比较 </span></span><br><span class="line">    System.out.println(b == c);<span class="comment">// true </span></span><br><span class="line">    Integer a1 =<span class="number">128</span>; </span><br><span class="line">    Integer b1 =<span class="number">128</span>; </span><br><span class="line">    System.out.println(a1 == b1);<span class="comment">// false </span></span><br><span class="line">    Integer a2 =<span class="number">127</span>; </span><br><span class="line">    Integer b2 =<span class="number">127</span>; </span><br><span class="line">    System.out.println(a2 == b2);<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="五种单例模式"><a href="#五种单例模式" class="headerlink" title="五种单例模式"></a><strong>五种单例模式</strong></h3><p>单例模式有<strong>饿汉式、懒汉式、枚举类(饿汉)、静态内部类</strong></p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题1：为什么<strong>类要加 final</strong></p>
<ul>
<li>防止子类继承后重写方法破坏单例</li>
</ul>
<p>问题2：如果实现了序列化接口，还要做什么来<strong>防止反序列化破坏单例</strong></p>
<ul>
<li>反序列化时候生成的对象可能会破坏单例，直接在类里加一个**public Object readResolve() {}**方法，可以让反序列化的时候调用这个方法返回单例的实例</li>
</ul>
<p>问题3：为什么<strong>构造方法设置为私有</strong>?</p>
<ul>
<li>避免其他类使用new生成新的实例，并不能防止反射创建新的实例，因为反射可以打破封装</li>
</ul>
<p>问题4：这样初始化是否能保证单例对象创建时的线程安全？</p>
<ul>
<li>可以保证，因为实例在<strong>类加载</strong>的时候就<strong>初始化</strong>，JVM会保证其线程安全性</li>
</ul>
<p>问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</p>
<ul>
<li>1.提供更好的<strong>封装性</strong>；2.提供<strong>泛型</strong>的支持</li>
</ul>
</blockquote>
<h4 id="饿汉式之枚举"><a href="#饿汉式之枚举" class="headerlink" title="饿汉式之枚举"></a>饿汉式之枚举</h4><p>饿汉式：因为枚举的变量，底层是通过public static final来修饰的，类加载就创建了，所以是饿汉式</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220122210404242.png" alt="image-20220122210404242"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span>+<span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingletonEnum instance = SingletonEnum.INSTANCE;</span><br><span class="line">        SingletonEnum instance1 = SingletonEnum.INSTANCE;</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">        instance.print();</span><br><span class="line">        instance1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">------<span class="number">1163157884</span></span><br><span class="line">------<span class="number">1163157884</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> EnumSingleton instance;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//JVM保证只执行一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题1：枚举单例是如何限制实例个数的</p>
<ul>
<li><strong>创建枚举类的时候就已经定义好了</strong>，每个枚举常量其实就是枚举类的一个静态成员变量</li>
</ul>
<p>问题2：枚举单例在创建时是否有并发问题</p>
<ul>
<li>没有并发问题，是线程安全的，因为枚举单例底层是一个静态成员变量，它是通过类加载器的加载而创建的，确保了线程安全</li>
</ul>
<p>问题3：枚举单例能否被反射破坏单例</p>
<ul>
<li><p><strong>反射无法破坏枚举单例</strong>, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">this</span>.clazz.getModifiers() &amp; <span class="number">16384</span>) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(“Cannot reflectively create <span class="class"><span class="keyword">enum</span> <span class="title">objects</span>”)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>问题4：枚举单例能否被反序列化破坏单例</p>
<ul>
<li><strong>反序列化不能破坏</strong>，枚举类默认也实现了序列号接口。但枚举类考虑到了这个问题，不会破坏单例。</li>
</ul>
<p>问题 5：枚举单例属于懒汉式还是饿汉式</p>
<ul>
<li>属于<strong>饿汉式</strong>, 静态成员变量, 通过类加载器的时候就加载了。</li>
</ul>
<p>问题 6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</p>
<ul>
<li>加构造方法，枚举也可以写构造方法，普通方法等</li>
</ul>
</blockquote>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点：</span></span><br><span class="line">    <span class="comment">// synchronized加在静态方法上，可以保证线程安全。缺点就是锁粒度大，效率低。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h4><p>DCL：double-check-locking</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题1：解释为什么要加 volatile</p>
<ul>
<li>因为在synchronized外部使用到了共享变量INSTANCE，可能存在一个线程先初始化了instance，但是别的线程没有从主存中获取instance，而是从工作内存中获取instance，仍然为空，volatile保证了可见性，保证读取变量的时候都从主存中去获取，这样就不会存在已经创建了实例，但读取到实例仍然为空的情况</li>
</ul>
<p>问题2：对比上面的懒汉式，说出这样做的意义</p>
<ul>
<li>增加了双重判断，如果存在了单例对象，别的线程再进来就无需加锁判断，<strong>提升效率</strong></li>
</ul>
<p>问题3：为什么还要加为空判断, 之前不是判断过了吗</p>
<ul>
<li>主要原因还是因为并发的时候产生线程不安全的问题</li>
<li>考虑这么一种情况：<ul>
<li>线程1第一次进入了synchronized代码，获取到了锁，判断到instance为null，然后就去创建实例</li>
<li>线程2此时已经进行了第一次判断为空，然后等待线程1释放锁。</li>
<li>如果不加判断，线程1创建完后释放锁，线程2进入同步代码块，此时没有了第二重为空判断，就会直接创建实例，此时就重复创建了实例，破坏了单例</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="懒汉式之静态内部类"><a href="#懒汉式之静态内部类" class="headerlink" title="懒汉式之静态内部类"></a>懒汉式之静态内部类</h4><p>通过静态内部类来创建单例，对外不可见</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题1：属于懒汉式还是饿汉式</p>
<ul>
<li>懒汉式，因为这是个静态内部类，类加载本身就是懒惰的，在没有用到这个类的时候，是不会进行类加载的，因此没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li>
</ul>
<p>问题2：在创建时是否有并发问题</p>
<ul>
<li>没有并发问题，仍然是单例的。因为类加载是懒惰的，没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li>
</ul>
</blockquote>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>静态代理：</strong></p>
<ul>
<li>静态代理就是代理对象和被代理对象实现相同的接口，然后代理对象关联一个被代理对象，然后代理对象的方法中就除了可以调用被代理对象的方法以外，还可以完成对方法的增强。之所以叫静态代理就是因为在<strong>编译期就已经决定好了代理对象的字节码</strong>，将被代理对象的字节码加入到代理对象中</li>
</ul>
<p><strong>动态代理：</strong></p>
<ul>
<li><strong>JDK动态代理</strong><ul>
<li>JDK动态代理也是基于接口的方式实现的，因为静态代理的缺陷很明显，要是我还有别的对象要代理，这样我还需要很多个代理对象去完成，极其不易扩展，那动态代理就是说通过反射机制，在运行期间动态的去完成对目标对象的一个代理。我们在代理类中关联一个Object对象，然后通过Proxy动态的在内存中拿着目标对象的信息去newInstance。最终它会生成一个继承了Proxy实现了目标对象的接口的子类，这也是为什么JDK动态代理需要基于接口去实现的原因，因为Java不支持多继承</li>
</ul>
</li>
<li><strong>CGLIB动态代理</strong><ul>
<li>CGLIB动态代理是为了解决JDK动态代理的缺陷，要是一个类确实不用实现其他的接口，这个时候就需要用CGLIB动态代理了，CGLIB底层是采用的字节码处理框架ASM去动态的对目标对象字节码完成一个转换，最终生成一个子类完成代理</li>
</ul>
</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><strong>简单工厂模式：</strong></p>
<ul>
<li><strong>简单工厂模式又叫静态工厂方法模式</strong>，在简单工厂模式中，可以<strong>根据参数的不同返回不同的实例类型</strong>。简单工厂模式<strong>专门定义一个类来负责创建其他类的实例</strong>，被创建的实例通常都有共同的父类。DateTime里面就是根据timeStyle来创建不同的对象实例的</li>
</ul>
<p><strong>工厂方法模式：</strong></p>
<ul>
<li><p><strong>定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法模式使一个类的实例化延迟到其子类。</strong></p>
</li>
<li><p>提供一个工厂的接口，具体的工厂由具体的子类去完成，像Collection接口就是一个工厂，Iterator迭代器就是产品，不同的工厂ArrayList产生自己的迭代器Itr产品、LinkedList产生自己的迭代器Itr产品</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306182342146.png" alt="image-20220306182342146"></p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306182404398.png" alt="image-20220306182404398"></p>
</li>
</ul>
<p><strong>抽象工厂模式：</strong></p>
<ul>
<li><p><strong>抽象工厂模式就是在工厂方法模式上的一个扩展</strong>，工厂方法模式是一个产品体系，抽象工厂模式则对应一个产品族，可以提供多个产品体系</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306183258293.png" alt="image-20220306183258293"></p>
</li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p><strong>装饰器模式就是说装饰一个类，对其完成功能的扩展。他不同于继承的方式，继承是直接继承然后获得父类的方法，然后自己添加方法完成扩展，装饰器模式则是实现某个接口，同时又关联一个接口的对象，这样就可以利用动态，在运行时动态的决定装饰哪个对象，除了可以调用接口的方法以外，同时可以完成增强。</strong></p>
<p>装饰器模式就是可以扩展某个类的功能，他不同于继承的方式子类添加方法去完成方法扩展，他是通过关联一个<strong>顶层接口的对象</strong>，这样就可以利用多态，同时又实现接口，这样既能持有接口的方法，然后在还可以完成扩展</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式定义了一种一对多的对象间的依赖关系，让多个观察者对象同时监听某一个主体对象。当这个主体对象的状态发生变化的时候，就通知所有监听的观察者对象，从而做出对应的响应</p>
<p>在用 Java 实现文件监控系统的时候，采用WatchService类</p>
<p>在Commons-IO的一个工具类中，在实现其中的FileMonitor的时候，就使用到了观察者模式。</p>
<ol>
<li>首先，创建文件观察者，FileAlterationObserver，Observer里面维护了一个list，就是用来存对应的 listener 监听器的</li>
<li>然后，继承文件变动监听适配器 FileAlterationListenerAdaptor 自定义一个文件变动后对应的操作，里面重写对应的文件发生变动的方法，比如要把对应事件存到数据库</li>
<li>给创建的Observer注册对应的监听器，<code>observer.addListener(new FileListener());</code></li>
<li>最后，就拿着这个Observer去创建一个线程实现监控</li>
</ol>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同表示</strong></p>
<p>使用场景： </p>
<ol>
<li>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式</li>
<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式</li>
<li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.interview;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String sex=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=builder.name;</span><br><span class="line">        <span class="keyword">this</span>.num=builder.num;</span><br><span class="line">        <span class="keyword">this</span>.sex=builder.sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num=-<span class="number">1</span>;</span><br><span class="line">        String sex=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sex = sex;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Student <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, num=&quot;</span> + num +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student zs = <span class="keyword">new</span> Student.Builder().setName(<span class="string">&quot;张三&quot;</span>).setNum(<span class="number">123</span>).setSex(<span class="string">&quot;男&quot;</span>).build();</span><br><span class="line">        System.out.println(zs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><ul>
<li><p>进程</p>
<p>进程是一个在内存运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。比如在windows系统中，一个运行的xx.exe程序就是一个进程</p>
</li>
<li><p>线程</p>
<p>线程是进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据</p>
</li>
</ul>
<h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p><strong>线程间通信</strong>无非就是要<strong>实现对共享资源的控制</strong></p>
<ol>
<li><strong>同步</strong>：采用synchronized关键字、对共享数据加锁等方式实现线程间的同步</li>
<li><strong>wait-notify等待唤醒机制</strong>：对共享数据进行同步，采用wait-notify来让某个线程等待，唤醒某个线程</li>
<li><strong>CAS</strong>：CASwhile循环，尝试操作共享数据</li>
</ol>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><p><strong>常见的进程通信方式：</strong></p>
<ol>
<li><strong>普通管道pipe</strong>：管道是一种<strong>半双工</strong>的通信方式，<strong>数据只能单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指<strong>父子进程关系</strong></li>
<li><strong>命名管道FIFO</strong>：去除了第二种限制,可以在许多并不相关的进程之间进行通讯</li>
<li><strong>信号量</strong>：它是一个<strong>计数器</strong>，<strong>记录资源能被多少个进程同时访问</strong>。用于控制多进程对临界资源的访问（同步)，并且是非负值。主要作为<strong>进程间</strong>以及<strong>同一进程的不同线程间</strong>的<strong>同步</strong>手段。比如<strong>操作系统中的P，V操作</strong>。临界资源：同一时刻，只能被一个进程访问的资源；临界区：访问临界资源的代码区；原子操作：任何情况下不能被打断的操作</li>
<li><strong>消息队列MessageQueue</strong>：消息队列是<strong>消息的链表</strong>，是存放<strong>在内核中</strong>并由<strong>消息队列标识符标识</strong>。因此是随内核持续的，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。消息队列<strong>克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区受限</strong>等特点。允许不同进程将格式化的数据流以消息队列形式发送给任意进程，对消息队列具有操作权限的进程都可以使用msgget完成对消息队列的操作控制，通过使用消息类型，进程可以按顺序读信息，或为消息安排优先级顺序</li>
<li><strong>共享存储SharedMemory</strong>：<strong>共享内存</strong>就是映射一段<strong>能被其他进程所访问的内存</strong>，这段<strong>共享内存由一个进程创建，但多个进程都可以访问</strong>。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
</ol>
<h3 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h3><ol>
<li><strong>根本区别</strong>：<strong>进程</strong>是操作系统<strong>资源分配</strong>的<strong>基本单位</strong>，<strong>线程</strong>是<strong>处理器任务调度和执行的基本单位</strong></li>
<li><strong>资源开销</strong>：每个<strong>进程</strong>都有<strong>独立的代码和数据空间</strong>（程序上下文），<strong>程序之间的切换会有较大的开销</strong>；<strong>线程</strong>可以看做轻量级的进程，同一类线程共享代码和数据空间，<strong>每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</strong></li>
<li>包含关系：一个进程可以包含多个线程，多个线程共同完成进程的任务。一个线程只属于一个进程</li>
<li>内存分配：同一个进程内的线程的资源是共享的，而进程之间的地址空间和资源是相互独立的</li>
<li>执行过程：每个<strong>独立的进程都有程序运行的入口</strong>、顺序执行序列和程序出口。但是<strong>线程不能独立执行</strong>，必须依赖于应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li>
</ol>
<h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3><p>当前线程任务获取到CPU时间片，当分配的CPU时间片用完或者说线程阻塞后，线程会保存当前状态以便下次再次切回这个任务时，能再次加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<h3 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h3><ul>
<li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li>
<li>守护(Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。<strong>一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</strong></li>
</ul>
<p><strong>注意事项：</strong> </p>
<ol>
<li>setDaemon(true)必须在start()方法前执行，否则会抛出 IllegalThreadStateException 异常 </li>
<li>在守护线程中产生的新线程也是守护线程</li>
<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li>
<li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。<strong>finally语句块中的语句也不一定被执行</strong></li>
</ol>
<h3 id="windows和linux查看进程和线程"><a href="#windows和linux查看进程和线程" class="headerlink" title="windows和linux查看进程和线程"></a>windows和linux查看进程和线程</h3><ol>
<li>windows<ul>
<li>任务管理器查看进程和线程，杀死进程</li>
<li><code>tasklist</code> 查看进程</li>
<li><code>taskkill /F /PID 进程号</code> 杀死进程</li>
</ul>
</li>
<li>linux<ul>
<li><code>ps -fe </code>查看所有进程</li>
<li><code>ps -ft -p &lt;PID&gt;</code> 查看某个进程的所有线程</li>
<li><code>kill</code> 杀死进程</li>
<li><code>pkill -9 &lt;PID&gt;</code> 杀死进程，-9代表一类操作，杀死进程</li>
<li><code>top</code> 查看进程信息</li>
<li><code>top -H -P &lt;PID&gt;</code> 查看某个进程PID的所有线程</li>
</ul>
</li>
<li>Java<ul>
<li><code>jps</code> 查看所有Java进程</li>
<li><code>jstack &lt;PID&gt;</code> 查看某个Java进程的所有线程状态</li>
<li><code>jconsole</code> 连接查看某个Java进程中线程的运行情况（Windows直接win+r 输入jconsole，图形界面）</li>
</ul>
</li>
</ol>
<h3 id="形成死锁的4个必要条件"><a href="#形成死锁的4个必要条件" class="headerlink" title="形成死锁的4个必要条件"></a>形成死锁的4个必要条件</h3><ol>
<li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能 被一个线程(进程)占用，直到被该线程(进程)释放</li>
<li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源</li>
<li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路 （类似于死循环），造成永久阻塞</li>
</ol>
<h3 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a><strong>线程池相关</strong></h3><h4 id="创建线程的4种方式"><a href="#创建线程的4种方式" class="headerlink" title="创建线程的4种方式"></a>创建线程的<strong>4种方式</strong></h4><ol>
<li><p>通过继承Thread创建线程</p>
<p>使用继承的好处就是在线程run()直接用this就可以代表当前线程了，也不用Thread.currentThread()方法</p>
<p>不好的地方就在于有很大的局限性，Java中不支持多继承，所以说继承了Thread就不能继承其他的类了。另外任务和代码没有分离，相当于多个线程执行一样的任务时需要多份任务代码</p>
</li>
<li><p>使用Runnable接口创建Thread</p>
<p>可以实现Runnable接口，重写里面的run方法，来编写任务代码。</p>
<p>使用Runnable创建的时候，相当于一个任务被分配给多个线程去执行了，多个线程获取到的是相同的资源。继承Thread创建线程相当于多个线程多个任务，每个线程都接收到相同的任务</p>
<p><strong>分析 Thread 的源码，查看与 Runnable 的关系</strong>，可以发现采用Runnable的方式最终new Thread的时候最终就是把实现Runnable作为Thread中的target成员，然后判断如果target不为null，就运行target的run()方法，也就是Runnable的run方法</p>
<ul>
<li>继承Thread方式: 是把线程和任务合并在了一起</li>
<li>实现Runnable方式: 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
</li>
<li><p>使用FutureTask与Thread结合</p>
<p>使用<strong>FutureTask可以用泛型指定线程的返回值类型</strong>（Runnable的run方法没有返回值），FutureTask实现了RunnableFuture，RunnableFuture继承了Runnable接口。</p>
<p>task.get()可以获得线程执行完毕后的返回值，如果还没执行完毕get()方法会阻塞起来等待线程执行完才返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">		FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		Thread r1 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		r1.start();</span><br><span class="line">		<span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">		System.out.println(task.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线程池创建线程</p>
<p>好处：</p>
<ol>
<li><p>提高响应速度（减少了创建新线程的时间）</p>
</li>
<li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
</li>
<li><p>便于线程管理</p>
</li>
</ol>
<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？四种！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line">		<span class="comment">//System.out.println(service.getClass());</span></span><br><span class="line">		<span class="comment">//service1.setCorePoolSize(15);</span></span><br><span class="line">		<span class="comment">//service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>ThreadPoolExecutor使用int的高3位来表现线程池的状态，低29位来表示线程数量</p>
<p><strong>RUNNING</strong>    111    接收新任务，同时处理任务队列中的任务</p>
<p><strong>SHUTDOWN</strong>    000    <strong>不接收</strong>新任务，但是<strong>处理</strong>任务队列中的任务</p>
<p><strong>STOP</strong>    001    <strong>中断正在执行的任务</strong>，同时<strong>抛弃</strong>阻塞队列中的任务</p>
<p><strong>TIDYING</strong>    010    任务执行完毕，<strong>活动线程为0</strong>，<strong>即将进入终结</strong>阶段</p>
<p><strong>TERMINATED</strong>    011    线程池进入<strong>终结</strong>阶段</p>
<h4 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h4><ol>
<li>提交任务给线程池</li>
<li>判断核心线程corePoolSize有没有用完</li>
<li>核心线程没用完，创建一个新的核心线程完成任务</li>
<li>核心线程使用完了，判断阻塞队列是否已满</li>
<li>阻塞队列不满，放入阻塞队列中，等待空闲线程执行</li>
<li>阻塞队列满了，判断最大线程数和核心线程数，也即是看有不有救急线程可用</li>
<li>有救急线程可用，救急线程执行任务</li>
<li>无救急线程可用，采用拒绝策略</li>
</ol>
<h4 id="如何实现线程复用"><a href="#如何实现线程复用" class="headerlink" title="如何实现线程复用"></a><strong>如何实现线程复用</strong></h4><p>实现线程复用，看源码主要是这样的：</p>
<p>有一个 <strong>worker</strong>，<strong>实现</strong>了 <strong>Runnable</strong>，所以这个 woker 就可以看做一个线程，它的 <strong>run()</strong> 方法，里面主要先<strong>循环</strong>去<strong>判断</strong>，当前要运行的<strong>初始任务是不是空</strong>（因为在创建 worker 的时候会同时传进一个 Runnable 任务 firstTask ），或者说 从<strong>阻塞队列中取出任务</strong> getTask() 方法如果<strong>不为null</strong>，就一直去<strong>执行任务</strong>。然而在 <strong>getTask()</strong> 方法中，里面一个<strong>死循环 for( ; ; )</strong> 主要去从阻塞队列 <strong>workQueue</strong> 中去 <strong>take</strong>（不带超时） 或者 <strong>poll</strong>（带超时）一个任务出来，会一直阻塞直到队列中有任务返回，然后return 到 runWoker() 方法的 while 循环里去执行，如果阻塞队列中为空，就进入。</p>
<p>因此，其实现 线程复用 的原理主要就是：while 循环一直去 阻塞队列中获取任务 getTask()，死循环<strong>直到</strong>阻塞队列中<strong>成功获取任务</strong> workQueue.take() ，成功获取就返回，到while 中去执行，进入下一次while 循环，又去 getTask()</p>
<h4 id="核心线程可以过期吗"><a href="#核心线程可以过期吗" class="headerlink" title="核心线程可以过期吗"></a><strong>核心线程</strong>可以过期吗</h4><p>可以过期，有一个allowCoreThreadTimeout()方法，会将救急线程的keepAliveTime设置为核心线程的过期时间</p>
<h4 id="有哪几种阻塞队列"><a href="#有哪几种阻塞队列" class="headerlink" title="有哪几种阻塞队列"></a>有哪几种阻塞队列</h4><ol>
<li><strong>LinkedBlockingQueue</strong><ul>
<li>这种阻塞队列基于链表实现的，构造的时候有一个dummy节点，用来占位，第一个入队就把节点放到dummy的next，然后出队，就把dummy节点换成本来该出队的节点，然后拿着要出队的节点的值返回，把下一个节点的item设为null，就成为新的dummy节点</li>
<li>它采用两把锁，一把putLock和一把takeLock，分别锁住头结点和尾节点，put和take这样锁住不同的对象，可以实现生产的时候同时消费</li>
<li>入队 先 加锁，加锁之后 判断队列满了没有，如果队列满了，就等待队列不满，调用notFull条件变量的 wait方法</li>
<li>队列不满的时候，就入队，入完队容量加1，然后再1看能不能再put一个，能就notFull条件的signal 唤醒，解锁</li>
</ul>
</li>
<li><strong>ArrayBlockingQueue</strong><ul>
<li>这种队列基于数组的实现，需要事先指定好队列的大小，因为数组需要指定大小，它采用的是一把锁，不能同时生产和消费</li>
<li><strong>性能比较</strong><ul>
<li>Linked支持有界，Array强制有界，毕竟是数组，创建需要有个大小限制</li>
<li>Linked是链表实现的，Array是数组</li>
<li>Linked是懒惰创建的，Array在初始化时就创建完所有的Node</li>
<li>Linked每次入队会生成一个新Node，而Array的Node是提前创建好的</li>
<li>Linked使用两把锁，一个锁住头，一个锁住尾，Array只使用了一把锁</li>
</ul>
</li>
</ul>
</li>
<li><strong>SynchronousQueue</strong><ul>
<li>这个阻塞队列是一种特殊的队列，没有容量，没有线程取的话是放不进去的，就类似于一手交钱一手交货</li>
</ul>
</li>
<li>DelayedWorkQueue</li>
<li><strong>ConcurrentLinkedQueue</strong><ul>
<li>和LinkedBlockingQueue非常相似</li>
<li>采用两把锁，同一时刻，可以允许两个线程同时（一个生产者一个消费者）执行</li>
<li>dummy节点的引入让两把锁锁住的不是同一个对象，避免竞争</li>
<li>只是ConcurrentLinkedQueue采用CAS来实现锁</li>
</ul>
</li>
</ol>
<h4 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h4><ol>
<li><strong>核心线程数</strong></li>
<li><strong>最大线程数</strong></li>
<li>救急线程的<strong>存活时间</strong></li>
<li>时间<strong>单位</strong></li>
<li><strong>阻塞队列</strong></li>
<li><strong>线程工厂</strong></li>
<li><strong>拒绝策略</strong><ul>
<li>Abort 直接抛弃，同时抛出异常</li>
<li>Discard 直接抛弃，不抛出异常</li>
<li>DiscardOldest 抛弃，最老的任务，即队列头</li>
<li>CallersRuns 调用者去处理</li>
</ul>
</li>
</ol>
<h4 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂 ThreadFactory"></a>线程工厂 ThreadFactory</h4><p>线程工厂就是用来创建线程的，像 <strong>SimpleThreadFactory</strong> 就是一个简单的new Thread，在 线程池中 如果没有指定线程工厂使用的是默认的 DefaultThreadFactory，里面创建非守护线程，控制了一下优先级设置，统计了线程个数等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="线程池刚初始化有线程吗，可以指定初始化有线程吗"><a href="#线程池刚初始化有线程吗，可以指定初始化有线程吗" class="headerlink" title="线程池刚初始化有线程吗，可以指定初始化有线程吗"></a>线程池刚初始化有线程吗，可以指定初始化有线程吗</h4><h3 id="线程相关（run、start、Callable、Future）"><a href="#线程相关（run、start、Callable、Future）" class="headerlink" title="线程相关（run、start、Callable、Future）"></a>线程相关（run、start、Callable、Future）</h3><h4 id="调用sleep-0-方法有什么作用"><a href="#调用sleep-0-方法有什么作用" class="headerlink" title="调用sleep(0)方法有什么作用"></a>调用sleep(0)方法有什么作用</h4><p>sleep(0)，睡眠0s可以触发一次CPU的竞争，sleep让当前线程放弃CPU使用权，睡眠一定时间，这样可以在服务压力大的时候，某个线程一直占用某个资源，占用时间过长了，可以一定程度上避免饥饿现象</p>
<h4 id="线程的run-和start-有什么区别"><a href="#线程的run-和start-有什么区别" class="headerlink" title="线程的run()和start()有什么区别"></a>线程的run()和start()有什么区别</h4><p>每个线程最终都是要调用其中的run()放来执行任务的。调用Thread类的start()方法来启动一个线程，调用了start()方法后，线程进入就绪状态，此刻还没有执行，等待CPU分配时间片然后继续执行。如果直接调用run()方法不调用start方法，这跟调用普通方法差不多，并没有开启多线程的运行，而只是普普通通的执行了一个run()方法而已</p>
<p>start()方法只能调用一次，源码会判断线程状态是否是0即新建状态，不是则抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br></pre></td></tr></table></figure>

<h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>new一个Thread，进入新建状态。调用start会启动一个线程进入就绪状态，等待分配时间片，分配到时间片后就可以开始运行了。start()之后会执行到run()方法完成任务。如果直接调用run()方法跟调用一个普通方法没啥区别，就是一个普通方法执行了而已，并没有开启多线程</p>
<h4 id="什么是-Callable-和-Future"><a href="#什么是-Callable-和-Future" class="headerlink" title="什么是 Callable 和 Future?"></a>什么是 Callable 和 Future?</h4><p>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 <strong>Runnable</strong> <strong>不会返回结果</strong>，并且<strong>无法抛出返回结果的异常</strong>，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值</p>
<p>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 <strong>Callable用于产生结果，Future 用于获取结果。</strong></p>
<h4 id="什么是-FutureTask"><a href="#什么是-FutureTask" class="headerlink" title="什么是 FutureTask"></a>什么是 FutureTask</h4><p>FutureTask 表示一个异步运算的任务。<strong>FutureTask 里面可以传入一个 Callable 的具体实现类</strong>，可以对这个异步运算的任务的结果进行<strong>等待获取</strong>、<strong>判断是否已经完成</strong>、<strong>取消任务</strong>等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所 以 FutureTask 也可以放入线程池中</p>
<h4 id="什么叫线程安全？servlet-是线程安全吗"><a href="#什么叫线程安全？servlet-是线程安全吗" class="headerlink" title="什么叫线程安全？servlet 是线程安全吗?"></a>什么叫线程安全？servlet 是线程安全吗?</h4><p>指某个方法在多线程环境中被调用时，能够正确地处 理多个线程之间的共享变量，使程序功能正确完成。 Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一 个方法，是不能保证共享变量的线程安全性的。</p>
<p>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</p>
<h4 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h4><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程 会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低 优先级，10 代表最高优先级。 Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p>
<h4 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h4><p>总的来说就是哪里new的，就是哪里调用的</p>
<p>假设 Thread2 中 new 了 Thread1，main 函数中 new 了 Thread2，那么： </p>
<p>（1）Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方 法是Thread2 自己调用的 （2）Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法 是Thread1 自己调用的</p>
<h4 id="Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取-线程堆栈？"><a href="#Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取-线程堆栈？" class="headerlink" title="Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取 线程堆栈？"></a>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取 线程堆栈？</h4><p>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump 文件中。</p>
<p> 在 <strong>Linux</strong> 下，你可以通过命令 <strong>kill -3 PID</strong> （Java 进程的进程 ID）来获取 Java应用的 dump 文件。 </p>
<p>在 Windows 下，你可以按下 <strong>Ctrl + Break</strong> 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件 中，具体位置依赖应用的配置。</p>
<h4 id="一个线程运行时发生异常会怎样"><a href="#一个线程运行时发生异常会怎样" class="headerlink" title="一个线程运行时发生异常会怎样"></a>一个线程运行时发生异常会怎样</h4><p>如果异常<strong>没有被捕获该线程将会停止执行</strong></p>
<p> Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理</p>
<h4 id="Java-线程数过多会造成什么异常？"><a href="#Java-线程数过多会造成什么异常？" class="headerlink" title="Java 线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h4><ul>
<li>线程的生命周期开销非常高 </li>
<li>消耗过多的 CPU</li>
<li>降低稳定性JVM</li>
</ul>
<h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><p><strong>synchronized底层原理</strong>其实就是 每个<strong>Java对象</strong>，都有一个<strong>对象头</strong>，对象头包含mark word和Klass word，<strong>每个对象</strong>都可以<strong>关联一个Monitor</strong>，当进入synchronized同步代码块的时候，该锁对象就把它的<strong>markword值设置为</strong>关联的对应<strong>monitor的地址值</strong>，然后把monitor的<strong>owner线程</strong>设为当前线程。后面有别的线程进入synchronized，会发现obj已经有一个关联的monitor，其owner线程为之前的线程，他就会进入monitor对象的EntryList中等待</p>
<p>它加锁依赖于底层操作系统的指令，会造成用户态和内核态之间的切换，比较耗性能</p>
<p>在JDK 6的时候采用了偏向锁和轻量级锁进行优化</p>
<p><strong>轻量级锁用于优化重量级锁</strong>，轻量级锁<strong>主要用于</strong>有一个线程要加锁，别的线程也需要，但是他们的加锁时间是错开的，就是说<strong>没有竞争的情况</strong>，会在线程栈帧中创建一个<strong>lock record 锁记录</strong>，然后把锁对象的<strong>markword</strong> 和 <strong>锁记录地址</strong>进行一个<strong>CAS交换</strong>，交换成功就是加锁成功，这样markword存的是锁记录的地址，锁记录地址就是对象的markword。如果后面又有线程来<strong>CAS加锁</strong>，那么就是可能出现<strong>锁膨胀</strong>或者<strong>锁重入</strong>的情况，锁膨胀就是说发生了竞争，这个时候就要升级为重量级锁了</p>
<p><strong>偏向锁</strong>主要用于<strong>优化轻量级锁</strong>，主要场景是：没有竞争的时候，一个线程多次进入<strong>synchronized需要重入加锁</strong>的时候，<strong>将进入临界区的线程的ID, 直接设置给锁对象的Mark word,</strong> 下次该线程<strong>又获取锁</strong>, 发现<strong>线程ID是自己</strong>, 就<strong>不需要CAS</strong>了</p>
<p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220416220641010.png" alt="image-20220416220641010"></p>
<p>synchronized最开始其实是重量级锁，在JDK6以后引入了轻量级锁和偏向锁的概念，它们只是jvm上的逻辑，避免了重量级锁频繁且不必须的在用户态和内核态之间的切换。</p>
<p>首先线程执行到synchronized同步代码块，会在栈帧中创建一个锁记录Lock Record，锁记录主要有两部分，一部分存放锁记录地址+00两位标识，还有一部分存储锁对象的地址。尝试加锁，首先会去将锁记录和锁对象的Mark Word进行CAS交换，第一次因为没人加锁，所以交换成功，然后锁记录里就存放着锁对象的markword和锁对象的地址。而锁对象的markword现在存放的是锁记录的地址。</p>
<p>如果后续当前加锁的线程还没释放锁，又准备进行一次加锁，即发生锁重入，线程首先也会创建锁记录，然后尝试一次CAS，这次加锁失败了，因为发现锁对象markword中记录的指向就是自己线程中的锁记录，所以就会把新建的锁记录地址设置为null，然后object reference指向锁对象。退出同步代码块的时候，发现锁记录的锁记录地址是null，说明有锁重入，计数器减去1，到最后发现不为null，就CAS交换回锁对象的markword。</p>
<p>锁膨胀：在Thread0线程还没释放锁的时候，如果又有一个线程Thread1执行到同步代码块，准备加锁，发现锁对象的markword已经是00了，说明已经是轻量级锁了，这个时候会进入锁膨胀的过程，生成一个monitor对象，将锁对象关联到monitor对象，然后将锁对象的markword重新指向monitor的地址，然后把monitor的Owner设置为Thread0，当前加锁失败的线程就进入Monitor的EntryList等待</p>
<p>Thread0线程执行完后，发现锁对象的markword已经是01了，已经是重量级锁，说明发生了锁膨胀，这样就进入重量级锁的解锁流程，根据锁对象的markword找到对应的monitor，然后设置Owner线程为null，唤醒EntryList中的Thread1</p>
<h3 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park Unpark"></a>Park Unpark</h3><p>park和unpark原理：每个线程都有一个parker对象，这个对象主要有3个值_counter、 _mutex、 _cond</p>
<p>park的时候先检查_counter的值是否为0，如果为0，就进入 _cond等待队列阻塞，如果为1，就继续运行，设置 _counter为0</p>
<p>unpark直接设置_counter值为1，唤醒 _cond中的线程，线程恢复运行设置counter为0</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile <strong>原子性、可见性、有序性的概念</strong> —–&gt; <strong>读写屏障</strong>保证可见性、有序性<strong>原理</strong> —–&gt;<strong>CAS 保证原子性</strong>，<strong>volatile保证 可见性、有序性</strong> <strong>乐观锁实现无锁并发</strong> ——&gt; CAS的<strong>底层lock指令</strong> —–&gt; API 层面的<strong>compareAndSwap方法</strong> —–&gt; <strong>缺点一直重试</strong>，竞争激烈效率反而降低，并且会有<strong>ABA问题</strong> —–&gt; <strong>优点</strong> 没有synchronized<strong>悲观的思想</strong>，<strong>没有线程上下文的切换</strong></p>
<p>volatile 关键字主要用于来保证多线程共享数据的安全性问题，主要保证其有序性和可见性。三个特性：原子性指程序代码的执行不会受到线程上下文切换的影响，这个主要采用加锁来保证。可见性指程序代码的执行不会受到缓存的影响，JIT即时编译器对于程序代码的优化，保证去主存中读取数据，更新数据到主存中。有序性指程序代码的执行不会受到CPU优化的影响，比如指令重排。因为CPU的指令是类似一条流水线，一个周期，多个指令。</p>
<p>volatile通过内存屏障来保证有序性和可见性。</p>
<p>保证可见性：就是在读数据的加一个读屏障，保证读取共享的数据的时候都去主存中读取，然后再加一个写屏障，保证更新数据都把数据更新到主存中</p>
<p>保证有序性：也是通过读写屏障，读屏障保证读屏障之后的代码不会重排到前面。写屏障保证写屏障之前的代码不会重排到写屏障后面。</p>
<p>结合CAS+volatile关键字就可以实现无锁并发。volatile保证有序性、可见性。CAS保证原子性</p>
<p>CAS底层采用一个lock指令，在多线程下能保证 比较-交换 操作的原子性。它会把CPU总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程不会被多线程调度机制所打断</p>
<p>在Java API层面就对应一个CompareAndSwap()方法，它需要一个期望的值，以及要修改的值，先拿着期望的值去主存中的值作比较，如果相等就去修改值，要是不相等，就代表CAS失败，这个时候就加一个while循环，让其一直尝试CAS去比较并交换。</p>
<p>可以发现它没有阻塞，而是一直去尝试更新值，更新不成功就再CAS一次。这种也会带来一定的开销，因为在竞争激烈的时候它可能一直CAS失败，效率反而会降低。不过它避免了synchronized的悲观锁的思想，避免了线程上下文的切换造成的开销。</p>
<p>此外CAS 还有可能造成ABA问题</p>
<h3 id="原子包装类"><a href="#原子包装类" class="headerlink" title="原子包装类"></a>原子包装类</h3><p><strong>java.util.concurrent.atomic</strong>提供的是一些原子类，都是基于CAS + volatile 来实现的</p>
<p><strong>原子整数类：</strong></p>
<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean ：布尔型原子类</li>
</ul>
<p><strong>原子引用类：</strong>原子引用保证引用类型的共享变量是线程安全的，刚才的是规定了数据类型比如为Integer</p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicMarkableReference</code>：原子更新带有<strong>标记</strong>的引用类型。该类并不关心中途修改了多少次，只关心有没有修改过，所以只需要用一个 boolean 标记与引用关联起来，可以解决ABA 问题</li>
<li><code>AtomicStampedReference</code> ：原子更新带有<strong>版本号</strong>的引用类型。用版本号一般是整型来标识是否被修改过，用来解决 ABA 问题</li>
</ul>
<p><strong>原子数组类：</strong>原子数组用来保证数组内的元素的线程安全，使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
<h3 id="AQS、ReentrantLock-条件变量-使用、ReentrantLock-原理"><a href="#AQS、ReentrantLock-条件变量-使用、ReentrantLock-原理" class="headerlink" title="AQS、ReentrantLock 条件变量 使用、ReentrantLock 原理"></a>AQS、ReentrantLock 条件变量 使用、ReentrantLock 原理</h3><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p><strong>AQS</strong>是<strong>抽象的队列同步器</strong>，是<strong>JDK1.5</strong>提供的一套<strong>实现阻塞锁</strong>的并且<strong>依赖于FIFO队列 CLH 队列 的同步器</strong>，<strong>AQS定义</strong>了一套<strong>多线程访问共享资源的方法</strong>，<strong>提供</strong>了一个<strong>等待队列</strong>，<strong>类似于</strong>Monitor中的<strong>EntryList</strong>。里面<strong>可以</strong>去<strong>获得锁</strong>，<strong>加锁</strong>，<strong>释放锁</strong>等一些<strong>操作</strong>，但是有的方法比如 <code>tryAcquire()</code> 是由其子类去实现的。AQS 主要还是起到一个模板的作用。像 通常都 创建一个 Sync 然后 继承 AQS，同时里面去实现一些自己的方法，然后 Sync 又对应 NonfairSync 和 FairSync，里面去实现其 自己的 tryAcquire() 方法。使用了 <strong>模板方法设计模式</strong></p>
<p>它<strong>用state属性</strong>来<strong>表示资源的状态</strong>，子类需要定义如何<strong>维护这个状态</strong>，<strong>控制</strong>如何<strong>获取锁和释放锁</strong>，比如<strong>state为0</strong>就是<strong>没有线程持有锁</strong>，<strong>把state改为1就是有线程持有锁</strong>，采用<strong>CAS来更新state</strong>的值</p>
<p><strong>AQS锁</strong>分为<strong>独占锁</strong>和<strong>共享锁</strong>，<strong>独占锁</strong>的实现主要有<strong>ReentrantLock</strong>，<strong>共享锁</strong>的实现主要有<strong>CountDownLatch</strong>、<strong>ReentrantReadWriteLock中的读锁</strong>。</p>
<h3 id="ReentrantLock-加锁"><a href="#ReentrantLock-加锁" class="headerlink" title="ReentrantLock 加锁"></a>ReentrantLock 加锁</h3><p>ReentrantLock 默认是非公平锁实现，构造方法就是构造一个非公平同步器，加锁就调用同步器的lock()方法。lock()方法先用CAS尝试将state的值改为1，如果修改成功，就设置独占锁线程为当前线程。假设第一个竞争出现，已经有Thread0加锁成功，那么当前线程Thread1cas失败，就<strong>加锁失败</strong>。进入acquire()方法，会<strong>再次尝试去获取一次锁，调用tryAquire()方法</strong>，如果仍然获取失败，就尝试加入到等待队列里去，加入返回true就调用selfInterrupt把该线程打断。</p>
<p>尝试加入等待队列中调用acquireQueued方法，等待队列是一个Node双向链表队列，首先会判断没获得锁的情况下，是否下一个就是自己，如果是就<strong>再一次尝试获取锁，调用tryAcquire()尝试加锁</strong>，这次成功了就把自己设置为Head节点。这次加锁失败，那么就应该<strong>在加锁失败后park住shouldParkAfterFailedAcquire</strong>这个方法会将前驱节点即head的waitStatus值改为-1，-1表示前面线程有责任唤醒后面的线程。最后返回false，结束判断后又进入for循环去尝试获取一次锁，假设又失败，那么又进入shouldParkAfterFailedAcquire方法，因为前面已经修改waitStatus值为-1，这次肯定设置失败，返回true，返回true后就进入parkAndCheckInterrupt把当前线程park住</p>
<h3 id="ReentrantLock-释放锁"><a href="#ReentrantLock-释放锁" class="headerlink" title="ReentrantLock 释放锁"></a>ReentrantLock 释放锁</h3><p>ReentrantLock 释放锁 release 方法，首先进入 tryRelease 方法，把 state 的值减去1，如果 state 的值为0，则将独占锁的Owner线程设置为null。如果全部释放了，就去 unparkSuccessor 唤醒队列中等待线程</p>
<h3 id="ReentrantLock-可打断与不可打断"><a href="#ReentrantLock-可打断与不可打断" class="headerlink" title="ReentrantLock 可打断与不可打断"></a>ReentrantLock 可打断与不可打断</h3><p>synchronized 的打断指的是获取到了锁以后，可以进行打断，打断正在运行的线程或者说打断在sleep，wait，join的线程</p>
<p>ReentrantLock 的打断指的是没获得到锁，被park阻塞住以后，可以打断它的阻塞</p>
<ol>
<li><strong>不可打断</strong><ul>
<li>ReentrantLock的可打断指的是在线程没获取到锁，去阻塞队列里等待的时候，是可以打断阻塞的</li>
<li>其实现原理：在线程正常尝试获取锁，获取失败后，进入parkAndCheckInterrupt方法park住的时候，方法的返回值是<code>return Thread.interrupted();</code>。这个方法会返回线程的打断标记，并且清除打断标记，也就是说线程在park被打断后，会返回true，然后打断标记重新置为false；从这个方法里面出来后，就把方法里的局部变量interrupted设置为true，然后下一次循环，获取到锁，回到acquire()方法，再进行一次自我打断selfInterrupt()，重新打断一次，如果是正常运行状态不是sleep中就不会抛打断异常</li>
</ul>
</li>
<li><strong>可打断</strong><ul>
<li>可打断是因为在park住后被唤醒了，返回线程是不是被打断，同时清除打断标记，如果要是被打断过了，返回为true，那就进入if代码块内部，抛出异常，否则返回false，直接进入下一次循环</li>
</ul>
</li>
</ol>
<h3 id="ReentrantLock-可重入"><a href="#ReentrantLock-可重入" class="headerlink" title="ReentrantLock 可重入"></a>ReentrantLock 可重入</h3><p>ReentrantLock 可重入主要基于它的 state 值，它tryAcquire方法会去判断要加锁的线程是不是当前线程，如果是，就把state的值+1，释放锁的时候，会一直把state的值减到0</p>
<h3 id="ReentrantLock-公平与非公平锁"><a href="#ReentrantLock-公平与非公平锁" class="headerlink" title="ReentrantLock 公平与非公平锁"></a>ReentrantLock 公平与非公平锁</h3><p>ReentrantLock 下面有不同的同步器实现，FairSycn或者nonFairSycn，</p>
<p>公平锁与非公平锁的实现区别主要在tryAcquire方法里，在使用CAS state的值之前，会先去判断队列里面是否还有前驱节点，也就是说还有不有线程关联的节点在排队，如果有，直接就返回false了。否则才去尝试 CAS</p>
<h3 id="ReentrantLock-条件变量"><a href="#ReentrantLock-条件变量" class="headerlink" title="ReentrantLock 条件变量"></a>ReentrantLock 条件变量</h3><p>AQS 中有个ConditionObject是实现了Condition的公共内部类，每个条件变量对对应着一个ConditionObject，每个ConditionObject 维护了一个等待队列</p>
<p><strong>await</strong>：</p>
<ul>
<li>线程持有锁的情况下，在调用条件变量的 await 方法时，首先将当前线程关联一个在ConditionObject中的一个节点，加入等待队列的尾部，然后 fullyRelease 释放所有的锁，最后再唤醒 AQS 队列中的下一个节点</li>
</ul>
<p><strong>signal</strong>：</p>
<ul>
<li>先判断是否持有独占锁，只有持有锁，才能去唤醒条件变量中的线程；然后每次取条件变量队列中的第一个 node ，然后就把这个节点断开，把这个节点加入到 ReentrantLock 的等待队列中去，把上一个节点的 waitStatus 值设置为-1</li>
</ul>
<h3 id="多线程顺序打印"><a href="#多线程顺序打印" class="headerlink" title="多线程顺序打印"></a>多线程顺序打印</h3><h3 id="多线程交替输出"><a href="#多线程交替输出" class="headerlink" title="多线程交替输出"></a>多线程交替输出</h3><h3 id="Semaphore、CountDownLatch、CycleBarrier"><a href="#Semaphore、CountDownLatch、CycleBarrier" class="headerlink" title="Semaphore、CountDownLatch、CycleBarrier"></a>Semaphore、CountDownLatch、CycleBarrier</h3><p><strong>Semaphore</strong> 信号量，可以用来控制同一时间有多少个线程能够执行，构造方法传入允许的 permits 最大的限制数。首先获取共享锁，将state-1看state是否小于0，如果是小于，那么就放入队列中等待，如果不是小于0，就尝试CAS把state的值减去1，CAS成功就成功返回。释放了一个线程后归还一个信号量，那么下一个线程才能执行。</p>
<p><strong>CountDownLatch</strong> 倒计时锁，维护一个计数器，当计数器的值不为0时，调用 await 方法就可以进行阻塞，每次使用就 countDown 计数减1，当计数器为0，所有阻塞的线程从 await 中返回执行</p>
<p>利用这个特性我们可以用来合并多个线程最终的结果，或者以此来模拟并发请求调用等等，如下并发请求代码</p>
<h3 id="CopyOnWriteArrayList原理"><a href="#CopyOnWriteArrayList原理" class="headerlink" title="CopyOnWriteArrayList原理"></a>CopyOnWriteArrayList原理</h3><p>CopyOnWriteArrayList写时复制list，是一个<strong>线程安全的list</strong>，底层通过<strong>复制数组</strong>的方式来实现。当我们往<strong>容器添加元素</strong>时，不直接往容器中添加，而是先将当前容器进行复制，<strong>复制出一个新的容器</strong>，<strong>然后往新的容器添加元素</strong>，添加完元素之后，再将原容器引用指向新容器。</p>
<p><strong>比较适合 读多写少 的场景，因为本身这样不能保证数据的强一致性，可能读到旧数据；此外，如果频繁的写入的话，因为它会创建出一个新的数组，写多，创建的新的数组就多，很容易就触发GC</strong></p>
<p>这样做的好处就是可以对CopyOnWrite容器进行并发的读而不需要加锁，因为当前容器不会被修改。</p>
<p>缺点：</p>
<ul>
<li>写时复制的机制，进行写操作的时候，内存里会同时驻扎两个对象的内存，也就是会同时存在两个容器</li>
<li>CopyOnWriteArrayList不能保证数据的实时一致性，可能读到旧数据</li>
</ul>
<h3 id="什么是ConcurrentHashMap？"><a href="#什么是ConcurrentHashMap？" class="headerlink" title="什么是ConcurrentHashMap？"></a>什么是ConcurrentHashMap？</h3><p>ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现。涉及高并发如果要用map结构，那第一时间想到的就是它。相对于hashmap来说，ConcurrentHashMap就是线程安全的map，其中利用了锁分段的思想提高了并发度。</p>
<p>JDK 1.6版本关键要素：</p>
<ul>
<li>segment继承了ReentrantLock充当锁的角色，为每一个segment提 供了线程安全的保障； </li>
<li>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。 </li>
</ul>
<p>JDK1.8后，ConcurrentHashMap抛弃了原有的Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p>
<h3 id="SynchronizedMap和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap和 ConcurrentHashMap 有什么区别？</h3><p>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访问map。</p>
<p>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。 ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。</p>
<p>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中， 当iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时 new 新的数据从 而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><strong>作用</strong></p>
<ul>
<li>ThreadLocal 可以实现【<strong>资源对象</strong>】的<strong>线程隔离</strong>，让<strong>每个线程各用各的</strong>【<strong>资源对象</strong>】，<strong>避免争用</strong>引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
</ul>
<p><strong>原理</strong></p>
<p>每个<strong>线程内</strong>有一个 <strong>ThreadLocalMap</strong> 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2/3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ins1mnia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://ins1mn1a.github.io/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/">http://ins1mn1a.github.io/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ins1mn1a.github.io" target="_blank">ins1mn1a</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="/img/background_img/1/8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/05/17/JUC/ThreadLocal/"><img class="next-cover" src="/img/background_img/1/5.jpg" onerror="onerror=null;src='/img/background_img/error_page.jpeg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ThreadLocal</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tvax1.sinaimg.cn/crop.0.0.996.996.180/007RWaeLly8gr7p82e9e6j30ro0rognd.jpg?KID=imgbed,tva&amp;Expires=1639625304&amp;ssig=yn%2FY%2BCtxLO" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="avatar"/></div><div class="author-info__name">ins1mnia</div><div class="author-info__description">because it feels like ins1mnia</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ins1mnia"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ins1mnia" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ins1mnia@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">穿梭时间的画面的钟,从反方向开始移动</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">为什么要有包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-%E5%92%8C-Integer%E7%9A%84%E5%8C%BA%E5%88%AB-new-Integer-127-new-Integer-127-%E6%98%AFtrue%E8%BF%98%E6%98%AFfalse"><span class="toc-number">1.3.</span> <span class="toc-text">int 和 Integer的区别 new Integer(127) &#x3D;&#x3D; new Integer(127) 是true还是false</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">1.4.</span> <span class="toc-text">String为什么不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-round-11-5-%E5%92%8CMath-round-11-5"><span class="toc-number">1.5.</span> <span class="toc-text">Math.round(11.5)和Math.round(-11.5)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#float-f-3-4-%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="toc-number">1.6.</span> <span class="toc-text">float f&#x3D;3.4;是否正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#short-s1-1-s1-s1-1-%E6%9C%89%E9%94%99%E5%90%97-short-s1-1-s1-1-%E6%9C%89%E9%94%99%E5%90%97"><span class="toc-number">1.7.</span> <span class="toc-text">short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗? short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Eboolean%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.8.</span> <span class="toc-text">关于boolean的默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cloneable%EF%BC%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.9.</span> <span class="toc-text">Cloneable，深拷贝、浅拷贝、零拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.10.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally"><span class="toc-number">1.11.</span> <span class="toc-text">finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fianlize"><span class="toc-number">1.12.</span> <span class="toc-text">fianlize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public%E3%80%81protected%E3%80%81%E7%BC%BA%E7%9C%81%E3%80%81private%E8%8C%83%E5%9B%B4"><span class="toc-number">1.13.</span> <span class="toc-text">public、protected、缺省、private范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">throw和throws的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-gc"><span class="toc-number">1.15.</span> <span class="toc-text">System.gc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.16.</span> <span class="toc-text">static 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.17.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-server%E6%A8%A1%E5%BC%8F-%E5%92%8C-client%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.18.</span> <span class="toc-text">JVM server模式 和 client模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">简述垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A"><span class="toc-number">2.2.</span> <span class="toc-text">对象引用的类型强、软、弱、虚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGC%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81GC"><span class="toc-number">2.3.</span> <span class="toc-text">什么是GC，为什么要GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-number">2.4.</span> <span class="toc-text">怎么判断对象是否可以回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-ROOTS%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.</span> <span class="toc-text">哪些对象可以作为GC ROOTS对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%90%E7%94%A8%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">2.7.</span> <span class="toc-text">为什么要运用分代垃圾回收策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">2.8.</span> <span class="toc-text">分代回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">2.9.</span> <span class="toc-text">什么时候对象进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC%E3%80%81Mixed-GC%E3%80%81Full-GC"><span class="toc-number">2.10.</span> <span class="toc-text">Minor GC、Mixed GC、Full GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%BC%8F%E6%A0%87%E9%97%AE%E9%A2%98"><span class="toc-number">2.11.</span> <span class="toc-text">并发标记算法——三色标记与并发漏标问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.12.</span> <span class="toc-text">有哪些垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E5%92%8C-G1-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.13.</span> <span class="toc-text">CMS 和 G1 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.14.</span> <span class="toc-text">CMS垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">2.15.</span> <span class="toc-text">G1垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5-%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">2.15.1.</span> <span class="toc-text">G1 回收阶段 - 新生代回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%B7%B7%E5%90%88%E6%94%B6%E9%9B%86"><span class="toc-number">2.15.2.</span> <span class="toc-text">G1 回收阶段 - 并发标记与混合收集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.16.</span> <span class="toc-text">划分方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0"><span class="toc-number">2.17.</span> <span class="toc-text">JVM内存参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="toc-number">2.18.</span> <span class="toc-text">JVM调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96Java%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F%E5%A0%86%E4%BD%BF%E7%94%A8%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">怎么获取Java程序使用的内存？堆使用的百分比？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">2.20.</span> <span class="toc-text">JVM常用调试工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84fail-fast%E5%92%8Cfail-safe%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">集合的fail-fast和fail-safe机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-%E5%92%8C-ListIterator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">Iterator 和 ListIterator 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-%E6%89%A9%E5%AE%B9"><span class="toc-number">3.3.</span> <span class="toc-text">ArrayList 扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.</span> <span class="toc-text">ArrayList和LinkedList区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ArrayList-%E7%9A%84-elementData-%E5%8A%A0%E4%B8%8A-transient-%E4%BF%AE%E9%A5%B0%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">为什么 ArrayList 的 elementData 加上 transient 修饰？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D%EF%BC%9FHashSet%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">HashSet如何检查重复？HashSet如何保证数据是不可重复的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99%E4%BA%86equals%E8%BF%98%E8%A6%81%E9%87%8D%E5%86%99hashcode"><span class="toc-number">3.7.</span> <span class="toc-text">为什么重写了equals还要重写hashcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-number">3.8.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable"><span class="toc-number">3.9.</span> <span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">3.10.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E6%AF%8F%E6%AC%A1%E6%89%A9%E5%AE%B9%E4%B8%A4%E5%80%8D%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.10.1.</span> <span class="toc-text">HashMap 每次扩容两倍的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.10.2.</span> <span class="toc-text">基本数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.10.3.</span> <span class="toc-text">遍历方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%8C%96%E4%B8%8E%E9%80%80%E5%8C%96"><span class="toc-number">3.10.4.</span> <span class="toc-text">树化与退化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="toc-number">3.10.5.</span> <span class="toc-text">put与扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashmap-%E5%B9%B6%E5%8F%91%E6%AD%BB%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.10.6.</span> <span class="toc-text">Hashmap 并发死链的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F10000%EF%BC%8C%E6%8F%92%E5%85%A510000%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%89%A9%E5%AE%B9"><span class="toc-number">3.10.7.</span> <span class="toc-text">HashMap初始容量10000，插入10000条数据，会不会扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-1-8-%E5%92%8C-1-7%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="toc-number">3.10.8.</span> <span class="toc-text">HashMap 1.8 和 1.7区别，做了哪些优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-table%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.10.9.</span> <span class="toc-text">HashMap table的初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">3.11.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">3.11.1.</span> <span class="toc-text">红黑树的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%A7%84%E5%88%99"><span class="toc-number">3.11.2.</span> <span class="toc-text">红黑树规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">3.12.</span> <span class="toc-text">ConcurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">4.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">4.1.</span> <span class="toc-text">流的划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Files%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">Files的常用方法都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-NIO-AIO"><span class="toc-number">4.3.</span> <span class="toc-text">BIO,NIO,AIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-number">5.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98IO%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2"><span class="toc-number">5.1.</span> <span class="toc-text">磁盘IO为什么慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-%E4%B8%8E-%E5%BC%82%E6%AD%A5"><span class="toc-number">5.2.</span> <span class="toc-text">同步 与 异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E9%98%BB%E5%A1%9E-%E4%B8%8E-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">5.3.</span> <span class="toc-text">IO 阻塞 与 非阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO"><span class="toc-number">5.3.1.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO"><span class="toc-number">5.3.2.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO"><span class="toc-number">5.3.3.</span> <span class="toc-text">AIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.</span> <span class="toc-text">Java NIO 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF-IO%E5%A4%8D%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">多路 IO复用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#select"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#poll"><span class="toc-number">5.5.0.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#epoll"><span class="toc-number">5.5.0.3.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LT-ET"><span class="toc-number">5.5.0.4.</span> <span class="toc-text">LT&#x2F;ET</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">6.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.</span> <span class="toc-text">什么是反射机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">反射优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.</span> <span class="toc-text">反射的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">反射的三种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.</span> <span class="toc-text">注解的三种保留策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">7.2.</span> <span class="toc-text">注解的使用范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-number">8.</span> <span class="toc-text">常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%9B%B8%E5%85%B3"><span class="toc-number">8.1.</span> <span class="toc-text">String相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.1.</span> <span class="toc-text">字符型常量和字符串常量的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">8.1.2.</span> <span class="toc-text">什么是字符串常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">8.1.3.</span> <span class="toc-text">String的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%9C%9F%E7%9A%84%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%90%97"><span class="toc-number">8.1.4.</span> <span class="toc-text">String真的是不可变的吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.5.</span> <span class="toc-text">String s &#x3D; new String(“xyz”);创建了几个字符串对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC"><span class="toc-number">8.1.6.</span> <span class="toc-text">如何将字符串反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.7.</span> <span class="toc-text">String类的常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8HashMap%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%94%A8String%E5%81%9AKey%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="toc-number">8.2.</span> <span class="toc-text">在使用HashMap的时候，用String做Key有什么好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%92%8CStringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FString%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">8.3.</span> <span class="toc-text">String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">日期相关类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">10.</span> <span class="toc-text">自动装箱和拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">五种单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">11.1.1.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E4%B9%8B%E6%9E%9A%E4%B8%BE"><span class="toc-number">11.1.2.</span> <span class="toc-text">饿汉式之枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">11.1.3.</span> <span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DCL%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">11.1.4.</span> <span class="toc-text">DCL懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E4%B9%8B%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.1.5.</span> <span class="toc-text">懒汉式之静态内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.2.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.3.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.4.</span> <span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.5.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.6.</span> <span class="toc-text">建造者模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">12.1.</span> <span class="toc-text">线程和进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">12.2.</span> <span class="toc-text">线程间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">12.3.</span> <span class="toc-text">进程间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">12.4.</span> <span class="toc-text">线程和进程区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">12.5.</span> <span class="toc-text">什么是上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.6.</span> <span class="toc-text">守护线程和用户线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E5%92%8Clinux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.7.</span> <span class="toc-text">windows和linux查看进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E6%88%90%E6%AD%BB%E9%94%81%E7%9A%844%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">12.8.</span> <span class="toc-text">形成死锁的4个必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3"><span class="toc-number">12.9.</span> <span class="toc-text">线程池相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">12.9.1.</span> <span class="toc-text">创建线程的4种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">12.9.2.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">12.9.3.</span> <span class="toc-text">线程池的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8"><span class="toc-number">12.9.4.</span> <span class="toc-text">如何实现线程复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%BF%87%E6%9C%9F%E5%90%97"><span class="toc-number">12.9.5.</span> <span class="toc-text">核心线程可以过期吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">12.9.6.</span> <span class="toc-text">有哪几种阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">12.9.7.</span> <span class="toc-text">线程池的核心参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82-ThreadFactory"><span class="toc-number">12.9.8.</span> <span class="toc-text">线程工厂 ThreadFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="toc-number">12.9.9.</span> <span class="toc-text">线程池刚初始化有线程吗，可以指定初始化有线程吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%EF%BC%88run%E3%80%81start%E3%80%81Callable%E3%80%81Future%EF%BC%89"><span class="toc-number">12.10.</span> <span class="toc-text">线程相关（run、start、Callable、Future）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8sleep-0-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">12.10.1.</span> <span class="toc-text">调用sleep(0)方法有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84run-%E5%92%8Cstart-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.10.2.</span> <span class="toc-text">线程的run()和start()有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">12.10.3.</span> <span class="toc-text">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Callable-%E5%92%8C-Future"><span class="toc-number">12.10.4.</span> <span class="toc-text">什么是 Callable 和 Future?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-FutureTask"><span class="toc-number">12.10.5.</span> <span class="toc-text">什么是 FutureTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9Fservlet-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97"><span class="toc-number">12.10.6.</span> <span class="toc-text">什么叫线程安全？servlet 是线程安全吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E7%90%86%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.10.7.</span> <span class="toc-text">你对线程优先级的理解是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E5%9D%97%E6%98%AF%E8%A2%AB%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84"><span class="toc-number">12.10.8.</span> <span class="toc-text">线程类的构造方法、静态块是被哪个线程调用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E4%B8%AD%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%B8%80%E4%BB%BD%E7%BA%BF%E7%A8%8B-dump-%E6%96%87%E4%BB%B6%EF%BC%9F%E4%BD%A0%E5%A6%82%E4%BD%95%E5%9C%A8-Java-%E4%B8%AD%E8%8E%B7%E5%8F%96-%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%EF%BC%9F"><span class="toc-number">12.10.9.</span> <span class="toc-text">Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取 线程堆栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">12.10.10.</span> <span class="toc-text">一个线程运行时发生异常会怎样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%BF%87%E5%A4%9A%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">12.10.11.</span> <span class="toc-text">Java 线程数过多会造成什么异常？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">12.11.</span> <span class="toc-text">synchronized底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Park-Unpark"><span class="toc-number">12.12.</span> <span class="toc-text">Park Unpark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">12.13.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">12.14.</span> <span class="toc-text">原子包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E3%80%81ReentrantLock-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E4%BD%BF%E7%94%A8%E3%80%81ReentrantLock-%E5%8E%9F%E7%90%86"><span class="toc-number">12.15.</span> <span class="toc-text">AQS、ReentrantLock 条件变量 使用、ReentrantLock 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">12.16.</span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E5%8A%A0%E9%94%81"><span class="toc-number">12.17.</span> <span class="toc-text">ReentrantLock 加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">12.18.</span> <span class="toc-text">ReentrantLock 释放锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E5%8F%AF%E6%89%93%E6%96%AD%E4%B8%8E%E4%B8%8D%E5%8F%AF%E6%89%93%E6%96%AD"><span class="toc-number">12.19.</span> <span class="toc-text">ReentrantLock 可打断与不可打断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">12.20.</span> <span class="toc-text">ReentrantLock 可重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E5%85%AC%E5%B9%B3%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">12.21.</span> <span class="toc-text">ReentrantLock 公平与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">12.22.</span> <span class="toc-text">ReentrantLock 条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0"><span class="toc-number">12.23.</span> <span class="toc-text">多线程顺序打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="toc-number">12.24.</span> <span class="toc-text">多线程交替输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore%E3%80%81CountDownLatch%E3%80%81CycleBarrier"><span class="toc-number">12.25.</span> <span class="toc-text">Semaphore、CountDownLatch、CycleBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList%E5%8E%9F%E7%90%86"><span class="toc-number">12.26.</span> <span class="toc-text">CopyOnWriteArrayList原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFConcurrentHashMap%EF%BC%9F"><span class="toc-number">12.27.</span> <span class="toc-text">什么是ConcurrentHashMap？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SynchronizedMap%E5%92%8C-ConcurrentHashMap-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.28.</span> <span class="toc-text">SynchronizedMap和 ConcurrentHashMap 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">12.29.</span> <span class="toc-text">ThreadLocal</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/" title="Java总结"><img src="/img/background_img/1/8.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="Java总结"/></a><div class="content"><a class="title" href="/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/" title="Java总结">Java总结</a><time datetime="2022-05-17T02:47:08.163Z" title="发表于 2022-05-17 10:47:08">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/17/JUC/ThreadLocal/" title="ThreadLocal"><img src="/img/background_img/1/5.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="ThreadLocal"/></a><div class="content"><a class="title" href="/2022/05/17/JUC/ThreadLocal/" title="ThreadLocal">ThreadLocal</a><time datetime="2022-05-17T02:42:58.375Z" title="发表于 2022-05-17 10:42:58">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/17/JUC/ConcurrentHashMap/" title="ConcurrentHashMap"><img src="/img/background_img/1/9.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="ConcurrentHashMap"/></a><div class="content"><a class="title" href="/2022/05/17/JUC/ConcurrentHashMap/" title="ConcurrentHashMap">ConcurrentHashMap</a><time datetime="2022-05-17T02:42:58.370Z" title="发表于 2022-05-17 10:42:58">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/17/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划算法"><img src="/img/background_img/1/6.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="动态规划算法"/></a><div class="content"><a class="title" href="/2022/05/17/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划算法">动态规划算法</a><time datetime="2022-05-17T02:39:12.302Z" title="发表于 2022-05-17 10:39:12">2022-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/" title="Java 内存模型"><img src="/img/background_img/1/7.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="Java 内存模型"/></a><div class="content"><a class="title" href="/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/" title="Java 内存模型">Java 内存模型</a><time datetime="2022-02-09T15:01:55.449Z" title="发表于 2022-02-09 23:01:55">2022-02-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By ins1mnia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">it feels like ins1mnia</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://ins1mn1a.github.io/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/'
    this.page.identifier = '2022/05/17/Java基础/Java基础/'
    this.page.title = 'Java总结'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="you,are,you,are,my,favorite,medicine" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>