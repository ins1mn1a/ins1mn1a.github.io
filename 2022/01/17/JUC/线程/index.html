<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>线程 | ins1mn1a</title><meta name="keywords" content="JUC并发编程"><meta name="author" content="ins1mnia"><meta name="copyright" content="ins1mnia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程的几种创建方式，线程设计原理，线程常用方法，多线程设计模式之两阶段终止模式">
<meta property="og:type" content="article">
<meta property="og:title" content="线程">
<meta property="og:url" content="http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="ins1mn1a">
<meta property="og:description" content="线程的几种创建方式，线程设计原理，线程常用方法，多线程设计模式之两阶段终止模式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ins1mn1a.github.io/img/background_img/1/7.jpg">
<meta property="article:published_time" content="2022-01-17T10:26:55.204Z">
<meta property="article:modified_time" content="2022-03-08T12:43:57.069Z">
<meta property="article:author" content="ins1mnia">
<meta property="article:tag" content="JUC并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ins1mn1a.github.io/img/background_img/1/7.jpg"><link rel="shortcut icon" href="/img/background_img/%E7%8E%89%E5%AD%90.icon.png"><link rel="canonical" href="http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-08 20:43:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="ins1mn1a" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tvax1.sinaimg.cn/crop.0.0.996.996.180/007RWaeLly8gr7p82e9e6j30ro0rognd.jpg?KID=imgbed,tva&amp;Expires=1639625304&amp;ssig=yn%2FY%2BCtxLO" onerror="onerror=null;src='/img/background_img/error_page.jpeg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background_img/1/7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ins1mn1a</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-17T10:26:55.204Z" title="发表于 2022-01-17 18:26:55">2022-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-08T12:43:57.069Z" title="更新于 2022-03-08 20:43:57">2022-03-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">JUC并发编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="线程与进程、并行并发、同步异步概念"><a href="#线程与进程、并行并发、同步异步概念" class="headerlink" title="线程与进程、并行并发、同步异步概念"></a>线程与进程、并行并发、同步异步概念</h2><ul>
<li>线程创建</li>
<li>线程重要api，如start，run，sleep, join，interrupt等</li>
<li>线程状态</li>
<li>应用方面<ul>
<li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li>
<li>提高效率：并行计算，缩短运算时间</li>
<li>同步等待：join</li>
<li>统筹规划：合理使用线程，得到最优效果</li>
</ul>
</li>
<li>原理方面<ul>
<li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li>
<li>Thread 两种创建方式的源码</li>
</ul>
</li>
<li><font color="green">模式方面</font><ul>
<li>两阶段终止</li>
</ul>
</li>
</ul>
<h2 id="进程与进程"><a href="#进程与进程" class="headerlink" title="进程与进程"></a>进程与进程</h2><p>进程: 资源分配的最小单位</p>
<p>进程是线程的容器, 一个进程中包含多个线程, 真正执行任务的是线程<br>线程: 资源调度的最小单位</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序由指令和数据组成，但是这些 指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令,管理内存,管理IO的<br>当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程<br>进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程之内可以分为多个线程。<br>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行<br>Java 中，线程作为资源的最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。</p>
<h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集<br>进程拥有共享的资源，如内存空间等，供其内部的线程共享; 进程间通信较为复杂<br>同一台计算机的进程通信称为 IPC（Inter-process communication）<br>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP<br>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<br>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>并发: 在单核CPU下, 一定是并发执行的, 也就是在同一个时间段内一起执行. 实际还是串行执行, CPU的时间片切换非常快, 给人一种同时运行的感觉。</p>
<p>并行: 在多核CPU下, 能真正意义上实现并行执行, 在同一个时刻, 多个线程同时执行; 比如说2核cpu, 同时执行4个线程. 理论上同时可以有2个线程是并行执行的. 此时还是存在并发, 因为2个cpu也会同时切换不同的线程执行任务罢了</p>
<h3 id="并发-concurrent"><a href="#并发-concurrent" class="headerlink" title="并发 (concurrent)"></a>并发 (concurrent)</h3><p>微观串行, 宏观并行<br>在单核 cpu下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu 在线程间（时间片很短）的切换非常快，给人的感觉是同时运行的 。一般会将这种线程轮流使用 CPU的做法称为并发（concurrent）<br>将线程轮流使用cput称为并发(concurrent)</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p>
<h3 id="二者对比-1"><a href="#二者对比-1" class="headerlink" title="二者对比"></a>二者对比</h3><p>引用 Rob Pike 的一段描述：<br>并发（concurrent）: 是同一时间应对（dealing with）多件事情的能力<br>并行（parallel）: 是同一时间动手做（doing）多件事情的能力<br>例子</p>
<p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发<br>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）<br>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是 并行</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>以调用方的角度讲</p>
<ul>
<li>如果需要等待结果返回才能继续运行的话就是同步</li>
<li>如果不需要等待就是异步</li>
</ul>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这5秒cpu什么都做不了，其它代码都得暂停</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li>
<li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li>
<li>UI 程序中，开线程进行其他操作，避免阻塞 UI 线程</li>
</ul>
<h2 id="线程的创建-重点"><a href="#线程的创建-重点" class="headerlink" title="线程的创建 (重点)"></a>线程的创建 (重点)</h2><h3 id="创建一个线程（非主线程）"><a href="#创建一个线程（非主线程）" class="headerlink" title="创建一个线程（非主线程）"></a>创建一个线程（非主线程）</h3><h4 id="通过继承Thread创建线程"><a href="#通过继承Thread创建线程" class="headerlink" title="通过继承Thread创建线程"></a>通过继承Thread创建线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">		myThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用继承方式的好处是，在run()方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread()方法；不好的地方是<strong>Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</strong></li>
</ul>
<h4 id="使用Runnable配合Thread-推荐"><a href="#使用Runnable配合Thread-推荐" class="headerlink" title="使用Runnable配合Thread (推荐)"></a>使用Runnable配合Thread (推荐)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建线程任务</span></span><br><span class="line">		Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">		Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread2</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;my runnable running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">      thread.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</li>
</ul>
<h5 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h5><ul>
<li><p>当一个接口带有**@FunctionalInterface**注解时，是可以使用lambda来简化操作的</p>
</li>
<li><p>所以方法二中的代码可以被简化为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建线程任务</span></span><br><span class="line">		Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="comment">//直接写方法体即可</span></span><br><span class="line">			System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">		Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Thread-与-Runnable的关系"><a href="#Thread-与-Runnable的关系" class="headerlink" title="Thread 与 Runnable的关系"></a>Thread 与 Runnable的关系</h5><p>分析 Thread 的源码，查看与 Runnable 的关系，可以发现采用Runnable的方式最终new Thread的时候最终就是把实现Runnable作为Thread中的target成员，然后判断如果target不为null，就运行target的run()方法，也就是Runnable的run方法。</p>
<ul>
<li>继承Thread方式: 是把线程和任务合并在了一起</li>
<li>实现Runnable方式: 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<h4 id="使用FutureTask与Thread结合"><a href="#使用FutureTask与Thread结合" class="headerlink" title="使用FutureTask与Thread结合"></a>使用FutureTask与Thread结合</h4><p>使用<strong>FutureTask可以用泛型指定线程的返回值类型</strong>（Runnable的run方法没有返回值），FutureTask实现了RunnableFuture，FutureRunable继承了Runnable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">		FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		Thread r1 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		r1.start();</span><br><span class="line">		<span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">		System.out.println(task.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseFutureTask</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">      FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCall());</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">      thread.start();</span><br><span class="line">      <span class="comment">// 获得线程运行后的返回值</span></span><br><span class="line">      System.out.println(futureTask.get());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用线程池来创建线程"><a href="#使用线程池来创建线程" class="headerlink" title="使用线程池来创建线程"></a>使用线程池来创建线程</h4><p>创建线程的方式四：使用线程池</p>
<p>好处：</p>
<ol>
<li><p>提高响应速度（减少了创建新线程的时间）</p>
</li>
<li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
</li>
<li><p>便于线程管理</p>
</li>
</ol>
<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？四种！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line">		<span class="comment">//System.out.println(service.getClass());</span></span><br><span class="line">		<span class="comment">//service1.setCorePoolSize(15);</span></span><br><span class="line">		<span class="comment">//service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="面试题：创建多线程有几种方式？四种！"><a href="#面试题：创建多线程有几种方式？四种！" class="headerlink" title="面试题：创建多线程有几种方式？四种！"></a>面试题：创建多线程有几种方式？四种！</h4><p>总结</p>
<ul>
<li>使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</li>
<li>开发中一般使用线程池的方式</li>
</ul>
<h2 id="三、Linux-Windows命令查看进程和线程"><a href="#三、Linux-Windows命令查看进程和线程" class="headerlink" title="三、Linux Windows命令查看进程和线程"></a>三、Linux Windows命令查看进程和线程</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul>
<li>任务管理器查看进程和线程，杀死进程</li>
<li> <code>tasklist</code> 查看进程</li>
<li><code>taskkill /F /PID 进程号</code> 杀死进程</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li><code>ps -fe </code>查看所有进程</li>
<li><code>ps -ft -p &lt;PID&gt;</code> 查看某个进程的所有线程</li>
<li><code>kill</code> 杀死进程</li>
<li><code>pkill -9 &lt;PID&gt;</code> 杀死进程，-9代表一类操作，杀死进程</li>
<li><code>top</code> 查看进程信息</li>
<li><code>top -H -P &lt;PID&gt;</code> 查看某个进程PID的所有线程</li>
</ul>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul>
<li><code>jps</code> 查看所有Java进程</li>
<li><code>jstack &lt;PID&gt;</code> 查看某个Java进程的所有线程状态</li>
<li><code>jconsole</code> 连接查看某个Java进程中线程的运行情况（Windows直接win+r 输入jconsole，图形界面）</li>
</ul>
<h2 id="线程运行原理-重点"><a href="#线程运行原理-重点" class="headerlink" title="线程运行原理 (重点)"></a>线程运行原理 (<code>重点</code>)</h2><h3 id="虚拟机栈与栈帧"><a href="#虚拟机栈与栈帧" class="headerlink" title="虚拟机栈与栈帧"></a>虚拟机栈与栈帧</h3><ul>
<li>虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法被执行</strong>的时候都会同时创建一个<strong>栈帧(stack frame)<strong>用于</strong>存储局部变量表</strong>、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。当Java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧(在栈顶)，<strong>对应着当前正在执行的那个方法</strong>。</li>
<li>每个线程都拥有自己的一个栈内存，里面对应着多个栈帧。可以用IDEA开启线程模式的调试功能。</li>
</ul>
<p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101108334.png" alt="image-20220115101108334"></p>
<p>t1线程的多个栈帧：</p>
<p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115100910857.png" alt="image-20220115100910857"></p>
<p>主线程的多个栈帧：</p>
<p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101011097.png" alt="image-20220115101011097"></p>
<h3 id="线程上下文切换（Thread-Context-Switch"><a href="#线程上下文切换（Thread-Context-Switch" class="headerlink" title="线程上下文切换（Thread Context Switch)"></a>线程上下文切换（Thread Context Switch)</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程</p>
<ul>
<li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当Thread Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>线程的状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能，所以线程数也不能过多，如果线程数大于CPU核心数，可能并不会提升性能</li>
</ul>
<h3 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h3><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111642378.png" alt="image-20220115111642378"></p>
<p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111913619.png" alt="image-20220115111913619"></p>
<h4 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h4><h5 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h5><p>调用 sleep() 会让当前线程从 Running(运行状态) 进入 Timed Waiting 状态（阻塞）<br>其它线程可以使用interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 InterruptedException异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】<br>睡眠结束后的线程未必会立刻得到执行 (需要分配到cpu时间片)<br>建议用 TimeUnit 的 sleep() 代替 Thread 的 sleep()来获得更好的可读性</p>
<h5 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h5><p>调用 yield 会让当前线程从Running 进入 Runnable 就绪状态，然后调度执行其它线程</p>
<p>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</p>
<p>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li>线程<code>优先级</code>会<code>提示（hint）调度器优先调度该线程</code>，但它仅仅是一个提示，调度器可以忽略它, 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
</ul>
<h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><ul>
<li>在<code>主线程</code>中调用<code>t1.join</code>，则<code>主线程</code>会<code>等待t1线程执行完之后</code>再<code>继续执行</code></li>
</ul>
<h4 id="interrupt-方法详解"><a href="#interrupt-方法详解" class="headerlink" title="interrupt 方法详解"></a>interrupt 方法详解</h4><p>该方法用于打断 sleep，wait，join的线程, 在阻塞期间cpu不会分配给时间片</p>
<ul>
<li><p>如果一个线程在在运行中被打断，打断标记会被置为true</p>
</li>
<li><p>如果是打断因sleep wait join方法而被阻塞的线程，只是会抛出一个Interrupted 异常，以这个异常来表示线程被打断了，打断标记仍然是false</p>
</li>
</ul>
<p>sleep，wait，join的线程，这几个方法都会让线程进入阻塞状态，join方法底层就是用的wait方法，以 sleep 为例，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>); <span class="comment">// wait, join</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;iterrupt..&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.isInterrupted()); <span class="comment">// 如果是打断sleep,wait,join的线程, 即使打断了, 标记也为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sleep...</span><br><span class="line">iterrupt..</span><br><span class="line">打断标记为:<span class="keyword">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at com.zc.ThreadPrintDemo.lambda$main$<span class="number">0</span>(ThreadPrintDemo.java:<span class="number">14</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h5><ul>
<li>调用Interrupt方法去打断一个正在运行的线程，就好比是一个打断请求，只是把其打断标记记为True，实际上是不是要被打断由线程自己决定，线程并不会直接暂停。我们可以判断<code>Thread.currentThread().isInterrupted();</code>的值来手动停止线程</li>
<li>这样可以方便当线程被打断时做一些后续的操作，料理线程后事</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被打断了, 退出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;打断标记为: &quot;</span>+t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interrupt</span><br><span class="line">被打断了, 退出循环</span><br><span class="line">打断标记为: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="终止模式之两阶段终止模式-多线程设计模式"><a href="#终止模式之两阶段终止模式-多线程设计模式" class="headerlink" title="终止模式之两阶段终止模式(多线程设计模式)"></a>终止模式之两阶段终止模式(多线程设计模式)</h4><p>当我们在执行线程一时，想要终止线程二，这时就需要使用interrupt方法来优雅的停止线程二。</p>
<h5 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h5><ul>
<li><p>使用线程对象的stop()方法停止线程</p>
<p>stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p>
</li>
<li><p>使用System.exit(int)方法停止线程</p>
<p>目的仅是停止一个线程，但这种做法会让整个程序都停止</p>
</li>
</ul>
<p>如下所示：那么线程的isInterrupted()方法可以取得线程的打断标记</p>
<p>如果线程在睡眠sleep期间被打断，打断标记是不会变的，为false，但是sleep期间被打断会抛出异常，我们据此手动设置打断标记为true；<br>如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为true。处理好这两种情况那我们就可以放心地来料理后事啦！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">		monitor.start();</span><br><span class="line">		Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">		monitor.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Thread monitor;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 启动监控器线程</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//设置线控器线程，用于监控线程状态</span></span><br><span class="line">		monitor = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">//开始不停的监控</span></span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">//判断当前线程是否被打断了</span></span><br><span class="line">					<span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;处理后续任务&quot;</span>);</span><br><span class="line">                        <span class="comment">//终止线程执行</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;监控器运行中...&quot;</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">//线程休眠</span></span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						<span class="comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span></span><br><span class="line">						Thread.currentThread().interrupt();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		monitor.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	用于停止监控器线程</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//打断线程</span></span><br><span class="line">		monitor.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sleep，yiled，wait，join-对比"><a href="#sleep，yiled，wait，join-对比" class="headerlink" title="sleep，yiled，wait，join 对比"></a>sleep，yiled，wait，join 对比</h4><ul>
<li>sleep，join，yield，interrupted是Thread类中的方法</li>
<li>wait/notify是object中的方法</li>
<li>sleep 不释放锁、释放cpu</li>
<li>join 释放锁、抢占cpu</li>
<li>yiled 不释放锁、释放cpu</li>
<li>wait 释放锁、释放cpu</li>
</ul>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>当Java进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，Java进程才会结束。但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</p>
<p>注意:</p>
<p>垃圾回收器线程就是一种守护线程<br>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会继续等待</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><ol>
<li><p>初始状态，仅仅是在语言层面上创建了线程对象，即Thread thread = new Thread();，还未与操作系统线程关联</p>
</li>
<li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p>
</li>
<li><p>运行状态，指线程获取了CPU时间片，正在运行</p>
<ul>
<li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li>
</ul>
</li>
<li><p>阻塞状态<br>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】<br>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p>
<p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p>
</li>
<li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p>
</li>
</ol>
<h3 id="Java-API层面"><a href="#Java-API层面" class="headerlink" title="Java API层面"></a>Java API层面</h3><p>根据<code>Thread.State 枚举，分为六种状态</code></p>
<ul>
<li><strong><code>新建状态</code>、<code>运行状态</code>(就绪状态, 运行中状态)、<code>阻塞状态</code>、<code>等待状态</code>、<code>定时等待状态</code>、<code>终止状态</code></strong></li>
</ul>
<ul>
<li><strong>NEW (新建状态)</strong> 线程刚被创建，但是还没有调用 start() 方法</li>
<li><strong>RUNNABLE (运行状态)</strong> 当调用了 start() 方法之后，注意，Java API 层面的<strong>RUNNABLE 状态</strong>涵盖了操作系统层面的 <strong>【就绪状态】、【运行中状态】和【阻塞状态】</strong>（由于 BIO 导致的线程阻塞，比如在读取文件时的操作系统层面的阻塞，也认为是运行状态，在 Java 里无法区分，仍然认为是可运行）</li>
<li><strong>BLOCKED (阻塞状态)</strong> ， <strong>WAITING (等待状态)</strong> ， <strong>TIMED_WAITING(定时等待状态)</strong> 都是 Java API 层面对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。</li>
<li><strong>TERMINATED (结束状态)</strong> 当线程代码运行结束</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ins1mnia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/">http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ins1mn1a.github.io" target="_blank">ins1mn1a</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">JUC并发编程</a></div><div class="post_share"><div class="social-share" data-image="/img/background_img/1/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"><img class="prev-cover" src="/img/background_img/1/3.jpg" onerror="onerror=null;src='/img/background_img/error_page.jpeg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">线程的安全性问题</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/17/JUC/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/"><img class="next-cover" src="/img/background_img/1/1.jpg" onerror="onerror=null;src='/img/background_img/error_page.jpeg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">synchronized底层原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/17/JUC/ThreadLocal/" title="ThreadLocal"><img class="cover" src="/img/background_img/1/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-17</div><div class="title">ThreadLocal</div></div></a></div><div><a href="/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" title="线程的安全性问题"><img class="cover" src="/img/background_img/1/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="title">线程的安全性问题</div></div></a></div><div><a href="/2022/02/09/JUC/AQS%20ReentrantLock%E5%8E%9F%E7%90%86/" title="AQS"><img class="cover" src="/img/background_img/1/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-09</div><div class="title">AQS</div></div></a></div><div><a href="/2022/02/09/JUC/CAS/" title="CAS"><img class="cover" src="/img/background_img/1/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-09</div><div class="title">CAS</div></div></a></div><div><a href="/2022/05/17/JUC/ConcurrentHashMap/" title="ConcurrentHashMap"><img class="cover" src="/img/background_img/1/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-17</div><div class="title">ConcurrentHashMap</div></div></a></div><div><a href="/2022/02/09/JUC/ReentrantLock/" title="ReentrantLock"><img class="cover" src="/img/background_img/1/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-09</div><div class="title">ReentrantLock</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tvax1.sinaimg.cn/crop.0.0.996.996.180/007RWaeLly8gr7p82e9e6j30ro0rognd.jpg?KID=imgbed,tva&amp;Expires=1639625304&amp;ssig=yn%2FY%2BCtxLO" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="avatar"/></div><div class="author-info__name">ins1mnia</div><div class="author-info__description">because it feels like ins1mnia</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ins1mnia"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ins1mnia" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ins1mnia@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">穿梭时间的画面的钟,从反方向开始移动</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E3%80%81%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91%E3%80%81%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">线程与进程、并行并发、同步异步概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">进程与进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.</span> <span class="toc-text">二者对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-concurrent"><span class="toc-number">3.1.</span> <span class="toc-text">并发 (concurrent)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-number">3.2.</span> <span class="toc-text">并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94-1"><span class="toc-number">3.3.</span> <span class="toc-text">二者对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">4.</span> <span class="toc-text">同步和异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.1.</span> <span class="toc-text">设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">4.2.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-%E9%87%8D%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">线程的创建 (重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E9%9D%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">创建一个线程（非主线程）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BFThread%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">通过继承Thread创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Runnable%E9%85%8D%E5%90%88Thread-%E6%8E%A8%E8%8D%90"><span class="toc-number">5.1.2.</span> <span class="toc-text">使用Runnable配合Thread (推荐)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E7%9A%84%E7%AE%80%E5%8C%96%EF%BC%9A%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">方法二的简化：使用lambda表达式简化操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Thread-%E4%B8%8E-Runnable%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">Thread 与 Runnable的关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8FutureTask%E4%B8%8EThread%E7%BB%93%E5%90%88"><span class="toc-number">5.1.3.</span> <span class="toc-text">使用FutureTask与Thread结合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.4.</span> <span class="toc-text">使用线程池来创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%9B%9B%E7%A7%8D%EF%BC%81"><span class="toc-number">5.1.5.</span> <span class="toc-text">面试题：创建多线程有几种方式？四种！</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Linux-Windows%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">三、Linux Windows命令查看进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#windows"><span class="toc-number">6.1.</span> <span class="toc-text">windows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux"><span class="toc-number">6.2.</span> <span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java"><span class="toc-number">6.3.</span> <span class="toc-text">Java</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-%E9%87%8D%E7%82%B9"><span class="toc-number">7.</span> <span class="toc-text">线程运行原理 (重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%8E%E6%A0%88%E5%B8%A7"><span class="toc-number">7.1.</span> <span class="toc-text">虚拟机栈与栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88Thread-Context-Switch"><span class="toc-number">7.2.</span> <span class="toc-text">线程上下文切换（Thread Context Switch)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">Thread的常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-%E4%B8%8E-yield"><span class="toc-number">7.3.1.</span> <span class="toc-text">sleep 与 yield</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sleep%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">sleep方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">yield方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">7.3.2.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.3.</span> <span class="toc-text">join方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupt-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.3.4.</span> <span class="toc-text">interrupt 方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E6%96%AD%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">打断正常运行的线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.5.</span> <span class="toc-text">终止模式之两阶段终止模式(多线程设计模式)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF"><span class="toc-number">7.3.5.1.</span> <span class="toc-text">错误思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep%EF%BC%8Cyiled%EF%BC%8Cwait%EF%BC%8Cjoin-%E5%AF%B9%E6%AF%94"><span class="toc-number">7.3.6.</span> <span class="toc-text">sleep，yiled，wait，join 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.3.7.</span> <span class="toc-text">守护线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2"><span class="toc-number">8.1.</span> <span class="toc-text">操作系统层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-API%E5%B1%82%E9%9D%A2"><span class="toc-number">8.2.</span> <span class="toc-text">Java API层面</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8C%87%E4%BB%A4%E4%B8%8E%E9%9B%86%E7%BE%A4/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/" title="Zookeeper、Redis、Kafka集群搭建指令与集群搭建过程"><img src="/img/background_img/1/1.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="Zookeeper、Redis、Kafka集群搭建指令与集群搭建过程"/></a><div class="content"><a class="title" href="/2022/09/20/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8C%87%E4%BB%A4%E4%B8%8E%E9%9B%86%E7%BE%A4/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/" title="Zookeeper、Redis、Kafka集群搭建指令与集群搭建过程">Zookeeper、Redis、Kafka集群搭建指令与集群搭建过程</a><time datetime="2022-09-20T04:44:31.833Z" title="发表于 2022-09-20 12:44:31">2022-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/20/JUC/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="自定义阻塞队列，线程池"><img src="/img/background_img/1/6.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="自定义阻塞队列，线程池"/></a><div class="content"><a class="title" href="/2022/09/20/JUC/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="自定义阻塞队列，线程池">自定义阻塞队列，线程池</a><time datetime="2022-09-20T04:31:26.322Z" title="发表于 2022-09-20 12:31:26">2022-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/27/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="滑动窗口"><img src="/img/background_img/1/2.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="滑动窗口"/></a><div class="content"><a class="title" href="/2022/07/27/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="滑动窗口">滑动窗口</a><time datetime="2022-07-27T14:57:22.561Z" title="发表于 2022-07-27 22:57:22">2022-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/27/ElasticSearch/ElasticSearch/" title="Elasticsearch"><img src="/img/background_img/1/8.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="Elasticsearch"/></a><div class="content"><a class="title" href="/2022/07/27/ElasticSearch/ElasticSearch/" title="Elasticsearch">Elasticsearch</a><time datetime="2022-07-27T14:48:59.392Z" title="发表于 2022-07-27 22:48:59">2022-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/27/Kafka/Kafka/" title="Kafka"><img src="/img/background_img/1/2.jpg" onerror="this.onerror=null;this.src='/img/background_img/error_page.jpeg'" alt="Kafka"/></a><div class="content"><a class="title" href="/2022/07/27/Kafka/Kafka/" title="Kafka">Kafka</a><time datetime="2022-07-27T14:46:17.266Z" title="发表于 2022-07-27 22:46:17">2022-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By ins1mnia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">it feels like ins1mnia</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://ins1mn1a.github.io/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/'
    this.page.identifier = '2022/01/17/JUC/线程/'
    this.page.title = '线程'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="you,are,you,are,my,favorite,medicine" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>