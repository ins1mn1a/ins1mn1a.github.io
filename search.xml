<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SHA-1算法的Java实现</title>
      <link href="/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/SHA-1/"/>
      <url>/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/SHA-1/</url>
      
        <content type="html"><![CDATA[<h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>SHA-1把长度小于2^64次方的输入进行分组，512bit为一组。</p><p>采用Merkle提出的安全Hash模型</p><p><img src="/../../img/markdown_img/SHA-1.assets/image-20220104084936990.png" alt="image-20220104084936990"></p><h2 id="填充方案"><a href="#填充方案" class="headerlink" title="填充方案"></a>填充方案</h2><p>先在后面补一个1，然后补0一直到448bit，最后加上64bit的原始x长度的二进制表示</p><p>举例：</p><ol><li><p>原始消息为”abc”，则其bit序列为01100001 01100010 01100011</p></li><li><p>补位，最高位补1，其余补0，补位到448bit</p><ul><li>原始序列：01100001 01100010 01100011</li><li>补位序列：01100001 01100010 01100011 10000000 00000000 … 00000000 （共448bit）</li></ul></li><li><p>原始数据长度的二进制补位</p><ul><li><p>换为16进制：61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000</p></li><li><p>原始消息的长度为24，补位</p><p>61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000018 </p></li></ul></li></ol><p>至此填充完毕，|y|=|x|+1+(447-|x|)+|l|=512</p><h2 id="初始化缓冲区"><a href="#初始化缓冲区" class="headerlink" title="初始化缓冲区"></a>初始化缓冲区</h2><p>缓冲区由5个32位的寄存器（A,B,C,D,E）组成，用于保存160位的中间结果和最终结果</p><p>寄存器初始化为：</p><ul><li>A：67452301</li><li>B：EFCDAB89</li><li>C：98BADCFE</li><li>D：10325476</li><li>E：C3D2E1F0</li></ul><h2 id="主处理"><a href="#主处理" class="headerlink" title="主处理"></a>主处理</h2><p>主处理是SHA-1的核心，每次处理一个512bit分组，链接迭代处理所有L个分组数</p><p>压缩函数是主处理的核心，它由4层运算，每层20步迭代，共80步迭代组成，4层运算结构相同。</p><p>每轮的输入是当前512bit分组BLK和160bit缓冲区ABCDE的内容，并且每轮都对ABCDE的内容更新，而且每轮使用的逻辑函数f不相同，分为f1,f2,f3,f4</p><p>第四轮的输出与第一轮的输入相加得到压缩函数的输出</p><p><img src="/../../img/markdown_img/SHA-1.assets/image-20220104090917830.png" alt="image-20220104090917830"></p><p>&lt;&lt;s 表示32位的变量循环左移s位</p><p>Wt 表示从当前分组BLK导出的32位的字</p><p>Kt 表示加法常量，共使用4个不同的加法常量，每一层一个</p><p>ft 逻辑函数</p><h2 id="逻辑函数ft"><a href="#逻辑函数ft" class="headerlink" title="逻辑函数ft"></a>逻辑函数ft</h2><p>每一轮使用一个逻辑函数，共4个，其输入均为B,C,D(每个32位)，输出为一个32位的字。</p><ul><li>0 ≤ t ≤ 19    f1=ft(B,C,D) = (B ∧C) ∨((¬ B) ∧ D)</li><li>20 ≤ t ≤ 39 f2=ft(B,C,D) = B ⊕ C ⊕ D</li><li>40 ≤ t ≤ 59 f3=ft(B,C,D) = (B ∧ C) ∨(B ∧ D) ∨ (C∧D)</li><li>60≤ t ≤ 79 f4=ft(B,C,D) = B ⊕ C ⊕ D</li></ul><p>f2和f4都是线性函数</p><h2 id="加法常量Kt"><a href="#加法常量Kt" class="headerlink" title="加法常量Kt"></a>加法常量Kt</h2><p>每层使用一个加法常量，各轮使用的加法常量：</p><p>K1 0 ≤ t ≤ 19    5A827999</p><p>K2 20 ≤ t ≤ 39    6ED9EBA1</p><p>K3 40 ≤ t ≤ 59    8F1BBCDC</p><p>K4 60≤ t ≤ 79    CA62C1D6</p><p>压缩字Kt的作用范围太小，只影响输出A，不影响B,C,D,E。</p><h2 id="压缩字Wt"><a href="#压缩字Wt" class="headerlink" title="压缩字Wt"></a>压缩字Wt</h2><p>每步迭代都需要用到一个字，共有80个步，需要80个字。因此将输入BLK（512位，16个字）扩展成80个32位的字。消息M共16个字。</p><p>扩展过程：</p><ul><li>0 ≤ t ≤ 15 Wt=Mt</li><li>16 ≤ t ≤ 79 Wt=（Wt-16 ⊕ Wt-14 ⊕ Wt-8 ⊕ Wt-3）&lt;&lt;1</li></ul><p>压缩字的扩展函数为线性函数</p><p>Wt作用范围太小，只影响输出A，不影响B,C,D,E。</p><h2 id="主处理过程"><a href="#主处理过程" class="headerlink" title="主处理过程"></a>主处理过程</h2><h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h3><p>填充后的消息M，共16个字</p><p>61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000018 </p><p>对M扩展成80个字</p><p>Wt = S1(Wt-3 ⊕Wt-8 ⊕Wt-14 ⊕Wt-16) (16  ≤ t ≤ 79)</p><h3 id="初始化缓冲区-1"><a href="#初始化缓冲区-1" class="headerlink" title="初始化缓冲区"></a>初始化缓冲区</h3><p>初始化MD缓冲区{Hi}，160bit(5个32的寄存器)。</p><p>A=H0= 0x67452301 </p><p>B=H1 = 0xEFCDAB89 </p><p>C=H2= 0x98BADCFE </p><p>D=H3= 0x10325476 </p><p>E=H4= 0xC3D2E1F0</p><p>每轮的常数K为：  </p><p>Kt = 5A827999 ( 0 ≤ t ≤ 19) </p><p>Kt = 6ED9EBA1 (20 ≤ t ≤ 39) </p><p>Kt = 8F1BBCDC (40 ≤ t ≤ 59) </p><p>Kt = CA62C1D6 (60 ≤ t ≤ 79)</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ul><li><p>TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt</p></li><li><p>E = D ; D = C ; C = S30(B) ; B = A ; A = TEMP</p></li><li><p>H0 = H0 + A  H1 = H1 + B H2 = H2 + C  H3 = H3 + D H4 = H4 + E</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java小功能实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java小功能实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现文件监控系统</title>
      <link href="/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>用Java实现文件监控一般有三种方式，第一种是使用WatchService，但是WatchService只能监视当前目录下的文件和目录，不能监视子目录，如果需要监视，则需要遍历根目录下的所有目录，第二种就是利用commons-io监控，最后还可以用JNofiy实现，这里只使用了前两种</p><h2 id="WatchService实现文件监控"><a href="#WatchService实现文件监控" class="headerlink" title="WatchService实现文件监控"></a>WatchService实现文件监控</h2><p>WatchService是jdk7之后nio包中的新功能。可以看作是文件监控器，通过操作系统原生文件系统来运行。 针对单点多appkey的情况，可以注册开启多个监控器。 每个监控器可看作是后台线程，通过监控文件发出的信号来实现监控。</p><p>应用场景：可以监控配置文件的变化，修改配置文件内容即时生效，无需重启服务；监控磁盘文件的变化</p><p>WatchService监控目录文件操作的流程大致如下：</p><ol><li>获取WatchService</li><li>注册指定目录的监视器</li><li>开启线程，等等目录下的文件发生变化</li><li>对发送变化的文件进行记录</li></ol><h3 id="获取WatchService实例"><a href="#获取WatchService实例" class="headerlink" title="获取WatchService实例"></a>获取WatchService实例</h3><p>WatchService是对原生操作系统文件监视器的封装，因为不需要遍历文件所以整体效率上会高很多。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService = FileSystems.getDefault().newWatchService();</span><br></pre></td></tr></table></figure><p>FileSystems.getDefault().newWatchService();直接封装了WatchService的获取方法。</p><p>可以查看它的源码，getDefault()方法的返回值是一个FileSystem，FileSystem提供一个访问文件系统的接口，是对象访问文件系统中的文件和其他对象的工厂，进入getDefault()方法，看看它default了个啥。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileSystem <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultFileSystemHolder.defaultFileSystem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用了DefaultFileSystemHolder，DefaultFileSystemHolder是FileSystems中的一个静态内部类，而defaultFileSystem是DefaultFileSystemHolder的一个用static修饰的属性，然后调用了defaultFileSystem()方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> FileSystem defaultFileSystem = defaultFileSystem();</span><br></pre></td></tr></table></figure><p>defaultFileSystem方法里面用匿名内部类的形式返回了一个FileSystemProvider，它是文件系统的服务提供者类，用它可以获取由provider创建的一个FileSystem。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// returns default file system</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FileSystem <span class="title">defaultFileSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// load default provider</span></span><br><span class="line">    FileSystemProvider provider = AccessController</span><br><span class="line">        .doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;FileSystemProvider&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileSystemProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getDefaultProvider();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return file system</span></span><br><span class="line">    <span class="keyword">return</span> provider.getFileSystem(URI.create(<span class="string">&quot;file:///&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类中，获取了一个defaultProvider，WindowsFileSystemProvider，然后由这个provider获取了一个文件系统，WindowsFileSystemProvider中初始化文件系统。然后调用newWatchService方法就可以获取到WindowsWatchService对象了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WindowsFileSystem theFileSystem = <span class="keyword">new</span> WindowsFileSystem(<span class="keyword">this</span>, System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br></pre></td></tr></table></figure><p>实际上调用此方法后也就是WindowsWatchService的构造方法中，程序会新开一个线程，监视文件变化发出的信号，此时线程尚未就绪。Poller是WindowsWatchService中的一个内部类，WindowsWatchService也有一个poller属性，Poller继承了AbstractPoller，AbstractPoller是实现了Runnable接口，创建了一个守护线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread var1 = <span class="keyword">new</span> Thread(AbstractPoller.<span class="keyword">this</span>);</span><br><span class="line">            var1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            var1.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册目录监视器"><a href="#注册目录监视器" class="headerlink" title="注册目录监视器"></a>注册目录监视器</h3><p>注册监视器需要用到 Path 实例，该实例对应的必须是一个目录，不允许是一个文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要监视的文件目录</span></span><br><span class="line">        String strPath=<span class="string">&quot;D:/FileSystemMonitorTest&quot;</span>;</span><br><span class="line">        <span class="comment">//Path继承了Watchable接口，因此才可以通过Path类来对文件目录进行监听</span></span><br><span class="line">        Path path= Paths.get(strPath);</span><br><span class="line">        <span class="comment">//注册监控服务，监控新增、修改、删除事件，也可以只监控一个事件</span></span><br><span class="line">        path.register(watchService,StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br></pre></td></tr></table></figure><p>StandardWatchEventKinds是文件对应的操作事件，包括修改，创建，删除，它看起来像是枚举类型，但实际上并不是。WatchEvent.Kind<T>是一个接口，对应事件种类名和WatchEvent#context的类型，StdWatchEventKind是它的实现类，StdWatchEventKind<T>也是StandardWatchEventKinds中的内部静态类，StandardWatchEventKinds中的属性调用StdWatchEventKind的构造创建对应的观察事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> WatchEvent.Kind&lt;Path&gt; ENTRY_CREATE =</span><br><span class="line">    <span class="keyword">new</span> StdWatchEventKind&lt;Path&gt;(<span class="string">&quot;ENTRY_CREATE&quot;</span>, Path.class);</span><br></pre></td></tr></table></figure><h3 id="获取目录下的变化"><a href="#获取目录下的变化" class="headerlink" title="获取目录下的变化"></a>获取目录下的变化</h3><p>获取目录的变化需要使用 WatchService 的 take() 方法或 poll() 方法。</p><p>take() 是一个阻塞方法，会等待监视器发出的信号才返回。</p><p>poll() 是一个非阻塞方法，会立即返回当时监视器中是否有信号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    WatchKey watchKey = watchService.take();</span><br><span class="line">    <span class="comment">//轮询</span></span><br><span class="line">    List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">    <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">        System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">    &#125;</span><br><span class="line">    watchKey.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 WatchKey 对象，实际上是一个单例，和之前 path.register() 方法返回的实例是同一个。它只能保存某一时间点的文件变化信息。在AbstractPoller中可以看到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">awaitResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> var1 = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!<span class="keyword">this</span>.completed) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException var5) &#123;</span><br><span class="line">                        var1 = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (var1) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>pollEvents() 用于获取文件变化事件，只能获取一次，不能重复获取，类似队列的形式。</p><p>context() 返回触发该事件的那个文件或目录的路径(相对路径)</p><p>reset() 每次调用 WatchService 的 take() 或 poll() 方法时需要通过本方法重置。</p><h3 id="文件变化记录"><a href="#文件变化记录" class="headerlink" title="文件变化记录"></a>文件变化记录</h3><p>开启一个线程一直监控文件的变化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建监视服务类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService=FileSystems.getDefault().newWatchService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainMonitor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//需要监视的文件目录</span></span><br><span class="line">        String strPath=<span class="string">&quot;D:/FileSystemMonitorTest&quot;</span>;</span><br><span class="line">        <span class="comment">//Path继承了Watchable接口，因此才可以通过Path类来对文件目录进行监听</span></span><br><span class="line">        Path path= Paths.get(strPath);</span><br><span class="line">        <span class="comment">//注册监控服务，监控新增、修改、删除事件，也可以只监控一个事件</span></span><br><span class="line">        path.register(watchService,StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">        WatchServiceRunnable watchServiceRunnable = <span class="keyword">new</span> WatchServiceRunnable(watchService, strPath);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(watchServiceRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.FileMonitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchEvent;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchService;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控线程重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchServiceRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchServiceRunnable</span><span class="params">(WatchService watchService,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.watchService=watchService;</span><br><span class="line">        <span class="keyword">this</span>.path=path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                WatchKey watchKey = watchService.take();</span><br><span class="line">                <span class="comment">//轮询</span></span><br><span class="line">                List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">                <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">                    System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                            <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">                &#125;</span><br><span class="line">                watchKey.reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WatchService监控根目录以及子目录"><a href="#WatchService监控根目录以及子目录" class="headerlink" title="WatchService监控根目录以及子目录"></a>WatchService监控根目录以及子目录</h3><p>这样的话就需要遍历子目录，每个目录都注册一个监控事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历根目录及其子目录，全都注册监听服务</span></span><br><span class="line">LinkedList&lt;File&gt; fileLinkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加根目录到链表尾</span></span><br><span class="line">fileLinkedList.addLast(file);</span><br><span class="line"><span class="comment">//去除并且链表头的文件对象，查看其子目录下文件，能注册服务就注册WatchService</span></span><br><span class="line"><span class="keyword">while</span> (fileLinkedList.size()&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    File f=fileLinkedList.removeFirst();</span><br><span class="line">    File[] files1 = f.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file1 : files1) &#123;</span><br><span class="line">        <span class="comment">//如果是目录，则可以注册监听服务</span></span><br><span class="line">        <span class="keyword">if</span> (file1.isDirectory())&#123;</span><br><span class="line">            fileLinkedList.addLast(file1);</span><br><span class="line">            file1.toPath().register(watchService, StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                    StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在使用Junit测试的时候会遇到Junit测试多线程的限制，不能直接测试，可以看另一篇，Junit测试多线程的问题。</p><h2 id="Commons-IO实现文件监控"><a href="#Commons-IO实现文件监控" class="headerlink" title="Commons-IO实现文件监控"></a>Commons-IO实现文件监控</h2><p>Commons-IO是一个针对开发IO流功能的工具库，主要包括6个部分</p><ol><li>Utility classes：工具类，包括一些静态方法来执行常用任务</li><li>Input：输入，InputStream 和 Reader 实现</li><li>Output：输出，OutputStream 和 Writer 实现</li><li>Filters：过滤器，多种文件过滤器实现(定义了 IOFileFilter接口,同时继承了 FileFilter 和 FilenameFilter 接口)</li><li>Comparators： 比较器，用于文件比较的多种java.util.Comparatot实现</li><li>File Monitor： 文件监控</li></ol><p>使用Commons-IO来实现文件监控主要就是基于观察者模式，也叫发/布订阅模式。</p><p>主要的类有：</p><p>FileAlterationObserver：观察者，观察文件的变化</p><p>FileAlterationListener：文件变化的通知对象，监听器</p><p>FileAlterationListenerAdaptor：FileAlterationListener的实现类，里面方法都没仅仅有个方法体，没有具体的实现，我们一般需要继承FileAlterationListenerAdaptor，然后做具体的实现，比如监控到文件变化打印日志等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File system observer started checking event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> observer The file system observer (ignored)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileAlterationMonitor ：线程监控，实现了Runnable接口，可以以一个固定的时间间隔监听注册到观察者FileAlterationObserver的事件</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>首先由文件监控类FileAlterationMonitor中的线程不停的扫描文件观察器FileAlterationObserver</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> FileAlterationObserver observer : observers) &#123;</span><br><span class="line">            observer.checkAndNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(interval);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FileAlterationObserver中，有一个无参的checkAndNotify()方法，就是用来检查文件和它的子文件有没有变化。</p><p>在该方法中，首先将Observer的所有listener开启onStart方法，表示开始Observer开始检查事件了。然后调用checkAndNotify()的重载方法，根据文件的Comparators比较器，判断文件发生哪种变化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAndNotify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAndNotify</span><span class="params">(<span class="keyword">final</span> FileEntry parent, <span class="keyword">final</span> FileEntry[] previous, <span class="keyword">final</span> File[] files)</span></span></span><br><span class="line"><span class="function"><span class="title">doCreate</span><span class="params">(current[c])</span></span>;<span class="comment">//创建</span></span><br><span class="line">doMatch(entry, files[c]);<span class="comment">//修改</span></span><br><span class="line">doDelete(entry);<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><h3 id="自定义监听器FileAlterationListener"><a href="#自定义监听器FileAlterationListener" class="headerlink" title="自定义监听器FileAlterationListener"></a>自定义监听器FileAlterationListener</h3><p>通过实现FileAlterationListener或者说继承FileAlterationListenerAdaptor来自定义一个监听器，重写其中文件或者目录发生改变的方法，记录日志。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.commons_io_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationListenerAdaptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationObserver;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListener</span> <span class="keyword">extends</span> <span class="title">FileAlterationListenerAdaptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger=Logger.getLogger(FileListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;新建文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;修改文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;删除文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryCreate</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;新建目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryChange</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;修改目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryDelete</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;删除目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建监听器FileAlterationMonitor"><a href="#创建监听器FileAlterationMonitor" class="headerlink" title="创建监听器FileAlterationMonitor"></a>创建监听器FileAlterationMonitor</h3><p>首先给定一个需要监听的文件目录，配置一个观察者FileAlterationObserver，添加观察者的监听器，最后再new一个线程监控FileAlterationMonitor。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.commons_io_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.FileFilterUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.HiddenFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.IOFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationMonitor;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListenerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String dir=<span class="string">&quot;D:\\FileSystemMonitorTest&quot;</span>;</span><br><span class="line">    <span class="comment">//设置轮询间隔 1s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = TimeUnit.SECONDS.toMillis(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileAlterationMonitor <span class="title">getMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//装配过滤器</span></span><br><span class="line">        FileAlterationObserver observer = <span class="keyword">new</span> FileAlterationObserver(<span class="keyword">new</span> File(dir));</span><br><span class="line">        <span class="comment">//添加监听器</span></span><br><span class="line">        observer.addListener(<span class="keyword">new</span> FileListener());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileAlterationMonitor(interval,observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileMonitorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileAlterationMonitor monitor = <span class="keyword">new</span> FileListenerFactory().getMonitor();</span><br><span class="line">            monitor.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java小功能实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java小功能实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit测试多线程的问题</title>
      <link href="/2022/01/04/Bug%E4%B9%8B%E7%8E%8B/%E5%85%B3%E4%BA%8EJunit%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B5%8B%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/01/04/Bug%E4%B9%8B%E7%8E%8B/%E5%85%B3%E4%BA%8EJunit%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B5%8B%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Junit测试多线程的问题"><a href="#Junit测试多线程的问题" class="headerlink" title="Junit测试多线程的问题"></a>Junit测试多线程的问题</h1><p>今天在用写一个用WatchService做文件监控的时候使用Junit测试，实现Runnable接口，重写run方法，明明run方法里写的死循环，使用Junit一测试，啥都没干，自动给我执行完了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainMonitor mainMonitor = <span class="keyword">new</span> MainMonitor();</span><br><span class="line">        mainMonitor.monitor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控线程重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchServiceRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchServiceRunnable</span><span class="params">(WatchService watchService,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.watchService=watchService;</span><br><span class="line">        <span class="keyword">this</span>.path=path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                WatchKey watchKey = watchService.take();</span><br><span class="line">                List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">                <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">                    System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                            <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">                &#125;</span><br><span class="line">                watchKey.reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我直接重新写一个for循环，打印数字，也不能正常输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">                Thread.currentThread().setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在输出&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整了半天，发现Junit并不能直接测试多线程。Junit单元测试当主线程执行完毕时，主线程会关闭，并且关闭子线程。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>使用join()等待子线程执行完毕</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    thread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainMonitor mainMonitor = <span class="keyword">new</span> MainMonitor();</span><br><span class="line">        mainMonitor.monitor();</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>还可以使用CountDownLatch类</li></ol><p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件系统安全</title>
      <link href="/2021/12/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
      <url>/2021/12/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-软件、程序、软件工程、软件系统、软件质量"><a href="#1-软件、程序、软件工程、软件系统、软件质量" class="headerlink" title="1.   软件、程序、软件工程、软件系统、软件质量"></a>1.   软件、程序、软件工程、软件系统、软件质量</h3><p>软件：程序+文档 程序：算法+数据结构</p><p>软件工程包含的研究内容：软件开发模型、软件开发方法，软件支持过程，软件管理过程。</p><p>软件系统是指由系统软件、支撑软件和应用软件组成的计算机软件系统，它是计算机系统中由软件组成的部分。</p><p>软件质量是指软件符合</p><ul><li>明确定义的功能和性能需求</li><li>明确规定的开发标准和准则</li><li>满足隐含要求的其它特性的程度</li></ul><p>软件质量是反映软件产品满足规定和潜在需求能力的特性的总和，描述和评价软件产品质量的一组属性常称为软件质量特性。</p><h3 id="2-软件构造过程存在哪些安全隐患"><a href="#2-软件构造过程存在哪些安全隐患" class="headerlink" title="2.   软件构造过程存在哪些安全隐患"></a>2.   软件构造过程存在哪些安全隐患</h3><p>软件安全主要包括的三个方面：</p><p>软件自身安全(软件缺陷与漏洞)：软件在开发时可能由于不安全编码等因素造成的软件在特定方面的缺陷与漏洞</p><p>恶意软件攻击：攻击者会利用软件的漏洞植入恶意代码，或者通过恶意的软件病毒比如木马，后门，蠕虫等等对系统进行攻击</p><p>软件逆向分析(软件破解)：通过对软件进行逆向分析，发现软件的注册机制，从而破解软件</p><h3 id="3-软件系统存在安全问题的本因"><a href="#3-软件系统存在安全问题的本因" class="headerlink" title="3.   软件系统存在安全问题的本因"></a>3.   软件系统存在安全问题的本因</h3><p>在软件设计之处，并没有结合到实际完全考虑到软件自身运行情况和可能面临的互联网环境下的复杂性，导致软件开发后存在不少的漏洞与缺陷，在面临异常环境时无法按照正常的预期的流程运行，降低了软件的动态行为可信性。</p><h3 id="4-从软件工程的视角如何预防软件系统安全缺陷"><a href="#4-从软件工程的视角如何预防软件系统安全缺陷" class="headerlink" title="4.   从软件工程的视角如何预防软件系统安全缺陷"></a>4.   从软件工程的视角如何预防软件系统安全缺陷</h3><p>强化软件工程思想，将安全问题融入到软件的开发管理流程之中，在软件开发阶段尽量减少软件缺陷和漏洞的数量。采用标准的软件工程开发模型与流程，合理的风险评估，严格要求整个开发生命周期，做到软件缺陷与漏洞的最小化。</p><h3 id="5-软件危机"><a href="#5-软件危机" class="headerlink" title="5.   软件危机"></a>5.   软件危机</h3><p>计算机软件的开发和维护过程中遇到的一系列严重问题。</p><ul><li>主要表现：<ul><li>开发成本和进度估计不准确</li><li>用户对已完成的软件不满意</li><li>软件产品质量不高</li><li>软件常常不可维护</li><li>软件没有文档资料</li><li>软件成本在总成本中占比上升</li><li>软件开发生产率赶不上硬件的发展速度也跟不上计算机应用普及的速度。</li></ul></li></ul><h3 id="6-可信软件"><a href="#6-可信软件" class="headerlink" title="6.可信软件"></a>6.可信软件</h3><p>软件系统的运行行为及其结果总是符合人们的预期，在受到干扰时仍能提供连续的服务。</p><p>包含安全性(safety，security)、可靠性、可用性、可维护性、机密性、完整性、可控性等等。</p><ul><li>safety：软件运行不引起危险、灾难的能力</li><li>security：软件系统对数据和信息提供保密性、 完整性、可用性、真实性保障的能力</li><li>reliability：在给定的环境下特定的时间内软件无失效运行的概率</li><li>maintainability：软件系统或部件修改错误、提高性能和属性，或是适应新环境的难易程度</li><li>survivability：（网络）软件在受到攻击或失效时提供基本服务并在规定时间内恢复所有服务的能力</li></ul><h3 id="7-软件安全"><a href="#7-软件安全" class="headerlink" title="7.软件安全"></a>7.软件安全</h3><p>软件规模的扩大，软件开发集成和演化越来越复杂，导致软件产品推出时会有已知或者未知的缺陷。就好比现在操作系统都是先推出使用后续再慢慢维护，更新。</p><p>软件的运行和开发环境从传统的静态转换到了动态的互联网环境下，安全风险更大。</p><p>计算机病毒和黑客地下产业链活动，软件漏洞增多，传播速度加大。</p><h3 id="8-信息与信息安全"><a href="#8-信息与信息安全" class="headerlink" title="8.信息与信息安全"></a>8.信息与信息安全</h3><p>信息以物质介质为载体，传递和反映世界各种事物存在的方式和运动状态的特征。信息是比较抽象的，有人说具有价值的消息就是信息，总之关键词就是价值、消除不确定性。</p><p>信息安全是对信息的保密性、完整性和可用性的保持。</p><h3 id="9-软件安全威胁及其来源；"><a href="#9-软件安全威胁及其来源；" class="headerlink" title="9.软件安全威胁及其来源；"></a>9.软件安全威胁及其来源；</h3><ul><li>软件缺陷与漏洞：软件开发时对软件自身运行环境和外部因素考虑不周导致出现的缺陷和漏洞。</li><li>恶意软件攻击：为了实现一些恶意目的的软件程序，比如计算机病毒、特洛伊木马、后门等等。</li><li>软件破解：对软件的逆向分析，破解软件的使用。</li></ul><h3 id="10-如何加强软件安全保护"><a href="#10-如何加强软件安全保护" class="headerlink" title="10.如何加强软件安全保护"></a>10.如何加强软件安全保护</h3><ul><li>从<strong>软件工程</strong>的角度来说，加强软件工程思想，让软件开发走标准的软件工程过程，将安全问题融入到软件的开发流程管理之中，在软件开发阶段尽量减少软件缺陷和漏洞的数量。</li><li>保证软件自身运行环境，加强系统自身的<strong>数据完整性校验</strong>。</li><li>加强系统自身软件的行为认证——<strong>软件动态可信认证</strong></li><li>恶意软件检测与查杀</li><li>黑客攻击防护——主机防火墙，HTPS</li><li>系统还原</li><li>虚拟机、沙箱技术</li></ul><h3 id="11-计算机的引导过程（简答）"><a href="#11-计算机的引导过程（简答）" class="headerlink" title="11.计算机的引导过程（简答）"></a>11.计算机的引导过程（简答）</h3><p>主要可分为四个阶段</p><ul><li>BIOS：首先进行硬件自检(POST power on self test)，如果发现有硬件故障会通过喇叭发声，然后按照启动顺序选择从哪个设备启动。</li><li>主引导记录(MBR)：读取设备的前512字节，判断设备能否启动，不能启动则按启动顺序尝试启动下一个设备。然后BIOS会一次遍历主分区找到激活分区。</li><li>硬盘启动：计算机会读取激活分区的第一个扇区即卷引导记录(VBR)，VBR告诉计算机操作系统位于该分区的哪个位置，然后计算机就可以开始加载操作系统了。</li><li>操作系统：首先载入操作系统的内核，然后加载各个模块，驱动程序以及服务启动，最后系统自启动程序。</li></ul><h3 id="12-PE文件格式"><a href="#12-PE文件格式" class="headerlink" title="12.PE文件格式"></a>12.PE文件格式</h3><p>PE是Win32环境自身所带的可执行的文件格式。它的一些特性继承自UNIX的COFF文件格式。</p><p>可移植的执行体意味着此文件格式是跨Win32平台的，即使Windows运行在非Intel的CPU上，任何Win32平台的PE装载器都能识别和使用该文件格式。</p><p>移植到不同的CPU上PE执行体必须得有一些改变。除了VxD和16位的DLL外，所有Win32执行文件都使用PE文件格式。因此，研究PE文件格式是我们洞悉 Windows结构的良机。</p><h3 id="13-软件漏洞成因分析"><a href="#13-软件漏洞成因分析" class="headerlink" title="13.软件漏洞成因分析"></a>13.软件漏洞成因分析</h3><p>软件脆弱性成因即形成软件脆弱性的原因。<strong>软件脆弱性成因</strong>包括导致软件脆弱性形成的<strong>内部因素</strong>和<strong>外部因素</strong>两个方面。</p><ul><li>内部因素主要是软件本身的<strong>不安全编码</strong>导致的内部安全缺陷，数据校验不当，类型初始化不当，空指针使用不当</li><li>外部环境因素指的是<strong>软件运行所在的外部环境因素</strong>，其主要包括接口参数(IP)，机器内存(M)，进程(PRS)，注册信息(REG)，代码(CD)，网络(NET)，磁盘文件系统(DF)等方面。因此外部环境因素可以进一步表示为以下形式：EM = {IP，M，DF，PRS，NET，REG，CD}。</li></ul><h3 id="14-漏洞按照成因分类"><a href="#14-漏洞按照成因分类" class="headerlink" title="14.漏洞按照成因分类"></a>14.漏洞按照成因分类</h3><p>按照漏洞的成因分类：输入验证错误、访问验证错误、竞争条件错误、意外情况处理错误、设计错误、配置错误以及环境错误。</p><h3 id="15-漏洞的一般特征及其描述"><a href="#15-漏洞的一般特征及其描述" class="headerlink" title="15.漏洞的一般特征及其描述"></a>15.漏洞的一般特征及其描述</h3><ol><li>脆弱性是软件系统中一个隐藏的弱点（Fault，F），它本身并不会造成错误，但被攻击者利用之后可能会产生严重的安全后果（Result，R），形式化的表示为：F→R</li><li>在软件开发过程中，开发人员自觉或不自觉的引入的逻辑错误（LF）是大多数脆弱性（SV）的根本来源，形式化的表示为：LF→SV</li><li>脆弱性的特征还与系统本身运行时的环境（EM）有关，不同的运行环境也有可能造成不同的脆弱性问题，形式化的表示为：EM→SV</li><li>旧的脆弱性（FSV）遭到修复后也有可能引入新的脆弱性（CSV）问题，形式化的表示为：FSV→CSV</li></ol><h3 id="16-漏洞分类及其标准"><a href="#16-漏洞分类及其标准" class="headerlink" title="16.漏洞分类及其标准"></a>16.漏洞分类及其标准</h3><ul><li>按漏洞可能对系统造成的直接威胁划分<ul><li>获取访问权限漏洞、权限提升漏洞、拒绝服务攻击漏洞、恶意软件植入漏洞、数据丢失或泄露漏洞</li></ul></li><li>按漏洞的成因划分<ul><li>输入验证错误、访问验证错误、竞争条件错误、意外情况处理错误、设计错误、配置错误、环境错误</li></ul></li><li>按漏洞的严重等级<ul><li>高级漏洞：远程和本地管理员权限</li><li>中级漏洞：普通用户权限、权限提升、读取受限文件以及远程和本地拒绝服务</li><li>低级漏洞：服务器信息泄露</li></ul></li><li>按漏洞被利用的方式<ul><li>本地攻击、远程主动攻击、远程被动攻击</li></ul></li></ul><h3 id="17-常见的软件漏洞分类"><a href="#17-常见的软件漏洞分类" class="headerlink" title="17.常见的软件漏洞分类"></a>17.常见的软件漏洞分类</h3><p>常见的软件漏洞大概分为8类：</p><ul><li><strong>代码注入</strong>：恶意代码的注入</li><li>缓冲错误：缓冲区溢出</li><li>跨站脚本：XSS攻击，植入代码脚本，保存型XSS漏洞：先把脚本存在数据库，等读取出来的时候有可能执行脚本</li><li>权限许可和访问控制：未检查返回值导致空指针解引用，空指针异常</li><li>SQL注入：攻击者输入携带可能被执行的危险指令或者恒成立条件进入数据库做正常的查询等操作，导致数据库错误的执行命令。</li><li>输入验证：没有做校验工作，比如没有校验生成的值为0导致0除异常</li><li>格式化字符串：输出非法格式化字符串导致输出了内存中的数据</li><li>竞争条件：并发编程对资源的共享可能造成内存泄露、系统崩溃</li></ul><h3 id="18-不安全编码分类"><a href="#18-不安全编码分类" class="headerlink" title="18.不安全编码分类"></a>18.不安全编码分类</h3><p>数据校验不当DO、类型初始化不当TI、空指针引用不当NP、返回操作不当RV、数字操作不当NO、类与方法操作不当CM、异常处理不当EO、多线程处理不当MT、IO操作不当IO、序列化操作不当SO、权限控制不当RC</p><h3 id="19-典型的软件漏洞机理分析（成因图分析法）"><a href="#19-典型的软件漏洞机理分析（成因图分析法）" class="headerlink" title="19.典型的软件漏洞机理分析（成因图分析法）"></a>19.典型的软件漏洞机理分析（成因图分析法）</h3><p>漏洞成因影响因素表：</p><p><img src="/../../img/markdown_img/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8.assets/image-20211224211315230.png" alt="image-20211224211315230"></p><p>软件脆弱性成因图由两部分构成：内因和外因。</p><ul><li><p>内因：指系统本身的不安全编码。如数据校验不当、类型初始 化不当、空指针使用不当、返回值操作不当、数字操作不当等。</p></li><li><p>外因：主要考虑的是接口参数（IP）、内存(M)、磁盘文件系统(DF)、进程(PRS)、 网络(NET)、注册环境信息(REG)和外部代码(ED)等影响因素。</p></li></ul><p>软件脆弱性的成因复杂，一部分脆弱性是内因作用的结果，另 一部分则是内因和外因共同作用的结果。</p><p>软件漏洞成因影响因素及其简称：</p><p><img src="/../../img/markdown_img/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8.assets/image-20211224212016072.png" alt="image-20211224212016072"></p><h3 id="20-软件漏洞的利用和发现"><a href="#20-软件漏洞的利用和发现" class="headerlink" title="20.软件漏洞的利用和发现"></a>20.软件漏洞的利用和发现</h3><h4 id="Exploit漏洞利用程序"><a href="#Exploit漏洞利用程序" class="headerlink" title="Exploit漏洞利用程序"></a>Exploit漏洞利用程序</h4><p>Exploit(漏洞利用程序)是针对某一特定漏洞或一组漏洞而精心编写的漏洞利用程序。其可以触发特定漏洞从而获得系统的控制权。</p><p>分为两个部分：被注入到目标进程触发漏洞获得执行权限的二进制串，以及代表攻击者意图的代码。</p><h4 id="漏洞利用的具体技术"><a href="#漏洞利用的具体技术" class="headerlink" title="漏洞利用的具体技术"></a>漏洞利用的具体技术</h4><ul><li>修改内存变量</li><li>修改代码逻辑</li><li>修改函数返回地址</li><li>修改函数指针</li><li>攻击异常处理机制</li><li>修改P.E.B中线程同步函数的入口地址</li></ul><h3 id="21-软件漏洞检测方法"><a href="#21-软件漏洞检测方法" class="headerlink" title="21.软件漏洞检测方法"></a>21.软件漏洞检测方法</h3><p>目前主流的软件漏洞挖掘方法有Fuzzing技术、安全扫描技术、静态分析、动态分析、基于二进制的检测分析技术等。</p><p>UltraEdit可以用于打开任意类型的文件，可以以二进制的形式查看文件的内容。可以用UltraEdit来检测文件的类型，包括未知文件类型。</p><p>OllyDBG是一个程序调试器，OllyDBG结合了静态和动态调试的方法，通过实时的反应出内存和程序执行的关系来进行程序的调试，可以用来检测漏洞，比如缓冲区溢出、内存泄露等等。可以编写好带有缓冲区溢出的程序，编译链接成exe文件，然后放到OllyDBG中执行，设置断点，实时观察内存地址、反汇编窗口，信息窗口以及堆栈信息等可以分析出程序的漏洞。</p><h4 id="静态漏洞挖掘工具"><a href="#静态漏洞挖掘工具" class="headerlink" title="静态漏洞挖掘工具"></a>静态漏洞挖掘工具</h4><ol><li>cppcheck<ul><li>静态的C/C++代码分析工具，用以检查内存泄露、缓冲区溢出以及更多问题</li></ul></li><li>SPLINT<ul><li>使用规则检查技术，支持对C/C++使用规则找到大规模程序故障，由于给定规则的限制，也就只能找到给定的故障</li></ul></li><li>FindBugs<ul><li>根据词汇分析和数据流分析，支持对Java的静态代码漏洞挖掘。该工具自带检测器Detector，开发者还可以根据自己的需求设计编写特定的缺陷检测器</li></ul></li><li>PMD<ul><li>也是Java的静态代码分析工具</li></ul></li></ol><h4 id="动态漏洞挖掘工具"><a href="#动态漏洞挖掘工具" class="headerlink" title="动态漏洞挖掘工具"></a>动态漏洞挖掘工具</h4><ol><li>MiniFuzz<ul><li>模糊测试技术(fuzzing)，简单易用，原理清晰</li></ul></li><li>AFL<ul><li>动态二进制插桩技术，比较高效</li></ul></li><li>Hodor<ul><li>污点跟踪技术，应用范围广</li></ul></li><li>Boofuzz<ul><li>模糊测试技术，简单易用，发生错误更少。内置多个模块，比如会话(Session)模块，Session对象是fuzz会话的中心；连接模块，Connection可以选择TCP、UDP等多种套接字连接。运行http用例，boofuzz通过事前约定好的数据进行测试，最后同时也可以在localhost的26000端口网页端查看检测日志。</li></ul></li></ol><h3 id="22-恶意代码分类及各自特点"><a href="#22-恶意代码分类及各自特点" class="headerlink" title="22.恶意代码分类及各自特点"></a>22.恶意代码分类及各自特点</h3><p>恶意代码也叫恶意软件，广义上的计算机病毒。可以分为以下几种：</p><ul><li><p>计算机病毒、蠕虫</p><ul><li><strong>计算机病毒</strong>是一种可以自我传播、需要用户干预（或者说不能独立运行、需要宿主程序激活）来触发执行的破坏性程序或者代码</li><li><strong>网络蠕虫</strong>是一种可以自我传播、但不需要用户干预（或者说可以独立运行）就可以触发执行的破坏性程序或代码</li></ul></li><li><p>木马、后门</p><ul><li><strong>特洛伊木马</strong>指看起来具有正常功能，但实际上却隐藏得有用户不希望的功能程序。通常由控制端和被控制端两端组成</li><li><strong>后门</strong>是使得攻击者可以非法获取到系统的权限来操作系统的一类程序。后门程序包括了木马程序，后门主要是获取到系统的权限就像给攻击者开了一个后门一样，以方便随时利用这个系统，木马就是隐藏在正常程序中的一段有恶意目的的代码或者文件，可以用来记录密码、记录键盘、删除文件等功能。</li></ul></li><li><p>Rootkit</p><ul><li><strong>Rootkit</strong>通过修改现有的操作系统软件，使得攻击者获取访问权并隐藏在计算机中的程序</li></ul></li><li><p>僵尸程序(bot)</p><ul><li><strong>僵尸程序</strong>通过聊天室，文件共享网络感染存在漏洞的计算机，这些感染的计算机就相当于被攻击者控制。</li></ul></li><li><p>流氓软件、间谍软件</p><ul><li><strong>流氓软件</strong>就是具有一定的实用价值但是具备电脑病毒和黑客软件的部分特征的软件（特点就是难以卸载）</li><li><strong>间谍软件</strong>是会收集用户计算机上的信息、机密文件或者隐私数据上报到服务器</li></ul></li><li><p>广告软件、Exploit、黑客工具等</p><ul><li><strong>广告软件</strong>未经过用户允许，直接下载并且安装或者说与其他软件以捆绑软件一起下载下来，一直弹出广告并且难以根除的程序</li><li><strong>Exploit</strong>是精心设计的用于特定漏洞利用来对目标系统实施攻击的程序</li><li><strong>黑客工具</strong>是各类直接或间接用于网络和主机渗透的软件，比如各种扫描器、后门植入工具、密码嗅探器、提权工具等</li></ul></li></ul><h3 id="23-如何更加科学地对恶意软件进行分类和命名"><a href="#23-如何更加科学地对恶意软件进行分类和命名" class="headerlink" title="23.如何更加科学地对恶意软件进行分类和命名"></a>23.如何更加科学地对恶意软件进行分类和命名</h3><p>目前互联网的发展，各种恶意软件层出不穷，防不胜防，一步小心就会给计算机带来麻烦。恶意软件的行为日益泛化，我们要进行分类可以分析软件的原理或者说按照恶意软件的功能就行划分，比如提权类的恶意软件、给普通计算机用户仅仅是造成不良好体验的流氓软件等类似这种功能的方面进行一个分类。其次，我们还可以建立一个恶意软件的标准危险等级，按照它对于计算机的一个威胁程度进行分类，威胁越大的等级越高。最后我们还可以用魔法打败魔法，采用人工智能，基于深度学习来进行恶意代码分类。</p><h3 id="24-流氓软件及其特点"><a href="#24-流氓软件及其特点" class="headerlink" title="24.流氓软件及其特点"></a>24.流氓软件及其特点</h3><p>流氓软件是属于恶意软件中的一种。流氓软件它本身其实是具有一定的实用价值，比如某2345，它本身可以给你提供一些压缩文件或者防病毒的功能，但是它会安装它的全家桶让你实在是难以接受，通常还会类似一个广告软件弹出各种广告。所以流氓软件就是具有一定实用价值具备电脑病毒和黑客软件部分特征的软件。其最大的特点就是对于普通用户来说难以卸载。</p><h3 id="25-网络蠕虫功能结构及工作机制"><a href="#25-网络蠕虫功能结构及工作机制" class="headerlink" title="25.网络蠕虫功能结构及工作机制"></a>25.网络蠕虫功能结构及工作机制</h3><p>蠕虫的功能模型包含有基本功能模块和扩展功能模块。</p><ul><li>基本功能模块包含有：<ul><li>信息收集模块：完成对本地和目标节点主机的信息汇集，为发现易感染目标提供支持</li><li>扫描探测模块：发现易感染主机群体</li><li>攻击渗透模块：利用已发现的服务漏洞实施攻击</li><li>自我推进模块：完成对目标节点的感染</li></ul></li><li>扩展功能模块主要取决于攻击者的目的，通常有：<ul><li>实体隐藏模块：主要提供蠕虫的生存能力。对蠕虫各个实体组成部分的隐藏、加密、变形</li><li>宿主破坏模块：破坏被感染主机网络正常运行，在被感染主机上植入后门</li><li>信息通信模块：使蠕虫间、蠕虫同黑客间进行通信</li><li>远程控制模块：控制被感染主机，执行攻击者下达的指令</li><li>自动升级模块：随时更新模块功能，实现持续攻击</li></ul></li></ul><h3 id="26-蠕虫的检测与防治"><a href="#26-蠕虫的检测与防治" class="headerlink" title="26.蠕虫的检测与防治"></a>26.蠕虫的检测与防治</h3><p>对于网络管理者和安全厂商比较典型的检测技术有流量监测与分析技术、安全软件监测等。当检测出蠕虫后进行防治可以采用网关阻断，补丁下发，网络安全设备阻断，利用客户端安全软件清除蠕虫个体并进行补丁修补。</p><p>对于个人用户来说，检测与防治蠕虫还是通过一些安全防护软件来进行，及时修护漏洞补丁，使用防火墙软件阻断等。</p><h3 id="27-木马的通信方式、连接方式及各自优缺点"><a href="#27-木马的通信方式、连接方式及各自优缺点" class="headerlink" title="27.木马的通信方式、连接方式及各自优缺点"></a>27.木马的通信方式、连接方式及各自优缺点</h3><p>木马的通信方式：传输通道构建信息，IP地址、端口等信息、第三方网站地址等。</p><p>建立通信连接的方式主要有正向连接和反向连接两种，反向连接又分为两种方式</p><ul><li><p>正向连接</p><ul><li><p>控制端（客户端）主动连接被控端（服务端）。创建服务器端TCP套接字，打开端口监听，连接服务器端口，采用TCP建立连接</p></li><li><p>优点：由控制端主动连接被控端，因此攻击者无需外部的IP地址；木马样本不会泄露攻击者的IP地址</p></li><li><p>缺点：可能会被防火墙阻断，被攻击者必须具备外部IP地址，定位被攻击者相对困难</p></li></ul></li><li><p>反向连接-1</p><ul><li>被控端直接连接控制端</li><li>优点：通过防火墙相对容易；攻击目标随时上线、随时控制；可以控制局域网内的目标</li><li>缺点：样本会暴露控制服务器信息(域名或者IP)，攻击者通常要具有外部IP</li></ul></li><li><p>反向连接-2</p><ul><li>被控端通过一个第三方肉鸡(傀儡机，受黑客远程控制的电脑)或者Web服务器和控制端间接的通信。</li><li>优点：可以绕过防火墙，自动连接上线，不易被发现</li><li>缺点：第三方服务器的稳定性需要保证</li></ul></li></ul><h3 id="28-PE病毒感染关键技术及实现过程"><a href="#28-PE病毒感染关键技术及实现过程" class="headerlink" title="28.==PE病毒感染关键技术及实现过程=="></a>28.==PE病毒感染关键技术及实现过程==</h3><ol><li><p>病毒感染重定位</p><p>由于病毒要用到变量（或常量），病毒感染HOST程序后，由于病毒代码的各个变量在内存中的位置会随HOST程序的大小不同而发生变化，因此病毒必须对病毒代码中的变量进行重定位。病毒代码目标寄生位置不固定。</p></li><li><p>获取API函数地址</p><p>病毒代码没有引入函数机制的支持，所以病毒必须自己获取API函数的地址。首先获取Kernel32的基地址，再从Kernel32中得到API函数的地址</p></li><li><p>目标程序遍历搜索</p><p>通常以PE文件格式的文件作为感染目标，进行搜索时调用FindFirstFile和FindNextFile两个API</p></li><li><p>文件感染</p><p>主要包括使病毒代码能够得到运行，并且原程序的正常功能不能被破坏。这就需要感染时记录原始“程序控制点位置”，病毒代码执行完毕后返回控制权。避免重复感染：感染标记</p></li></ol><h3 id="30-Windows-PE病毒的常用感染方式及优缺点"><a href="#30-Windows-PE病毒的常用感染方式及优缺点" class="headerlink" title="30.Windows PE病毒的常用感染方式及优缺点"></a>30.Windows PE病毒的常用感染方式及优缺点</h3><p>添加新节感染：增加新节存放病毒代码，要事先检查节表空间是否足够</p><p>碎片式感染：代码分解插入到节之间的填充部分</p><p>插入式感染：病毒代码插入到HOST文件的代码节，这样会增加HOST程序大小，并且可能会修改HOST程序中的数据导致HOST程序运行失败</p><p>伴随式感染：备份HOST程序，用自身替换HOST程序，病毒代码执行完毕再把控制权交回HOST程序。</p><h3 id="31-宏病毒传播过程"><a href="#31-宏病毒传播过程" class="headerlink" title="31.宏病毒传播过程"></a>31.宏病毒传播过程</h3><p>宏病毒将代码放到数据文件或者模板的宏中，由于这些宏会自动执行，因此获取控制权。宏病毒在单机情况下就是Office文档模板传播，在网络情况下也可能通过邮件进行传播。通过让宏在数据文档和文档模板两类文件之间互相感染进行传播。自我保护、代码导出（到本地文件）、代码导入（到当前活动文档）。</p><h3 id="32-常见的病毒检测技术及优缺点"><a href="#32-常见的病毒检测技术及优缺点" class="headerlink" title="32.常见的病毒检测技术及优缺点"></a>32.常见的病毒检测技术及优缺点</h3><ol><li>特征值检测技术<ul><li>从病毒中提取病毒特征值进行检测，通常是病毒中的一段或者多段字符串或二进制串</li><li>优点：检测速度快，误报率低，技术成熟</li><li>缺点：只能检测已知的恶意代码，容易被免杀绕过</li></ul></li><li>校验和检测技术<ul><li>检查检测对象的实际校验和与预期的是否一致，判断是否感染</li><li>优点：方法简单，能发现未知病毒，目标文件的细微变化也能发现</li><li>缺点：必须预先记录正常文件的校验和才能做对比，误报率高，不能识别病毒名称，效率低</li></ul></li><li>启发式扫描技术<ul><li>恶意代码检测经验和知识的软件实现</li><li>优点：能发现未知病毒</li><li>缺点：误报率高</li></ul></li><li>虚拟机检测技术<ul><li>在内存中模拟一个小的封闭程序执行环境，所有待查的文件在其中被虚拟执行</li><li>优点：有效处理加密类病毒；虚拟机技术+特征值扫描，准确率更高；虚拟机技术+启发式扫描，有利于检测未知变形病毒</li></ul></li><li>主动防御技术<ul><li>也叫行为监控技术，动态监视API接口的调用，判断其程序执行的合法，监控敏感行为</li><li>优点：可发现未知恶意软件，可准确的发现未知恶意软件的恶意行为</li><li>缺点：误报率高，不能识别恶意软件名称，实现困难</li></ul></li></ol><h3 id="33-恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性"><a href="#33-恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性" class="headerlink" title="33.恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性"></a>33.恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性</h3><h4 id="特征值检测技术对抗方式"><a href="#特征值检测技术对抗方式" class="headerlink" title="特征值检测技术对抗方式"></a>特征值检测技术对抗方式</h4><ol><li><p>事后对抗，手工修改自身特征：</p><ul><li>首先利用反病毒软件定位特征值，然后做针对性修改。原理就是定位到检测软件检测到的特征值然后做针对性修改来逃过检测。不同的特征值检测方式可能不同，并且也不止一处特征值。需要灵活的使用特征码定位工具。</li></ul></li><li><p>事前对抗，自动修改自身特征：</p><ul><li>通过加密、多态、变形等，对病毒代码进行加密混淆，使其逃过特征值检测软件。编写这种代码非常的耗时，并且仅仅适用于恶意程序自我复制的情况。但现在因为基于行为的反病毒检测手段出现后，这种对抗的有效性也降低了。</li><li>加壳处理，通过对代码加壳实现数据特征的变化，体积的压缩，实现程序的免杀</li></ul></li></ol><h4 id="人工分析对抗"><a href="#人工分析对抗" class="headerlink" title="人工分析对抗"></a>人工分析对抗</h4><ol><li><p>在病毒代码编写过程中加入自我保护手段(反汇编、反调试代码等)</p></li><li><p>直接采用第三方软件（加壳软件）增强病毒程序的人工分析难度。</p><p>所谓加壳就是加入一段程序，专门负责保护其不被非法修改或者反编译的程序。但是采用的加壳软件也可能会有对应的脱壳软件，会反对抗到加壳，使得加壳无效。</p></li></ol><h3 id="34-面对恶意软件样本，分析目标，分析方法"><a href="#34-面对恶意软件样本，分析目标，分析方法" class="headerlink" title="34.面对恶意软件样本，分析目标，分析方法"></a>34.面对恶意软件样本，分析目标，分析方法</h3><ol><li>恶意软件样本分析的分析目标：<ul><li>理解恶意软件的工作原理和行为特征</li><li>实现或完善相应的安全检测机制</li><li>实现对已有恶意软件和未知恶意软件的防御、检测</li></ul></li><li>恶意软件样本分析的分析方法：<ul><li>在线分析：<strong>在线病毒扫描</strong>、<strong>在线行为分析</strong></li><li>本地静态分析：<strong>加壳检测与脱壳</strong>、<strong>反汇编/反编译</strong>、资源分析</li><li>本地动态分析：快照对比分析、<strong>行为监控分析</strong>、<strong>调试跟踪</strong>、<strong>网络监控分析</strong>、<strong>运行环境仿真</strong></li><li>网络交互的动态分析：网络连接选择、网络交互环境仿真、<strong>数据包捕获分析</strong></li></ul></li></ol><h3 id="35-常见的加壳类型检测工具"><a href="#35-常见的加壳类型检测工具" class="headerlink" title="==35.常见的加壳类型检测工具=="></a>==35.常见的加壳类型检测工具==</h3><h3 id="36-针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？"><a href="#36-针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？" class="headerlink" title="36.针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？"></a>36.针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？</h3><p>对于已知病毒我们可以先查看病毒是否进行过加壳处理，如果加壳了则需要用脱壳技术进行解密，然后可以利用特征值检测技术，或者用虚拟机检测技术进行检测，然后虚拟机检测+特征值结合可以提高检测效率。</p><p>对于未知病毒的检测方法有校验和检测技术，可以发现未知的恶意代码，但是这样的方法需要提前对文件有一个校验和的预期，才能同被植入了恶意代码的文件做对比。其次还可以采用启发式扫描结合虚拟机技术来实现对未知病毒的检测，提高检测的准确率。也可以用主动防御技术，监控程序API接口调用，进行逻辑分析，识别出恶意软件，但是这样的实现有些复杂，比较困难。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全协议基础</title>
      <link href="/2021/12/24/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/12/24/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="Http和Https协议的端口号："><a href="#Http和Https协议的端口号：" class="headerlink" title="Http和Https协议的端口号："></a>Http和Https协议的端口号：</h3><p>Http：80  Https：443</p><h3 id="网络监听："><a href="#网络监听：" class="headerlink" title="网络监听："></a>网络监听：</h3><p>网络监听是一种监视网络状态、数据流程以及网络上信息传输的工具，它可以将网络界面设定成监听模式，并且可以截获网络上所传输的信息。但是网络监听只能应用于连接同一网段的主机，通常被用来获取用户密码等。也就是说，当黑客登录网络主机并取得超级用户权限后，若要登录其它主机，使用网络监听便可以有效地截获网络上的数据，这是黑客使用最好的方法。</p><h3 id="非对称密码算法："><a href="#非对称密码算法：" class="headerlink" title="非对称密码算法："></a>非对称密码算法：</h3><p>RSA（密钥分配，也能用于加解密数据，“私钥加密，公钥解密”和“公钥加密，私钥解密”）、DH（密钥分配，不能用于加解密）、DSA、ECC算法建立在有限域上椭圆曲线的离散对数问题的难解性。</p><h3 id="攻击行为："><a href="#攻击行为：" class="headerlink" title="攻击行为："></a>攻击行为：</h3><p>窃听 篡改 重放攻击 预重放 反射 类型缺陷攻击 协议交互攻击 拒绝服务攻击 密码分析 协议交互。</p><p>主动攻击是指攻击者对某个连接中通过的协议数据、单元进行各种处理。</p><p>被动攻击是指攻击者通过窃听消息来达到攻击目的；</p><p>选择出主动攻击</p><ul><li><p>被动攻击：截获</p></li><li><p>主动攻击：中断、篡改、伪造</p></li></ul><h3 id="防止用户被冒名所欺骗的方法："><a href="#防止用户被冒名所欺骗的方法：" class="headerlink" title="防止用户被冒名所欺骗的方法："></a>防止用户被冒名所欺骗的方法：</h3><p>对信息源进行身份验证 </p><h3 id="Kerberos认证支持的加密算法："><a href="#Kerberos认证支持的加密算法：" class="headerlink" title="Kerberos认证支持的加密算法："></a>Kerberos认证支持的加密算法：</h3><p>Kerberos采用的加密算法是DES</p><h3 id="ISAKMP安全关联和密钥管理协议："><a href="#ISAKMP安全关联和密钥管理协议：" class="headerlink" title="ISAKMP安全关联和密钥管理协议："></a>ISAKMP安全关联和密钥管理协议：</h3><p>一种协议框架，定义了<strong>有效负载的格式、实现密钥交换协议的机制以及SA协商</strong>。使用<strong>UDP的端口500</strong>，一般使用UDP。</p><p>从宏观上来看，ISAKMP主要做了三件事情：</p><ol><li><p><strong>SA协商</strong></p><p> SA协商的目的是为了在通信双方间协商出一组双方都认可的安全参数。比如两端采用相同的加密算法和完整性算法。</p></li><li><p><strong>密钥交换</strong>  </p><p>密钥交换的目的是为已经协商好的算法生成必要的密钥信息。</p></li><li><p><strong>对等端身份认证</strong></p><p>认证的目的是鉴别对方的身份，保证自己不是在跟一个伪造的对象通信。</p></li></ol><p>这样，通过一系列的消息交互，通信的双方既鉴别了对方的身份，也保证了后继通信的安全性。</p><h3 id="IPSEC的典型应用："><a href="#IPSEC的典型应用：" class="headerlink" title="IPSEC的典型应用："></a>IPSEC的典型应用：</h3><ul><li>端到端安全</li><li>基本VPN支持</li><li>保护移动用户访问内部网</li><li>嵌入式隧道</li></ul><h3 id="Kerberos实体认证采用的身份凭证："><a href="#Kerberos实体认证采用的身份凭证：" class="headerlink" title="Kerberos实体认证采用的身份凭证："></a>Kerberos实体认证采用的身份凭证：</h3><p>口令，票据；虹膜，指纹</p><h3 id="网络安全需求有哪些："><a href="#网络安全需求有哪些：" class="headerlink" title="网络安全需求有哪些："></a>网络安全需求有哪些：</h3><p>机密性、完整性、可控性、不可否认性、可用性</p><h3 id="IPSEC规定的2个组件："><a href="#IPSEC规定的2个组件：" class="headerlink" title="IPSEC规定的2个组件："></a>IPSEC规定的2个组件：</h3><ol><li>SAD（安全关联数据库）</li><li>SPD（安全策略数据库）</li></ol><h3 id="网络安全协议的基础："><a href="#网络安全协议的基础：" class="headerlink" title="网络安全协议的基础："></a>网络安全协议的基础：</h3><p>密码学</p><h3 id="SSL报文最终封装在什么环境："><a href="#SSL报文最终封装在什么环境：" class="headerlink" title="SSL报文最终封装在什么环境："></a>SSL报文最终封装在什么环境：</h3><ul><li>在SSL协议中，所有的传输数据都被封装在<strong>记录</strong>中进行投递</li><li>而对于总体而言，封装在<strong>传输层报文</strong>中传递</li></ul><h2 id="什么是以破坏认证协议为目标的实体"><a href="#什么是以破坏认证协议为目标的实体" class="headerlink" title="什么是以破坏认证协议为目标的实体"></a>什么是以破坏认证协议为目标的实体</h2><p>攻击者是以破坏认证协议为目标的实体</p><h2 id="Kerberos用什么来进行认证"><a href="#Kerberos用什么来进行认证" class="headerlink" title="Kerberos用什么来进行认证"></a>Kerberos用什么来进行认证</h2><p>票据</p><h3 id="IPSec、AH、ESP、IKE："><a href="#IPSec、AH、ESP、IKE：" class="headerlink" title="IPSec、AH、ESP、IKE："></a>IPSec、AH、ESP、IKE：</h3><p>IKE：互联网密钥交换协议，对应IPSec的协商阶段</p><p>AH：认证首部，对应IPSec的数据交互阶段，规定了报文格式以及对报文的处理方式和处理过程。AH只提供认证功能，不加密，仅计算消息验证码（ICV，完整性校验值）</p><p>ESP：封装安全载荷，对应IPSec的数据交互阶段。ESP同时提供机密性和完整性保护，这意味着ESP会加密报文，同时计算ICV。</p><h4 id="AH提供的三类安全服务："><a href="#AH提供的三类安全服务：" class="headerlink" title="AH提供的三类安全服务："></a>AH提供的三类安全服务：</h4><ul><li>数据完整性</li><li>数据源发认证</li><li>抗重放攻击</li></ul><h4 id="ESP提供的五类安全服务："><a href="#ESP提供的五类安全服务：" class="headerlink" title="ESP提供的五类安全服务："></a>ESP提供的五类安全服务：</h4><ul><li>数据完整性</li><li>抗数据源发认证</li><li>抗重放攻击</li><li>机密性</li><li>有限的传输流机密</li></ul><h1 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h1><h3 id="重放攻击："><a href="#重放攻击：" class="headerlink" title="重放攻击："></a>重放攻击：</h3><p>重放攻击是针对安全协议的最常见攻击，重放攻击指的是攻击者参与到协议的交互过程，利用窃听到的已经发送过的部分或全部消息，在交互过程中重新发送，来干涉协议的正常运行。</p><h3 id="前向安全："><a href="#前向安全：" class="headerlink" title="前向安全："></a>前向安全：</h3><p>一个协议具备前向安全，是指即便安全协议中使用的长期密钥被攻击者破获，而由这些长期密钥所建立（通过安全协议建立）的<strong>会话密钥</strong>仍然是安全的。如果对于协议中的任何主体，都能保证他们长期密钥的前向安全，那么这个协议提供了前向安全。</p><h3 id="类型缺陷攻击："><a href="#类型缺陷攻击：" class="headerlink" title="类型缺陷攻击："></a>类型缺陷攻击：</h3><p>消息最终是由一系列的二进制比特串组成的，类型缺陷攻击使得诚实主体对它所接收的消息发送了错误的理解，使得诚实主体把一次性随机数，时间戳或者身份等信息嵌入到某个密钥中去，进而导致协议安全性被破坏。</p><h3 id="并行会话攻击："><a href="#并行会话攻击：" class="headerlink" title="并行会话攻击："></a>并行会话攻击：</h3><p>是指攻击者安排协议的一个或多个会话并行地执行，使得自己能够从一个会话中获得消息，并通过重放到其他并行的会话中以达到自己的目的，如针对NSPK的并行会话攻击。</p><h3 id="中间人攻击："><a href="#中间人攻击：" class="headerlink" title="中间人攻击："></a>中间人攻击：</h3><p>中间人攻击就是攻击者在协议参与者双方分别进行冒充通信。攻击者先冒充参与方A与参与方B进行协议的运行，然后又冒充参与方B与参与方A进行协议的运行，但事实上参与者双方并没有感受到。</p><h3 id="IPSec："><a href="#IPSec：" class="headerlink" title="IPSec："></a>IPSec：</h3><p>TLS（安全传输层协议）可以对应用层的协议加密，并传递给传输层，但在IP层并不做任何安全性处理。IP作为其他高层协议的载体，本身并未考虑安全性问题。IPSec就是用来在IP层进行安全处理，对于高层数据，只要是通过IP传输，都会在IP层进行安全防护，实现IP数据包的机密性、完整性等安全特性，为上层协议提供“透明”的安全服务。</p><h3 id="IPSec协议的组件（什么是IPSec协议，从协议组件上回答）"><a href="#IPSec协议的组件（什么是IPSec协议，从协议组件上回答）" class="headerlink" title="IPSec协议的组件（什么是IPSec协议，从协议组件上回答）"></a>IPSec协议的组件（什么是IPSec协议，从协议组件上回答）</h3><p>IPSec是一个协议套件，<strong>核心协议是IKE、AH和ESP</strong>。其中<strong>IKE</strong>完成通信<strong>对等端身份验证、SA协商和密钥交换功能</strong>，是一个<strong>协商协议</strong>；<strong>AH和ESP是数据通信协议</strong>，他们规定了IPSec的报文格式和报文的处理过程。</p><h3 id="SSL协议："><a href="#SSL协议：" class="headerlink" title="SSL协议："></a>SSL协议：</h3><p>SSL（安全套接字协议）协议是一种增强传输层安全的协议，其协议套件由握手，更改密码规范，警告和记录协议组成。</p><ul><li>握手提供算法协商、密钥生成和身份验证功能。</li><li>更改密码规范协议用以通告对等端用新的安全参数来保护数据。</li><li>警告则同时具备安全断连和错误通告功能。</li><li>记录协议是SSL的数据承载层。</li></ul><h3 id="SSH协议的解释（SSH会话安全）："><a href="#SSH协议的解释（SSH会话安全）：" class="headerlink" title="SSH协议的解释（SSH会话安全）："></a>SSH协议的解释（SSH会话安全）：</h3><p>SSH是一个应用层安全协议，端口号为22。可以对数据进行加密，身份认证，完整性校验等。SSH由传输层协议，用户认证协议和连接协议构成，主要用于远程登录会话和为其他网络服务提供安全性的协议。</p><h3 id="Kerberos协议："><a href="#Kerberos协议：" class="headerlink" title="Kerberos协议："></a>Kerberos协议：</h3><p>Kerberos是一项认证服务。它提供一种验证用户身份的方法。它的实现不依赖于主机操作系统的认证，不基于主机的地址，也不需要有主机物理安全性的保证，并假设网络上传输的包都可以被任意地读取、修改和插入。</p><h3 id="散列函数的特征："><a href="#散列函数的特征：" class="headerlink" title="散列函数的特征："></a>散列函数的特征：</h3><ol><li>映射分布均匀性和差分分布均匀性</li><li>单向性</li><li>抗冲突性</li></ol><h3 id="数据认证性："><a href="#数据认证性：" class="headerlink" title="数据认证性："></a>数据认证性：</h3><p>数据认证性保证数据来源的合法性，通常也包含了对数据完整性的保证，这是因为修改数据相当于改变数据的来源。尽管在理论上，可以在不保证数据认证性的情况下保证数据的完整性，它们仍常通过相同的机制实现。</p><h3 id="密钥建立的目标："><a href="#密钥建立的目标：" class="headerlink" title="密钥建立的目标："></a>密钥建立的目标：</h3><p>密钥建立是一个过程，通过这个过程，可以使得两个或者多个主体拥有良好的共享秘密，以用于后继的密码学运算。</p><h3 id="针对SSL攻击方法："><a href="#针对SSL攻击方法：" class="headerlink" title="针对SSL攻击方法："></a>针对SSL攻击方法：</h3><blockquote><p><strong>中间人攻击，野兽攻击，罪恶攻击，溺水攻击，降级攻击</strong><br>主要是围绕通讯过程，加密方式，旧版本漏洞展开攻击。</p></blockquote><ol><li>中间人攻击：</li></ol><ul><li>SSL sniffing攻击解释为伪装攻击，一般结合ARP欺骗构成一个中间人攻击。它是一种针对ssl协议的应用发起的攻击。</li><li>SSL stripping攻击：是在客户端和服务器端，利用ARP欺骗等技术进行的一个中间人攻击（重定向网址）</li></ul><ol start="2"><li><p>BEAST（野兽攻击）<br>BEAST是一种明文攻击，通过从SSL/TLS加密的会话中获取受害者的COOKIE值（通过进行一次会话劫持攻击），进而篡改一个加密算法的 CBC（密码块链）的模式以实现攻击目录，其主要针对TLS1.0和更早版本的协议中的对称加密算法CBC模式。</p></li><li><p>CRIME（罪恶攻击）<br>CRIME(CVE-2012-4929)，全称Compression Ratio Info-leak Made Easy，<strong>这是一种因SSL压缩造成的安全隐患</strong>，通过它可窃取启用数据压缩特性的HTTPS或SPDY协议传输的私密Web Cookie。在成功读取身份验证Cookie后，攻击者可以实行会话劫持和发动进一步攻击。</p></li><li><p>DROWN（溺水攻击/溺亡攻击）<br>即利用过时的、<strong>弱化的一种RSA加密算法</strong>来解密破解TLS协议中被该算法加密的会话密钥。 具体说来，DROWN漏洞可以利用过时的SSLv2协议来解密与之共享相同RSA私钥的TLS协议所保护的流量。 DROWN攻击依赖于SSLv2协议的设计缺陷以及知名的Bleichenbacher攻击。</p></li><li><p>Downgrade（降级攻击）<br>降级攻击是一种对计算机系统或者通信协议的攻击，在降级攻击中，攻击者故意使系统放弃新式、安全性高的工作方式，反而使用为向下兼容而准备的老式、安全性差的工作方式，降级攻击常被用于中间人攻击，将加密的通信协议安全性大幅削弱，得以进行原本不可能做到的攻击。 在现代的回退防御中，使用单独的信号套件来指示自愿降级行为，需要理解该信号并支持更高协议版本的服务器来终止协商，该套件是TLS_FALLBACK_SCSV(0x5600)</p></li></ol><h3 id="Kerberos的票据和认证符的功能："><a href="#Kerberos的票据和认证符的功能：" class="headerlink" title="Kerberos的票据和认证符的功能："></a>Kerberos的票据和认证符的功能：</h3><ol><li>进行身份认证（用户及服务器）</li><li>防止IP地址伪造和重放攻击</li><li>加密数据</li><li>保护子会话密钥</li></ol><p>票据提供服务器（TGS）</p><p>认证服务器（AS）</p><ul><li>票据：为避免口令认证的缺陷，Kerberos引入票据许可服务，它只向已由AS（认证服务器）认证了身份的客户端颁发票据，避免了明文口令的传输。</li><li>认证符：认证符的作用是验证客户的身份，客户不仅要传输票据，还需要发送额外的信息来证明自己确实是票据的合法拥有者，这个信息就是认证符（authenticator），它使用会话密钥加密，并包含了用户名和时间戳。</li></ul><h1 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h1><h3 id="windows下的IPSec实验："><a href="#windows下的IPSec实验：" class="headerlink" title="windows下的IPSec实验："></a>windows下的IPSec实验：</h3><ol><li>安装Wireshark软件</li><li>操作机配置IPsec加密策略</li><li>目标机配置同样的IPsec加密策略，操作机和目标机同时指派策略，查看之间通信</li><li>用Wireshark查看密钥交换过程</li></ol><h3 id="Windows下的SSL实验："><a href="#Windows下的SSL实验：" class="headerlink" title="Windows下的SSL实验："></a>Windows下的SSL实验：</h3><ol><li>搭建证书服务器</li><li>搭建web服务器端SSL证书应用</li><li>搭建Https的网站</li><li>目标机用Sniffer监测两者间的SSL连接</li></ol><p>优点</p><p>SSL在应用层协议通信前就<strong>已完成加密算法</strong>，<strong>通信密钥的协商</strong>及<strong>服务器认证</strong>工作，此后应用层协议所传送的<strong>所有数据都会被加密</strong>，从而保证通信的安全性。</p><p>缺点</p><p>SSL除了<strong>传输过程外不能提供任何安全保证</strong>；<strong>不能提供交易的不可否认性</strong>；客户认证是可选的，所以无法保证购买者就是该信用卡合法拥有者；SSL不是专为信用卡交易而设计，在多方参与的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。</p><p>工作原理<br>　　客户机向服务器发送SSL版本号和选定的加密算法；服务器回应相同信息外还回送一个含RSA公钥的数字证书；客户机检查收到的证书足否在可信任CA列表中，若在就用对应CA的公钥对证书解密获取服务器公钥，若不在，则断开连接终止会话。客户机随机产生一个DES会话密钥，并用服务器公钥加密后再传给服务器，服务器用私钥解密出会话密钥后发回一个确认报文，以后双方就用会话密钥对传送的报交加密。</p><h1 id="协议分析："><a href="#协议分析：" class="headerlink" title="协议分析："></a>协议分析：</h1><h3 id="NSPK协议的攻击："><a href="#NSPK协议的攻击：" class="headerlink" title="NSPK协议的攻击："></a>NSPK协议的攻击：</h3><p>NSPK协议提供了对主体双方的双向认证。主体A和B交换各自的随机数Na、Nb，从而共享Na和Nb，并将其结合以生成一个新的会话密钥。PKa和PKb分别为A和B的公开密钥。</p><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152024386.png" alt="image-20211105152024386"></p><blockquote><p><strong>并行会话攻击：攻击者Z首先使A发起一个会话，然后在另一个会话中，攻击者成功地冒充了A。</strong></p></blockquote><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152120732.png" alt="image-20211105152120732"></p><h3 id="大嘴青蛙协议的攻击："><a href="#大嘴青蛙协议的攻击：" class="headerlink" title="大嘴青蛙协议的攻击："></a>大嘴青蛙协议的攻击：</h3><p>会话密钥由主体产生，可信第三方将这个会话密钥传送给另外的主体，Ta、Ts分别为A、S根据各自的本地时钟产生的时间戳。S通过Ta来检查Msg1的新鲜性。如果Msg1是新鲜的，S则将密钥Kab连同自己产生的时间戳Ts发送给B。B 收到Msg2后，检查其中的Ts，若Ts位于时间窗口内，B则认为Kab是新鲜的。5</p><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152228421.png" alt="image-20211105152228421"></p><blockquote><p>并行会话攻击：</p><ul><li><p>攻击者冒充B，向S重放S刚刚发送给B的消息。S收到后，由于Ts在时间窗口内，故认可Msg1，并产生 一个新的时间戳Ts‘，发送消息Msg2’。</p></li><li><p>接着，攻击者再冒充A，S会产生一个更新的时间戳 Ts‘’，并发送消息Msg2‘’。</p></li><li><p>这最终导致攻击者能够从S得到一个“时间戳足够新，但Kab足够老”的消息，并将其发送给B，使B接受一个老的密钥</p></li></ul><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152250491.png" alt="image-20211105152250491"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDN的TopoGuard解决方案</title>
      <link href="/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/TopoGuard/"/>
      <url>/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/TopoGuard/</url>
      
        <content type="html"><![CDATA[<h1 id="SDN攻击和对策"><a href="#SDN攻击和对策" class="headerlink" title="SDN攻击和对策"></a>SDN攻击和对策</h1><h2 id="SDN攻击"><a href="#SDN攻击" class="headerlink" title="SDN攻击"></a>SDN攻击</h2><h3 id="1-主机位置劫持攻击"><a href="#1-主机位置劫持攻击" class="headerlink" title="1. 主机位置劫持攻击"></a>1. 主机位置劫持攻击</h3><p>对于主机位置的改变，由于SDN控制器缺乏对传输的数据包认证步骤，无法保证拓扑信息的真实性，攻击者通过发送伪装的主机消息，就可以实现对网络中的主机的伪装。如下图所示，攻击者向SDN交换机发送一个全新的数据包，交换机会上报到控制器，因为无法认证数据包的真实性，控制器会依据这个数据包默认网络服务器位置发生移动，然而实际上由于拓扑管理信息中该服务器的位置已经变更为攻击者所在的位置，导致后续正常主机无法访问该服务器。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211118094512908.png" alt="image-20211118094512908"></p><h3 id="2-链路伪造攻击"><a href="#2-链路伪造攻击" class="headerlink" title="2. 链路伪造攻击"></a>2. 链路伪造攻击</h3><p>由于目前广泛使用的SDN控制器源码是开源的，因此任何人都可以获取LLDP包格式和每个字段的语义，并且交换机每个端口都可以发送链路层发现协议（LLDP）包，包括连接着主机的端口。</p><h4 id="伪造LLDP包"><a href="#伪造LLDP包" class="headerlink" title="伪造LLDP包"></a>伪造LLDP包</h4><p>攻击者可以通过监控SDN交换机的流量然后伪造出相应的LLDP包，后续伪造的LLDP将会被发送到控制器，因此控制器便更新一条攻击者伪造的链路。</p><h4 id="重放LLDP包"><a href="#重放LLDP包" class="headerlink" title="重放LLDP包"></a>重放LLDP包</h4><p>从一个目标交换机接收到一个LLDP数据包时，攻击者将直接重放到另一目标交换机，而无需进行任何修改。如下图，攻击者将收到的LLDP包通过隧道、物理链路等方式将LLDP包发送给另一目标交换机，这样攻击者便构造了一个虚假的拓扑视图。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211118094555756.png" alt="image-20211118094555756"></p><h3 id="3-拒绝服务攻击"><a href="#3-拒绝服务攻击" class="headerlink" title="3. 拒绝服务攻击"></a>3. 拒绝服务攻击</h3><p>为了避免boardcast strom，OpenFlow控制器提供生成树服务。当网络拓扑更新时，会触发生成树服务来阻止冗余端口。这种能力可能会被攻击者利用，以发动拒绝服务攻击。比如通过给现有拓扑注入一个虚假的链接，攻击者就可以借用生成树服务来杀死正常开关端口。</p><p>生成树算法总是排除连接最大DPID交换机的链接。攻击者拥有几个连接到入口交换机的几个受损主机，通过收听LLDP数据包，对手就可以获得两个入口交换机的的DPID。然后，攻击控制受损主机通过较低的DPID连接到入口交换机，并注入假LLDP以与目标交换机宣布链接。</p><p>最终将导致两种情况：如果聚合交换机的DPID小于所选交换机的DPID，则攻击者可以关闭目标交换机的任意端口，如图a所示；如果所选择的交换机具有最小的DPID，则目标交换机和聚合交换机之间的链路被排除在生成树之外，并且相应端口也会被阻塞，如图b所示。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211118095722939.png" alt="image-20211118095722939"></p><h3 id="4-中间人攻击"><a href="#4-中间人攻击" class="headerlink" title="4. 中间人攻击"></a>4. 中间人攻击</h3><p>虚假的链路可以干扰最短路径路由服务。攻击者可以构建一个LLDP channel来欺骗OpenFlow控制器，让控制器感觉在两个目标交换机之间还存在一个内部链路（实际上并不存在）。一旦控制器注意到了链路，它就会根据这个受到污染的拓扑信息来重新计算最短路径。这样所有与虚假链路有连接的路线都被攻击者进行了污染。但是，OpenFlow与传统的以太网交换机不同，它并不会修改数据包的源MAC地址。因此为了规避可能的异常检测，我们必须在重放LLDP和普通数据包的时保留源MAC地址。</p><h2 id="防御策略"><a href="#防御策略" class="headerlink" title="防御策略"></a>防御策略</h2><h3 id="1-静态防御策略"><a href="#1-静态防御策略" class="headerlink" title="1. 静态防御策略"></a>1. 静态防御策略</h3><p>静态防御策略是预先手动配置/管理主机位置和链路信息（比如，将主机标识符（比如MAC地址）分配给一个特定的交换机端口），然后每当有新的改变时（new addition or removal）手动验证和修改。显然，静态防御策略并不是一个很好的选择，因为手动的去管理是特别繁琐的，容易出错，并且在实践中也不好扩展。特别地，它并不适用于动态的并且有可扩展性的需求的SDN网络。</p><h3 id="2-动态防御策略TopoGuard"><a href="#2-动态防御策略TopoGuard" class="headerlink" title="2. 动态防御策略TopoGuard"></a>2. 动态防御策略TopoGuard</h3><h4 id="2-1-主机位置劫持攻击的动态防御策略"><a href="#2-1-主机位置劫持攻击的动态防御策略" class="headerlink" title="2.1 主机位置劫持攻击的动态防御策略"></a>2.1 主机位置劫持攻击的动态防御策略</h4><p>主机位置劫持攻击的问题主要在于，当主机位置更新的时候，OpenFlow控制器缺乏了对主机标识符的验证。</p><h5 id="2-1-1-主机实体认证"><a href="#2-1-1-主机实体认证" class="headerlink" title="2.1.1 主机实体认证"></a>2.1.1 主机实体认证</h5><p>这是一个密码学的加密解决方案：添加额外的公钥来验证主机。当一个主机需要改变它的位置的时候，它就把新的位置信息通过私钥加密到数据包中没使用的部分（比如VLAN ID or ToS）。</p><p>这个方案理论上确实是可行的，可以解决恶意主机的profile伪造，因为攻击者无法获取目标主机的私钥。但是在现实上，这种方案需要增加额外的存储开销来保存OpenFlow控制器的公钥，以及用于处理每个Packet-In数据包的计算开销。并且，所有主机的密钥管理和动态添加/修改也会带来额外的开销和成本。此外，这种方法需要在每个主机上修改实现，实际部署上非常的繁琐和困难。</p><h5 id="2-1-2-主机迁移合法性的验证"><a href="#2-1-2-主机迁移合法性的验证" class="headerlink" title="2.1.2 主机迁移合法性的验证"></a>2.1.2 主机迁移合法性的验证</h5><blockquote><p>主机迁移完成的条件：</p></blockquote><ul><li>主机迁移的前置条件是OpenFlow控制器必须接收到一个Port_Down信号在主机迁移完成之前</li><li>主机迁移的后置条件是主机在完成迁移之后，对先前位置的主机实体的访问是不可达的。</li></ul><p>因此，基于上述两种情况，我们可以通过检查前置条件和后置条件来验证主机迁移的合法性。若有一个条件不满足，那么可能原主机位置被劫持，与控制器进行通信的主机是攻击者伪造的主机，这样就会被检测到。这个方法也增加了额外的开销，但是比较上面基于公私钥的实体认证相比，显然此方法更加轻量级。</p><p>在面向SDN的车载边缘计算中我们也可以利用这种模型，来对抗主机位置劫持的攻击。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222850617.png" alt="image-20211224222850617"></p><h4 id="2-2-链路伪造攻击的动态防御策略"><a href="#2-2-链路伪造攻击的动态防御策略" class="headerlink" title="2.2 链路伪造攻击的动态防御策略"></a>2.2 链路伪造攻击的动态防御策略</h4><blockquote><p>链路伪造的攻击主要在两个方面：</p></blockquote><ul><li><p>在OpenFlow网络的链路发现过程中，LLDP包的完整性/来源可能遭到破坏</p></li><li><p>受损主机参与LLDP传播路径</p><h5 id="2-2-1-LLDP数据包的身份验证"><a href="#2-2-1-LLDP数据包的身份验证" class="headerlink" title="2.2.1 LLDP数据包的身份验证"></a>2.2.1 LLDP数据包的身份验证</h5><p>解决这个问题的一个方案是在LLDP数据包中添加额外的身份验证器TLVs。比如，我们可以在LLDP数据包中添加一个有控制器签名的TLV，并在接收到LLDP数据包时检查签名。签名TLV是通过LLDP数据包中的DPID和端口号都计算的。这样，攻击者很难操纵LLDP数据包。然而这种方法，无法抵抗基于LLDP重放/隧道的方式的链路伪造攻击。</p><h5 id="2-2-2-交换机端口属性的验证"><a href="#2-2-2-交换机端口属性的验证" class="headerlink" title="2.2.2 交换机端口属性的验证"></a>2.2.2 交换机端口属性的验证</h5><p>如果OpenFlow链路发现过程中没有主机参与到LLDP的传播，那么就可以判断没有攻击者进行链路伪造。因此可以检查是否有主机驻留在LLDP的链路传播中从而检测是否有攻击者参与。</p><p>我们可以增加一些额外的逻辑来跟踪来自不同交换机端口的流量，已决定哪个设备连接到哪个端口。如果 OpenFlow 控制器从特定的交换机端口检测到主机生成的流量（例如DNS），则我们将该端口的设备类型设置为 HOST。否则，当从这些端口接收到 LLDP 数据包时，我们将这些交换机端口指定为交换机。在 OpenFlow 网络中，这两个类型是相互排斥的，因为 LLDP 只能在交换机内部链路端口和连接到OpenFlow控制器的端口上传输。</p><p>这种方法的一个假设是：受损的主机不是一个实际的交换机，因此将生成常规的主机生成的流量（如ARP，DNS）。这假设也确实是合理的，在实践中大多数情况下也成立。虽然攻击者也可以禁用受损主机或者虚拟机中的所有主机生成流量，但它这样多少页破坏了主机的正常网络活动功能，无异于暴露自己，使得正常机器用户注意到。</p></li></ul><h2 id="TopoGuard"><a href="#TopoGuard" class="headerlink" title="TopoGuard"></a>TopoGuard</h2><p>TopoGuard的基本思想是通过修复上一节所提到的安全漏洞来确保控制器的安全。</p><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>下图展示了TopoGuard防御系统的体系结构。The Topology Update Checker在探测到拓扑更新后会去验证主机迁移的合法性，LLDP数据包的完整性和来源以及交换机端口属性。具体来说，Port Manager监视 OpenFlow 消息，以跟踪存储在Port Property（端口属性）中的交换机端口动态。然后，Port Property将用于推理拓扑更新的可信性。Host Prober（主机探测）用来测试在OpenFlow网络中特点位置的主机的活动性，并且判断主机迁移的合法性。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222838902.png" alt="image-20211224222838902"></p><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="端口属性管理"><a href="#端口属性管理" class="headerlink" title="端口属性管理"></a>端口属性管理</h4><p>为了推断拓扑更新的有效性，给OpenFlow控制器中每个交换机端口增加了额外属性。包括：</p><p>设备类型（Device Type）、主机列表（HOST List）和标识（SHUT_DOWN_FLAG）。</p><ol><li><p>设备类型</p><p>设备类型指的是一个特定交换机端口连接到的设备类型。该值可以是任意值ANY，交换机SWITCH，主机HOST。初始值是ANY，它将根据后续流量切换到SWITCH或者HOST。当端口管理器从具有设备类型为ANY的交换机端口接收LLDP数据包时，它会将其类型更改为SWITCH。同样，若接收到任何 first-hop 主机流量时，交换机端口的设备类型被设置为HOST。相反，当接收到端口状态信息中指示的Port_Down信号时，HOST和交换机端口值被设置为ANY。如果端口管理器检测到HOST端口的LLDP包或者交换机端口的first-hop主机流量包，则会引发攻击警报并通知拓扑更新检查器以防止相关拓扑更新。这种防御方法的认为LLDP数据包仅被设计为通过数据平面上的交换机内部链路端口。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222829755.png" alt="image-20211224222829755"></p></li></ol><ul><li><p>设备类型被判定为HOST说明交换机端口所连接到的设备类型是一个主机，而当端口管理器检测到主机端口发送的是LLDP数据包，那么可以认定发生了链路伪造的攻击。</p></li><li><p>设备类型被判定为SWITCH说明交换机端口所连接到的设备类型是一个交换机，而当端口管理器检测到主机端口发送的是主机流量数据包，那么就可以认为在链路发现的过程中有主机的参与，即是发生了攻击。</p></li></ul><ol start="2"><li><p>主机列表</p><p>端口属性管理的一个挑战是<strong>如何确定端口的设备类型为HOST。</strong>尽管上述中我们认为若接收到任何first-hop 主机流量时，交换机端口的设备类型被设置为HOST。但是在实际上，发现不同的OpenFlow交换机可能会为特定的主机流发出多个包内消息的副本，即<strong>OpenFlow控制器将从交换机内部链路端口接收主机流量。</strong></p><p>为了解决这个问题，在每个交换机端口的端口属性中维护<strong>主机列表</strong>，其中包含主机实体（MAC地址形式）。当接收到Packet-In消息时，端口管理器<strong>在现有端口属性的主机列表中定位主机实体。如果没有找到，则将流量视为first-hop流量，并将源MAC地址记录在入口交换机端口的端口属性的主机列表中。</strong></p></li><li><p>SHUT_DOWN_FLAG</p><p>主机列表的另一个作用是验证主机迁移的可信度。主机迁移的前置条件是控制器在主机迁移完成之前接收到一个Port_Down信号。此时一旦检测到该<strong>端口关闭</strong>，我们将为交换机端口的主机列表中的主机<strong>设置SHUT_DOWN_FLAG</strong>。当端口管理器从该端口接收到相关的主机流量时，可以禁用SHUT_DOWN_FLAG。此外，我们还可以验证主机列表中的SHUT_DOWN_FLAG，以验证主机迁移。</p></li></ol><h4 id="主机探测"><a href="#主机探测" class="headerlink" title="主机探测"></a>主机探测</h4><p>我们还可以利用主机探测器（Host Prober）来验证主机迁移的后置条件，即主机迁移完成后在前一个位置无法访问主机。</p><p>主机探测器向主机的前一个位置发出一个主机探测数据包，例如：IMCPEcho请求，并且设置一个合理的timeout（1s）等待响应。为了确保响应的成功交付，主机探测器还安装了一个流规则，以将 ICMP 响应引导回 OpenFlow 控制器。</p><h4 id="拓扑更新验证"><a href="#拓扑更新验证" class="headerlink" title="拓扑更新验证"></a>拓扑更新验证</h4><p>拓扑更新检查器将验证拓扑更新的正确性，包括主机迁移和新的链路发现。</p><ul><li><p><input disabled="" type="checkbox">  检测到主机迁移</p><p>检查器将引用<strong>端口属性</strong>来检查该<strong>前置条件</strong>，并指示<strong>主机探测</strong>程序验证该<strong>后置条件</strong>。</p></li><li><p><input disabled="" type="checkbox">  验证链路发现</p><p>第一个任务是确保 LLDP 的完整性/来源。为此，我们在一个LLDP 数据包中放置一个签名 TLV，这是一个 DPID 和端口号的加密哈希值。一旦发现一个新链路，拓扑更新检查器就会对已签名的哈希值 TLV 执行额外的验证逻辑。然后，拓扑更新检查器检测主机是否位于 LLDP 传播的路径上。通过检查新链路的交换机端口的设备类型来完成。因此，HOST 端口中涉及的任何内部链接更新都将被拒绝，并触发攻击警报。</p></li></ul><h2 id="传统网络的具体攻击方式"><a href="#传统网络的具体攻击方式" class="headerlink" title="传统网络的具体攻击方式"></a>传统网络的具体攻击方式</h2><h3 id="主机位置劫持"><a href="#主机位置劫持" class="headerlink" title="主机位置劫持"></a>主机位置劫持</h3><p>一个臭名昭著的主机位置劫持攻击是以太网网络中的 <strong>ARP 缓存毒化攻击</strong>。即攻击者发送伪造的 ARP 消息，以将目标主机的 IP 地址与恶意主机 的 MAC 地址关联起来。通过这样做，对手可以劫持目标主机的实体，这通常是一个网关。但是，ARP 缓存中毒攻击与主机位 置劫持攻击有几个不同，如下表所示。首先，ARP 高速缓存中 毒的攻击范围仅限于一个广播域，即对手必须与其目标保持在 同一广播域内。相比之下，对手可以在 OpenFlow 网络的任何位置发起主机位置劫持攻击。第二，除了 ARP 应答数据包外，主 机位置劫持攻击还可以利用几乎各种数据包，如 ICMPEcho、UDP 和 TCP，来篡夺目标主机的位置。在这一点上，主机位置劫持攻击可以隐藏在正常流量中，以避开 NIDS（网络入侵检测）。同样从防御的角度来看，传统的 ARP 缓存中毒缓解策略， 如静态 ARP 条目，可能不适合直接应用于 SDN 网络，因为其静态配置破坏了 OpenFlow 网络的动态处理能力。例如，跟踪各种 OpenFlow 访问点之间的主机迁移。为了抵御主机位置劫持攻击以及跟踪网络动态，在本文中，我们利用 OpenFlow 的特定功能来动态验证主机迁移。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222820222.png" alt="image-20211224222820222"></p><h3 id="链路伪造"><a href="#链路伪造" class="headerlink" title="链路伪造"></a>链路伪造</h3><p>在传统网络中，类似于链路伪造攻击的攻击是 <strong>STP 破坏</strong>（即 BPDU 伪造），即对手用最小的桥 ID 伪造 BPDUs，以抢占生成树的根。在伪造根之后，对手有可能精心策划拒绝服务或中间攻击。然而，STP 破坏攻击只会扰乱STP 的运行，而不是向网络拓扑中注入一个假的链路，以毒害整个网络操作。</p>]]></content>
      
      
      <categories>
          
          <category> SDN软件定义网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mininet的环境安装</title>
      <link href="/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/SDN/"/>
      <url>/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/SDN/</url>
      
        <content type="html"><![CDATA[<h1 id="Mininet"><a href="#Mininet" class="headerlink" title="Mininet"></a>Mininet</h1><h3 id="安装Mininet"><a href="#安装Mininet" class="headerlink" title="安装Mininet"></a>安装Mininet</h3><p><a href="http://mininet.org/download/#option-2-native-installation-from-source">http://mininet.org/download/#option-2-native-installation-from-source</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> git://github.com/mininet/mininet</span><br><span class="line">sudo mininet/util/install.sh -n3v<span class="comment">#-a基本不会成功</span></span><br><span class="line">sudo install.sh -h <span class="comment">#安装OpenFlow Wireshark分解器</span></span><br></pre></td></tr></table></figure><h3 id="Mininet命令"><a href="#Mininet命令" class="headerlink" title="Mininet命令"></a>Mininet命令</h3><h4 id="网络建构启动参数"><a href="#网络建构启动参数" class="headerlink" title="网络建构启动参数"></a>网络建构启动参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--topo自定义拓扑结构（最常用）</span><br><span class="line">--custom加载脚本拓扑</span><br><span class="line">--switch自定义要使用的交换机</span><br><span class="line">--controller自定义要使用的控制器</span><br><span class="line">--mac自动配置设备的MAC地址</span><br></pre></td></tr></table></figure><h5 id="–topo"><a href="#–topo" class="headerlink" title="–topo"></a>–topo</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --topo=single,3<span class="comment">#单一拓扑：交换机只有一个，下挂一个或多个主机</span></span><br><span class="line">sudo mn --topo=linear,4<span class="comment">#线性拓扑：交换机连接为线性排列，每个交换机所连接的主机数目只有一个</span></span><br><span class="line">sudo mn --topo=tree,depth=2,fanout=2<span class="comment">#树形拓扑：交换机连接成树形，depth为深度，叶子结点为主机，fanout为广度，即一个交换机下有多少个设备</span></span><br><span class="line">sudo mn --custom file.py --topo mytopo<span class="comment">#file.py最好替换成绝对路径 mytopo为file.py中的类名</span></span><br><span class="line">sudo mn --protocol=openflow13<span class="comment">#最小化拓扑，一个交换机，两个主机</span></span><br></pre></td></tr></table></figure><h5 id="–swicth"><a href="#–swicth" class="headerlink" title="–swicth"></a>–swicth</h5><p>默认使用OpenVSwitch交换机</p><h5 id="–controller"><a href="#–controller" class="headerlink" title="–controller"></a>–controller</h5><p>定义要使用的控制器，如果没有则使用mininet中默认的控制器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --controller=remote,--ip=[controller IP],--port=[port]<span class="comment">#remote表示远程控制器</span></span><br></pre></td></tr></table></figure><h5 id="–mac"><a href="#–mac" class="headerlink" title="–mac"></a>–mac</h5><p>自动设置设备的MAC地址，设置交换机的MAC、主机MAC及IP地址从小到大排序</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --topo=tree,depth=2,fanout=2,--mac<span class="comment">#直接在正常命令后面添加--mac即可</span></span><br></pre></td></tr></table></figure><h5 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --switch ovsk,protocols=OpenFlow13 --controller=remote,ip=192.168.31.139,port=6653 --topo=tree,depth=2,fanout=3</span><br><span class="line"><span class="comment">#交换机为Open vSwitch Kernel Mode，支持的协议为OpenFlow1.3，控制器为远程控制器，远程控制器的ip地址为192.168.31.139，端口为6653，拓扑为树形拓扑，深度为2，广度为3</span></span><br></pre></td></tr></table></figure><h4 id="内部交互命令"><a href="#内部交互命令" class="headerlink" title="内部交互命令"></a>内部交互命令</h4><h5 id="设备查看："><a href="#设备查看：" class="headerlink" title="设备查看："></a>设备查看：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump查看节点信息</span><br><span class="line">net查看链路信息</span><br><span class="line">nodes查看总共的节点</span><br><span class="line">links查看链路是否连通（不代表能ping通）</span><br><span class="line">intfs   查看网络接口信息</span><br><span class="line">pingpair只验证前两个主机的连通性</span><br><span class="line">pingall验证所有主机间的通信</span><br></pre></td></tr></table></figure><h5 id="设备操作："><a href="#设备操作：" class="headerlink" title="设备操作："></a>设备操作：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf两节点间进行iperftcp带宽测试</span><br><span class="line">iperfudp两节点间进行iperfudp带宽测试</span><br><span class="line">link禁用或开启节点间链路</span><br><span class="line">dpctl所有交换机上的流表</span><br><span class="line">xterm进入某个节点终端</span><br><span class="line">py执行python表达式</span><br></pre></td></tr></table></figure><h6 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf h1 h2</span><br></pre></td></tr></table></figure><h6 id="iperfudp"><a href="#iperfudp" class="headerlink" title="iperfudp"></a>iperfudp</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperfudp bw h1 h2</span><br></pre></td></tr></table></figure><h6 id="link"><a href="#link" class="headerlink" title="link"></a>link</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">link h1 s1 up<span class="comment">#禁用链路</span></span><br><span class="line">link h1 s1 down<span class="comment">#开启链路</span></span><br></pre></td></tr></table></figure><h6 id="dpctl"><a href="#dpctl" class="headerlink" title="dpctl"></a>dpctl</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpctl dump-flows</span><br><span class="line">dpctl dump-flows -O Openflow13  <span class="comment">#如果指定了使用openflow1.3协议则应这样输入</span></span><br></pre></td></tr></table></figure><h6 id="xterm"><a href="#xterm" class="headerlink" title="xterm"></a>xterm</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xterm h1</span><br></pre></td></tr></table></figure><h6 id="py"><a href="#py" class="headerlink" title="py"></a>py</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">py <span class="built_in">help</span>(s1)</span><br><span class="line">py dir(s1)</span><br><span class="line">添加主机的命令：<span class="comment">#原拓扑中为（h1，s1）（h2，s1）</span></span><br><span class="line">py net.addHost(<span class="string">&quot;h3&quot;</span>)<span class="comment">#添加h3主机</span></span><br><span class="line">py net.addLink(s1,net.get(<span class="string">&quot;h3&quot;</span>))<span class="comment">#添加s1与h3之间的链路</span></span><br><span class="line">py s1.attach(<span class="string">&quot;s1-eth3&quot;</span>)<span class="comment">#添加s1的eth3的接口</span></span><br><span class="line">py net.get(<span class="string">&quot;h3&quot;</span>).cmd(<span class="string">&quot;ifconfig h3-eth0 10.3&quot;</span>)  <span class="comment">#给h3添加ip地址（10.0.0.3）</span></span><br><span class="line">之后其他主机就可以ping通h3</span><br></pre></td></tr></table></figure><h4 id="外部运行参数"><a href="#外部运行参数" class="headerlink" title="外部运行参数"></a>外部运行参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c  清除配置</span><br><span class="line">-h  帮助</span><br></pre></td></tr></table></figure><h1 id="RYU"><a href="#RYU" class="headerlink" title="RYU"></a>RYU</h1><h3 id="安装RYU"><a href="#安装RYU" class="headerlink" title="安装RYU"></a>安装RYU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip python-dev build-essential</span><br><span class="line">sudo pip install --upgrade pip</span><br><span class="line">sudo apt-get install python-eventlet</span><br><span class="line">sudo apt-get install python-routes</span><br><span class="line">sudo apt-get install python-webob</span><br><span class="line">sudo apt-get install python-paramiko</span><br><span class="line">sudo pip install ryu</span><br></pre></td></tr></table></figure><h3 id="测试RYU"><a href="#测试RYU" class="headerlink" title="测试RYU"></a>测试RYU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ryu-manager</span><br><span class="line"><span class="comment">#如果出现 DistributionNotFound: webob&gt;=1.2 类似问题则输入sudo pip install --upgrade webob 即可，缺少什么就将“webob”替换成什么</span></span><br></pre></td></tr></table></figure><h3 id="启动RYU"><a href="#启动RYU" class="headerlink" title="启动RYU"></a>启动RYU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ryu-manager simple_switch_13.py  <span class="comment">#适用于OpenFlow 1.3协议</span></span><br></pre></td></tr></table></figure><h1 id="验证OpenFlow-1-3"><a href="#验证OpenFlow-1-3" class="headerlink" title="验证OpenFlow 1.3"></a>验证OpenFlow 1.3</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --switch ovs,protocols=OpenFlow13 --controller=remote,ip=192.168.31.139,port=6633  <span class="comment">#Mininet连接支持OpenFlow1.3的控制器</span></span><br><span class="line">sudo ovs-ofctl dump-flows -O openflow13 s1  <span class="comment">#查看交换机S1的流表</span></span><br></pre></td></tr></table></figure><p>也可用Wireshark对any端口进行抓包，可以捕捉到OpenFlow 1.3协议（需要筛选）</p>]]></content>
      
      
      <categories>
          
          <category> SDN软件定义网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 缓存穿透击穿与雪崩</title>
      <link href="/2021/12/17/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9/"/>
      <url>/2021/12/17/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<p>在生产环境中，会因为很多的原因造成访问请求绕过了缓存，都需要访问数据库持久层，虽然对Redis缓存服务器不会造成影响，但是数据库的负载就会增大，使缓存的作用降低</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p><strong>缓存穿透</strong>是指查询一个<strong>数据库一定不存在的数据</strong>。</p><p>正常的使用缓存流程大致是：数据查询先到缓存中查找key，发现key不存在或者已经过期，再对数据库进行查询，并把查询到的对象，数据存到缓存中。但是如果数据库为空，则不放进缓存。</p><p>缓存穿透：一个数据缓存中不存在，导致请求的数据走数据库，就会使得后端存储负载加大，然而数据库中也不存在。这种情况下如果有攻击者故意多次请求一个不存在的主键id（比如负数id），而这个负数id在数据库根本就没有，就有可能搞垮整个数据库，甚至使整个服务瘫痪。</p><p>造成缓存穿透的基本原因有两个。</p><ul><li>自身业务代码或者数据出现问题（例如：set 和 get 的key不一致）</li><li>一些恶意攻击、爬虫等造成大量空命中（爬取线上商城商品数据，超大循环递增商品的ID）</li></ul><h1 id="缓存穿透解决方案"><a href="#缓存穿透解决方案" class="headerlink" title="缓存穿透解决方案"></a>缓存穿透解决方案</h1><h2 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h2><p>缓存空对象是指：在持久层没有命中的情况下，仍然将数据进行缓存。把key的value设置为null，并设置过期时间。</p><h4 id="缓存空对象带来的问题"><a href="#缓存空对象带来的问题" class="headerlink" title="缓存空对象带来的问题"></a>缓存空对象带来的问题</h4><ol><li>缓存空对象设置key的value为空，但是仍然是占用了内存空间的，对空值做缓存，缓存中还需要去保存这个空值的key，消耗内存空间。因此我们要对这种空值设置一个过期时间，让一定时间过后自动过期。</li><li>缓存空对象可能带来缓存和数据库的数据有一段时间窗口内的不一致，可能会对业务造成影响。比如设置过期时间为1分钟，如果此时数据库又添加了这个数据，那么这段时间就会出现缓存和数据库的数据不一致。此时，可以利用消息系统或者其他方式清除缓存中的空对象。</li></ol><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><blockquote><p>布隆过滤器参照知乎[@YoungChen][<a href="https://zhuanlan.zhihu.com/p/43263751]%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E8%AE%B2%E5%BE%97%E9%9D%9E%E5%B8%B8%E6%B8%85%E6%A5%9A">https://zhuanlan.zhihu.com/p/43263751]的文章，讲得非常清楚</a></p></blockquote><p>布隆过滤器（Bloom Filter）本质是其实是一种概率型数据结构。它可以高效的查询和插入，但是不能删除。可以<strong>用来判断某个数一定不存在或者可能存在</strong>。</p><p>跟传统的list、set、map相比，因为布隆过滤器本质存的是二进制比特位，且不存key，所以它占用的空间更小。跟HashMap相比，HashMap可以根据特定的key查询到对应的value值，并且判断key是否存在的时间复杂度也很低O(1)。但是，HashMap既需要存key，还需要存value值，存储容量比较高，并且考虑到HashMap的负载因子，HashMap一般情况下会有空间的浪费的。数据一旦过高，用HashMap占用的空间可就太高的。</p><p>布隆过滤器的虽然占用的空间小，但是它不确定的判断某个key一定存在，只能说概率。</p><ul><li>实现原理</li></ul><p>布隆过滤器就是一个bit向量或者说bit数组。</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122091819486.png" alt="image-20211122091819486"></p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122091912029.png" alt="image-20211122091912029"></p><p>我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122092135911.png" alt="image-20211122092135911"></p><p>4这个bit位被“baidu”和“tencent”两都置1，因为4这个bit位是被覆盖了的。那么我们现在想查询一个值是否存在，假设这个值通过哈希函数映射到了1，5，7三个bit位上。发现5这个bit位上的值是0，那么就说明这个值一定是不存在的。如果它存在，则它的映射到的所有bit位都必须为1。</p><p>现在我们要查询”baidu”是否存在。通过哈希函数我们得到三个bit位1,4,7。我们发现这三个bit上全都是1，尽管如此，我们仍然不能说”baidu”这个值必然是存在的，因为不要忘记了4这个bit位，”tencent”也存为1过。那么或许有个数，它根本就没进来存过，却意外的被其他的key一起把这个数的bit位全置为1了，所以布隆过滤器不能认定一个key一定存在。</p><ul><li>哈希函数的个数选择和布隆过滤器的长度选择</li></ul><p>如果哈希函数的个数选择太少了，bit位的覆盖率就会变高，误报率就会变高。</p><p>如果哈希函数的个数选择太多了，每个bit位置1的速度就会加快，并且每次的哈希函数计算就是一个消耗资源的行为，布隆过滤器的效率就会降低。</p><p>如果布隆过滤器的长度设置太小了，那么每个bit位置1的速度也会加快，误报率同样会增加。</p><p>如果布隆过滤器的长度设置太大了，那么就意味着更多的空间。</p><p>对于哈希函数的个数和布隆过滤器的长度选择有一个公式：</p><p>m：布隆过滤器的长度    k：哈希函数的个数    n：插入元素的个数    p：误报率</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122093555700.png" alt="image-20211122093555700"></p><h2 id="Redis缓存穿透的布隆过滤器的解决方案"><a href="#Redis缓存穿透的布隆过滤器的解决方案" class="headerlink" title="Redis缓存穿透的布隆过滤器的解决方案"></a>Redis缓存穿透的布隆过滤器的解决方案</h2><p>根据上述布隆过滤器的描述，那么我们可以很好的将Redis的缓存穿透和布隆过滤器联系起来。</p><p>一个请求先去Redis缓存中去请求数据，缓存中并不存在，接着我们让这个请求进入布隆过滤器，去判断这个值是否存在，如果存在则再让这个请求进入到数据库中去查询。</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122095540985.png" alt="image-20211122095540985"></p><p>布隆过滤器的特性就是占用的空间相对较小，并且查询速度相比数据库也比较快，能支撑的QPS更高，可以很好的保护数据库。</p><p>分布式环境下，数据放到内存中来处理， 属于local cache 问题；如果想要保持一致性，可以通过数据变更时，群发MQ消息的方式让应用服务器实例更新。这个方案在数据变更频次很低而访接口QPS极高时，可以尝试。否则，当有实例 bloom filter数据未更新时， 在未更新这个间隔内，用户请求路由到不同实例，就会出现一下能查到，一下查不到奇怪现象。 如果数据变更频次很低时，也可以考虑把bloom fliter 数据写到配置中心里，让配置中心把数据推送到应用实例上。</p><h2 id="两种解决方案的对比"><a href="#两种解决方案的对比" class="headerlink" title="两种解决方案的对比"></a>两种解决方案的对比</h2><table><thead><tr><th>解决缓存穿透</th><th>适用场景</th><th>维护成本</th></tr></thead><tbody><tr><td>缓存空对象</td><td>数据命中不高<br />数据变更频次高</td><td>代码维护简单<br />需要过多的缓存空间来存key和null值<br />数据不一致</td></tr><tr><td>布隆过滤器</td><td>数据命中不高<br />数据变更频次低</td><td>代码维护复杂<br />缓存空间占用少</td></tr></tbody></table><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿是指一个热点key，并发量特别的大，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就击穿缓存，直接请求走数据库。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>设置热点数据过期时间</p><p>让过期时间更加均匀一点或者永不过期，这样就解决了热点key过期后的问题。当然这也会带来一些空间的问题。</p></li><li><p>加互斥锁</p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此需要等待。这种方式将高并发的压力转到分布式锁上，因此对分布式锁的考验很大。这样就会导致高并发场景下的性能降低。</p></li></ul><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是指：缓存不可用Redis宕机或者说大批缓存集体失效，大量的请求同时达到数据库，造成数据库系统雪崩。</p><p>产生雪崩的原因之一，比如马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122100233282.png" alt="image-20211122100233282"></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>针对缓存不可用这种情况可以提高缓存层的可用性，比如设计成分布式，Redis集群，配置哨兵模式和cluster实现。</li><li>服务降级（限流降级）：关闭一些服务，保证主要的服务可用。</li><li>数据预热：在正式部署之前，先把可能的数据先预访问一遍，这样部分可能大量访问的数据就会加载到缓存中，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 持久化及优化方式</title>
      <link href="/2021/12/17/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/12/17/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>因为Redis是内存数据库，一旦宕机，数据就会丢失，所以需要一种持久化的操作，将内存中的数据写到磁盘上保存。Redis本身提供了两种数据持久化方式：RDB和AOF。这两种方式各有其优点和缺点。</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>Redis默认的持久化方案就是RDB。RDB就是把数据以快照的形式保存到磁盘上。快照就类似于VMware上虚拟机快照的意思，把当前时刻状态记录下来。</p><p>RDB持久化是指在指定的时间间隔内，将内存中的数据集快照写入磁盘中。这样方式是将内存中的数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。</p><h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>save命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB持久化完成。这样对于内存比较大的服务器，会造成较长时间的阻塞，所以不太建议使用。</p><p>具体流程如下：</p><p><img src="/../../img/markdown_img/Redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211121091823127.png" alt="image-20211121091823127"></p><p>执行完成后如果存在旧的RDB文件，就会把旧的RDB文件替换成新的RDB文件。客户端数据太大的时候，这种方式显然不可取。</p><h3 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h3><p>bgsave命令Redis会在后台异步进行快照操作，同时Redis还可以响应客户端的请求。</p><p>具体操作是Redis主进程会执行fork操作创建一个子进程，然后RDB持久化过程由子进程负责，完成后自动结束。这样，尽管也会阻塞，但是阻塞只发生在fork阶段，基本上Redis内部所有的RDB操作都是bgsave命令。</p><p>具体流程如下：</p><p><img src="/../../img/markdown_img/Redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211121092857471.png" alt="image-20211121092857471"></p><h3 id="配置文件自动触发"><a href="#配置文件自动触发" class="headerlink" title="配置文件自动触发"></a>配置文件自动触发</h3><p>自动触发模式是需要我们在配置文件redis.conf中完成的。</p><p>配置save，这里的save 3600 1的意思是：如果3600秒内，至少有1个key值变化，就进行持久化。</p><p>在redis.conf配置文件中有配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># You can set these explicitly by uncommenting the three following lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># save 3600 1</span></span><br><span class="line"><span class="comment"># save 300 100</span></span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes<span class="comment"># 默认yes 当启用RDB且最后一次bgsave失败了，Redis是否停止接收数据</span></span><br><span class="line">rdbcompression yes<span class="comment"># 默认yes，存到磁盘的快照，可以设置是否进行压缩存储</span></span><br><span class="line">rdbchecksum yes<span class="comment"># 默认yes，存储快照后让redis进行数据校验，这样做会增加大约10%性能消耗</span></span><br><span class="line">dbfilename dump.rdb<span class="comment"># 快照文件名</span></span><br><span class="line">dir ./<span class="comment"># 快照文件存放路径</span></span><br></pre></td></tr></table></figure><h3 id="save与bgsave的比较"><a href="#save与bgsave的比较" class="headerlink" title="save与bgsave的比较"></a>save与bgsave的比较</h3><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞</td><td>是</td><td>是（仅在fork期间阻塞）</td></tr><tr><td>复杂度</td><td>O（n）</td><td>O（n）</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>fork，消耗额外内存</td></tr></tbody></table><p>除了上述三种方式，以下情况也会生成RDB文件：</p><ul><li>主从的全量复制时，主机会生成RDB文件。</li><li>Redis中的debug reload提供debug级别的重启，不清空内存的一种重启，这种方式也会触发RDB文件的生成。</li><li>执行shutdown时，会触发RDB文件的生成。</li><li>执行flushall命令，也会生成dump.rdb文件，但此时里面是空的。</li></ul><h2 id="RDB的优点和缺点"><a href="#RDB的优点和缺点" class="headerlink" title="RDB的优点和缺点"></a>RDB的优点和缺点</h2><p>优点</p><ul><li>RDB文件是全量备份，适合用于进行备份和数据恢复</li><li>生成RDB文件的时候，Redis主进程会fork( )一个子进程来处理所有保存的工作，主进程不需要进行任何磁盘IO操作</li><li>RDB在加载RDB恢复数据比AOF方式快</li></ul><p>缺点</p><ul><li>RDB是全量备份比较耗时，存储的是内存数据的二进制序列化形式，存储上非常紧凑。写RDB文件还是会消耗大量IO性能。</li><li>当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有主进程的内存数据，父进程如果在此时进行数据的修改，子进程并不知情，所有在持久化期间修改的数据不会被保存，如果此时宕机，就有可能丢失数据。即并不支持数据持久化的实时性。</li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>RDB的全量备份有些耗时，所以提出了另外一种持久化方式AOF。此外，AOF还可以解决数据持久化的实时性。</p><p>默认关闭AOF模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><h2 id="持久化原理"><a href="#持久化原理" class="headerlink" title="持久化原理"></a>持久化原理</h2><p>AOF的持久化方式工作机制很简单，Redis将收到的每一个写命令都通过write函数追加到aof文件中。</p><p>随着aof文件越来越大，需要定期对aof文件进行重写，达到压缩的目的。</p><h2 id="文件重写原理"><a href="#文件重写原理" class="headerlink" title="文件重写原理"></a>文件重写原理</h2><ol><li><p>AOF的方式每次写命令都追加到aof文件中，这样aof文件会变得越来越大。为了压缩aof的持久化文件，Redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时fork出一条新进程来将文件重写。</p></li><li><p>重写后的aof文件为什么可以变小</p><p>a). 进程内已经超时的数据不再写入文件。</p><p>b). 旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a111、set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</p><p>c). 多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢 出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。</p></li></ol><p>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据内容用命令的方式重写一个新的aof文件。</p><p>重写后的aof文件更小，可以被Redis更快的加载。</p><h3 id="触发方式-1"><a href="#触发方式-1" class="headerlink" title="触发方式"></a>触发方式</h3><h4 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h4><p>通过Redis的命令bgrewriteaof手动触发</p><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p><p>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。</p><p>auto-aof-rewrite-percentage：代表当前AOF文件空间 （aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb<span class="comment"># 表示运行AOF重写时文件最小体积，默认为64MB。</span></span><br></pre></td></tr></table></figure><p>自动触发时机 = aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（aof_current_size - aof_base_size）/ aof_base_size&gt;=auto-aof-rewritepercentage</p><p>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</p><h2 id="触发方式-2"><a href="#触发方式-2" class="headerlink" title="触发方式"></a>触发方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If unsure, use &quot;everysec&quot;.</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure><ul><li><p>always Redis的每条写命令都写入到系统aof_buffer缓冲区，然后fsync同步到磁盘。每次发送数据变更会被立即记录到磁盘，<strong>性能较差，IO开销比较大</strong>。但是数据完整性比较好。</p></li><li><p>everysec 过程与always相同，每秒记录一次，如果一秒内宕机，则会有数据丢失。</p></li><li><p>no 从不记录。</p></li></ul><h2 id="AOF的优点和缺点"><a href="#AOF的优点和缺点" class="headerlink" title="AOF的优点和缺点"></a>AOF的优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>AOF可以更好的保存数据不丢失，一般AOF每隔一秒，通过一个后台线程执行一次fsync操作，最多丢失1s的数据。</li><li>AOF日志文件过大的时候，出现后台重写操作，不会影响客户端的读写。</li><li>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如如果不小心flushall清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令删除，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</li><li>AOF开启后，支持的写QPS（每秒查询率）会比RDB支持的写QPS低，因为AOP一般会配置成每秒fsync一次日志文件，每秒一次fsync，性能也还是很高的</li></ul><h1 id="RDB和AOF比较"><a href="#RDB和AOF比较" class="headerlink" title="RDB和AOF比较"></a>RDB和AOF比较</h1><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>没有实时持久化</td><td>根据策略不同决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table><h1 id="Redis启动数据加载的流程"><a href="#Redis启动数据加载的流程" class="headerlink" title="Redis启动数据加载的流程"></a>Redis启动数据加载的流程</h1><ol><li>AOF持久化开启并且存在AOF文件，优先加载AOF文件。</li><li>AOF持久化关闭或者AOF文件不存在，加载RDB文件。</li><li>AOF/RDB加载成功后，Redis启动成功。</li><li>AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</li></ol><h1 id="Redis持久化的优化方式"><a href="#Redis持久化的优化方式" class="headerlink" title="Redis持久化的优化方式"></a>Redis持久化的优化方式</h1><p>可以看到不管是RDB的快照，还是AOP的重写，都需要fork一个进程，这会对Redis造成阻塞。因此为了不影响Redis主进程的响应，我们需要尽可能的降低阻塞。即是<strong>减少fork操作的阻塞。</strong></p><ol><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例的最大可用内存maxmemory，fork耗时跟内存量成正比。</li><li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败。vm.overcommit_memory=1。默认值为0，会使Linux在内存分配时，发现不够内存不足时，不会进行分配，进而造成fork阻塞。</li><li>降低fork频率。放宽AOF自动触发时机，避免不必要的全量复制。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity+Jwt整合</title>
      <link href="/2021/12/17/SpringSecurity/SpringSecurity+Jwt%E6%95%B4%E5%90%88/"/>
      <url>/2021/12/17/SpringSecurity/SpringSecurity+Jwt%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="常见的认证机制"><a href="#常见的认证机制" class="headerlink" title="常见的认证机制"></a>常见的认证机制</h3><h4 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h4><p>　HTTP Basic Auth简单点说就是每次请求API时都提供用户的username和password。简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth。</p><h4 id="Cookie-Auth"><a href="#Cookie-Auth" class="headerlink" title="Cookie Auth"></a>Cookie Auth</h4><p>​    Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。     </p><p><img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image64.png"></p><h4 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h4><p>　OAuth（开放授权,Open Authorization）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。</p><p>　OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。</p><p>下面是OAuth2.0的流程：</p><p> <img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image65.png"></p><p>　这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。</p><p>缺点：过重。</p><h4 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h4><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li><p>客户端使用用户名跟密码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p></li><li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p></li></ol><p> <img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image66.png"></p><p>比第一种方式更安全，比第二种方式更节约服务器资源，比第三种方式更加轻量。</p><p>具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）：</p><ol><li><p>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</p></li><li><p>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</p></li><li><p>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</p></li><li><p>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</p></li><li><p>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 10等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p></li><li><p>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</p></li><li><p>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多.</p></li><li><p>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</p></li><li><p>基于标准化：你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</p></li></ol><h2 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h2><h4 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h4><p>　JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。</p><p>官网：  <a href="https://jwt.io/">https://jwt.io/</a></p><p>标准：  <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a></p><p>JWT令牌的优点：</p><ol><li><p>jwt基于json，非常方便解析。</p></li><li><p>可以在令牌中自定义丰富的内容，易扩展。</p></li><li><p>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</p></li><li><p>资源服务使用JWT可不依赖认证服务即可完成授权。</p></li></ol><p>缺点：</p><ol><li>JWT令牌较长，占存储空间比较大。</li></ol><h4 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h4><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p><h5 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h5><p>头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法（如HMAC SHA256或RSA）等。这也可以被表示成一个JSON对象。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>typ</code>：是类型。</p></li><li><p><code>alg</code>：签名的算法，这里使用的算法是HS256算法</p></li></ul><p>我们对头部的json字符串进行BASE64编码（网上有很多在线编码的网站），编码后的字符串如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  </span><br></pre></td></tr></table></figure><p>　<code>Base64</code>是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 <code>BASE64Encoder </code>和 <code>BASE64Decoder</code>，用它们可以非常方便的完成基于 BASE64 的编码和解码。</p><h5 id="负载-Payload"><a href="#负载-Payload" class="headerlink" title="负载(Payload)"></a>负载(Payload)</h5><p>第二部分是负载，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：</p><ul><li>标准中注册的声明（建议但不强制使用）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iss: jwt签发者</span><br><span class="line">sub: jwt所面向的用户</span><br><span class="line">aud: 接收jwt的一方</span><br><span class="line">exp: jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">nbf: 定义在什么时间之前，该jwt都是不可用的.</span><br><span class="line">iat: jwt的签发时间</span><br><span class="line">jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</span><br></pre></td></tr></table></figure><ul><li>公共的声明</li></ul><p>　公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><ul><li>私有的声明</li></ul><p>　私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>　这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>sub</code>是标准的声明，<code>name</code>是自定义的声明（公共的或私有的）</p><p>然后将其进行base64编码，得到Jwt的第二部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbWVzIiwiYWRtaW4iOnRydWV9  </span><br></pre></td></tr></table></figure><p>提示：声明中不要放一些敏感信息。</p><h5 id="签证、签名（signature）"><a href="#签证、签名（signature）" class="headerlink" title="签证、签名（signature）"></a>签证、签名（signature）</h5><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ol><li><p>header (base64后的)</p></li><li><p>payload (base64后的)</p></li><li><p>secret（盐，一定要保密）</p></li></ol><p>　这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI</span><br></pre></td></tr></table></figure><p>将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR9cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI  </span><br></pre></td></tr></table></figure><p>注意：<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以自我签发<code>jwt</code>了。</p><h3 id="JJWT简介"><a href="#JJWT简介" class="headerlink" title="JJWT简介"></a>JJWT简介</h3><h4 id="什么是JJWT"><a href="#什么是JJWT" class="headerlink" title="什么是JJWT"></a>什么是JJWT</h4><p>　JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</p><p>规范官网：<a href="https://jwt.io/">https://jwt.io/</a></p><h2 id="SpringSecurity整合JWT"><a href="#SpringSecurity整合JWT" class="headerlink" title="SpringSecurity整合JWT"></a>SpringSecurity整合JWT</h2><p>SpringSecurity整合JWT最终达到的效果：</p><p>当用户首次登录的时候，输入用户名和密码走正常的登录逻辑，到数据库中根据用户名找到用户的密码信息，然后比对密码是否匹配。若匹配，先将这个用户存入Security的安全上下文holder中，然后利用<strong>JWT工具类</strong>生成一个token，返回给客户端。</p><p>接下来，用户每次请求，都需要在请求头header中携带一个token，这个token首先会进入我们<strong>自定义的Jwt登录认证过滤器</strong>，从请求头中获取token，利用<strong>Jwt工具类</strong>解析token，如果能获取到用户名，则用户认证成功，执行下一个过滤器。否则用<strong>自定义的拒绝访问类</strong>返回权限不足，或者直接用<strong>自定义的认证失败类</strong>返回token失效或者请先登录。</p><h3 id="Application-properties配置"><a href="#Application-properties配置" class="headerlink" title="Application.properties配置"></a>Application.properties配置</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">springsecurityforjwt</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="comment"># Jwt盐</span></span><br><span class="line"><span class="meta">jwt.secret</span>=<span class="string">******</span></span><br><span class="line"><span class="comment"># 请求头的key value为token</span></span><br><span class="line"><span class="meta">jwt.tokenHeader</span>=<span class="string">Authorization</span></span><br><span class="line"><span class="comment"># 过期时间7天</span></span><br><span class="line"><span class="meta">jwt.expiration</span>=<span class="string">604800</span></span><br><span class="line"><span class="comment"># token的头部</span></span><br><span class="line"><span class="meta">jwt.tokenHead</span>=<span class="string">Bearer</span></span><br><span class="line"><span class="comment"># 配置freemarker视图的位置</span></span><br><span class="line"><span class="meta">spring.freemarker.template-loader-path</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="comment"># 配置freemarker后缀</span></span><br><span class="line"><span class="meta">spring.freemarker.suffix</span>=<span class="string">.ftl</span></span><br><span class="line"><span class="meta">spring.freemarker.charset</span>=<span class="string">utf-8</span></span><br></pre></td></tr></table></figure><h3 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.springsecurityforjwt.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_USERNAME=<span class="string">&quot;sub&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_CREATED=<span class="string">&quot;created&quot;</span>;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHead;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expiration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTokenHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tokenHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expiration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims claims</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateToken</span><span class="params">(Map&lt;String,Object&gt; claims)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户信息生成token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从token中获取负载</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> claims</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Claims <span class="title">getClaimsFromToken</span><span class="params">(String token)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Claims claims = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secret)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;JWT格式验证失败:&#123;&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从token中获取登录用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsernameFromToken</span><span class="params">(String token)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String username;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            username = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> expiration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">generateExpirationDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(System.currentTimeMillis()+expiration*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证token是否还有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     *客户端传入的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDetails 从数据库中查询出来的用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateToken</span><span class="params">(String token, UserDetails userDetails)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String username = getUsernameFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断token是否已经失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTokenExpired</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date expiredDate = getExpiredDateFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> expiredDate.before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从token中获取过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getExpiredDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClaimsFromToken(token).getExpiration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当原来的token没过期时是可以刷新的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldToken 带tokenHead的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">refreshHeadToken</span><span class="params">(String oldToken)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(oldToken))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = oldToken.substring(tokenHead.length());</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//token校验不通过</span></span><br><span class="line">        Claims claims = getClaimsFromToken(token);</span><br><span class="line">        <span class="keyword">if</span>(claims==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果token已经过期，不支持刷新</span></span><br><span class="line">        <span class="keyword">if</span>(isTokenExpired(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">return</span> generateToken(claims);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jwt登录认证过滤器JwtAuthenticationFilter"><a href="#Jwt登录认证过滤器JwtAuthenticationFilter" class="headerlink" title="Jwt登录认证过滤器JwtAuthenticationFilter"></a>Jwt登录认证过滤器JwtAuthenticationFilter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHead;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String authHeader=request.getHeader(tokenHeader);</span><br><span class="line">        System.out.println(authHeader);</span><br><span class="line">        <span class="comment">//存在token</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>!=authHeader&amp;&amp;authHeader.startsWith(tokenHead))</span><br><span class="line">        &#123;</span><br><span class="line">            String authToken=authHeader.substring(tokenHead.length());</span><br><span class="line">            System.out.println(authToken);</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            System.out.println(<span class="string">&quot;token中解析到的用户名为：&quot;</span>+username);</span><br><span class="line">            <span class="comment">//token存在但是未登录</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span>!=username&amp;&amp;<span class="keyword">null</span>==SecurityContextHolder.getContext().getAuthentication())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//登录</span></span><br><span class="line">                User user = userService.findUserByUsername(username);</span><br><span class="line">                System.out.println(user);</span><br><span class="line">                <span class="comment">//判断token是否有效</span></span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken,user))</span><br><span class="line">                &#123;</span><br><span class="line">                    UsernamePasswordAuthenticationToken authenticationToken=</span><br><span class="line">                            <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    authenticationToken.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝方法异常RestfulAccessDeniedHandler"><a href="#拒绝方法异常RestfulAccessDeniedHandler" class="headerlink" title="拒绝方法异常RestfulAccessDeniedHandler"></a>拒绝方法异常RestfulAccessDeniedHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean error = RespBean.error(<span class="string">&quot;权限不足，联系管理员!&quot;</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));</span><br><span class="line">        error.setCode(<span class="number">403</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="认证失败异常RestfulAuthorizationEntryPoint"><a href="#认证失败异常RestfulAuthorizationEntryPoint" class="headerlink" title="认证失败异常RestfulAuthorizationEntryPoint"></a>认证失败异常RestfulAuthorizationEntryPoint</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当未登录或者token失效时访问接口自定义的返回结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAuthorizationEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean bean = RespBean.error(<span class="string">&quot;请先登录!&quot;</span>);</span><br><span class="line">        bean.setCode(<span class="number">401</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(bean));</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringSecurity安全配置类"><a href="#SpringSecurity安全配置类" class="headerlink" title="SpringSecurity安全配置类"></a>SpringSecurity安全配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationFilter jwtAuthenticationFilter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestfulAccessDeniedHandler restfulAccessDeniedHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestfulAuthorizationEntryPoint restfulAuthorizationEntryPoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/toLogin&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/static/**&quot;</span>,<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/static/**&quot;</span>,<span class="string">&quot;wabjars/**&quot;</span>,<span class="string">&quot;swagger-resources/**&quot;</span>,<span class="string">&quot;/v2/api-doc/**&quot;</span>).permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//开启跨域访问</span></span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//使用jwt，禁用csrf保护</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//关闭session存储</span></span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .headers().cacheControl();</span><br><span class="line">            <span class="comment">//配置自定义过滤器 添加jwt登录授权过滤器</span></span><br><span class="line">            <span class="comment">//在过滤器UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line">            http.addFilterBefore(jwtAuthenticationFilter,UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">            <span class="comment">//添加自定义未授权未登录结果返回</span></span><br><span class="line">            http.exceptionHandling()</span><br><span class="line">                    .accessDeniedHandler(restfulAccessDeniedHandler)</span><br><span class="line">                    .authenticationEntryPoint(restfulAuthorizationEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenUtil <span class="title">tokenUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenUtil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">login</span><span class="params">(User user, HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.login(user,request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserInfo</span><span class="params">(Principal principal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==principal)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String username = principal.getName();</span><br><span class="line">        User user = userService.findUserByUsername(username);</span><br><span class="line">        user.setPassword(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service实现类"><a href="#Service实现类" class="headerlink" title="Service实现类"></a>Service实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserByUsername&quot;</span>);</span><br><span class="line">        User user = userMapper.findUserByUsername(username);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">login</span><span class="params">(User user, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//登录</span></span><br><span class="line">        User userDetails = userMapper.findUserByUsername(user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">&quot;登录用户为：&quot;</span>+user);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==userDetails||passwordEncoder.matches(user.getPassword(),userDetails.getPassword()))</span><br><span class="line">            <span class="keyword">return</span> RespBean.error(<span class="string">&quot;用户名或者密码不正确&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!userDetails.isEnabled())</span><br><span class="line">            <span class="keyword">return</span> RespBean.error(<span class="string">&quot;账户被禁止使用，请联系管理员&quot;</span>);</span><br><span class="line">        <span class="comment">//更新security登录用户对象</span></span><br><span class="line">        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken=</span><br><span class="line">                <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails,<span class="keyword">null</span>,userDetails.getAuthorities());</span><br><span class="line">        String token=jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">        map.put(<span class="string">&quot;tokenHead&quot;</span>,jwtTokenUtil.getTokenHead());</span><br><span class="line">        <span class="keyword">return</span> RespBean.success(<span class="string">&quot;登录成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Postman测试"><a href="#Postman测试" class="headerlink" title="Postman测试"></a>Postman测试</h3><p>用户首次进行访问登录接口，携带username和password以post方式进行提交。服务器端返回一个token。</p><p>因为后端采用的PostMapping所以注意提交方式。</p><p><img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image-20211202195719521.png" alt="image-20211202195719521"></p><p>用户访问后端其他接口，需要在请求头中加上token。</p><p>因为后端采用的GetMapping所以注意提交方式。</p><p><img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image-20211202200021002.png" alt="image-20211202200021002"></p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2021/12/17/SpringSecurity/SpringSecurity/"/>
      <url>/2021/12/17/SpringSecurity/SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p><img src="/../../img/markdown_img/SpringSecurity.assets/Snipaste_2020-03-04_19-34-27.png"></p><h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><h3 id="SpringSecurity简介"><a href="#SpringSecurity简介" class="headerlink" title="SpringSecurity简介"></a>SpringSecurity简介</h3><h4 id="安全框架概述"><a href="#安全框架概述" class="headerlink" title="安全框架概述"></a>安全框架概述</h4><p>　什么是安全框架？ 解决系统安全问题的框架。如果没有安全框架，我们需要手动处理每个资源的访问控制，非常麻烦。使用安全框架，我们可以通过配置的方式实现对资源的访问限制。</p><h4 id="常用安全框架"><a href="#常用安全框架" class="headerlink" title="常用安全框架"></a>常用安全框架</h4><ul><li><p>Spring Security：Spring家族一员。是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了<code>Spring IoC</code>，<code>DI（控制反转Inversion of Control,DI:Dependency Injection 依赖注入）</code>和<code>AOP（面向切面编程）</code>功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p></li><li><p>Apache Shiro：一个功能强大且易于使用的Java安全框架,提供了认证,授权,加密,和会话管理。</p></li></ul><h4 id="Spring-Security简介"><a href="#Spring-Security简介" class="headerlink" title="Spring Security简介"></a>Spring Security简介</h4><p><strong>概述</strong></p><p>　Spring Security是一个高度自定义的安全框架。利用 Spring IoC/DI和AOP功能，为系统提供了声明式安全访问控制功能，减少了为系统安全而编写大量重复代码的工作。使用 Spring Secruity 的原因有很多，但大部分都是发现了 javaEE的 Servlet 规范或 EJB 规范中的安全功能缺乏典型企业应用场景。同时认识到他们在 WAR 或 EAR 级别无法移植。因此如果你更换服务器环境，还有大量工作去重新配置你的应用程序。使用 Spring Security解决了这些问题，也为你提供许多其他有用的、可定制的安全功能。正如你可能知道的两个应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两点也是 Spring Security 重要核心功能。“认证”，是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统），通俗点说就是系统认为用户是否能登录。“授权”指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情。</p><p><strong>历史</strong></p><p>　Spring Security 以“The Acegi Secutity System for Spring”的名字始于2003年年底。其前身为 acegi 项目。起因是 Spring 开发者邮件列表中一个问题，有人提问是否考虑提供一个基于 Spring 的安全实现。限制于时间问题，开发出了一个简单的安全实现，但是并没有深入研究。几周后，Spring 社区中其他成员同样询问了安全问题，代码提供给了这些人。2004 年 1 月份已经有 20 人左右使用这个项目。随着更多人的加入，在 2004 年 3 月左右在 sourceforge 中建立了一个项目。在最开始并没有认证模块，所有的认证功能都是依赖容器完成的，而 acegi 则注重授权。但是随着更多人的使用，基于容器的认证就显现出了不足。acegi 中也加入了认证功能。大约 1 年后 acegi 成为 Spring子项目。在 2006 年 5 月发布了 acegi 1.0.0 版本。2007 年底 acegi 更名为Spring Security。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yjxxt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springsecurity-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>springsecurity-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--spring security 组件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--web 组件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- test 组件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h4><p>login.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h4><p>　导入spring-boot-starter-security 启动器后，Spring Security 已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。</p><p>​         <img src="/../../img/markdown_img/SpringSecurity.assets/image1.png">             </p><p>默认的 username 为 user，password 打印在控制台中。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image2.png"></p><p>在浏览器中输入账号和密码后会显示 login.html 页面内容。</p><h3 id="UserDetailsService详解"><a href="#UserDetailsService详解" class="headerlink" title="UserDetailsService详解"></a>UserDetailsService详解</h3><p>　当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口定义如下：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image3.png"></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回值 UserDetails 是一个接口，定义如下</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image4.png"></p><p>要想返回 <code>UserDetails </code>的实例就只能返回接口的实现类。SpringSecurity 中提供了如下的实例。对于我们只需要使用里面的 <code>User </code>类即可。注意 User 的全限定路径是：</p><p><code>org.springframework.security.core.userdetails.User</code>此处经常和系统中自己开发的 User 类弄混。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image5.png"></p><p>在 User 类中提供了很多方法和属性。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image6.png"></p><p>其中构造方法有两个，调用其中任何一个都可以实例化</p><p><code>UserDetails </code>实现类 <code>User </code>类的实例。而三个参数的构造方法实际上也是调用 7 个参数的构造方法。</p><ul><li><p><code>username</code>:用户名</p></li><li><p><code>password</code>:密码</p></li><li><p><code>authorities</code>：用户具有的权限。此处不允许为 null</p></li></ul><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image7.png"></p><p>　此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。Spring Security 会根据 User 中的 <code>password</code>和客户端传递过来的 <code>password </code>进行比较。如果相同则表示认证通过，如果不相同表示认证失败。</p><p>　<code>authorities </code>里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现 403。通常都是通过<code>AuthorityUtils.commaSeparatedStringToAuthorityList(“”)</code> 来创建<code>authorities</code> 集合对象的。参数是一个字符串，多个权限使用逗号分隔。</p><h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><p>方法参数表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫 <code>username</code>，否则无法接收。</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>　<code>UsernameNotFoundException </code>用户名没有发现异常。在<code>loadUserByUsername</code>中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出<code>UsernameNotFoundException</code>，系统就知道用户名没有查询到。</p><h3 id="PasswordEncoder-密码解析器详解"><a href="#PasswordEncoder-密码解析器详解" class="headerlink" title="PasswordEncoder 密码解析器详解"></a>PasswordEncoder 密码解析器详解</h3><p>　Spring Security 要求容器中必须有<code>PasswordEncoder</code>实例。所以当自定义登录逻辑时要求必须给容器注入<code>PaswordEncoder</code>的bean对象。</p><h4 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h4><ul><li><p><code>encode()</code>：把参数按照特定的解析规则进行解析。</p></li><li><p><code>matches()</code> ：验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。</p></li><li><p><code>upgradeEncoding()</code>：如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回 false。默认返回 false。</p></li></ul><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image8.png"></p><h4 id="内置解析器介绍"><a href="#内置解析器介绍" class="headerlink" title="内置解析器介绍"></a>内置解析器介绍</h4><p>在 Spring Security 中内置了很多解析器。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image9.png"></p><h4 id="BCryptPasswordEncoder-简介"><a href="#BCryptPasswordEncoder-简介" class="headerlink" title="BCryptPasswordEncoder 简介"></a>BCryptPasswordEncoder 简介</h4><p>　BCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，平时多使用这个解析器。</p><p>　BCryptPasswordEncoder 是对 <code>bcrypt </code>强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度，默认 10.</p><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p>新建测试方法BCryptPasswordEncoder 用法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//创建解析器</span></span><br><span class="line">      PasswordEncoder pw = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">      <span class="comment">//对密码加密</span></span><br><span class="line">      String encode = pw.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      System.out.println(encode);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断原字符和加密后内容是否匹配</span></span><br><span class="line">      <span class="keyword">boolean</span> matches = pw.matches(<span class="string">&quot;1234&quot;</span>, encode);</span><br><span class="line">      System.out.println(<span class="string">&quot;===================&quot;</span>+matches);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义登录逻辑"><a href="#自定义登录逻辑" class="headerlink" title="自定义登录逻辑"></a>自定义登录逻辑</h3><p>　当 进 行 自 定 义 登 录 逻 辑 时 需 要 用 到 之 前 讲 解 的<code>UserDetailsService </code>和 <code>PasswordEncoder</code>。但是 Spring Security 要求：当进行自定义登录逻辑时容器内必须有 <code>PasswordEncoder </code>实例。所以不能直接 new 对象。</p><h4 id="编写配置类"><a href="#编写配置类" class="headerlink" title="编写配置类"></a>编写配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">getPw</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义逻辑"><a href="#自定义逻辑" class="headerlink" title="自定义逻辑"></a>自定义逻辑</h4><p>在 Spring Security 中实现 UserDetailService 就表示为用户详情服务。在这个类中编写用户认证逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> PasswordEncoder pw;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">      <span class="comment">//1.查询数据库判断用户名是否存在，如果不存在抛出UsernameNotFoundException异常</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="string">&quot;admin&quot;</span>.equals(username))&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//2.把查询出来的密码（注册时已经加密过）进行解析，或直接把密码放入构造方法中</span></span><br><span class="line">      String password = pw.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,normal&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h4><p>重启项目后，在浏览器中输入账号：admin，密码：123。后可以正确进入到 login.html 页面。</p><h3 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h3><p>　虽然 Spring Security 给我们提供了登录页面，但是对于实际项目中，大多喜欢使用自己的登录页面。所以 Spring Security 中不仅仅提供了登录页面，还支持用户自定义登录页面。实现过程也比较简单，只需要修改配置类即可。</p><h4 id="编写登录页面"><a href="#编写登录页面" class="headerlink" title="编写登录页面"></a>编写登录页面</h4><p>login.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改配置类"><a href="#修改配置类" class="headerlink" title="修改配置类"></a>修改配置类</h4><p>修改配置类中主要是设置哪个页面是登录页面。配置类需要继承WebSecurityConfigurerAdapter,并重写 configure 方法。</p><ul><li><p><code>successForwardUrl()</code>：登录成功后跳转地址</p></li><li><p><code>loginPage()</code> ：登录页面</p></li><li><p><code>loginProcessingUrl </code>：登录页面表单提交地址，此地址可以不真实存在。</p></li><li><p><code>antMatchers()</code>：匹配内容</p></li><li><p><code>permitAll()</code>：允许</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//表单提交</span></span><br><span class="line">      http.formLogin()</span><br><span class="line">            <span class="comment">//自定义登录页面</span></span><br><span class="line">            .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">            <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">            .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      http.authorizeRequests()</span><br><span class="line">            <span class="comment">//login.html不需要被认证</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/login.html&quot;</span>).permitAll()</span><br><span class="line">            <span class="comment">//所有请求都必须被认证，必须登录后被访问</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭csrf防护</span></span><br><span class="line">      http.csrf().disable();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">getPw</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写控制器"><a href="#编写控制器" class="headerlink" title="编写控制器"></a>编写控制器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">   <span class="comment">//该方法不执行</span></span><br><span class="line">   <span class="comment">// @RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="comment">// public String login()&#123;</span></span><br><span class="line">   <span class="comment">//     System.out.println(&quot;登录方法&quot;);</span></span><br><span class="line">   <span class="comment">//     return &quot;main.html&quot;;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 成功后跳转页面</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/toMain&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="认证过程其他常用配置"><a href="#认证过程其他常用配置" class="headerlink" title="认证过程其他常用配置"></a>认证过程其他常用配置</h3><h4 id="失败跳转"><a href="#失败跳转" class="headerlink" title="失败跳转"></a>失败跳转</h4><p>表单处理中成功会跳转到一个地址，失败也可以跳转到一个地址。</p><h5 id="编写页面error-html"><a href="#编写页面error-html" class="headerlink" title="编写页面error.html"></a>编写页面error.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">操作失败，请重新登录 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>= <span class="string">&quot;/login.html&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改表单配置"><a href="#修改表单配置" class="headerlink" title="修改表单配置"></a>修改表单配置</h5><p>　在配置方法中表单认证部分添加<code> failureForwardUrl()</code>方法，表示登录失败跳转的 url。此处依然是 POST 请求，所以跳转到可以接收 POST请求的控制器/error中。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表单提交</span></span><br><span class="line">http.formLogin()</span><br><span class="line">      <span class="comment">//自定义登录页面</span></span><br><span class="line">      .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">      <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">      .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">      <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">      .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>)</span><br><span class="line">      <span class="comment">//登录失败后跳转页面，POST请求</span></span><br><span class="line">      .failureForwardUrl(<span class="string">&quot;/toError&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="添加控制器的方法"><a href="#添加控制器的方法" class="headerlink" title="添加控制器的方法"></a>添加控制器的方法</h5><p>　在控制器类中添加控制器方法，方法映射路径/error。此处要注意：由于是 POST 请求访问/error。所以如果返回值直接转发到 error.html 中，即使有效果，控制台也会报警告，提示 error.html 不支持 POST 访问方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 失败后跳转页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toError&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toError</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/error.html&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置error-html不需要认证"><a href="#设置error-html不需要认证" class="headerlink" title="设置error.html不需要认证"></a>设置error.html不需要认证</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">      <span class="comment">//login.html不需要被认证</span></span><br><span class="line">      .antMatchers(<span class="string">&quot;/login.html&quot;</span>).permitAll()</span><br><span class="line">      <span class="comment">//error.html不需要被认证</span></span><br><span class="line">      .antMatchers(<span class="string">&quot;/error.html&quot;</span>).permitAll()</span><br><span class="line">      <span class="comment">//所有请求都必须被认证，必须登录后被访问</span></span><br><span class="line">      .anyRequest().authenticated();</span><br></pre></td></tr></table></figure><h4 id="设置请求账户和密码的参数名"><a href="#设置请求账户和密码的参数名" class="headerlink" title="设置请求账户和密码的参数名"></a>设置请求账户和密码的参数名</h4><h5 id="源码简介"><a href="#源码简介" class="headerlink" title="源码简介"></a>源码简介</h5><p>当进行登录时会执行 UsernamePasswordAuthenticationFilter 过滤器。</p><ul><li><p><code>usernamePasrameter</code>：账户参数名</p></li><li><p><code>passwordParameter</code>：密码参数名</p></li><li><p><code>postOnly=true</code>：默认情况下只允许POST请求。</p></li></ul><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image10.png"></p><h5 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表单提交</span></span><br><span class="line">http.formLogin()</span><br><span class="line">      <span class="comment">//自定义登录页面</span></span><br><span class="line">      .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">      <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">      .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">      <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">      .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>)</span><br><span class="line">      <span class="comment">//登录失败后跳转页面，POST请求</span></span><br><span class="line">      .failureForwardUrl(<span class="string">&quot;/toError&quot;</span>)</span><br><span class="line">      .usernameParameter(<span class="string">&quot;myusername&quot;</span>)</span><br><span class="line">      .passwordParameter(<span class="string">&quot;mypassword&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="修改login-html"><a href="#修改login-html" class="headerlink" title="修改login.html"></a>修改login.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myusername&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mypassword&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义登录成功处理器"><a href="#自定义登录成功处理器" class="headerlink" title="自定义登录成功处理器"></a>自定义登录成功处理器</h4><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>　使用successForwardUrl()时表示成功后转发请求到地址。内部是通过 <code>successHandler()</code>方法进行控制成功后交给哪个类进行处理</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image11.png"></p><p>　ForwardAuthenticationSuccessHandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image12.png"></p><p>当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>自定义类</strong></p><p>新建类 com.yjxxt.handler.MyAuthenticationSuccessHandler 编写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyAuthenticationSuccessHandler</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.url = url;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      <span class="comment">//Principal 主体，存放了登录用户的信息</span></span><br><span class="line">      User user = (User) authentication.getPrincipal();</span><br><span class="line">      System.out.println(user.getUsername());</span><br><span class="line">      <span class="comment">//输出null</span></span><br><span class="line">      System.out.println(user.getPassword());</span><br><span class="line">      System.out.println(user.getAuthorities());</span><br><span class="line">      response.sendRedirect(url);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改配置项</strong></p><p>使用 successHandler()方法设置成功后交给哪个对象进行处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表单提交</span></span><br><span class="line">http.formLogin()</span><br><span class="line">      <span class="comment">//自定义登录页面</span></span><br><span class="line">      .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">      <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">      .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">      <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">      <span class="comment">// .successForwardUrl(&quot;/toMain&quot;)</span></span><br><span class="line">      <span class="comment">//和successForwardUrl不能共存</span></span><br><span class="line">      .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler(<span class="string">&quot;http://www.baidu.com&quot;</span>))</span><br><span class="line">      <span class="comment">//登录失败后跳转页面，POST请求</span></span><br><span class="line">      .failureForwardUrl(<span class="string">&quot;/toError&quot;</span>)</span><br><span class="line">      .usernameParameter(<span class="string">&quot;myusername&quot;</span>)</span><br><span class="line">      .passwordParameter(<span class="string">&quot;mypassword&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="自定义登录失败处理器"><a href="#自定义登录失败处理器" class="headerlink" title="自定义登录失败处理器"></a>自定义登录失败处理器</h4><h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><p>failureForwardUrl()内部调用的是<code> failureHandler()</code>方法</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image13.png"></p><p>ForwardAuthenticationFailureHandler 中也是一个请求转发，并在request 作用域中设置 <code>SPRING_SECURITY_LAST_EXCEPTION </code>的 key，内容为异常对象。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image14.png"></p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>新建控制器</strong></p><p>新建 com.yjxxt.handler.MyForwardAuthenticationFailureHandler 实现AuthenticationFailureHandler。在方法中添加重定向语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyForwardAuthenticationFailureHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyForwardAuthenticationFailureHandler</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.url = url;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      response.sendRedirect(url);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改配置类</strong></p><p>修改配置类中表单登录部分。设置失败时交给失败处理器进行操作。<code>failureForwardUrl </code>和 <code>failureHandler </code>不可共存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表单提交</span></span><br><span class="line">http.formLogin()</span><br><span class="line">      <span class="comment">//自定义登录页面</span></span><br><span class="line">      .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">      <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">      .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">      <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">      <span class="comment">// .successForwardUrl(&quot;/toMain&quot;)</span></span><br><span class="line">      <span class="comment">//和successForwardUrl不能共存</span></span><br><span class="line">      .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler(<span class="string">&quot;http://www.baidu.com&quot;</span>))</span><br><span class="line">      <span class="comment">//登录失败后跳转页面，POST请求</span></span><br><span class="line">      <span class="comment">// .failureForwardUrl(&quot;/toError&quot;)</span></span><br><span class="line">      .failureHandler(<span class="keyword">new</span> MyForwardAuthenticationFailureHandler(<span class="string">&quot;/error.html&quot;</span>))</span><br><span class="line">      .usernameParameter(<span class="string">&quot;myusername&quot;</span>)</span><br><span class="line">      .passwordParameter(<span class="string">&quot;mypassword&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="访问控制url匹配"><a href="#访问控制url匹配" class="headerlink" title="访问控制url匹配"></a>访问控制url匹配</h3><p>　在前面讲解了认证中所有常用配置，主要是对<code> http.formLogin()</code>进行操作。而在配置类中 <code>http.authorizeRequests()</code>主要是对url进行控制，也就是我们所说的授权（访问控制）。<code>http.authorizeRequests()</code>也支持连缀写法，总体公式为：</p><ul><li>url 匹配规则.权限控制方法</li></ul><p>　通过上面的公式可以有很多 url 匹配规则和很多权限控制方法。这些内容进行各种组合就形成了Spring Security中的授权。</p><p>　在所有匹配规则中取所有规则的交集。配置顺序影响了之后授权效果，越是具体的应该放在前面，越是笼统的应该放到后面。</p><h4 id="anyRequest"><a href="#anyRequest" class="headerlink" title="anyRequest()"></a>anyRequest()</h4><p>　在之前认证过程中我们就已经使用过 anyRequest()，表示匹配所有的请求。一般情况下此方法都会使用，设置全部内容都需要进行认证。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.anyRequest().authenticated();  </span><br></pre></td></tr></table></figure><h4 id="antMatcher"><a href="#antMatcher" class="headerlink" title="antMatcher()"></a>antMatcher()</h4><p>方法定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> C <span class="title">antMatchers</span><span class="params">(String... antPatterns)</span>  </span></span><br></pre></td></tr></table></figure><p>参数是不定向参数，每个参数是一个 ant 表达式，用于匹配 URL规则。</p><p>规则如下：</p><ul><li><p><code>?</code>： 匹配一个字符</p></li><li><p><code>*</code>：匹配 0 个或多个字符</p></li><li><p><code>**</code> ：匹配 0 个或多个目录</p></li></ul><p>在实际项目中经常需要放行所有静态资源，下面演示放行 js 文件夹下所有脚本文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/js/**&quot;</span>,<span class="string">&quot;/css/**&quot;</span>).permitAll()  </span><br></pre></td></tr></table></figure><p>还有一种配置方式是只要是.js 文件都放行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/**/*.js&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><h4 id="regexMatchers"><a href="#regexMatchers" class="headerlink" title="regexMatchers()"></a>regexMatchers()</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>　使用正则表达式进行匹配。和 <code>antMatchers()</code>主要的区别就是参数，<code>antMatchers()</code>参数是 ant 表达式，<code>regexMatchers()</code>参数是正则表达式。</p><p>　演示所有以.js 结尾的文件都被放行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.regexMatchers( <span class="string">&quot;.+[.]js&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><h5 id="两个参数时使用方式"><a href="#两个参数时使用方式" class="headerlink" title="两个参数时使用方式"></a>两个参数时使用方式</h5><p>　无论是<code> antMatchers()</code>还是<code> regexMatchers()</code>都具有两个参数的方法，其中第一个参数都是 <code>HttpMethod</code>，表示请求方式，当设置了<code>HttpMethod </code>后表示只有设定的特定的请求方式才执行对应的权限设置。</p><p>枚举类型 <code>HttpMethod </code>内置属性如下：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image15.png"></p><h4 id="mvcMatchers"><a href="#mvcMatchers" class="headerlink" title="mvcMatchers()"></a>mvcMatchers()</h4><p>　mvcMatchers()适用于配置了 servletPath 的情况。</p><p>　<code>servletPath </code>就是所有的 URL 的统一前缀。在 SpringBoot 整合SpringMVC 的项目中可以在 application.properties 中添加下面内容设置 <code>ServletPath</code></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.servlet.path</span>=<span class="string">/yjxxt</span></span><br></pre></td></tr></table></figure><p>　在 Spring Security 的配置类中配置<code>.servletPath()</code>是 mvcMatchers()返回值特有的方法，antMatchers()和 regexMatchers()没有这个方法。在<code> servletPath()</code>中配置了<code>servletPath </code>后，mvcMatchers()直接写 SpringMVC 中@RequestMapping()中设置的路径即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.mvcMatchers(<span class="string">&quot;/demo&quot;</span>).servletPath(<span class="string">&quot;/yjxxt&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><p>　如果不习惯使用 mvcMatchers()也可以使用 antMatchers()，下面代码和上面代码是等效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/yjxxt/demo&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><h3 id="内置访问控制方法"><a href="#内置访问控制方法" class="headerlink" title="内置访问控制方法"></a>内置访问控制方法</h3><p>　Spring Security 匹配了 URL 后调用了<code> permitAll()</code>表示不需要认证，随意访问。在 Spring Security 中提供了多种内置控制。</p><h4 id="permitAll"><a href="#permitAll" class="headerlink" title="permitAll()"></a>permitAll()</h4><p>permitAll()表示所匹配的 URL 任何人都允许访问。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image16.png"></p><h4 id="authenticated"><a href="#authenticated" class="headerlink" title="authenticated()"></a>authenticated()</h4><p>authenticated()表示所匹配的 URL 都需要被认证才能访问。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image17.png"></p><h4 id="anonymous"><a href="#anonymous" class="headerlink" title="anonymous()"></a>anonymous()</h4><p>anonymous()表示可以匿名访问匹配的URL。和permitAll()效果类似，只是设置为 anonymous()的 url 会执行 filter 链中</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image18.png"></p><h4 id="denyAll"><a href="#denyAll" class="headerlink" title="denyAll()"></a>denyAll()</h4><p>denyAll()表示所匹配的 URL 都不允许被访问。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image19.png"></p><h4 id="rememberMe"><a href="#rememberMe" class="headerlink" title="rememberMe()"></a>rememberMe()</h4><p>被“remember me”的用户允许访问</p><p>  <img src="/../../img/markdown_img/SpringSecurity.assets/image20.png"></p><h4 id="fullyAuthenticated"><a href="#fullyAuthenticated" class="headerlink" title="fullyAuthenticated()"></a>fullyAuthenticated()</h4><p>如果用户不是被 remember me 的，才可以访问。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image21.png"></p><h3 id="角色权限判断"><a href="#角色权限判断" class="headerlink" title="角色权限判断"></a>角色权限判断</h3><p>　除了之前讲解的内置权限控制。Spring Security 中还支持很多其他权限控制。这些方法一般都用于用户已经被认证后，判断用户是否具有特定的要求。</p><h4 id="hasAuthority-String"><a href="#hasAuthority-String" class="headerlink" title="hasAuthority(String)"></a>hasAuthority(String)</h4><p>　判断用户是否具有特定的权限，用户的权限是在自定义登录逻辑中创建 User 对象时指定的。下图中 admin和normal 就是用户的权限。admin和normal 严格区分大小写。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image22.png"></p><p>在配置类中通过 hasAuthority(“admin”)设置具有 admin 权限时才能访问。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/main1.html&quot;</span>).hasAuthority(<span class="string">&quot;admin&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="hasAnyAuthority-String-…"><a href="#hasAnyAuthority-String-…" class="headerlink" title="hasAnyAuthority(String …)"></a>hasAnyAuthority(String …)</h4><p>如果用户具备给定权限中某一个，就允许访问。</p><p>下面代码中由于大小写和用户的权限不相同，所以用户无权访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/main1.html&quot;</span>).hasAnyAuthority(<span class="string">&quot;adMin&quot;</span>,<span class="string">&quot;admiN&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="hasRole-String"><a href="#hasRole-String" class="headerlink" title="hasRole(String)"></a>hasRole(String)</h4><p>如果用户具备给定角色就允许访问。否则出现 403。</p><p>参数取值来源于自定义登录逻辑 <code>UserDetailsService </code>实现类中创建 User 对象时给 User 赋予的授权。</p><p>　在给用户赋予角色时角色需要以：<code>ROLE_开头</code>，后面添加角色名称。例如：ROLE_abc 其中 abc 是角色名，ROLE_是固定的字符开头。</p><p>使用 hasRole()时参数也只写 abc 即可。否则启动报错。</p><p>给用户赋予角色：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image23.png"></p><p>　在配置类中直接写 abc 即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/main1.html&quot;</span>).hasRole(<span class="string">&quot;abc&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="hasAnyRole-String-…"><a href="#hasAnyRole-String-…" class="headerlink" title="hasAnyRole(String …)"></a>hasAnyRole(String …)</h4><p>如果用户具备给定角色的任意一个，就允许被访问</p><h4 id="hasIpAddress-String"><a href="#hasIpAddress-String" class="headerlink" title="hasIpAddress(String)"></a>hasIpAddress(String)</h4><p>如果请求是指定的 IP 就运行访问。</p><p>可以通过 <code>request.getRemoteAddr()</code>获取 ip 地址。</p><p>需要注意的是在本机进行测试时 localhost 和 127.0.0.1 输出的 ip地址是不一样的。</p><p>当浏览器中通过 localhost 进行访问时控制台打印的内容：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image24.png"></p><p>当浏览器中通过 127.0.0.1 访问时控制台打印的内容：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image25.png"></p><p>当浏览器中通过具体 ip 进行访问时控制台打印内容：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image26.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">&quot;/main1.html&quot;</span>).hasIpAddress(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="自定义403处理方案"><a href="#自定义403处理方案" class="headerlink" title="自定义403处理方案"></a>自定义403处理方案</h3><p>使用 Spring Security 时经常会看见 403（无权限），默认情况下显示的效果如下：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image27.png"></p><p>而在实际项目中可能都是一个异步请求，显示上述效果对于用户就不是特别友好了。Spring Security 支持自定义权限受限。</p><h4 id="新建类"><a href="#新建类" class="headerlink" title="新建类"></a>新建类</h4><p>新建类实现 AccessDeniedHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.access.AccessDeniedException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.access.AccessDeniedHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">      response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line">      out.write(<span class="string">&quot;&#123;\&quot;status\&quot;:\&quot;error\&quot;,\&quot;msg\&quot;:\&quot;权限不足，请联系管理员！\&quot;&#125;&quot;</span>);</span><br><span class="line">      out.flush();</span><br><span class="line">      out.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改配置类-1"><a href="#修改配置类-1" class="headerlink" title="修改配置类"></a>修改配置类</h4><p>配置类中重点添加异常处理器。设置访问受限后交给哪个对象进行处理。</p><p>myAccessDeniedHandler 是在配置类中进行自动注入的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常处理</span></span><br><span class="line">http.exceptionHandling()</span><br><span class="line">      .accessDeniedHandler(myAccessDeniedHandler);</span><br></pre></td></tr></table></figure><h3 id="基于表达式的访问控制"><a href="#基于表达式的访问控制" class="headerlink" title="基于表达式的访问控制"></a>基于表达式的访问控制</h3><h4 id="access-方法使用"><a href="#access-方法使用" class="headerlink" title="access()方法使用"></a>access()方法使用</h4><p>之前学习的登录用户权限判断实际上底层实现都是调用access(表达式)</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image28.png"></p><p>可以通过<code> access()</code>实现和之前学习的权限控制完成相同的功能。</p><p>以 hasRole 和 和 permitAll 举例</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image29.png"></p><h4 id="使用自定义方法"><a href="#使用自定义方法" class="headerlink" title="使用自定义方法"></a>使用自定义方法</h4><p>虽然这里面已经包含了很多的表达式(方法)但是在实际项目中很有可能出现需要自己自定义逻辑的情况。</p><p>判断登录用户是否具有访问当前 URL 权限。</p><h5 id="新建接口及实现类"><a href="#新建接口及实现类" class="headerlink" title="新建接口及实现类"></a>新建接口及实现类</h5><p>MyService.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(HttpServletRequest request, Authentication authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyServiceImpl.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecuritydemo.service.MyService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceImpl</span> <span class="keyword">implements</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(HttpServletRequest request, Authentication authentication)</span> </span>&#123;</span><br><span class="line">      Object obj = authentication.getPrincipal();</span><br><span class="line">      <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UserDetails)&#123;</span><br><span class="line">         UserDetails userDetails = (UserDetails) obj;</span><br><span class="line">         Collection&lt;? extends GrantedAuthority&gt; authorities = userDetails.getAuthorities();</span><br><span class="line">         <span class="keyword">return</span> authorities.contains(<span class="keyword">new</span> SimpleGrantedAuthority(request.getRequestURI()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改配置类-2"><a href="#修改配置类-2" class="headerlink" title="修改配置类"></a>修改配置类</h5><p>在 access 中通过@bean的id名.方法(参数)的形式进行调用配置类中修改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//url拦截</span></span><br><span class="line">http.authorizeRequests()</span><br><span class="line">      <span class="comment">//login.html不需要被认证</span></span><br><span class="line">      <span class="comment">// .antMatchers(&quot;/login.html&quot;).permitAll()</span></span><br><span class="line">      .antMatchers(<span class="string">&quot;/login.html&quot;</span>).access(<span class="string">&quot;permitAll&quot;</span>)</span><br><span class="line">      <span class="comment">// .antMatchers(&quot;/main.html&quot;).hasRole(&quot;abc&quot;)</span></span><br><span class="line">      .antMatchers(<span class="string">&quot;/main.html&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>)</span><br><span class="line">      .anyRequest().access(<span class="string">&quot;@myServiceImpl.hasPermission(request,authentication)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="基于注解的访问控制"><a href="#基于注解的访问控制" class="headerlink" title="基于注解的访问控制"></a>基于注解的访问控制</h3><p>在 Spring Security 中提供了一些访问控制的注解。这些注解都是默认是都不可用的，需要通过<code>@EnableGlobalMethodSecurity </code>进行开启后使用。</p><p>如果设置的条件允许，程序正常执行。如果不允许会报 500</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image30.png"></p><p>这些注解可以写到 Service 接口或方法上，也可以写到 Controller或 Controller 的方法上。通常情况下都是写在控制器方法上的，控制接口URL是否允许被访问。</p><h4 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h4><p>@Secured 是专门用于判断是否具有角色的。能写在方法或类上。参数要以 ROLE_开头。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image31.png"></p><h5 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h5><p>在 启 动 类 ( 也 可 以 在 配 置 类 等 能 够 扫 描 的 类 上 ) 上 添 加<code>@EnableGlobalMethodSecurity(securedEnabled = true)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringsecurityDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(SpringsecurityDemoApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在控制器方法上添加-Secured-注解"><a href="#在控制器方法上添加-Secured-注解" class="headerlink" title="在控制器方法上添加@Secured 注解"></a>在控制器方法上添加@Secured 注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成功后跳转页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Secured(&quot;ROLE_abc&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toMain&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">//表单提交</span></span><br><span class="line">   http.formLogin()</span><br><span class="line">         <span class="comment">//自定义登录页面</span></span><br><span class="line">         .loginPage(<span class="string">&quot;/login.html&quot;</span>)</span><br><span class="line">         <span class="comment">//当发现/login时认为是登录，必须和表单提交的地址一样。去执行UserServiceImpl</span></span><br><span class="line">         .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">         <span class="comment">//登录成功后跳转页面，POST请求</span></span><br><span class="line">         .successForwardUrl(<span class="string">&quot;/toMain&quot;</span>)</span><br><span class="line">         </span><br><span class="line">   <span class="comment">//url拦截</span></span><br><span class="line">   http.authorizeRequests()</span><br><span class="line">         <span class="comment">//login.html不需要被认证</span></span><br><span class="line">         .antMatchers(<span class="string">&quot;/login.html&quot;</span>).permitAll()</span><br><span class="line">         <span class="comment">//所有请求都必须被认证，必须登录后被访问</span></span><br><span class="line">         .anyRequest().authenticated();</span><br><span class="line">   <span class="comment">//关闭csrf防护</span></span><br><span class="line">   http.csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PreAuthorize-PostAuthorize"><a href="#PreAuthorize-PostAuthorize" class="headerlink" title="@PreAuthorize/@PostAuthorize"></a>@PreAuthorize/@PostAuthorize</h4><p>@PreAuthorize 和@PostAuthorize 都是方法或类级别注解。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image32.png"></p><ul><li><p><code>@PreAuthorize </code>表示访问方法或类在执行之前先判断权限，大多情况下都是使用这个注解，注解的参数和access()方法参数取值相同，都是权限表达式。</p></li><li><p><code>@PostAuthorize</code> 表示方法或类执行结束后判断权限，此注解很少被使用到。</p></li></ul><h5 id="开启注解-1"><a href="#开启注解-1" class="headerlink" title="开启注解"></a>开启注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringsecurityDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(SpringsecurityDemoApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="添加-PreAuthorize"><a href="#添加-PreAuthorize" class="headerlink" title="添加@PreAuthorize"></a>添加@PreAuthorize</h5><p>在控制器方法上添加@PreAuthorize，参数可以是任何 access()支持的表达式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成功后跳转页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ROLE_abc&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toMain&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RememberMe功能实现"><a href="#RememberMe功能实现" class="headerlink" title="RememberMe功能实现"></a>RememberMe功能实现</h3><p>　Spring Security 中 Remember Me 为“记住我”功能，用户只需要在登录时添加 remember-me复选框，取值为true。Spring Security 会自动把用户信息存储到数据源中，以后就可以不登录进行访问</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>　Spring Security 实 现 Remember Me 功 能 时 底 层 实 现 依 赖Spring-JDBC，所以需要导入 Spring-JDBC。以后多使用 MyBatis 框架而很少直接导入 spring-jdbc，所以此处导入 mybatis 启动器同时还需要添加 MySQL 驱动</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mysql 数据库依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><p>在 application.properties 中配置数据源。请确保数据库中已经存在shop数据库</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.driver-class-name</span>= <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>= <span class="string">jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>= <span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>= <span class="string">root</span></span><br></pre></td></tr></table></figure><h4 id="编写配置"><a href="#编写配置" class="headerlink" title="编写配置"></a>编写配置</h4><p>RememberMeConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecuritydemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RememberMeConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">getPersistentTokenRepository</span><span class="params">()</span></span>&#123;</span><br><span class="line">      JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">      jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">      <span class="comment">//自动建表，第一次启动时需要，第二次启动时注释掉</span></span><br><span class="line">      jdbcTokenRepository.setCreateTableOnStartup(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改SecurityConfig-java"><a href="#修改SecurityConfig-java" class="headerlink" title="修改SecurityConfig.java"></a>修改SecurityConfig.java</h4><p>在SecurityConfig中添加RememberMeConfig和UserDetailsService实现类对象，并自动注入。</p><p>在 configure 中添加下面配置内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.rememberMe()</span><br><span class="line">      <span class="comment">//登录逻辑交给哪个对象</span></span><br><span class="line">      .userDetailsService(userService)</span><br><span class="line">      <span class="comment">// 持久层对象</span></span><br><span class="line">      .tokenRepository(persistentTokenRepository);</span><br></pre></td></tr></table></figure><h4 id="在客户端页面添加复选框"><a href="#在客户端页面添加复选框" class="headerlink" title="在客户端页面添加复选框"></a>在客户端页面添加复选框</h4><p>在客户端登录页面中添加 remember-me 的复选框，只要用户勾选了复选框下次就不需要进行登录了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="有效时间"><a href="#有效时间" class="headerlink" title="有效时间"></a>有效时间</h4><p>默认情况下重启项目后登录状态失效了。但是可以通过设置状态有效时间，即使项目重新启动下次也可以正常登录。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.rememberMe()</span><br><span class="line">      <span class="comment">//失效时间，单位秒</span></span><br><span class="line">      .tokenValiditySeconds(<span class="number">120</span>)</span><br><span class="line">      <span class="comment">//登录逻辑交给哪个对象</span></span><br><span class="line">      .userDetailsService(userService)</span><br><span class="line">      <span class="comment">// 持久层对象</span></span><br><span class="line">      .tokenRepository(persistentTokenRepository);</span><br></pre></td></tr></table></figure><h3 id="Thymeleaf中SpringSecurity的使用"><a href="#Thymeleaf中SpringSecurity的使用" class="headerlink" title="Thymeleaf中SpringSecurity的使用"></a>Thymeleaf中SpringSecurity的使用</h3><p>　Spring Security 可以在一些视图技术中进行控制显示效果。例如：<code>JSP </code>或 <code>Thymeleaf</code>。在非前后端分离且使用 Spring Boot 的项目中多使用 <code>Thymeleaf </code>作为视图展示技术。</p><p>　Thymeleaf 对 Spring Security 的 支 持 都 放 在<code>thymeleaf-extras-springsecurityX </code>中，目前最新版本为 5。所以需要在项目中添加此 jar 包的依赖和 thymeleaf 的依赖。。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--thymeleaf springsecurity5 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--thymeleaf依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 html 页面中引入 thymeleaf 命名空间和 security 命名空间</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h4><p>可以在html页面中通过<code>sec:authentication=&quot;&quot;</code>获取</p><p><code>UsernamePasswordAuthenticationToken</code>中所有 <code>getXXX </code>的内容，包含父类中的 <code>getXXX </code>的内容。</p><p>根据源码得出下面属性：</p><ul><li><p><code>name</code>：登录账号名称</p></li><li><p><code>principal</code>：登录主体，在自定义登录逻辑中是 UserDetails</p></li><li><p><code>credentials</code>：凭证</p></li><li><p><code>authorities</code>：权限和角色</p></li><li><p><code>details</code>：实际上是 <code>WebAuthenticationDetails </code>的实例。可以获取<code>remoteAddress</code>(客户端 ip)和 <code>sessionId</code>(当前 sessionId)</p></li></ul><h5 id="新建demo-html"><a href="#新建demo-html" class="headerlink" title="新建demo.html"></a>新建demo.html</h5><p>在项目 resources 中新建 templates 文件夹，在 templates 中新建demo.html 页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    登录账号:<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    登录账号:<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;principal.username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    凭证：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;credentials&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    权限和角色：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;authorities&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    客户端地址：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;details.remoteAddress&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    sessionId：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;details.sessionId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h5><p>thymeleaf 页面需要控制转发，在控制器类中编写下面方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="权限判断"><a href="#权限判断" class="headerlink" title="权限判断"></a>权限判断</h4><h5 id="设置用户角色和权限"><a href="#设置用户角色和权限" class="headerlink" title="设置用户角色和权限"></a>设置用户角色和权限</h5><p>设定用户具有 admin，/insert，/delete 权限 ROLE_abc 角色。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,ROLE_abc,/insert,/delete&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="控制页面显示效果"><a href="#控制页面显示效果" class="headerlink" title="控制页面显示效果"></a>控制页面显示效果</h5><p>在页面中根据用户权限和角色判断页面中显示的内容</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">通过权限判断：</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasAuthority(&#x27;/insert&#x27;)&quot;</span>&gt;</span>新增<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasAuthority(&#x27;/delete&#x27;)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasAuthority(&#x27;/update&#x27;)&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasAuthority(&#x27;/select&#x27;)&quot;</span>&gt;</span>查看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">通过角色判断：</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>&gt;</span>新增<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;abc&#x27;)&quot;</span>&gt;</span>查看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><p>用户只需要向 Spring Security 项目中发送<code>/logout </code>退出请求即可。</p><h4 id="退出登录-1"><a href="#退出登录-1" class="headerlink" title="退出登录"></a>退出登录</h4><p>实现退出非常简单，只要在页面中添加<code>/logout</code> 的超链接即可。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了实现更好的效果，通常添加退出的配置。默认的退出 url 为<code>/logout</code>，退出成功后跳转到<code>/login?logout</code></p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image33.png"></p><p>如果不希望使用默认值，可以通过下面的方法进行修改。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.logout()</span><br><span class="line">      .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">      .logoutSuccessUrl(<span class="string">&quot;/login.html&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="logout其他常用配置源码解读"><a href="#logout其他常用配置源码解读" class="headerlink" title="logout其他常用配置源码解读"></a>logout其他常用配置源码解读</h4><h5 id="addLogoutHandler-LogoutHandler"><a href="#addLogoutHandler-LogoutHandler" class="headerlink" title="addLogoutHandler(LogoutHandler)"></a>addLogoutHandler(LogoutHandler)</h5><p>默认是 contextLogoutHandler</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image34.png"></p><p> 默认实例内容</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image35.png"></p><h5 id="clearAuthentication-boolean"><a href="#clearAuthentication-boolean" class="headerlink" title="clearAuthentication(boolean)"></a>clearAuthentication(boolean)</h5><p>是否清除认证状态，默认为 true</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image36.png"></p><h5 id="invalidateHttpSession-boolean"><a href="#invalidateHttpSession-boolean" class="headerlink" title="invalidateHttpSession(boolean)"></a>invalidateHttpSession(boolean)</h5><p>是否销毁 HttpSession 对象，默认为 true</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image37.png"></p><h5 id="logoutSuccessHandler-LogoutSuccessHandler"><a href="#logoutSuccessHandler-LogoutSuccessHandler" class="headerlink" title="logoutSuccessHandler(LogoutSuccessHandler)"></a>logoutSuccessHandler(LogoutSuccessHandler)</h5><p>退出成功处理器</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image38.png"></p><p>　也可以自己进行定义退出成功处理器。只要实现了<code>LogoutSuccessHandler </code>接口。与之前讲解的登录成功处理器和登录失败处理器极其类似。</p><h3 id="SpringSecurity中的CSRF"><a href="#SpringSecurity中的CSRF" class="headerlink" title="SpringSecurity中的CSRF"></a>SpringSecurity中的CSRF</h3><p>　从刚开始学习Spring Security时，在配置类中一直存在这样一行代码：<code>http.csrf().disable();</code>如果没有这行代码导致用户无法被认证。这行代码的含义是：关闭 csrf 防护。</p><h4 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h4><p>　CSRF（Cross-site request forgery）跨站请求伪造，也被称为“OneClick Attack” 或者 Session Riding。通过伪造用户请求访问受信任站点的非法请求访问。</p><p>　跨域：只要网络协议，ip 地址，端口中任何一个不相同就是跨域请求。</p><p>　客户端与服务进行交互时，由于 http 协议本身是无状态协议，所以引入了cookie进行记录客户端身份。在cookie中会存放session id用来识别客户端身份的。在跨域的情况下，session id 可能被第三方恶意劫持，通过这个 session id 向服务端发起请求时，服务端会认为这个请求是合法的，可能发生很多意想不到的事情。</p><h4 id="2、Spring-Security中的CSRF"><a href="#2、Spring-Security中的CSRF" class="headerlink" title="2、Spring Security中的CSRF"></a>2、Spring Security中的CSRF</h4><p>　从 Spring Security4开始CSRF防护默认开启。默认会拦截请求。进行CSRF处理。CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为<code>_csrf</code>值为token(token 在服务端产生)的内容，如果token和服务端的token匹配成功，则正常访问。</p><h5 id="2-1、编写控制器方法"><a href="#2-1、编写控制器方法" class="headerlink" title="2.1、编写控制器方法"></a>2.1、编写控制器方法</h5><p>编写控制器方法，跳转到 templates 中 login.html 页面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showLogin&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2、新建login.html</p><p>红色部分是必须存在的否则无法正常登录。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;_csrf&#125;&quot;</span>/&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改配置类-3"><a href="#修改配置类-3" class="headerlink" title="修改配置类"></a>修改配置类</h5><p>在配置类中注释掉 CSRF 防护失效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭csrf防护</span></span><br><span class="line"><span class="comment">// http.csrf().disable();</span></span><br></pre></td></tr></table></figure><h2 id="Oauth2认证"><a href="#Oauth2认证" class="headerlink" title="Oauth2认证"></a>Oauth2认证</h2><h3 id="Oauth2简介"><a href="#Oauth2简介" class="headerlink" title="Oauth2简介"></a>Oauth2简介</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>　第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间要遵循一定的接口协议。</p><p>　OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。</p><p>　Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。</p><p>参考：<a href="https://baike.baidu.com/item/oAuth/7153134?fr=aladdin">https://baike.baidu.com/item/oAuth/7153134?fr=aladdin</a></p><p>Oauth 协议：<a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p>下边分析一个Oauth2认证的例子，网站使用微信认证的过程：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image39.png"></p><ol><li>用户进入网站的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。</li></ol><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image40.png"></p><p>点击“微信”出现一个二维码，此时用户扫描二维码，开始给网站授权。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image41.png"></p><ol start="2"><li>资源拥有者同意给客户端授权</li></ol><p>　资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证，验证通过后，微信会询问用户是否给授权网站访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到网站。</p><ol start="3"><li>客户端获取到授权码，请求认证服务器申请令牌</li></ol><p>　此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。</p><ol start="4"><li>认证服务器向客户端响应令牌</li></ol><p>　认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。此交互过程用户看不到，当客户端拿到令牌后，用户在网站看到已经登录成功。</p><ol start="5"><li>客户端请求资源服务器的资源</li></ol><p>　客户端携带令牌访问资源服务器的资源。网站携带令牌请求访问微信服务器获取用户的基本信息。</p><ol start="6"><li>资源服务器返回受保护资源</li></ol><p>　资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。</p><p>注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。</p><p>Oauth2.0认证流程如下：</p><p>引自Oauth2.0协议rfc6749 <a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image42.png"></p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><strong>客户端</strong></p><p>本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。</p><p><strong>资源拥有者</strong></p><p>通常为用户，也可以是应用程序，即该资源的拥有者。</p><p><strong>授权服务器（也称认证服务器）</strong></p><p>用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。</p><p><strong>资源服务器</strong></p><p>存储资源的服务器，比如，网站用户管理服务器存储了网站用户信息，网站相册服务器存储了用户的相册信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。</p><h4 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h4><ul><li><code>客户凭证(client Credentials)</code>：客户端的clientId和密码用于认证客户</li><li><code>令牌(tokens)</code>：授权服务器在接收到客户请求后，颁发的访问令牌</li><li><code>作用域(scopes)</code>：客户请求访问令牌时，由资源拥有者额外指定的细分权限(permission)</li></ul><h4 id="令牌类型"><a href="#令牌类型" class="headerlink" title="令牌类型"></a>令牌类型</h4><ul><li><p><code>授权码</code>：仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌</p></li><li><p><code>访问令牌</code>：用于代表一个用户或服务直接去访问受保护的资源</p></li><li><p><code>刷新令牌</code>：用于去授权服务器获取一个刷新访问令牌</p></li><li><p><code>BearerToken</code>：不管谁拿到Token都可以访问资源，类似现金</p></li><li><p><code>Proof of Possession(PoP) Token</code>：可以校验client是否对Token有明确的拥有权</p></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>优点</strong>：</p><p>​     更安全，客户端不接触用户密码，服务器端更易集中保护</p><p>​     广泛传播并被持续采用</p><p>​     短寿命和封装的token</p><p>​     资源服务器和授权服务器解耦</p><p>​     集中式授权，简化客户端</p><p>​     HTTP/JSON友好，易于请求和传递token</p><p>​     考虑多种客户端架构场景</p><p>​     客户可以具有不同的信任级别</p><p><strong>缺点</strong>：</p><p>​     协议框架太宽泛，造成各种实现的兼容性和互操作性差</p><p>​     不是一个认证协议，本身并不能告诉你任何用户信息。</p><h3 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h3><h4 id="授权码模式（Authorization-Code）"><a href="#授权码模式（Authorization-Code）" class="headerlink" title="授权码模式（Authorization Code）"></a>授权码模式（Authorization Code）</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image43.jpeg"></p><h4 id="简化授权模式（Implicit）"><a href="#简化授权模式（Implicit）" class="headerlink" title="简化授权模式（Implicit）"></a>简化授权模式（Implicit）</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image44.png"></p><h4 id="密码模式（Resource-Owner-PasswordCredentials）"><a href="#密码模式（Resource-Owner-PasswordCredentials）" class="headerlink" title="密码模式（Resource Owner PasswordCredentials）"></a>密码模式（Resource Owner PasswordCredentials）</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image45.png"></p><h4 id="客户端模式（Client-Credentials）"><a href="#客户端模式（Client-Credentials）" class="headerlink" title="客户端模式（Client Credentials）"></a>客户端模式（Client Credentials）</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image46.png"></p><h4 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h4><p><img src="/../../img/markdown_img/SpringSecurity.assets/image47.jpeg"></p><h2 id="Spring-Security-Oauth2"><a href="#Spring-Security-Oauth2" class="headerlink" title="Spring Security Oauth2"></a>Spring Security Oauth2</h2><h3 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h3><p><img src="/../../img/markdown_img/SpringSecurity.assets/image48.png"></p><ul><li><p><code>Authorize Endpoint</code>：授权端点，进行授权</p></li><li><p><code>Token Endpoint</code>：令牌端点，经过授权拿到对应的Token</p></li><li><p><code>Introspection Endpoint</code>：校验端点，校验Token的合法性</p></li><li><p><code>Revocation Endpoint</code>：撤销端点，撤销授权</p></li></ul><h3 id="Spring-Security-Oauth2架构"><a href="#Spring-Security-Oauth2架构" class="headerlink" title="Spring Security Oauth2架构"></a>Spring Security Oauth2架构</h3><p><img src="/../../img/markdown_img/SpringSecurity.assets/image49.png"></p><p>流程：</p><ol><li><p>用户访问,此时没有Token。Oauth2RestTemplate会报错，这个报错信息会被Oauth2ClientContextFilter捕获并重定向到认证服务器</p></li><li><p>认证服务器通过Authorization Endpoint进行授权，并通过AuthorizationServerTokenServices生成授权码并返回给客户端</p></li><li><p>客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端</p></li><li><p>客户端拿到Token去资源服务器访问资源，一般会通过Oauth2AuthenticationManager调用ResourceServerTokenServices进行校验。校验通过可以获取资源。</p></li></ol><h3 id="Spring-Security-Oauth2授权码模式"><a href="#Spring-Security-Oauth2授权码模式" class="headerlink" title="Spring Security Oauth2授权码模式"></a>Spring Security Oauth2授权码模式</h3><h4 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h4><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image50.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image51.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image52.png"></p><h4 id="2、添加依赖"><a href="#2、添加依赖" class="headerlink" title="2、添加依赖"></a>2、添加依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yjxxt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springsecurityoauth2demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>springsecurityoauth2demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、编写实体类"><a href="#3、编写实体类" class="headerlink" title="3、编写实体类"></a>3、编写实体类</h4><p>User.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password, List&lt;GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、编写Service"><a href="#4、编写Service" class="headerlink" title="4、编写Service"></a>4、编写Service</h4><p>UserService.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">      String password = passwordEncoder.encode(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;admin&quot;</span>,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5、编写Controller"><a href="#5、编写Controller" class="headerlink" title="5、编写Controller"></a>5、编写Controller</h4><p>UserController.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getCurrentUser&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> authentication.getPrincipal();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、编写配置类"><a href="#6、编写配置类" class="headerlink" title="6、编写配置类"></a>6、编写配置类</h4><p>SecurityConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      http.csrf()</span><br><span class="line">            .disable()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/oauth/**&quot;</span>, <span class="string">&quot;/login/**&quot;</span>, <span class="string">&quot;/logout/**&quot;</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AuthorizationServerConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResourceServerConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .requestMatchers()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/**&quot;</span>);<span class="comment">//配置需要保护的资源路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h4><h5 id="获取授权码"><a href="#获取授权码" class="headerlink" title="获取授权码"></a>获取授权码</h5><p><a href="http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=http://www.baidu.com&amp;scope=all">http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=admin&amp;redirect_uri=http://www.baidu.com&amp;scope=all</a> </p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image53.png"></p><p>输入账户密码</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image54.png"></p><p>点击授权获取授权码</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image55.png"></p><h5 id="根据授权码获取令牌（POST请求）"><a href="#根据授权码获取令牌（POST请求）" class="headerlink" title="根据授权码获取令牌（POST请求）"></a>根据授权码获取令牌（POST请求）</h5><p><img src="/../../img/markdown_img/SpringSecurity.assets/image56.png"></p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image57.png"></p><ul><li><p><code>grant_type</code>：授权类型，填写authorization_code，表示授权码模式</p></li><li><p><code>code</code>：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。</p></li><li><p><code>client_id</code>:客户端标识</p></li><li><p><code>redirect_uri</code>：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。</p></li><li><p><code>scope</code>:授权范围。</p></li></ul><p>认证失败服务端返回 401 Unauthorized</p><p>注意：此时无法请求到令牌，访问服务器会报错</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image58.png"></p><h5 id="根据token去资源服务器拿资源"><a href="#根据token去资源服务器拿资源" class="headerlink" title="根据token去资源服务器拿资源"></a>根据token去资源服务器拿资源</h5><p><img src="/../../img/markdown_img/SpringSecurity.assets/image59.png"></p><p>如果修改token就会报错</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image60.png"></p><h3 id="Spring-Security-Oauth2-密码模式"><a href="#Spring-Security-Oauth2-密码模式" class="headerlink" title="Spring Security Oauth2 密码模式"></a>Spring Security Oauth2 密码模式</h3><p>在上面的代码中进行适当的修改即可</p><p>SecurityConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      http.csrf()</span><br><span class="line">            .disable()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/oauth/**&quot;</span>, <span class="string">&quot;/login/**&quot;</span>, <span class="string">&quot;/logout/**&quot;</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AuthorizationServerConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image56.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image61.png"></p><h3 id="在Redis中存储token"><a href="#在Redis中存储token" class="headerlink" title="在Redis中存储token"></a>在Redis中存储token</h3><p>之前的代码我们将token直接存在内存中，这在生产环境中是不合理的，下面我们将其改造成存储在Redis中</p><h4 id="添加依赖及配置"><a href="#添加依赖及配置" class="headerlink" title="添加依赖及配置"></a>添加依赖及配置</h4><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- commons-pool2 对象池依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis配置</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.10.100</span></span><br></pre></td></tr></table></figure><h4 id="编写Redis配置类"><a href="#编写Redis配置类" class="headerlink" title="编写Redis配置类"></a>编写Redis配置类</h4><p>RedisConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TokenStore <span class="title">redisTokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RedisTokenStore(redisConnectionFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在认证服务器配置中指定令牌的存储策略为Redis"><a href="#在认证服务器配置中指定令牌的存储策略为Redis" class="headerlink" title="在认证服务器配置中指定令牌的存储策略为Redis"></a>在认证服务器配置中指定令牌的存储策略为Redis</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;redisTokenStore&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService)</span><br><span class="line">                .tokenStore(tokenStore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>使用密码模式请求token</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image62.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image63.png"></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="常见的认证机制"><a href="#常见的认证机制" class="headerlink" title="常见的认证机制"></a>常见的认证机制</h3><h4 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h4><p>　HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth。</p><h4 id="Cookie-Auth"><a href="#Cookie-Auth" class="headerlink" title="Cookie Auth"></a>Cookie Auth</h4><p>　Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。       </p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image64.png">                   </p><h4 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h4><p>　OAuth（开放授权,Open Authorization）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。</p><p>　OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。</p><p>下面是OAuth2.0的流程：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image65.png"></p><p>　这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。</p><p>缺点：过重。</p><h4 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h4><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li><p>客户端使用用户名跟密码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p></li><li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p></li></ol><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image66.png"></p><p>比第一种方式更安全，比第二种方式更节约服务器资源，比第三种方式更加轻量。</p><p>具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）：</p><ol><li><p>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</p></li><li><p>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</p></li><li><p>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</p></li><li><p>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</p></li><li><p>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 10等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p></li><li><p>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</p></li><li><p>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多.</p></li><li><p>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</p></li><li><p>基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</p></li></ol><h3 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h3><h4 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h4><p>　JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。</p><p>官网：  <a href="https://jwt.io/">https://jwt.io/</a></p><p>标准：  <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a></p><p>JWT令牌的优点：</p><ol><li><p>jwt基于json，非常方便解析。</p></li><li><p>可以在令牌中自定义丰富的内容，易扩展。</p></li><li><p>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</p></li><li><p>资源服务使用JWT可不依赖认证服务即可完成授权。</p></li></ol><p>缺点：</p><ol><li>JWT令牌较长，占存储空间比较大。</li></ol><h4 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h4><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p><h5 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h5><p>头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法（如HMAC SHA256或RSA）等。这也可以被表示成一个JSON对象。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>typ</code>：是类型。</p></li><li><p><code>alg</code>：签名的算法，这里使用的算法是HS256算法</p></li></ul><p>我们对头部的json字符串进行BASE64编码（网上有很多在线编码的网站），编码后的字符串如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  </span><br></pre></td></tr></table></figure><p>　<code>Base64</code>是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 <code>BASE64Encoder </code>和 <code>BASE64Decoder</code>，用它们可以非常方便的完成基于 BASE64 的编码和解码。</p><h5 id="负载-Payload"><a href="#负载-Payload" class="headerlink" title="负载(Payload)"></a>负载(Payload)</h5><p>第二部分是负载，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：</p><ul><li>标准中注册的声明（建议但不强制使用）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iss: jwt签发者</span><br><span class="line">sub: jwt所面向的用户</span><br><span class="line">aud: 接收jwt的一方</span><br><span class="line">exp: jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">nbf: 定义在什么时间之前，该jwt都是不可用的.</span><br><span class="line">iat: jwt的签发时间</span><br><span class="line">jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</span><br></pre></td></tr></table></figure><ul><li>公共的声明</li></ul><p>　公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><ul><li>私有的声明</li></ul><p>　私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>　这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>sub</code>是标准的声明，<code>name</code>是自定义的声明（公共的或私有的）</p><p>然后将其进行base64编码，得到Jwt的第二部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbWVzIiwiYWRtaW4iOnRydWV9  </span><br></pre></td></tr></table></figure><p>提示：声明中不要放一些敏感信息。</p><h5 id="签证、签名（signature）"><a href="#签证、签名（signature）" class="headerlink" title="签证、签名（signature）"></a>签证、签名（signature）</h5><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ol><li><p>header (base64后的)</p></li><li><p>payload (base64后的)</p></li><li><p>secret（盐，一定要保密）</p></li></ol><p>　这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI</span><br></pre></td></tr></table></figure><p>将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR9cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI  </span><br></pre></td></tr></table></figure><p>注意：<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以自我签发<code>jwt</code>了。</p><h3 id="JJWT简介"><a href="#JJWT简介" class="headerlink" title="JJWT简介"></a>JJWT简介</h3><h4 id="什么是JJWT"><a href="#什么是JJWT" class="headerlink" title="什么是JJWT"></a>什么是JJWT</h4><p>　JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</p><p>规范官网：<a href="https://jwt.io/">https://jwt.io/</a></p><h4 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h4><h5 id="token的创建"><a href="#token的创建" class="headerlink" title="token的创建"></a>token的创建</h5><p>创建SpringBoot工程，引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yjxxt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jwtdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>jwtdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--JWT依赖--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 创建测试类JwtTest，用于生成token：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.jwtdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.impl.Base64Codec;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtdemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建token</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreatToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建一个JwtBuilder对象</span></span><br><span class="line">      JwtBuilder jwtBuilder = Jwts.builder()</span><br><span class="line">            <span class="comment">//声明的标识&#123;&quot;jti&quot;:&quot;888&quot;&#125;</span></span><br><span class="line">            .setId(<span class="string">&quot;888&quot;</span>)</span><br><span class="line">            <span class="comment">//主体，用户&#123;&quot;sub&quot;:&quot;Rose&quot;&#125;</span></span><br><span class="line">            .setSubject(<span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">            <span class="comment">//创建日期&#123;&quot;ita&quot;:&quot;yjxxtxx&quot;&#125;</span></span><br><span class="line">            .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">            <span class="comment">//签名手段，参数1：算法，参数2：盐</span></span><br><span class="line">            .signWith(SignatureAlgorithm.HS256,<span class="string">&quot;yjxxt&quot;</span>);</span><br><span class="line">      <span class="comment">//获取jwt的token</span></span><br><span class="line">      String token = jwtBuilder.compact();</span><br><span class="line">      System.out.println(token);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//三部分的base64解密</span></span><br><span class="line">      System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">      String[] split = token.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">      System.out.println(Base64Codec.BASE64.decodeToString(split[<span class="number">0</span>]));</span><br><span class="line">      System.out.println(Base64Codec.BASE64.decodeToString(split[<span class="number">1</span>]));</span><br><span class="line">      <span class="comment">//无法解密</span></span><br><span class="line">      System.out.println(Base64Codec.BASE64.decodeToString(split[<span class="number">2</span>]));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image67.png"></p><p>再次运行，会发现每次运行的结果是不一样的，因为我们的载荷中包含了时间</p><h5 id="token的验证解析"><a href="#token的验证解析" class="headerlink" title="token的验证解析"></a>token的验证解析</h5><p>　我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParseToken</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//token</span></span><br><span class="line">   String token = <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE0MjUyfQ&quot;</span> +</span><br><span class="line">         <span class="string">&quot;.-FYFMHyfTcGzq900f_Drfdsges0ge2UjaWvPW9gCDto&quot;</span>;</span><br><span class="line">   <span class="comment">//解析token获取负载中的声明对象</span></span><br><span class="line">   Claims claims = Jwts.parser()</span><br><span class="line">         .setSigningKey(<span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         .parseClaimsJws(token)</span><br><span class="line">         .getBody();</span><br><span class="line">   <span class="comment">//打印声明的属性</span></span><br><span class="line">   System.out.println(<span class="string">&quot;id:&quot;</span>+claims.getId());</span><br><span class="line">   System.out.println(<span class="string">&quot;subject:&quot;</span>+claims.getSubject());</span><br><span class="line">   System.out.println(<span class="string">&quot;issuedAt:&quot;</span>+claims.getIssuedAt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token</p><h5 id="token过期校验"><a href="#token过期校验" class="headerlink" title="token过期校验"></a>token过期校验</h5><p>　有很多时候，我们并不希望签发的token是永久生效的（上节的token是永久的），所以我们可以为token添加一个过期时间。原因：从服务器发出的token，服务器自己并不做记录，就存在一个弊端就是，服务端无法主动控制某token的立刻失效。</p><p>测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreatTokenHasExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//当前系统时间的长整型</span></span><br><span class="line">   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">//过期时间，这里是1分钟后的时间长整型</span></span><br><span class="line">   <span class="keyword">long</span> exp = now + <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">   <span class="comment">//创建一个JwtBuilder对象</span></span><br><span class="line">   JwtBuilder jwtBuilder = Jwts.builder()</span><br><span class="line">         <span class="comment">//声明的标识&#123;&quot;jti&quot;:&quot;888&quot;&#125;</span></span><br><span class="line">         .setId(<span class="string">&quot;888&quot;</span>)</span><br><span class="line">         <span class="comment">//主体，用户&#123;&quot;sub&quot;:&quot;Rose&quot;&#125;</span></span><br><span class="line">         .setSubject(<span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">         <span class="comment">//创建日期&#123;&quot;ita&quot;:&quot;yjxxtxx&quot;&#125;</span></span><br><span class="line">         .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">         <span class="comment">//签名手段，参数1：算法，参数2：盐</span></span><br><span class="line">         .signWith(SignatureAlgorithm.HS256, <span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         <span class="comment">//设置过期时间</span></span><br><span class="line">         .setExpiration(<span class="keyword">new</span> Date(exp));</span><br><span class="line">   <span class="comment">//获取jwt的token</span></span><br><span class="line">   String token = jwtBuilder.compact();</span><br><span class="line">   System.out.println(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParseTokenHasExp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//token</span></span><br><span class="line">   String token = <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9&quot;</span> +</span><br><span class="line">         <span class="string">&quot;.eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE1MDYyLCJleHAiOjE1Nzg4MTUxMjIsInJvbGVzIjoiYWRtaW4iLCJsb2dvIjoic2hzeHQuanBnIn0.hKog0RsZ9_6II_R8kUCp0HLAouUAYXAJVbz3xtLTUh4&quot;</span>;</span><br><span class="line">   <span class="comment">//解析token获取负载中的声明对象</span></span><br><span class="line">   Claims claims = Jwts.parser()</span><br><span class="line">         .setSigningKey(<span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         .parseClaimsJws(token)</span><br><span class="line">         .getBody();</span><br><span class="line">   <span class="comment">//打印声明的属性</span></span><br><span class="line">   System.out.println(<span class="string">&quot;id:&quot;</span> + claims.getId());</span><br><span class="line">   System.out.println(<span class="string">&quot;subject:&quot;</span> + claims.getSubject());</span><br><span class="line">   System.out.println(<span class="string">&quot;issuedAt:&quot;</span> + claims.getIssuedAt());</span><br><span class="line">   DateFormat sf =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;签发时间:&quot;</span>+sf.format(claims.getIssuedAt()));</span><br><span class="line">   System.out.println(<span class="string">&quot;过期时间:&quot;</span>+sf.format(claims.getExpiration()));</span><br><span class="line">   System.out.println(<span class="string">&quot;当前时间:&quot;</span>+sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：当未过期时可以正常读取，当过期时会引发io.jsonwebtoken.ExpiredJwtException异常。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image68.png"></p><h5 id="自定义claims"><a href="#自定义claims" class="headerlink" title="自定义claims"></a>自定义claims</h5><p>我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角色）可以定义自定义claims </p><p>测试用例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreatTokenByClaims</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//当前系统时间的长整型</span></span><br><span class="line">   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">//过期时间，这里是1分钟后的时间长整型</span></span><br><span class="line">   <span class="keyword">long</span> exp = now + <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">   <span class="comment">//创建一个JwtBuilder对象</span></span><br><span class="line">   JwtBuilder jwtBuilder = Jwts.builder()</span><br><span class="line">         <span class="comment">//声明的标识&#123;&quot;jti&quot;:&quot;888&quot;&#125;</span></span><br><span class="line">         .setId(<span class="string">&quot;888&quot;</span>)</span><br><span class="line">         <span class="comment">//主体，用户&#123;&quot;sub&quot;:&quot;Rose&quot;&#125;</span></span><br><span class="line">         .setSubject(<span class="string">&quot;Rose&quot;</span>)</span><br><span class="line">         <span class="comment">//创建日期&#123;&quot;ita&quot;:&quot;yjxxtxx&quot;&#125;</span></span><br><span class="line">         .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">         <span class="comment">//签名手段，参数1：算法，参数2：盐</span></span><br><span class="line">         .signWith(SignatureAlgorithm.HS256, <span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         <span class="comment">//设置过期时间</span></span><br><span class="line">         .setExpiration(<span class="keyword">new</span> Date(exp))</span><br><span class="line">         <span class="comment">//直接传入map</span></span><br><span class="line">         <span class="comment">// .addClaims(map)</span></span><br><span class="line">         .claim(<span class="string">&quot;roles&quot;</span>,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">         .claim(<span class="string">&quot;logo&quot;</span>,<span class="string">&quot;yjxxt.jpg&quot;</span>);</span><br><span class="line">   <span class="comment">//获取jwt的token</span></span><br><span class="line">   String token = jwtBuilder.compact();</span><br><span class="line">   System.out.println(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParseTokenByClaims</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//token</span></span><br><span class="line">   String token = <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9&quot;</span> +</span><br><span class="line">         <span class="string">&quot;.eyJqdGkiOiI4ODgiLCJzdWIiOiJSb3NlIiwiaWF0IjoxNTc4ODE1MDYyLCJleHAiOjE1Nzg4MTUxMjIsInJvbGVzIjoiYWRtaW4iLCJsb2dvIjoic2hzeHQuanBnIn0.hKog0RsZ9_6II_R8kUCp0HLAouUAYXAJVbz3xtLTUh4&quot;</span>;</span><br><span class="line">   <span class="comment">//解析token获取负载中的声明对象</span></span><br><span class="line">   Claims claims = Jwts.parser()</span><br><span class="line">         .setSigningKey(<span class="string">&quot;yjxxt&quot;</span>)</span><br><span class="line">         .parseClaimsJws(token)</span><br><span class="line">         .getBody();</span><br><span class="line">   <span class="comment">//打印声明的属性</span></span><br><span class="line">   System.out.println(<span class="string">&quot;id:&quot;</span> + claims.getId());</span><br><span class="line">   System.out.println(<span class="string">&quot;subject:&quot;</span> + claims.getSubject());</span><br><span class="line">   System.out.println(<span class="string">&quot;issuedAt:&quot;</span> + claims.getIssuedAt());</span><br><span class="line">   DateFormat sf =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;签发时间:&quot;</span>+sf.format(claims.getIssuedAt()));</span><br><span class="line">   System.out.println(<span class="string">&quot;过期时间:&quot;</span>+sf.format(claims.getExpiration()));</span><br><span class="line">   System.out.println(<span class="string">&quot;当前时间:&quot;</span>+sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">&quot;roles:&quot;</span>+claims.get(<span class="string">&quot;roles&quot;</span>));</span><br><span class="line">   System.out.println(<span class="string">&quot;logo:&quot;</span>+claims.get(<span class="string">&quot;logo&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Security-Oauth2-整合JWT"><a href="#Spring-Security-Oauth2-整合JWT" class="headerlink" title="Spring Security Oauth2 整合JWT"></a>Spring Security Oauth2 整合JWT</h2><h3 id="整合JWT"><a href="#整合JWT" class="headerlink" title="整合JWT"></a>整合JWT</h3><p>我们拿之前Spring Security Oauth2的完整代码进行修改</p><p>添加配置文件JwtTokenStoreConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtTokenStore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenStoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TokenStore <span class="title">jwtTokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      JwtAccessTokenConverter accessTokenConverter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">      <span class="comment">//配置JWT使用的秘钥</span></span><br><span class="line">      accessTokenConverter.setSigningKey(<span class="string">&quot;test_key&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> accessTokenConverter;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在认证服务器配置中指定令牌的存储策略为JWT</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;jwtTokenStore&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService)</span><br><span class="line">                <span class="comment">//配置存储令牌策略</span></span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用密码模式测试：</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image69.png"></p><p>发现获取到的令牌已经变成了JWT令牌，将access_token拿到<a href="https://jwt.io/">https://jwt.io/</a> 网站上去解析下可以获得其中内容。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image70.png"></p><h3 id="扩展JWT中存储的内容"><a href="#扩展JWT中存储的内容" class="headerlink" title="扩展JWT中存储的内容"></a>扩展JWT中存储的内容</h3><p>　有时候我们需要扩展JWT中存储的内容，这里我们在JWT中扩展一个<code>key为enhance，value为enhance info</code>的数据。</p><p>继承TokenEnhancer实现一个JWT内容增强器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.common.OAuth2AccessToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.OAuth2Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenEnhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JWT内容增强器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenEnhancer</span> <span class="keyword">implements</span> <span class="title">TokenEnhancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> OAuth2AccessToken <span class="title">enhance</span><span class="params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">      Map&lt;String,Object&gt; info = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      info.put(<span class="string">&quot;enhance&quot;</span>,<span class="string">&quot;enhance info&quot;</span>);</span><br><span class="line">      ((DefaultOAuth2AccessToken)accessToken).setAdditionalInformation(info);</span><br><span class="line">      <span class="keyword">return</span> accessToken;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个JwtTokenEnhancer实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtTokenStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Jwt存储token的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenStoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TokenStore <span class="title">jwtTokenStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      JwtAccessTokenConverter accessTokenConverter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">      <span class="comment">//配置JWT使用的秘钥</span></span><br><span class="line">      accessTokenConverter.setSigningKey(<span class="string">&quot;test_key&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> accessTokenConverter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JwtTokenEnhancer <span class="title">jwtTokenEnhancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenEnhancer();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在认证服务器配置中配置JWT的内容增强器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.component.JwtTokenEnhancer;</span><br><span class="line"><span class="keyword">import</span> com.yjxxt.springsecurityoauth2demo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenEnhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenEnhancerChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 授权服务器配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;jwtTokenStore&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenEnhancer jwtTokenEnhancer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密码模式需要配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">        TokenEnhancerChain enhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        List&lt;TokenEnhancer&gt; delegates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//配置JWT的内容增强器</span></span><br><span class="line">        delegates.add(jwtTokenEnhancer);</span><br><span class="line">        delegates.add(jwtAccessTokenConverter);</span><br><span class="line">        enhancerChain.setTokenEnhancers(delegates);</span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .userDetailsService(userService)</span><br><span class="line">                <span class="comment">//配置存储令牌策略</span></span><br><span class="line">                .tokenStore(tokenStore)</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter)</span><br><span class="line">                .tokenEnhancer(enhancerChain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                <span class="comment">//配置client_id</span></span><br><span class="line">                .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                <span class="comment">//配置client-secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">                <span class="comment">//配置访问token的有效期</span></span><br><span class="line">                .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">                .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">                <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                <span class="comment">//配置申请的权限范围</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">                <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行项目后使用密码模式来获取令牌，之后对令牌进行解析，发现已经包含扩展的内容。</p><p> <img src="/../../img/markdown_img/SpringSecurity.assets/image71.png"></p><h3 id="Java中解析JWT中的内容"><a href="#Java中解析JWT中的内容" class="headerlink" title="Java中解析JWT中的内容"></a>Java中解析JWT中的内容</h3><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jwt 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改UserController类，使用jjwt工具类来解析Authorization头中存储的JWT内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.springsecurityoauth2demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/getCurrentUser&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">      String header = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      String token = header.substring(header.indexOf(<span class="string">&quot;bearer&quot;</span>) + <span class="number">7</span>);</span><br><span class="line">      <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">            .setSigningKey(<span class="string">&quot;test_key&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            .parseClaimsJws(token)</span><br><span class="line">            .getBody();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将令牌放入Authorization头中，访问如下地址获取信息：</p><p><a href="http://localhost:8080/user/getCurrentUser">http://localhost:8080/user/getCurrentUser</a></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image72.png"></p><h3 id="刷新令牌-1"><a href="#刷新令牌-1" class="headerlink" title="刷新令牌"></a>刷新令牌</h3><p>　在Spring Cloud Security 中使用oauth2时，如果令牌失效了，可以使用刷新令牌通过refresh_token的授权模式再次获取access_token。</p><p>只需修改认证服务器的配置，添加refresh_token的授权模式即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            <span class="comment">//配置client_id</span></span><br><span class="line">            .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">            <span class="comment">//配置client-secret</span></span><br><span class="line">            .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">            <span class="comment">//配置访问token的有效期</span></span><br><span class="line">            .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">            <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">            .refreshTokenValiditySeconds(<span class="number">86400</span>)</span><br><span class="line">            <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">            .redirectUris(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">            <span class="comment">//配置申请的权限范围</span></span><br><span class="line">            .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">            <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">            .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用刷新令牌模式来获取新的令牌，访问如下地址：</p><p><a href="http://localhost:8080/oauth/token">http://localhost:8080/oauth/token</a></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image73.png"></p><h2 id="Spring-Security-Oauth2-整合单点登录（SSO）"><a href="#Spring-Security-Oauth2-整合单点登录（SSO）" class="headerlink" title="Spring Security Oauth2 整合单点登录（SSO）"></a>Spring Security Oauth2 整合单点登录（SSO）</h2><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><p><img src="/../../img/markdown_img/SpringSecurity.assets/image74.png"></p><p>   <img src="/../../img/markdown_img/SpringSecurity.assets/image75.png"></p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image76.png"></p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yjxxt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oauth2client01demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>oauth2client01demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>application.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment">#防止Cookie冲突，冲突会导致登录验证不通过</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.name</span>=<span class="string">OAUTH2-CLIENT-SESSIONID01</span></span><br><span class="line"><span class="comment">#授权服务器地址</span></span><br><span class="line"><span class="meta">oauth2-server-url</span>: <span class="string">http://localhost:8080</span></span><br><span class="line"><span class="comment">#与授权服务器对应的配置</span></span><br><span class="line"><span class="meta">security.oauth2.client.client-id</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">security.oauth2.client.client-secret</span>=<span class="string">112233</span></span><br><span class="line"><span class="meta">security.oauth2.client.user-authorization-uri</span>=<span class="string">$&#123;oauth2-server-url&#125;/oauth/authorize</span></span><br><span class="line"><span class="meta">security.oauth2.client.access-token-uri</span>=<span class="string">$&#123;oauth2-server-url&#125;/oauth/token</span></span><br><span class="line"><span class="meta">security.oauth2.resource.jwt.key-uri</span>=<span class="string">$&#123;oauth2-server-url&#125;/oauth/token_key</span></span><br></pre></td></tr></table></figure><h3 id="在启动类上添加-EnableOAuth2Sso注解来启用单点登录功能"><a href="#在启动类上添加-EnableOAuth2Sso注解来启用单点登录功能" class="headerlink" title="在启动类上添加@EnableOAuth2Sso注解来启用单点登录功能"></a>在启动类上添加@EnableOAuth2Sso注解来启用单点登录功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.oauth2client01demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableOAuth2Sso</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Oauth2client01demoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(Oauth2client01demoApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加接口用于获取当前登录用户信息"><a href="#添加接口用于获取当前登录用户信息" class="headerlink" title="添加接口用于获取当前登录用户信息"></a>添加接口用于获取当前登录用户信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yjxxt.oauth2client01demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getCurrentUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> authentication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改认证服务器配置"><a href="#修改认证服务器配置" class="headerlink" title="修改认证服务器配置"></a>修改认证服务器配置</h3><p>修改授权服务器中的AuthorizationServerConfig类，将绑定的跳转路径为</p><p><a href="http://localhost:8081/login%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%8E%B7%E5%8F%96%E7%A7%98%E9%92%A5%E6%97%B6%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">http://localhost:8081/login，并添加获取秘钥时的身份认证</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            <span class="comment">//配置client_id</span></span><br><span class="line">            .withClient(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">            <span class="comment">//配置client-secret</span></span><br><span class="line">            .secret(passwordEncoder.encode(<span class="string">&quot;112233&quot;</span>))</span><br><span class="line">            <span class="comment">//配置访问token的有效期</span></span><br><span class="line">            .accessTokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">            <span class="comment">//配置刷新token的有效期</span></span><br><span class="line">            .refreshTokenValiditySeconds(<span class="number">864000</span>)</span><br><span class="line">            <span class="comment">//配置redirect_uri，用于授权成功后跳转</span></span><br><span class="line">            <span class="comment">// .redirectUris(&quot;http://www.baidu.com&quot;)</span></span><br><span class="line">            <span class="comment">//单点登录时配置</span></span><br><span class="line">            .redirectUris(<span class="string">&quot;http://localhost:8081/login&quot;</span>)</span><br><span class="line">            <span class="comment">//配置申请的权限范围</span></span><br><span class="line">            .scopes(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">            <span class="comment">//自动授权配置</span></span><br><span class="line">            .autoApprove(<span class="keyword">true</span>) </span><br><span class="line">            <span class="comment">//配置grant_type，表示授权类型</span></span><br><span class="line">            .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>,<span class="string">&quot;password&quot;</span>,<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取密钥需要身份认证，使用单点登录时必须配置</span></span><br><span class="line">    security.tokenKeyAccess(<span class="string">&quot;isAuthenticated()&quot;</span>);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动授权服务和客户端服务；</p><p>访问客户端需要授权的接口<a href="http://localhost:8081/user/getCurrentUser">http://localhost:8081/user/getCurrentUser</a></p><p>会跳转到授权服务的登录界面；</p><p><img src="/../../img/markdown_img/SpringSecurity.assets/image77.png"></p><p>授权后会跳转到原来需要权限的接口地址，展示登录用户信息；</p><p><img src="/../../img/markdown_img/SpringSecurity.assets%5Cimage78.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 主从哨兵脑裂</title>
      <link href="/2021/12/16/redis/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/16/redis/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><p>读和写以及备份操作都是在一台Redis服务器上进行的，那么随着项目访问量的增加，对Redis服务器的操作也越加频繁，虽然Redis读写速度都很快，但是一定程度上也会造成一定的延时，那么为了解决访问量大的问题（大概有80%的请求都是读请求），通常会采取的一种方式是主从架构Master/Slave，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机Slave 节点。</p><p>主从复制之后，<strong>主服务器用来处理写请求，而从服务器只能用于读，不能写</strong>。最简单一主二从的方式，也可以采用一主多从的或者级联结构，Redis主从复制又可以分为全量复制和增量复制。</p><p>主从复制一主多从：</p><ul><li><p>这样的问题就是，如果Master服务器宕机了，那么两个从服务器便没有了主人一样，这时候我们只能去重新启动master，或者说在剩下的从服务器中选一个作为主服务器，然后进行将剩下的从服务器手动的连接到新master，这样就显得并不智能。显然，这非常的麻烦，大型的项目从服务器可能会有很多。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121200823820.png" alt="image-20211121200823820"></p></li></ul><p>主从复制链路形式：</p><ul><li>这种模式也有上述的问题，Master6379宕机之后，Slave6380并不会摇身一变成为matser，它仍然是一个salve。</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121194755383.png" alt="image-20211121194755383"></p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。</p><ul><li>从服务器连接主服务器，发送sync命令；</li><li>主服务器接收到sync命令，开始执行bgsave命令生成rdb文件，并使用缓冲区记录此后执行的所有写命令</li><li>主服务器bgsave命令执行完成后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照</li><li>主服务器快照发送完毕后开始向服务器发送缓冲区中的写命令</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令</li></ul><p>至此，从服务器数据初始化的所有操作完成，从服务器此时可以接收来自用户的读请求，但是不能写。</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>Redis<strong>增量复制</strong>是指<strong>Slave初始化后开始正常工作时，主服务器发生的写操作同步到从服务器的过程。</strong></p><p>增量复制的过程主要是<strong>主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行写命令</strong>。</p><h1 id="主从复制模拟"><a href="#主从复制模拟" class="headerlink" title="主从复制模拟"></a>主从复制模拟</h1><p>这里用3个不同的端口，生成3个redis服务器，并且准备用6379端口设置为主机，6380和6381设置为从机。</p><p>主从复制，配置从节点不配置主节点</p><h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><ol><li>拷贝redis.conf文件</li></ol><p>这里拷贝3份配置文件redis.conf，1一个主，2个从</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121190849226.png" alt="image-20211121190849226"></p><ol start="2"><li><p>修改配置文件</p><ul><li>redis.conf中的端口号</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185306902.png" alt="image-20211121185306902"></p><ul><li>daemonize 设置为yes</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185315718.png" alt="image-20211121185315718"></p><ul><li>进程id pid</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185322334.png" alt="image-20211121185322334"></p><ul><li>日志</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185331341.png" alt="image-20211121185331341"></p><ul><li>dump.rdb</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185345459.png" alt="image-20211121185345459"></p><ul><li>如果redis设置了密码，那么需要在从机上设置主机的密码</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185439977.png" alt="image-20211121185439977"></p></li><li><p>分别启动三个端口的redis-server和redis-cli</p></li><li><p>将端口6380、6381设置为6379的从机</p><ul><li><p><code>slave ip port</code>设置为Ip+port主机的从机</p></li><li><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191420316.png"></p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191440436-16374932859391.png" alt="image-20211121191440436"></p></li><li><p><code>info replication</code>查看当6380和6381服务器的状态</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191544255.png" alt="image-20211121191544255"></p></li><li><p>6379主机查看服务器状态</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191650650.png" alt="image-20211121191650650"></p></li></ul></li></ol><p>我们上述的配置是通过命令配置的，如果在配置文件中进行配置，那么则是永久的配置。</p><p>配置文件中进行的配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置主服务器IP 端口</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment"># redis设置了密码的话 还需要配置主服务器的密码</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure><p>这种命令配置的主从，当主机关闭后，重启，它仍然会是两个从机的主机，从机依旧可以直接获取到主机写的信息！如果我们将主机关闭后，让从机比如6380成为。但是，当从机关闭，重启，这个从机就不再是之前它master的slave了，现在重启后，它自己就是一个master，跟之前的master就没关系了。</p><p>如果Master宕机了，如果要让slave中的一个成为master，在哨兵模式没有设置的情况下，执行命令<code>slaveof no one</code>，那么这个结点就成为了master，然后其他的slave就可以再手动连接到新手动设置的master了。</p><h3 id="链路形式"><a href="#链路形式" class="headerlink" title="链路形式"></a>链路形式</h3><p>这里将6379作为master，然后6380连接到6381上。</p><p>现在将6379master断掉，然后在6381上info replication，发现它并不会成为master。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121195727429.png" alt="image-20211121195727429"></p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121195757090.png" alt="image-20211121195757090"></p><p>主从模式没办法对master进行自动的更新。因此引入了哨兵模式Sentinel。</p><p>从master到slave的复制是异步的，所以可能有部分数据还没复制到slave，master宕机，由此数据就部分丢失了，这就是<strong>Redis异步复制导致的数据丢失问题。</strong></p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>上面的模式，如果Master宕机了那么就类似群龙无首一样，多个slave中没有一个站出来自动充当master，如果我们手动选择就太繁琐了，引入的哨兵模式就可以解决这种问题。</p><h3 id="哨兵模式的作用"><a href="#哨兵模式的作用" class="headerlink" title="哨兵模式的作用"></a>哨兵模式的作用</h3><ol><li><strong>监控(Monitoring):</strong> 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</li><li><strong>提醒(Notification):</strong> 当被监控的某个Redis节点出现问题时， 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>主节点故障转移(Automatic failover)<strong>：当</strong>一个Master不能正常工作</strong>时，哨兵(sentinel) 会开始<strong>一次自动故障迁移操作</strong>。从节点晋升到主节点并维护后续正确的主从关系；</li></ol><h3 id="哨兵进程的工作方式"><a href="#哨兵进程的工作方式" class="headerlink" title="哨兵进程的工作方式"></a>哨兵进程的工作方式</h3><p>Sentinel（哨兵）是Redis的高可用性解决方案：由一个或者多个哨兵实例组成的哨兵系统来监视多个服务器的运行状态。</p><p>当一个master主服务器宕机的时候，如果有一个哨兵检测到这个主机处于下线状态，这时候这个主机被认为是<strong>主观下线</strong>（SDOWN），然后当一定数量的哨兵都检测到这个主服务器下线时，这个主机被认为<strong>客观下线</strong>（ODOWN），并在确定主服务器进入<strong>客观下线</strong>的状态之后，哨兵自动投票选举从服务器中的一个成为主服务器，剩下的所有从服务器都会自动的连接到这个新选取出来的主服务器。</p><ol><li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。</li><li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态。</li><li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）。</li><li>在一般情况下， 每个Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li><li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li></ol><h3 id="哨兵模式模拟"><a href="#哨兵模式模拟" class="headerlink" title="哨兵模式模拟"></a>哨兵模式模拟</h3><h4 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h4><p>新建一个哨兵模式配置文件<code>sentinel.conf</code>，这里设置同意主节点真的挂掉的哨兵数量为1。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 同意主节点真的挂掉的哨兵数量</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6381 1</span><br></pre></td></tr></table></figure><h4 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h4><p><code>redis-sentinel sentinel.conf</code>启动哨兵</p><p>第一次启动哨兵：Next failover delay: I will not start a failover before Sun Nov 21 20:50:55 2021</p><p>这是因为在redis主从服务器中设置了密码，但是哨兵配置文件中并没有配置密码，所有没有成功启动哨兵模式。</p><p>重新配置如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 同意主节点真的挂掉的哨兵数量</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6381 1</span><br><span class="line">sentinel auth-pass myredis password <span class="comment"># 密码配置</span></span><br></pre></td></tr></table></figure><p>重新启动哨兵模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># redis-sentinel myredisconfig/sentinel.conf</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.176 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.176 <span class="comment"># Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=8175, just started</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.176 <span class="comment"># Configuration loaded</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.177 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">8175:X 21 Nov 2021 21:26:49.177 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.6 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 8175</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">          `-._        _.-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span></span><br><span class="line"></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.177 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># Sentinel ID is 16cbd6e88092909d2f92476c149045138facc8f1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># +monitor master myredis 127.0.0.1 6381 quorum 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.180 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:26:49.181 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动成功，可以看到6381端口下有两个slave：</p><p>+slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381；</p><p>+slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381；</p><p>现在我们将主节点6381断掉，验证哨兵模式是否会重新选举主服务器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8175:X 21 Nov 2021 21:26:49.177 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># Sentinel ID is 16cbd6e88092909d2f92476c149045138facc8f1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># +monitor master myredis 127.0.0.1 6381 quorum 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.180 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:26:49.181 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +sdown master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +odown master myredis 127.0.0.1 6381 #quorum 1/1</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +new-epoch 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +try-failover master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.869 <span class="comment"># +vote-for-leader 16cbd6e88092909d2f92476c149045138facc8f1 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.869 <span class="comment"># +elected-leader master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.869 <span class="comment"># +failover-state-select-slave master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.931 <span class="comment"># +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.931 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:55.991 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:56.291 <span class="comment"># +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:56.291 <span class="comment"># +failover-state-reconf-slaves master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:56.345 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.273 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.273 * +slave-reconf-done slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 <span class="comment"># +failover-end master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 <span class="comment"># +switch-master myredis 127.0.0.1 6381 127.0.0.1 6380</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6380</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6380</span><br><span class="line">8175:X 21 Nov 2021 21:28:27.369 <span class="comment"># +sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6380</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这里+表示进入，-表示退出</span><br><span class="line">+sdown就表示实例进入主观下线状态</span><br><span class="line"></span><br><span class="line">-sdown表示实例退出主观下线状态</span><br><span class="line"></span><br><span class="line">+odown表示实例进入客观下线状态</span><br><span class="line"></span><br><span class="line">-odown表示实例退出客观下线状态</span><br><span class="line"></span><br><span class="line">+swtich-master表示主服务器地址发生变化</span><br></pre></td></tr></table></figure><p>可以看到，确实是重新选举了一个master：+switch-master myredis 127.0.0.1 6381 127.0.0.1 6380；</p><p>现在6380成为了一个master，然后我们去查看6380的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line">Error: Server closed the connection</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment"># 角色从slave变为master</span></span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6379,state=online,offset=5126,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4f3894e2484b0ed7c7cf3ddb62805a4cd865e726</span><br><span class="line">master_replid2:c2a5af21553f6f3996fdfd68742d9a667960d9e5</span><br><span class="line">master_repl_offset:5126</span><br><span class="line">second_repl_offset:2408</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:5126</span><br></pre></td></tr></table></figure><p>可以看到现在6380的角色成为了master。</p><p>查看6379的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">Error: Server closed the connection</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6380<span class="comment"># 主节点从6381变为了6380</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:5390</span><br><span class="line">slave_repl_offset:5390</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4f3894e2484b0ed7c7cf3ddb62805a4cd865e726</span><br><span class="line">master_replid2:c2a5af21553f6f3996fdfd68742d9a667960d9e5</span><br><span class="line">master_repl_offset:5390</span><br><span class="line">second_repl_offset:2408</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:5376</span><br></pre></td></tr></table></figure><h3 id="哨兵配置文件"><a href="#哨兵配置文件" class="headerlink" title="哨兵配置文件"></a>哨兵配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">  sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line"> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h3><p>当只有一个哨兵的时候，如果这个哨兵一不小心崩掉了，那么我们的主从模式就没有哨兵了，就无法完成自动选举主节点的功能了。所以我们可以给哨兵也做一个集群。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121214930557.png" alt="image-20211121214930557"></p><p>根据端口不同配置多份哨兵的配置文件，然后启动redis-master，redis-slaves，哨兵。</p><h1 id="异步数据丢失"><a href="#异步数据丢失" class="headerlink" title="异步数据丢失"></a>异步数据丢失</h1><p>因为Redis从master到slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，由此数据就部分丢失了，这就是<strong>Redis异步复制导致的数据丢失问题。</strong></p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211123224114132.png" alt="image-20211123224114132"></p><h1 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h1><p>Redis的一个master因为网络的波动，与其他slave失去了连接，但是master实际上还是在正常的运行。哨兵们就认为这个master挂掉了，于是哨兵就会选举出一个新的master。这个时候集群里就有两个master了，这就是<strong>脑裂。</strong></p><p>尽管这个时候某个slave已经被选举成为了master，但是可能客户端client还没来得及从旧的master切换到新的master，仍在继续写数据，就可能造成这仍向旧master写的部分数据丢失。</p><p>然后当原本的master携带数据重新连接回来的时候，哨兵让原master执行slaveof命令，和新master进行全量复制，当从服务器收到master的快照文件后丢弃所有旧数据，原master数据被清空，重新向新master复制数据。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211123224138254.png" alt="image-20211123224138254"></p><h1 id="脑裂以及异步数据丢失解决方案"><a href="#脑裂以及异步数据丢失解决方案" class="headerlink" title="脑裂以及异步数据丢失解决方案"></a>脑裂以及异步数据丢失解决方案</h1><p>Redis提供以下配置：</p><ul><li><p>min-slaves-to-write M</p><p>配置了master能进行数据同步的最少slave数量。</p></li><li><p>min-slaves-max-lag N</p><p>配置了master，slave进行数据复制时，slave给master发送ACK消息的最大延迟。</p></li></ul><p>我们可以把min-slaves-to-write和min-slaves-max-lag结合起来使用，分别设置一定阈值。</p><p>比如这里配置后要求：一个master至少要有M个slave，并且slave和master进行数据复制时的ACK消息不能超过N秒，否则，master就不能再接收client的请求。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity过滤器原理</title>
      <link href="/2021/01/23/SpringSecurity/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2021/01/23/SpringSecurity/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringSecurity原理"><a href="#SpringSecurity原理" class="headerlink" title="SpringSecurity原理"></a>SpringSecurity原理</h1><h2 id="主要过滤器链"><a href="#主要过滤器链" class="headerlink" title="主要过滤器链"></a>主要过滤器链</h2><p>SpringSecurity的功能主要是由一系列的过滤器链相互配合完成的。验证一个过滤器之后放行到下一个过滤器链，然后到最后。</p><p><img src="/../../img/markdown_img/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.assets/image-20211202145237010.png" alt="image-20211202145237010"></p><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p><img src="/../../img/markdown_img/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.assets/d359fe34bc7860c11a1b6e50bfd0e086.png" alt="img"></p><h3 id="过滤器作用"><a href="#过滤器作用" class="headerlink" title="过滤器作用"></a>过滤器作用</h3><ol><li><p>SecurityContextPersistenceFilter：会在每次请求处理之前从配置好的SecurityContextRepository中获取SecurityContext安全上下文信息，然后加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓库”中，然后将SecurityContextHolder中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</p></li><li><p>DefaultLoginPageGeneratingFilter：如果没有配置自定义登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p></li><li><p>BasicAuthenticationFilter：检测和处理http basic认证。</p></li><li><p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自/login的表单action。从表单中获取用户名和密码时，默认使用的表单name属性值为username和password，这俩个值也可以通过usernameParameter和passwordParameter在配置中自定义。</p><p>这个过滤器在表单提交登录请求之时会起作用。那么假设现在采用SpringSecurity整合Jwt，那么我需要配置一个Jwt登录认证类（继承BasicAuthenticationFilter或者继承OncePerRequestFilter都可以，因为BasicAuthenticationFilter继承了OncePerRequestFilter），重写过滤器方法。Jwt的token认证登录是需要在<strong>在采用用户名密码登录认证之前</strong>，所以在配置Jwt登录认证类的时候需要在UsernamePasswordAuthenticationFilter之前添加过滤器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置自定义过滤器 添加jwt登录授权过滤器</span></span><br><span class="line"><span class="comment">//在过滤器UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line">http.addFilterBefore(jwtAuthenticationFilter,UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure></li><li><p>RequestCacheAwareFilter：用来处理请求的缓存。</p></li><li><p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。</p></li><li><p>AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在则为其提供一个匿名Authentication。</p></li><li><p>SessionManagementFilter：管理Session的过滤器</p></li><li><p>ExceptionTranslationFilter：捕获来自过滤器链的所有异常，并进行处理。但是只处理两类异常：AccessDeniedException和AuthenticationException 异常，其他的异常会继续抛出。</p><p>如果捕获到的AuthenticationException，那么将会使用其对应的AuthenticationEntryPoint的commence()方法处理。在处理之前，ExceptionTranslationFilter先使用RequestCache将当前的HTTPServletRequest的信息保存起来，方便用户登录成功后可以跳转到之前的页面。</p><p>可以自定义AuthenticationException的处理方法。需要实现AuthenticationEntryPoint接口，然后重写commence()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当未登录或者token失效时访问接口自定义的返回结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAuthorizationEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean bean = RespBean.error(<span class="string">&quot;请先登录!&quot;</span>);</span><br><span class="line">        bean.setCode(<span class="number">401</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(bean));</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果捕获的AuthenticationDeniedException，那么将会根据当前访问的用户是否已经登录认证做不同的处理，如果未登录，则会使用关联的AuthenticationEntryPoint的commence()方法进行处理，否则将使用关联的AccessDeniedHandler的handle()方法进行处理。</p><p>可以进行自定义AuthenticationDeniedException的处理方法。需要实现AccessDeniedHandler接口，然后重写handle()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean error = RespBean.error(<span class="string">&quot;权限不足，联系管理员!&quot;</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));</span><br><span class="line">        error.setCode(<span class="number">403</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FilterSecurityInterceptor：可以看做过滤器链的出口</p></li><li><p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p></li></ol><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>SecurityContext对象是安全上下文信息，包括当前使用系统的用户的信息。每个用户都会有它的安全上下文对象，所以把每一个用户的SecurityContext保存到SecurityContextHolder中。</p><p>SecurityContextHolder存储SecurityContext的方式根据应用场景不同也有区别：</p><p>（1）单机系统，即应用从开启到关闭的整个生命周期只有一个用户在使用。由于整个应用只需要保存一个SecurityContext（安全上下文即可）</p><p>（2）多用户系统，比如典型的Web系统，整个生命周期可能同时有多个用户在使用。这时候应用需要保存多个SecurityContext（安全上下文），需要利用ThreadLocal进行保存，每个线程都可以利用ThreadLocal获取其自己的SecurityContext，及安全上下文。ThreadLocal内部会用数组来存储多个对象的。原理是，ThreadLocal会为每个线程开辟一个存储区域，来存储相应的对象。</p><p>Authentication：用户信息的表示</p><p>在SecurityContextHolder中存储了当前与系统交互的用户的信息。Spring Security使用一个Authentication 对象来表示这些信息。</p><p>Authentication 主要包含了：</p><ul><li>用户权限集合</li><li>用户证书（密码）</li><li>细节（Details）</li><li>Principal（就是这个用户的账户信息）</li></ul><p>在自定义登录认证过滤器的时候，记得需要把用户的信息（Authentication ）保存到SecurityContextHolder中，以便后续用户的正常使用。比如我在做和Jwt认证的整合的时候，继承OncePerRequestFilter，重写doFilterInternal方法，认证完token之后，就需要把用户的信息存入安全上下文Holder中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UsernamePasswordAuthenticationToken authenticationToken</span><br><span class="line">    =<span class="keyword">new</span> UsernamePasswordAuthenticationToken(user,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">authenticationToken.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource()</span><br><span class="line">                               .buildDetails(request));</span><br><span class="line"></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br></pre></td></tr></table></figure><p>关于SecurityContextHolder大概就这样，有一些关于SecurityContextHolder具体的源码的细节可以参考一篇博客：</p><p><a href="https://www.cnblogs.com/longfurcat/p/9417912.html">https://www.cnblogs.com/longfurcat/p/9417912.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
