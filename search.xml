<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java总结</title>
      <link href="/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/17/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>byte short int long float double boolean char</p><p>1      2      4   8      4        8        1        2</p><h3 id="为什么要有包装类"><a href="#为什么要有包装类" class="headerlink" title="为什么要有包装类"></a>为什么要有包装类</h3><p>Java 本身就一个面向对象的语言，这些基本数据类型是比较基础的数据类型，但又不是面向对象的。为了让基本数据类型也有对象的特征，就给每个基本数据类型都创建了包装类型，使得这些基本数据类型都有了对象的性质，并且添加了属性和方法</p><p>并且向集合中添加元素的时候，放入基本数据类型是放不进去的，容器都是装Object的，所以就使用包装类型，然后提供自动拆箱装箱完成转换</p><h3 id="int-和-Integer的区别-new-Integer-127-new-Integer-127-是true还是false"><a href="#int-和-Integer的区别-new-Integer-127-new-Integer-127-是true还是false" class="headerlink" title="int 和 Integer的区别 new Integer(127) == new Integer(127) 是true还是false"></a>int 和 Integer的区别 new Integer(127) == new Integer(127) 是true还是false</h3><p>int 是基本数据类型，Integer 是引用数据类型，属于int 的包装类型，可以通过自动拆箱和装箱转换。</p><p> new Integer(127) == new Integer(127) 返回false 比较地址值，属于不同对象</p><p>Integer c1 = 127;     Integer c2 = Integer.valueOf(127);  <strong>c1==c2 返回true</strong>，Java对**-128到127进行了缓存**，故相等</p><p>Integer d1 = 128;     Integer d2 = 128;  <strong>d1==d2 返回false</strong> <strong>128不适用于缓存</strong>，不相等</p><h3 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h3><p>String内的成员变量char数组 value是用final修饰的，并且是private，value的引用是不可变的，但是value内的值是可以通过反射改变的，String本身也是个final类，是不能被继承的，也保证了没有子类对其修改</p><p>其次，String内的一些方法，返回的值也是String，但是这些个String都是在返回的时候重新new出来的一个String，而不是原来那个了</p><p>String 的不可变，首先可以保证一定的线程安全性，它不可变，那他可以被多个线程共享</p><p>其次String 的不可变，String的hashcode在创建的时候被缓存了，像map中键一般采用String类型也就是这个原因，这样通过key做hash的时候速度就比较快</p><h3 id="Math-round-11-5-和Math-round-11-5"><a href="#Math-round-11-5-和Math-round-11-5" class="headerlink" title="Math.round(11.5)和Math.round(-11.5)"></a>Math.round(11.5)和Math.round(-11.5)</h3><p>Math.round()函数就是取整四舍五入，然后在参数的基础上加0.5然后再做向下取整，所以结果就是12，-11</p><h3 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f=3.4;是否正确"></a>float f=3.4;是否正确</h3><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化） 会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。</p><h3 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗</h3><p> 对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。 而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p><h3 id="关于boolean的默认值"><a href="#关于boolean的默认值" class="headerlink" title="关于boolean的默认值"></a>关于boolean的默认值</h3><p>局部变量boolean没有默认值，打印编译不通过没有初始化，</p><p>静态变量有默认值，为false</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306165357708.png" alt="image-20220306165357708"></p><h3 id="Cloneable，深拷贝、浅拷贝、零拷贝"><a href="#Cloneable，深拷贝、浅拷贝、零拷贝" class="headerlink" title="Cloneable，深拷贝、浅拷贝、零拷贝"></a>Cloneable，深拷贝、浅拷贝、零拷贝</h3><p><strong>深拷贝</strong>：把内存对象完全复制了一份，也就是说内存中存在有两份一模一样的对象</p><p><strong>浅拷贝</strong>：相当于多一个引用指向同一个堆中的对象，两个引用实际上还是一样的</p><p>在 Object 中有一个本地方法 clone()，一个对象想要调用这个 clone 方法，必须实现 Cloneable 接口，重写 clone() 方法，里面先调用 父类 Object 的clone方法 <code>Person clone = (Person) super.clone();</code></p><p>这样拷贝出来的对象是一个新的对象，但是对象里面的各种属性等等和原来的都是一样的。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final就是一个关键字，可以用来修饰类，属性，变量，方法，表示的意思就是最终的意思，不可变的意思在里面，修饰类，那么类就不能被继承，修饰属性，那么属性就不能再改变（引用），</p><p>修饰符（关键字）如果一个<strong>类</strong>被声明<strong>为final</strong>，意味着它<strong>不能再派生出新的子类</strong>，<strong>不能</strong>作为父类<strong>被继承</strong>。因此一个类<strong>不能</strong>既被声明<strong>为 abstract</strong>的，<strong>又</strong>被声明<strong>为final</strong>的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为<strong>final的变量</strong>必须在声明时<strong>给定初值</strong>，而在以后的<strong>引用中只能读取</strong>，<strong>不可修改</strong>。被声明为<strong>final的方法</strong>也同样<strong>只能使用</strong>，<strong>不能重载</strong>。</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>finally是在异常中<strong>try catch finally</strong>中用到的，finally表示无论是否捕获到异常都会去执行finally语句块里面的代码，守护线程除外，主要用于做一些<strong>事后处理的操作</strong>，比如<strong>释放锁</strong>等</p><p>异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。一般异常处理块需要。</p><p>如果在try 里面使用了return 语句，finally里的语句还是照样会执行的，在return语句把控制权转移给其他的方法前会执行finally语句</p><p><strong>try</strong> 有 <strong>return</strong> 语句，会执行 try 里的 return 语句，然后将<strong>返回结果保存到栈</strong>中，接着执行 <strong>finally</strong> 里的语句块，如果 <strong>finally</strong> 里有 <strong>return</strong> 语句，则会 <strong>返回 finally 里 return 的结果</strong>，并终止方法，<strong>栈中的 return 不会被完成</strong></p><h3 id="fianlize"><a href="#fianlize" class="headerlink" title="fianlize"></a>fianlize</h3><p><strong>方法名</strong>，<strong>fianlize()<strong>是</strong>Object中</strong>的一个<strong>方法</strong>，当垃圾回收器将要释放一个对象的内存的时候，它会调用该对象的finalize()方法</p><p>这个方法是由<strong>垃圾收集器</strong>在确定<strong>这个对象没有被引用时</strong>对这个对象<strong>调用的</strong>。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p><p>在Java中很不幸，<strong>如果内存总是充足的</strong>，那么<strong>垃圾回收可能永远不会进行</strong>，也就是说<strong>finalize()可能永远不被执行</strong>，显然指望它做收尾工作是靠不住的。</p><h3 id="public、protected、缺省、private范围"><a href="#public、protected、缺省、private范围" class="headerlink" title="public、protected、缺省、private范围"></a>public、protected、缺省、private范围</h3><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220412091654001.png" alt="image-20220412091654001"></p><h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>throw是主动抛出某个异常，throw后面跟一个异常对象，表示程序什么什么情况下，比如参数为null，if判断到后，就throw一个NullPointerException。</p><p>throws则是跟在方法后面，表示这个方法可能会抛出某个异常，处理方式只是往上抛，抛到调用这个方法的地方。否则就直接try catch捕获住，然后直接throw某个异常</p><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>我们不能强制java中的garbage collection进程，它只是一个守护线程。将System.gc()方法视为垃圾收集应该运行的 VM 的”提示”。显示调用只能说程序员建议System.gc()，但是JVM并不一定真正gc。</p><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p><strong>static</strong> 关键字主要是为了能够<strong>创建独立与对象之外的方法或者属性</strong>，以至于可以使得没有创建对象，也能使用属性和调用方法。此外还可以使用 static 关键字用来形成静态代码块来做些初始化工作，因为静态代码块只会在类加载的时候执行一次。</p><p>被static修饰的变量，表示是一个静态变量，这个静态变量不属于某一个对象，而是所有对象共享的变量。</p><p>被static修饰的方法，表示是一个静态方法，这个静态方法可以看做类级别的，直接通过类点方法名调用。</p><p>静态方法只能方法静态变量，非静态方法都可以访问</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类可以分为：</p><ol><li><p>成员内部类</p><ul><li><p>成员内部类中的方法可以访问外部类中所有的变量，不受控制符的影响</p></li><li><p>必须使用外部类的对象才能创建内部类的对象，不能直接 new 一个内部类对象</p></li><li><p>```java<br>public class InternalClass {</p><pre><code>private int a=1;private class InnerClazz&#123;    int b=2;    public void test()    &#123;        System.out.println(&quot;a：&quot;+a);        System.out.println(&quot;b：&quot;+b);    &#125;&#125;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 静态内部类</span><br><span class="line"></span><br><span class="line">   * 静态内部类就是用static修饰过的成员内部类</span><br><span class="line"></span><br><span class="line">   * 静态内部类不能直接访问外部类的非static成员，只能通过new对象的方式访问对象的非static</span><br><span class="line"></span><br><span class="line">   * 创建静态内部类的对象时，可以直接创建，不需要通过外部类的对象来创建</span><br><span class="line"></span><br><span class="line">   * &#96;&#96;&#96;java</span><br><span class="line">     public class InternalClass2 &#123;</span><br><span class="line">     </span><br><span class="line">         private int a&#x3D;1;</span><br><span class="line">     </span><br><span class="line">         static class InnerClazz&#123;</span><br><span class="line">             int b&#x3D;2;</span><br><span class="line">             public void test()</span><br><span class="line">             &#123;</span><br><span class="line">                 System.out.println(&quot;a：&quot;+new InternalClass2().a);</span><br><span class="line">                 System.out.println(&quot;b：&quot;+b);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方法内部类</p><ul><li><p>方法内部类就是定义在外部类的方法里面的类，只能在对应方法里面去访问到</p></li><li><p>```java<br>public class Outer {</p><pre><code>private int out_a=1;private static int static_b=2;void outMethod()&#123;    final int a=10;    class Inner&#123;        void innerMethod()&#123;            System.out.println(a);            System.out.println(out_a);            System.out.println(static_b);        &#125;    &#125;    new Inner().innerMethod();    System.out.println(a);&#125;public static void main(String[] args) &#123;    Outer outer = new Outer();    outer.outMethod();&#125;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 匿名内部类</span><br><span class="line"></span><br><span class="line">   * 匿名内部类必须继承一个抽象类或者实现一个接口</span><br><span class="line">   * 匿名内部类不能定义任何静态成员和静态方法</span><br><span class="line">   * 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final</span><br><span class="line">   * 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</span><br><span class="line"></span><br><span class="line">   * 对于某个接口的实现，可以在new的时候直接创建一个匿名内部类，实现对应的方法</span><br><span class="line"></span><br><span class="line">### 多态</span><br><span class="line"></span><br><span class="line">**多态**就是指在程序中定义的**引用变量**，具体**所指向的具体类型**以及通过**该引用变量调用的方法**在**编译**的**时**候并**不确定**，而是**在程序运行时期去确定的**。即一个**引用变量**到底是**什么类型**，调用的对应的方法到底是哪个实现类对应的方法编译的时候是无法确定的。</span><br><span class="line"></span><br><span class="line">**多态**分为**编译时多态**和**运行时多态**：</span><br><span class="line"></span><br><span class="line">* 编译时多态：主要指的是方法的重载，它根据参数列表的不同来区分不同的函数调用</span><br><span class="line">* 运行时多态：运行时多态就是常说的多态，在程序运行时才能确定的。父类或者接口定义的引用可以指向子类或者实现类的实例对象</span><br><span class="line"></span><br><span class="line">实现多态：</span><br><span class="line"></span><br><span class="line">* **方法重写**</span><br><span class="line">* **继承或者实现关系**</span><br><span class="line"></span><br><span class="line">## 排序算法</span><br><span class="line"></span><br><span class="line">![image-20220419083720096](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220419083720096.png)</span><br><span class="line"></span><br><span class="line">1. 堆排序</span><br><span class="line">   * 按照给定的数组，构建一个完全二叉树</span><br><span class="line">   * 从最后一个非叶子节点 树中索引 n&#x2F;2 -1 开始，大顶堆就把它这个节点和它的子树进行比较交换，选择一个最大的</span><br><span class="line">   * 接着选定下一个非叶子节点，一直到根节点</span><br><span class="line">   * 排序：取出根节点，根节点就是最大值，然后把最后一个叶子节点取出来放到根节点，维护成一个大顶堆</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## JVM</span><br><span class="line"></span><br><span class="line">### Java代码执行过程理解JVM内存划分</span><br><span class="line"></span><br><span class="line">**结合一段Java代码的执行理解内存划分**</span><br><span class="line"></span><br><span class="line">![image-20220217220809311](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220217220809311.png)</span><br><span class="line"></span><br><span class="line">* 执行javac命令编译源代码为字节码</span><br><span class="line">* 执行java命令</span><br><span class="line">  1. 创建JVM，调用类加载子系统**加载class**，将类的信息存入**方法区**</span><br><span class="line">  2. 创建main线程，使用的内存区域是**JVM虚拟机栈**，开始执行main方法代码</span><br><span class="line">  3. 如果遇到了未见过的类，会继续触发类加载过程，同样会存入**方法区**</span><br><span class="line">  4. 需要创建**对象**，会使用**堆内存**来存储对象</span><br><span class="line">  5. 不再使用的对象，会由**垃圾回收器**在内存不足时回收其内存</span><br><span class="line">  6. 调用方法时，**方法内的局部变量、方法参数**所使用的是**JVM虚拟机栈**中的**栈帧内存**</span><br><span class="line">  7. 调用方法时，先要到**方法区**获得到该方法的字节码指令，由**解释器**将**字节码指令解释为机器码**执行</span><br><span class="line">  8. 调用方法时，会将要执行的指令行号读到**程序计数器**，这样当**发生了线程切换**，**恢复**时就可以从中断的位置继续</span><br><span class="line">  9. 对于非Java实现的方法调用，使用内存称为**本地方法栈**</span><br><span class="line">  10. 对于**热点方法调用**，或者**频繁的循环代码**，由**JIT即使编译器**将这些代码编译成机器码缓存，提高执行性能</span><br><span class="line"></span><br><span class="line">说明</span><br><span class="line"></span><br><span class="line">* 对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</span><br><span class="line"></span><br><span class="line">**会发生内存溢出的区域**</span><br><span class="line"></span><br><span class="line">* 不会出现内存溢出的区域 - 程序计数器</span><br><span class="line">* 出现OOM（OutOfMemoryError）的情况</span><br><span class="line">  * **堆内存耗尽** — 对象越来越多，又一直在使用，不能被垃圾回收</span><br><span class="line">  * **方法区内存耗尽** — 加载的类越来越多，很多框架都会在运行期间动态产生新的类</span><br><span class="line">  * **虚拟机栈累积** — 每个线程最多会占用1M内存，线程个数越来越多，而又长时间运行不销毁时</span><br><span class="line">* 出现 **StackOverflowError** 的区域</span><br><span class="line">  * **JVM虚拟机栈**，原因有**方法递归调用未正确结束**，**反序列化 json 时循环引用**</span><br><span class="line"></span><br><span class="line">### JVM常量池</span><br><span class="line"></span><br><span class="line">JVM的常量池，实际上划分为两种形态：静态常量池和动态常量池</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 字符串常量池</span><br><span class="line"></span><br><span class="line">字符串常量池存在堆内存中</span><br><span class="line"></span><br><span class="line">**字符串常量池为什么要移动到堆空间中？**</span><br><span class="line">个人的理解：对于字符串常量这种创建完成用几次就不被使用的对象，是很容易被回收的。而要进行频繁垃圾回收的地方是堆空间， 这样在JDK7就把字符串[常量池](https:&#x2F;&#x2F;so.csdn.net&#x2F;so&#x2F;search?q&#x3D;常量池&amp;spm&#x3D;1001.2101.3001.7020)移动到堆空间中就是很明智和有必要的选择了。</span><br><span class="line"></span><br><span class="line">**字符串常量池的设计思想**：</span><br><span class="line"></span><br><span class="line">* 字符串的分配，和其他对象一样，频繁的分配字符串的内存也需要消耗大量的资源</span><br><span class="line">* JVM 为了提高性能和减小内存开销，在实例化字符串常量的时候进行了一些优化</span><br><span class="line">  * 为字符串开辟一个字符串常量池，类似于缓冲区</span><br><span class="line">  * 创建字符串常量时，首先判断字符串常量池是否存在该字符串</span><br><span class="line">  * 存在该字符串，返回引用实例，不存在，就实例化该字符串并放入常量池</span><br><span class="line">* 实现基础</span><br><span class="line">  * 因为String 是不可变的，因此不用担心字符串共享产生的问题</span><br><span class="line">  * 运行时，实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JVM的几个组成部分</span><br><span class="line"></span><br><span class="line">JVM包含两个子系统和两个组件，共4个组成部分，**两个子系统**分别为：**类加载器**(ClassLoader)、**执行引擎**(Execution Engine)、**两个组件**分别为：**运行时数据区**(Runtime Data Area)、**本地接口**(Native interface)</span><br><span class="line"></span><br><span class="line">![image-20220214145053735](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220214145053735.png)</span><br><span class="line"></span><br><span class="line">**类加载器**：就是把字节码文件加载到运行时数据区的method area 方法区中</span><br><span class="line"></span><br><span class="line">**运行时数据区**：也就是常说的JVM的内存</span><br><span class="line"></span><br><span class="line">**执行引擎**：就是执行classes中的指令，包括有JIT即使编译器、GC垃圾回收器</span><br><span class="line"></span><br><span class="line">**本地接口**：就是底层和不同语言交互的接口，同一些本地库相关联</span><br><span class="line"></span><br><span class="line">执行流程就是：先把Java代码编译成字节码文件，然后类加载器就加载字节码文件到Method Area中，而字节码只是JVM的一套指令集规范，并不能直接交给底层的操作系统去执行，因此就需要特点的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由CPU执行，而这个过程中需要调用其他语言的本地接口（Native Interface）来实现整个程序的功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### JVM类加载机制</span><br><span class="line"></span><br><span class="line">#### 简述java类加载机制</span><br><span class="line"></span><br><span class="line">虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的java类型。类加载器负责读取Java字节码，并转换成Java.lang.Class类的一个实例</span><br><span class="line"></span><br><span class="line">#### JVM加载Class文件的原理机制</span><br><span class="line"></span><br><span class="line">Java中的所有**类**，都需要**被类加载器加载**到**JVM的方法区**中，然后由**执行引擎去解析**最终被底层操作系统执行。**类加载器本身也是一个类**，**加载类**就是把**Class文件**从**硬盘**中**加载到内存**中去。</span><br><span class="line"></span><br><span class="line">加载的方式一般有两种：</span><br><span class="line"></span><br><span class="line">* 隐式加载：就是在程序中使用new关键字等方式创建出来的对象，隐式的调用类加载器加载对应的类到JVM中</span><br><span class="line">* 显式加载：通过Class.forname()、类.class或者说 对象.getClass()方法获取到字节码对象，显式加载所需要的类</span><br><span class="line"></span><br><span class="line">Java**类的加载**是动态（**懒惰**）的，**它并不会一次性将所有类全部加载后再运行**，而是保证程序运行的基础类完全加载到JVM中，至于其他类，则是在需要的时候才加载，从而节省内存开销</span><br><span class="line"></span><br><span class="line">#### 类加载器及其种类</span><br><span class="line"></span><br><span class="line">实现通过类的全限定类名来获取该类的二进制字节流的代码块叫做类加载器。</span><br><span class="line"></span><br><span class="line">主要有四种类加载器：</span><br><span class="line"></span><br><span class="line">1. 启动类加载器（Bootstrap ClassLoader）用来加载Java核心类库，无法被Java程序直接引用。是虚拟机自身的一部分，用来加载 Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库</span><br><span class="line">2. 扩展类加载器（Extensions ClassLoader）用来加载Java的扩展库，Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载Java类。如读取JRE&#x2F;lib&#x2F;ext&#x2F;*.jar中的包等</span><br><span class="line">3. 应用程序类加载器（Application ClassLoader）根据Java应用的类路径（CLASSPATH）来加载Java类。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它</span><br><span class="line">4. 用户自定义类加载器，通过继承java.lang.ClassLoader类的方式实现</span><br><span class="line"></span><br><span class="line">#### 类加载的执行过程</span><br><span class="line"></span><br><span class="line">类加载的执行过程分为加载、链接、初始化。链接又分为验证、准备、解析</span><br><span class="line"></span><br><span class="line">* **加载**：将class字节码文件加载到内存中</span><br><span class="line">* **链接**：</span><br><span class="line">  * **验证**：**检查**加载的class文件的**正确性**，确保没有问题</span><br><span class="line">  * **准备**：给类中的**静态变量分配内存空间**</span><br><span class="line">  * **解析**：虚拟机将**常量池**中的**符号引用**替换成**直接引用**（地址引用）的过程。符号引用就理解为一个标识，而在直接引用直接指向内存中的地址</span><br><span class="line">    * 符号引用：符号引用就是一个字符串，他给出一个名字，就好比类的全限定类名，必须要求通过这个字符串能唯一找到对应的引用</span><br><span class="line">    * 直接引用：直接引用就是指向类、方法、字段的指针或者偏移量</span><br><span class="line">* **初始化**：对静态变量和静态代码块执行初始化工作</span><br><span class="line"></span><br><span class="line">#### 双亲委派模型</span><br><span class="line"></span><br><span class="line">![image-20220214161654695](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220214161654695.png)</span><br><span class="line"></span><br><span class="line">如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类</span><br><span class="line"></span><br><span class="line">当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">双亲委派模型的具体实现主要在ClassLoader的loadClass()方法中，首先检查父类有没有去加载过，没有则让父类去加载，当父类抛出ClassNotFoundException的时候才让自己去加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### java类加载为什么采用双亲委派模型</span><br><span class="line"></span><br><span class="line">如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载（因为它在jdk8&#x2F;lib&#x2F;rt.jar中），因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。这样，会委派给启动类加载器去加载到rt.jar中的Object类</span><br><span class="line"></span><br><span class="line">#### 如何打破双亲委派机制</span><br><span class="line"></span><br><span class="line">1. 重写loadClass()方法破坏双亲委派模型</span><br><span class="line"></span><br><span class="line">   类加载器的加载方法的逻辑主要就在loadClass()方法中，里面的逻辑就是先判断当前类是否已经被加载过，如果没有加载过就将委派给父类加载器，如果父类加载器无法加载则向下传递，回来由自己进行加载。如果我们把这个方法重写了就能实现自定义的加载逻辑，就可以打破双亲委派模型</span><br><span class="line"></span><br><span class="line">2. 线程上下文加载器破坏双亲委派机制</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### new 一个对象发生了什么</span><br><span class="line"></span><br><span class="line">![image-20220405094342381](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220405094342381.png)</span><br><span class="line"></span><br><span class="line">**一、类加载**</span><br><span class="line"></span><br><span class="line">1. 看new 的那个类是否加载，没有加载则采用双亲委派模型进行类加载。</span><br><span class="line">2. 类加载过程：把字节码加载到方法区，验证字节码文件的正确性，为静态变量分配内存空间，将符号引用替换为直接引用，初始化为静态变量赋值、加载静态代码块</span><br><span class="line"></span><br><span class="line">**二、创建对象**</span><br><span class="line"></span><br><span class="line">1. 在堆区给**对象分配**需要的**空间**</span><br><span class="line">   * 分配的内存包括本类和父类的实例变量，静态变量不分配</span><br><span class="line">2. 对所有**实例变量设置默认值**</span><br><span class="line">   * 将方法区中对实例变量的定义拷贝一份，然后赋默认值</span><br><span class="line">3. **设置对象头**</span><br><span class="line">   * 设置新对象的哈希码、GC分代年龄、锁信息、对象所属类元信息</span><br><span class="line">4. 执行实例**初始化**代码</span><br><span class="line">   * 初始化成员变量，执行实例化代码块，调用构造方法，并将堆内对象的首地址赋值给引用变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Java内存</span><br><span class="line"></span><br><span class="line">![image-20220214163528925](..&#x2F;..&#x2F;img&#x2F;markdown_img&#x2F;Java基础.assets&#x2F;image-20220214163528925.png)</span><br><span class="line"></span><br><span class="line">Java 虚拟机规范规定的区域分为以下 5 个部分： </span><br><span class="line"></span><br><span class="line">* **程序计数器**（Program Counter Register）：用于**保存当前线程执行的内存地址**。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。</span><br><span class="line">* **Java 虚拟机栈**（Java Virtual Machine Stacks）：用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息，是**每个线程所私有**的，每个**线程创建的同时会创建JVM栈**，栈中是**基本数据类型**和**堆中对象的引用**</span><br><span class="line">* **本地方法栈**（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而**本地方法栈**是**为虚拟机调用 Native 方法服务**的； </span><br><span class="line">* **Java 堆**（Java Heap）：Java 虚拟机中内存最大的一块，是**被所有线程共享**的，几乎所有的对象实例都在这里分配内存； 它是JVM用来**存储对象实例以及数组**值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收，Heap在32位的操作系统上最大为2G，在64位的操作系统上则没有限制，其大小通过-Xms和-Xmx来控制</span><br><span class="line">* **方法区**（Methed Area）：用于**存储**已被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译后的代码**等数据</span><br><span class="line"></span><br><span class="line">### 栈帧</span><br><span class="line"></span><br><span class="line">**栈帧** Stack Frame 是用来支持虚拟机进行**方法调用**和**方法执行**的数据结构，它是虚拟机运行时数据区中的**虚拟机栈的栈元素**。</span><br><span class="line"></span><br><span class="line">栈帧 Stack Frame 存储了方法的局部变量表、操作数栈、动态连接、和方法返回地址、额外的附加信息。</span><br><span class="line"></span><br><span class="line">每个方法在执行的同时，都会创建一个栈帧(Stack Frame)。**每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。**</span><br><span class="line"></span><br><span class="line">### 堆栈的区别</span><br><span class="line"></span><br><span class="line">1. 物理地址</span><br><span class="line"></span><br><span class="line">   堆的物理地址是不连续的，因此性能相对会比较慢，这样在GC的时候需要考虑的就更多，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记-压缩）</span><br><span class="line"></span><br><span class="line">2. 内存分配时期</span><br><span class="line"></span><br><span class="line">   堆中的内存因为是不连续的，所以需要在**运行期**确认大小，因此大小不固定。一般堆大小远大于栈。而栈的内存是连续分配的，所以一般在**编译时**就已经确定了内存大小，大小是固定的</span><br><span class="line"></span><br><span class="line">3. 存放的内容</span><br><span class="line"></span><br><span class="line">   **堆中更关注内存的存储**，因此堆中一般存放的是**对象实例**，或者**数组**</span><br><span class="line"></span><br><span class="line">   **栈更关注程序方法的执行**，因此栈内存中一般存放：**局部变量**，操作数栈，返回结果，对象的引用地址等。</span><br><span class="line"></span><br><span class="line">4. 可见性</span><br><span class="line"></span><br><span class="line">   栈中的数据线程之间是不共享的，堆中的内存线程之间是共享的</span><br><span class="line"></span><br><span class="line">### OOM，Java会存在内存泄漏吗？请简单描述 </span><br><span class="line"></span><br><span class="line">**会发生内存溢出的区域**</span><br><span class="line"></span><br><span class="line">* 不会出现内存溢出的区域 - 程序计数器</span><br><span class="line"></span><br><span class="line">* **出现OOM（OutOfMemoryError）的情况**</span><br><span class="line">  * **堆内存耗尽** — 对象越来越多，又一直在使用，不能被垃圾回收</span><br><span class="line">  </span><br><span class="line">    &#96;&#96;&#96;java</span><br><span class="line">    比如使用了Executors工具类中创建线程池的方法，比如newFixedThreadPool和newSingleThreadPool这些线程池的阻塞队列都是无界的，很有可能让阻塞队列拉满，导致内存溢出</span><br></pre></td></tr></table></figure></li><li><p>*解决方法**：</p></li></ul><p> 不要用这种new线程池，可以修改堆内存的大小-Xmx，扩大最大堆内存</p></li></ol><ul><li><strong>方法区内存耗尽</strong> — 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li><li><strong>虚拟机栈累积</strong> — 每个线程最多会占用1M内存，线程个数越来越多，而又长时间运行不销毁时<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比如使用了Executors工具类中创建线程池的方法，比如newScheduledThreadPool和newCachedThreadPool这些线程池的能创建的线程都是无限的，很有可能创建很多线程，导致内存溢出</span><br></pre></td></tr></table></figure></li><li>出现 <strong>StackOverflowError</strong> 的区域<ul><li><strong>JVM虚拟机栈</strong>，原因有<strong>方法递归调用未正确结束</strong>，<strong>反序列化 json 时循环引用</strong></li></ul></li></ul><p><strong>内存泄漏</strong>是指<strong>不再被使用的对象或者变量一直被占据在内存中</strong>。理论上来说， Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。 但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：<strong>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露</strong>， 尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导 致不能被回收，这就是java中内存泄露的发生场景</p><h3 id="JVM-server模式-和-client模式"><a href="#JVM-server模式-和-client模式" class="headerlink" title="JVM server模式 和 client模式"></a>JVM server模式 和 client模式</h3><p>JVM 有两种运行模式 Server 和 Client 模式</p><p><strong>Client</strong> 模式：采用较为轻量级的虚拟机来启动程序，<strong>采用代号为C1的轻量级编译器</strong>，因此 程序<strong>启动较快</strong>，<strong>内存占用少</strong>，<strong>编译快</strong>，<strong>针对桌面应用程序优化</strong>，为在客户端环境中<strong>减少启动时间</strong>而优化 </p><p><strong>Server</strong> 模式：采用较为重量级的虚拟机来启动程序，<strong>采用相对重量级代号为C2的编译器</strong>，因此 程序<strong>启动较慢</strong>，但是 <strong>编译得更完全</strong>，<strong>针对服务器应用优化</strong>，<strong>整个程序跑起来以后，性能会很高</strong></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="简述垃圾回收机制"><a href="#简述垃圾回收机制" class="headerlink" title="简述垃圾回收机制"></a>简述垃圾回收机制</h3><p>Java程序一般是不需要我们去管理其内存的回收，对象的释放，也就是垃圾回收。JVM中的垃圾回收线程是一个守护线程，它是低优先级的，正常情况下是不会执行的，它只有在虚拟机空闲或者当前堆内存不足的时候才会触发执行，扫描那些没有被引用的对象，并将它们添加到回收的集合中，进行回收。</p><h3 id="对象引用的类型强、软、弱、虚"><a href="#对象引用的类型强、软、弱、虚" class="headerlink" title="对象引用的类型强、软、弱、虚"></a><strong>对象引用的类型强、软、弱、虚</strong></h3><p><strong>强引用</strong>：</p><ul><li><p>普通变量赋值就是强引用，<code>A a=new A();</code></p></li><li><p>通过GC Root的引用链，如果强引用找不到该对象，该对象才能被回收</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307135659131.png" alt="image-20220307135659131"></p></li></ul><p><strong>软引用</strong>：</p><ul><li><p><code>SoftReference a = new SoftReference(new A())</code></p></li><li><p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍然不足，再次回收的时候才会释放对象</p></li><li><p>回收的时候只是回收后面的A对象，软引用本身不会释放，软引用自身需要配合引用队列来释放</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307135945240.png" alt="image-20220307135945240"></p></li></ul><p><strong>弱引用</strong>：</p><ul><li><p><code>WeakReference a = new WeakReference(new A())</code></p></li><li><p>如果仅有弱引用引用该对象，只要发生垃圾回收，就会释放该对象</p></li><li><p>同样，弱引用本身要配合引用队列来释放</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307140118825.png" alt="image-20220307140118825"></p></li></ul><p><strong>虚引用</strong>：</p><ul><li><p><code>PhantomReference a =new PhantomReference(new A())</code></p></li><li><p>必须配合引用队列一起使用，当虚引用引用的对象被回收时，会将虚引用对象入队，有Reference Handler线程释放其关联的外部资源</p></li><li><p>除了释放a、b对象以外，还要将虚引用对象入队，找出哪些对象被回收了，然后由Reference Handler线程释放掉其关联的外部资源</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220307140553303.png" alt="image-20220307140553303"></p></li></ul><h3 id="什么是GC，为什么要GC"><a href="#什么是GC，为什么要GC" class="headerlink" title="什么是GC，为什么要GC"></a>什么是GC，为什么要GC</h3><p>GC就是Garbage Collection，垃圾回收，内存处理是程序员最容易出现问题的地方，忘记或者错误的内存回收将会导致程序或系统的不稳定甚至是崩溃，Java提供GC功能，不需要程序员去关注内存的回收，这些都由JVM中的垃圾回收线程去处理，这极大的方便了开发，提高了开发效率，也正是这样，因此Java对内存的控制，其实是比较粗糙的</p><h3 id="怎么判断对象是否可以回收"><a href="#怎么判断对象是否可以回收" class="headerlink" title="怎么判断对象是否可以回收"></a>怎么判断对象是否可以回收</h3><p>垃圾收集器必须完成的两件事就是：垃圾检测、垃圾回收。首先需要判定哪些内存是需要被回收的，哪些对象是存活的，不可以被回收；哪些对象已经死掉了，需要被回收</p><p>一般有两种方法来判断垃圾是否可回收</p><ul><li><p>引用计数法</p><p>为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0的时候就可以被回收。但是其有一个明显的缺点：<strong>不能解决循环引用的问题</strong>。也就是说我有两个对象，他们之间互相引用，除此之外没有其他对象引用它们，实际上这两个对象已经无法访问，也就是说是垃圾对象，但又因为是相互引用，计数不为0，导致无法回收。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> A();</span><br><span class="line">B b=<span class="keyword">new</span> B();</span><br><span class="line">a.setB(b);</span><br><span class="line">b.setA(a);</span><br></pre></td></tr></table></figure></li><li><p>可达性分析算法：从根集对象（GC Roots）出发向下搜索，搜索所走过的路径称为引用链。当<strong>一个对象到GC Roots没有任何引用链相连</strong>时候（<strong>也就是说这个对象不可达</strong>），则证明此对象是可以被回收的</p></li></ul><h3 id="哪些对象可以作为GC-ROOTS对象"><a href="#哪些对象可以作为GC-ROOTS对象" class="headerlink" title="哪些对象可以作为GC ROOTS对象"></a>哪些对象可以作为GC ROOTS对象</h3><p>主要是有四种对象：</p><ol><li>虚拟机栈中的对象</li><li>本地方法栈中<strong>Native方法引用的对象</strong></li><li>方法区中类<strong>静态属性引用的对象</strong></li><li>方法区中<strong>常量引用的对象</strong></li></ol><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><ol><li><p><strong>标记-清除</strong>（Mark-Sweep）</p><p>算法和名字一样，分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的</p><p>不足：标记、清除效率低；标记清除之后会<strong>产生大量不连续的内存碎片</strong></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220214203643235.png" alt="image-20220214203643235"></p></li><li><p><strong>复制</strong></p><p>此算法把内存空间划分为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现<strong>“内存碎片”</strong>问题。</p><p>不足：这样就<strong>需要两倍的内存空间</strong></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220214203937400.png" alt="image-20220214203937400"></p></li><li><p><strong>标记-整理</strong>（Mark-Compact）</p><p>在<strong>新生代</strong>中可以使用复制算法，但是在<strong>老年代</strong>就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除 算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片</p><p>因此算法结合了“标记清除”和“复制”算法的优点。同样的，分两个阶段，第一个阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220214204425385.png" alt="image-20220214204425385"></p></li><li><p><strong>分代收集算法</strong></p><p>这是当前商业虚拟机常用的垃圾收集算法。分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不<strong>同生命周期的对象可以采取不同的收集方式</strong>，以便提高回收效率。一般包括<strong>年轻代</strong>、<strong>老年代</strong>、<strong>永久代</strong></p><ul><li>对新生代的对象的收集称为Minor GC</li><li>对旧生代的对象的收集称为Full GC</li><li>程序中主动调用System.gc()或者Runtime.gc()强制执行的GC为Full GC</li></ul></li></ol><h3 id="为什么要运用分代垃圾回收策略"><a href="#为什么要运用分代垃圾回收策略" class="headerlink" title="为什么要运用分代垃圾回收策略"></a>为什么要运用分代垃圾回收策略</h3><p>GC 大都采用了<strong>分代回收思想</strong></p><ul><li>理论依据是<strong>大部分对象朝生夕灭</strong>，<strong>用完立刻就可以回收</strong>，另有<strong>少部分对象</strong>会<strong>长时间存活</strong>，每次很难回收</li><li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，<strong>新生代</strong>采用<strong>标记复制</strong>法、<strong>老年代</strong>一般采用<strong>标记整理</strong>法</li></ul><p>在Java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同，所具有的<strong>生命周期</strong>也<strong>不同</strong>；有的对象<strong>生命周期较长</strong>，比如Http请求中的<strong>Session</strong>对象，<strong>线程</strong>，<strong>Socket连接</strong>等；有的对象<strong>生命周期较短</strong>，比如<strong>String对象</strong>，由于其<strong>不变类</strong>的特性，有的在使用一次后即可回收。如果不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在不同的代上使用不同的垃圾回收方式</p><p>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></p><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h3><ol><li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213622704.png" alt="image-20210831213622704"></p><ol start="2"><li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213640110.png" alt="image-20210831213640110"></p><ol start="3"><li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213657861.png" alt="image-20210831213657861"></p><ol start="4"><li>将 from 和 to 交换位置</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213708776.png" alt="image-20210831213708776"></p><ol start="5"><li>经过一段时间后伊甸园的内存又出现不足</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213724858.png" alt="image-20210831213724858"></p><ol start="6"><li>标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213737669.png" alt="image-20210831213737669"></p><ol start="7"><li>将存活对象采用复制算法复制到 to 中</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213804315.png" alt="image-20210831213804315"></p><ol start="8"><li>复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213815371.png" alt="image-20210831213815371"></p><ol start="9"><li>将 from 和 to 交换位置</li></ol><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20210831213826017.png" alt="image-20210831213826017"></p><ol start="10"><li>老年代 old，当<strong>幸存区对象熬过几次回收（最多15次）</strong>，晋升到老年代（<strong>幸存区内存不足</strong>或<strong>大对象</strong>会导致提前晋升）</li></ol><h3 id="什么时候对象进入老年代"><a href="#什么时候对象进入老年代" class="headerlink" title="什么时候对象进入老年代"></a>什么时候对象<strong>进入老年代</strong></h3><ol><li><p><strong>大对象提前晋升</strong>：虚拟机提供了一个阈值参数，大于这个参数的对象的内存就直接到老年代中去分配。如果大对象进入到了新生代，采用 复制 算法去做垃圾回收的时候，就会导致在 eden 和 survivor 区中进行 大量的内存复制</p><p><strong>CMS(老年代） 配合 Serial 和 ParNew(年轻代)<strong>：可以</strong>参数设置</strong> 进入老年代。</p><p><strong>G1</strong>：当一个对象<strong>大小超过 Region 区的一半</strong>的时候，会是大对象，堆中会分配连续的（Homongous Region）区来存放 </p></li><li><p><strong>长期存活的对象进入老年代</strong>：通过 JVM 参数：<code>-XX:MaxTenuringThreshold</code> 来设置，默认是15岁，eden 到 survivor 中超过了 <strong>15</strong> 次就进入老年代</p></li><li><p><strong>动态对象年龄判断</strong>：在 Survivor 区中，<strong>年龄相同的对象</strong>，<strong>大小总和大于 Survivor 区总空间大小的一半</strong>，那么<strong>大于等于这个年龄的对象都会进入老年代</strong></p></li><li><p><strong>空间分配担保</strong>：当 <strong>Survivor 区空间不够</strong>的时候，就会通过 <strong>分配担保机制</strong>，将多出来的<strong>对象提前转移到老年代</strong>。为了 <strong>确保老年代的空间还有容纳这些对象的剩余空间</strong>，就取之前每次晋升到老年代的<strong>对象的大小的平均值</strong>作为经验值，与老年代的<strong>剩余空间做对比</strong>（因为无法提前知道会有多少对象存活下来）</p></li></ol><h3 id="Minor-GC、Mixed-GC、Full-GC"><a href="#Minor-GC、Mixed-GC、Full-GC" class="headerlink" title="Minor GC、Mixed GC、Full GC"></a>Minor GC、Mixed GC、Full GC</h3><p><strong>GC 规模</strong></p><ul><li><strong>Minor GC</strong> 发生在<strong>新生代的垃圾回收</strong>，<strong>Eden区空间不足的时候就会触发一次</strong>，<strong>暂停时间短</strong><ul><li><strong>触发时机</strong><ol><li>Eden区空间不足</li></ol></li></ul></li><li><strong>Mixed GC</strong> 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</li><li><strong>Full GC</strong> <strong>新生代 + 老年代完整垃圾回收</strong>，暂停时间长，<strong>应尽力避免</strong><ul><li><strong>触发时机</strong>：<ol><li><strong>旧生代空间不足</strong></li><li>显式调用 System.gc()</li><li>统计得到的 <strong>Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</strong></li></ol></li></ul></li></ul><h3 id="并发标记算法——三色标记与并发漏标问题"><a href="#并发标记算法——三色标记与并发漏标问题" class="headerlink" title="并发标记算法——三色标记与并发漏标问题"></a>并发标记算法——三色标记与并发漏标问题</h3><p><strong>三色标记</strong></p><p>即用三种颜色记录对象的标记状态</p><ul><li>黑色 – 已标记</li><li>灰色 – 标记中</li><li>白色 – 还未标记</li></ul><ol><li>起始的三个对象还未处理完成，用灰色表示</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;" /><ol start="2"><li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;" /><ol start="3"><li>依次类推</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;" /><ol start="4"><li>沿着引用链都标记了一遍</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;" /><ol start="5"><li>最后为标记的白色对象，即为垃圾</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;" /><p><strong>并发漏标问题</strong></p><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p><ol><li>如图所示标记工作尚未完成</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;" /><ol start="2"><li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;" /><ol start="3"><li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;" /><ol start="4"><li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;" /><p>因此对于<strong>并发标记</strong>而言，必须解决<strong>漏标问题</strong>，也就是要记录标记过程中的变化。有两种解决方法：</p><ol><li><strong>Incremental Update 增量更新法</strong>，<strong>CMS 垃圾回收器采用</strong><ul><li><strong>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</strong></li></ul></li><li><strong>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用</strong><ul><li>思路也是拦截每次赋值动作，不过<strong>记录的对象不同，记录的不再是黑色对象，而是新加对象或者被删除引用的对象</strong>，也需要在重新标记阶段对这些对象二次处理</li><li><strong>新加对象会被记录</strong></li><li><strong>被删除引用关系的对象也被记录</strong></li></ul></li></ol><h3 id="有哪些垃圾回收器"><a href="#有哪些垃圾回收器" class="headerlink" title="有哪些垃圾回收器"></a><strong>有哪些垃圾回收器</strong></h3><p><strong>垃圾回收器 - SerialGC</strong></p><ul><li><strong>串行</strong>垃圾回收器</li><li><strong>新生代</strong>采用<strong>复制算法</strong>，<strong>老年代</strong>采用 <strong>标记整理算法</strong></li><li><strong>单线程执行</strong>，一条垃圾回收线程进行垃圾回收</li><li>工作的时候都会 <strong>STW</strong>，直到收集结束</li></ul><p><strong>垃圾回收器 - Parallel Scavenge GC</strong></p><ul><li><strong>eden 内存</strong>不足发生 Minor GC，采用<strong>标记复制</strong>算法，需要暂停用户线程</li><li><strong>old 内存</strong>不足发生 Full GC，采用<strong>标记整理</strong>算法，需要暂停用户线程</li><li><strong>虽然会暂停用户线程，但是它会启动多个线程来一起回收，注重吞吐量</strong></li><li>可以使用参数 <code>-XX:ParallelGCThreads</code> 指定收集线程数，默认和CPU核心数相同</li></ul><p><strong>垃圾回收器 - ParNew收集器(-XX:+UseParNewGC)</strong></p><ul><li><strong>ParNew收集器</strong>其实<strong>跟Parallel收集器</strong>很<strong>类似</strong>，区别主要在于它可以和CMS收集器配合使用</li><li><strong>新生代</strong>采用<strong>复制</strong>算法，<strong>老年代</strong>采用<strong>标记-整理</strong>算法</li><li>运行在<strong>Server模式</strong>下的虚拟机的首要选择，除了Serial收集器外，只有它<strong>能与CMS收集器配合工作</strong></li></ul><h3 id="CMS-和-G1-的区别"><a href="#CMS-和-G1-的区别" class="headerlink" title="CMS 和 G1 的区别"></a>CMS 和 G1 的区别</h3><ol><li>CMS 工作于老年代，G1 适用于新生代，也适用于老年代</li><li>CMS 主要基于 标记-清除 算法，G1 则采用 标记-整理 算法</li><li>回收过程不同</li></ol><h3 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h3><p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p><ul><li>它是工作在 <strong>old 老年代</strong>，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法<ul><li>并发标记时不需暂停用户线程</li><li>重新标记时仍需暂停用户线程</li></ul></li><li>如果<strong>并发失败</strong>（即回收速度赶不上创建新对象速度），<strong>会触发 Full GC</strong></li><li><strong>注重响应时间</strong></li></ul><p><strong>回收过程</strong></p><ol><li>初始化标记：标记一些GC ROOTS对象，这个过程会STW(Stop The World)</li><li>并发标记：根据GC ROOTS对象并发的标记回收对象</li><li>重新标记：解决漏标问题</li><li>并发清理：并发清理</li><li>重置：CMS重置内部状态，准备下一并发回收期。重置CMS收集器的数据结构，等待下一次回收</li></ol><p><strong>优点</strong>： 并发收集低停顿</p><p><strong>缺点</strong>： 并发执行，对CPU资源压力大， 采用的<strong>标记清除算法</strong>会导致大量碎片</p><h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h3><p><strong>垃圾回收器 - G1 GC</strong></p><ul><li><strong>响应时间与吞吐量兼顾</strong></li><li><strong>划分</strong>成多个<strong>区域Region</strong>，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>分成三个阶段：<ol><li><strong>新生代回收</strong></li><li><strong>并发标记</strong></li><li><strong>混合收集</strong></li></ol></li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><strong>回收过程</strong></p><h4 id="G1-回收阶段-新生代回收"><a href="#G1-回收阶段-新生代回收" class="headerlink" title="G1 回收阶段 - 新生代回收"></a><strong>G1 回收阶段 - 新生代回收</strong></h4><ol><li>初始时，所有区域都处于空闲状态</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222639754.png" alt="image-20210831222639754" style="zoom:50%;" /><ol start="2"><li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222653802.png" alt="image-20210831222653802" style="zoom:50%;" /><ol start="3"><li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222705814.png" alt="image-20210831222705814" style="zoom:50%;" /><ol start="4"><li>复制完成，将之前的伊甸园内存释放</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222724999.png" alt="image-20210831222724999" style="zoom:50%;" /><ol start="5"><li>随着时间流逝，伊甸园的内存又有不足</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222737928.png" alt="image-20210831222737928" style="zoom:50%;" /><ol start="6"><li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222752787.png" alt="image-20210831222752787" style="zoom:50%;" /><ol start="7"><li>释放伊甸园以及之前幸存区的内存</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222803281.png" alt="image-20210831222803281" style="zoom:50%;" /><h4 id="G1-回收阶段-并发标记与混合收集"><a href="#G1-回收阶段-并发标记与混合收集" class="headerlink" title="G1 回收阶段 - 并发标记与混合收集"></a><strong>G1 回收阶段 - 并发标记与混合收集</strong></h4><ol><li>当<strong>老年代占用内存超过阈值后</strong>，触发<strong>并发标记</strong>，这时无需暂停用户线程</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222813959.png" alt="image-20210831222813959" style="zoom:50%;" /><ol start="2"><li><p><strong>并发标记</strong>之后，会有<strong>重新标记</strong>阶段<strong>解决漏标</strong>问题，此时需要<strong>暂停用户线程</strong>。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（<strong>存活对象少</strong>）的区域（这也是 Gabage First 名称的由来）。</p><p>回收价值：回收该region<strong>所获空间</strong>和<strong>所需时间</strong>的<strong>价值</strong></p></li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222828104.png" alt="image-20210831222828104" style="zoom:50%;" /><ol start="3"><li>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222841096.png" alt="image-20210831222841096" style="zoom:50%;" /><ol start="4"><li>下图显示了老年代和幸存区晋升的存活对象的复制</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222859760.png" alt="image-20210831222859760" style="zoom:50%;" /><ol start="5"><li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li></ol><img src="../../img/markdown_img/Java基础.assets/image-20210831222919182.png" alt="image-20210831222919182" style="zoom:50%;" /><h3 id="划分方式"><a href="#划分方式" class="headerlink" title="划分方式"></a>划分方式</h3><p>将对象按照生命周期的不同划分为：年轻代、年老代、永久代。其中永久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代</p><h3 id="JVM内存参数"><a href="#JVM内存参数" class="headerlink" title="JVM内存参数"></a><strong>JVM内存参数</strong></h3><p>对于JVM内存配置参数：-Xmx10240m -Xms10240m -Xmn5120m -XX:SurvivorRatio=3 其最小内存值和Survivor区总大小分别是</p><ul><li><strong>-Xms</strong> 最小堆内存（包括新生代和老年代）</li><li><strong>-Xmx</strong> 最大堆内存（包括新生代和老年代）</li><li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li><li><strong>-Xmn</strong> 新生代的内存</li><li><strong>-XX:SurvivorRatio</strong>=3 Eden区占3份，from和to各占1份</li><li><strong>-XX:NewSize</strong> 与 <strong>-XX:MaxNewSize</strong> 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li></ul><h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><p><strong>JVM调优的重点</strong>是<strong>垃圾回收</strong>（gc）和<strong>内存管理</strong>，垃圾回收的时候会导致整个虚拟机暂停服务。因此，应该尽可能地缩短垃圾回收的处理时间</p><p>在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置,让JVM获得最佳性能</p><ol><li><p><strong>开启-server模式</strong>，（启动虽然慢，但是运行效率高）</p></li><li><p>针对<strong>JVM堆的设置</strong>一般，可以通过-Xms -Xmx 限定其最小，最大值，为了防止垃圾收集器在最小、最大之间收缩而产生额外的时间，我们通常把最大、最小设置为相同的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms2g: 初始化堆大小为2g；</span><br><span class="line">-Xmx2g：堆最大内存为2g；</span><br></pre></td></tr></table></figure></li><li><p>年轻代和年老代将根据<strong>默认</strong>的比例<strong>（1：2）</strong>分配堆内存。年轻代和年老代设置多大才算合理，<strong>原则是减少GC的频率和Full GC的次数</strong></p></li><li><p>在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法：</p><p>-XX：+UserParalleloldGC，默认为Serial收集</p></li><li><p>-XX:SurvivorRatio=8；默认是8，表示新生代Eden占8份，Survivor区的from和to各占1份，8:1:1</p></li><li><p><strong>线程堆栈的设置</strong>：<strong>每个线程默认会开启1M</strong>的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，<strong>一般256K就足用</strong>。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统</p></li></ol><h3 id="怎么获取Java程序使用的内存？堆使用的百分比？"><a href="#怎么获取Java程序使用的内存？堆使用的百分比？" class="headerlink" title="怎么获取Java程序使用的内存？堆使用的百分比？"></a>怎么获取Java程序使用的内存？堆使用的百分比？</h3><p>可以通过java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存以及最大堆内存。通过这些方法你也可以获取到堆使用的百分比以及堆内存的剩余空间。Runtime.freeMemory()方法返回剩余空间的字节数，Runtime.totalMemory()方法返回总内存的字节数，Runtime.maxMemory()返回最大内存的字节数</p><h3 id="JVM常用调试工具"><a href="#JVM常用调试工具" class="headerlink" title="JVM常用调试工具"></a>JVM常用调试工具</h3><p>jconsole 和 jvisualvm 两款视图监控工具：</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220416151404690.png" alt="image-20220416151404690"></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220217095213698.png" alt="image-20220217095213698"></p><h3 id="集合的fail-fast和fail-safe机制"><a href="#集合的fail-fast和fail-safe机制" class="headerlink" title="集合的fail-fast和fail-safe机制"></a>集合的fail-fast和fail-safe机制</h3><p>fail-fast和fail-safe是集合的一种错误检测机制，当集合的迭代器正在遍历集合的同时又对集合进行结构上的改变的操作，就有可能引起fail-fast机制</p><p>比如：线程1通过iterator正在遍历集合A中的元素，线程2修改了集合A的结构（<strong>是结构上面的修改，而不是简单的修改集合元素的内容</strong>），那么这个时候就会抛出异常<strong>ConcurrentModificationException</strong>，从而产生fail-fast机制</p><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量来记录在遍历期间集合是否发生改变。在每次迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为期望的expectedModCount，是的话则遍历，否则抛出异常，终止遍历</p><p>可以使用写时复制数组代替普通数组CopyOnWriteArrayList代替ArrayList。CopyOnWriteArrayList是Fail-Safe的，遍历的同时可以修改，原理是读写分离</p><h3 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h3><p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。 </p><p>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。 </p><p>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p><h3 id="ArrayList-扩容"><a href="#ArrayList-扩容" class="headerlink" title="ArrayList 扩容"></a>ArrayList 扩容</h3><p>当我们添加第一个元素的时候，首次扩容为10，再次扩容为上次容量的1.5倍，实际上是上次容量右移1位后再加上上次的容量。接下来再判断扩容后的容量是不是大于期望的最小容量，选择两者中大的作为新容量，最后Arrays.copyOf()完成扩容</p><p><strong>扩容因子1.5的原因</strong>：</p><h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><p><strong>LinkedList</strong></p><ol><li>基于双向链表，无需连续的内存</li><li>随机访问慢，需要沿着链表进行遍历</li><li>头尾插入删除性能高</li><li>占用内存多，因为节点还要存一些prev，next的指向信息</li></ol><p><strong>ArrayList</strong></p><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p><ol><li>基于数组，需要连续的内存空间</li><li>随机访问快，因为内存空间连续，直接通过下标访问</li><li>尾部插入和删除性能高，其他部分的插入删除都会引起数组的移动，性能低</li><li>可以利用CPU缓存，局部性原理，访问到某一个下标时，把附近的也加载进入</li></ol><h3 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h3><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。 transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p><h3 id="HashSet如何检查重复？HashSet如何保证数据是不可重复的？"><a href="#HashSet如何检查重复？HashSet如何保证数据是不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet如何保证数据是不可重复的？"></a>HashSet如何检查重复？HashSet如何保证数据是不可重复的？</h3><p>HashSet底层就是一个HashMap实现的，调用HashSet的添加add(E e)方法就是调用的HashMap的put()方法，将HashSet中要添加的元素e作为HashMap的key，因为HashMap的key是不重复的，所以HashSet的的值也是不重复的</p><h3 id="为什么重写了equals还要重写hashcode"><a href="#为什么重写了equals还要重写hashcode" class="headerlink" title="为什么重写了equals还要重写hashcode"></a>为什么重写了equals还要重写hashcode</h3><p>对于基本数据类型equals比较的是值，对于引用数据类型，equals是比较的地址的引用是否相等。我们一般要比较对象是否相等的时候要重写equals方法，但是这还不够，因为java中会先进行hash运算，也即是hashcode方法得到哈希码来判断对象应该位于哪个桶里，如果位于不同桶里，也就是说hashcode的值不同的，这两个对象一定不同，如果hashcode相同，则还要去后续的链表中用equals方法去比较两个对象是否相等。如果没有重写hashcode方法，那么一开始两个相同的对象的hashcode值就不同，这样咋比也不会相同了。所以重写hashcode，就是确保我们认为相同的对象的hashcode也要相同</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet实现了Set接口，而HashMap实现的是Map接口。但是HashSet内部维护了一个map，HashSet调用add就是调用的map的put方法。但是HashSet不允许有重复的值，map中的put方法在判断出有重复值的时候不会添加元素，而是把旧值设置为新值后直接返回，最后并没有添加节点</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable可以说是就是线程安全版的Hashmap，因为它的方法都加了synchronized关键字，<strong>Hashtable不允许有null的key和value</strong>，put的时候就会检查value是否为null，key为空的话当key.hashcode方法的时候就会报错，都采用fail-fast机制，就是说在iterator遍历的时候，如果做了结构上的修改操作，那么就会抛出异常</p><p>Hashtable的初始容量是11，装载因子是0.75，扩容每次2n+1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>计算hash值的方法不同</strong></p><p><strong>Hashtable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。</strong><br><strong>HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。</strong></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>初始容量16</strong>  负载因子<strong>0.75</strong>  <strong>扩容2倍</strong></p><h4 id="HashMap-每次扩容两倍的原因"><a href="#HashMap-每次扩容两倍的原因" class="headerlink" title="HashMap 每次扩容两倍的原因"></a>HashMap 每次扩容两倍的原因</h4><p>HashMap 每次保证 map 的大小为2的倍数，目的则是为了能够更好的计算hash 值，让其元素分布均匀，并且2的倍数的话 可以采用位运算来代替取模运算，这样计算就会很方便，性能也会好很多</p><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><ul><li>1.7 数组 + 链表</li><li>1.8 数组 + （链表 | 红黑树）</li></ul><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>Hashmap可以采用keyset和entryset遍历以及values()方法获取所有的值</p><p>在用迭代器方法遍历的同时，如果调用hashmap自身的remove方法去删除一个key，将会引出fail-fast机制</p><p>调用nextNode方法的时候报错</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220305100357140.png" alt="image-20220305100357140"></p><p>但是如果用<strong>迭代器的remove()方法去删除一个key，则不会抛出异常</strong>，这是因为迭代器的remove()方法在删除的时候，会同时更新modCount和expectedModCount;这样就不会出现fail-fast，而hashmap的remove方法最终会修改modCount的值，而不会同步更新expectedModCount</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220305100331579.png" alt="image-20220305100331579"></p><h4 id="树化与退化"><a href="#树化与退化" class="headerlink" title="树化与退化"></a>树化与退化</h4><p><strong>树化意义</strong></p><ul><li>红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然情况才树化为红黑树，是保底策略</li><li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 O(log_2⁡n )，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li><li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li></ul><p><strong>树化规则</strong></p><ul><li>当<strong>链表长度超过</strong>树化阈值<strong>8</strong>时，先尝试扩容来减少链表长度，如果<strong>数组容量</strong>已经**&gt;=64**，才会进行树化</li></ul><p><strong>退化规则</strong></p><ul><li>情况1：在扩容时如果拆分树时，树元素个数 &lt;= 6 则会退化链表</li><li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul><h4 id="put与扩容"><a href="#put与扩容" class="headerlink" title="put与扩容"></a>put与扩容</h4><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220302204906775.png" alt="image-20220302204906775"></p><p><strong>put流程</strong></p><ol><li>HashMap 是懒惰创建数组的，首次使用才创建数组，首先看table是否为null，为null就去初始化table</li><li>table初始化完后，就看对应的table[i]是不是有不有值，没有值，直接插入</li><li>table[i]有值，就看table[i]的key是不是和要插入的重复了，重复了直接覆盖值</li><li>没有重复，就判断是不是treenode，是treenode就走红黑树的put流程</li><li>不是treenode，就准备插入到链表尾，判断链表需不需要转为红黑树</li><li>不需要转为红黑树，判断key是否存在，存在直接覆盖value</li><li>最后看需不需要扩容</li></ol><h4 id="Hashmap-并发死链的问题"><a href="#Hashmap-并发死链的问题" class="headerlink" title="Hashmap 并发死链的问题"></a>Hashmap 并发死链的问题</h4><p>Hashmap在多线程的情况还有可能发生死链的问题：</p><ul><li>JDK1.7在调用resize()方法的时候，会调用其中的transfer()方法，因为JDK1.7采用<strong>头插</strong>的方式，比如现在一个桶下的链有元素a，b。当线程1来的时候先指向这个引用，这个时候线程切换，线程2进行扩容，正常扩容完后因为头插法元素的顺序就b，a了，但是线程1这个时候之前已经拿到了这个两的引用，先把a头插，然后next原来指向的b，接着b头插，next又是a，头插a，这个时候a的next又指向的b，next指向null。这个就形成了一个死链，a的next是b，b的next又是a</li></ul><h4 id="HashMap初始容量10000，插入10000条数据，会不会扩容"><a href="#HashMap初始容量10000，插入10000条数据，会不会扩容" class="headerlink" title="HashMap初始容量10000，插入10000条数据，会不会扩容"></a>HashMap初始容量10000，插入10000条数据，会不会扩容</h4><p>不会扩容，因为带有初始容量的构造方法并不是直接把初始容量参数设置为threshold，而是经过一个tableSizeFor()方法，将阈值要设置为2的多少次方，10000的话应该是2^14次方=16384，所以16384*0.75=12288&gt;10000，所以能存</p><h4 id="HashMap-1-8-和-1-7区别，做了哪些优化"><a href="#HashMap-1-8-和-1-7区别，做了哪些优化" class="headerlink" title="HashMap 1.8 和 1.7区别，做了哪些优化"></a>HashMap 1.8 和 1.7区别，做了哪些优化</h4><ol><li>JDK 1.7 头插法，存在并发死链问题</li><li>JDK 1.8 采用的hash 算法不同，hashcode ^ (hashcode &gt;&gt;&gt; 16)</li></ol><h4 id="HashMap-table的初始化"><a href="#HashMap-table的初始化" class="headerlink" title="HashMap table的初始化"></a>HashMap table的初始化</h4><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="红黑树的引入"><a href="#红黑树的引入" class="headerlink" title="红黑树的引入"></a>红黑树的引入</h4><p><strong>有了二叉搜索树，为什么还要二叉平衡树</strong></p><ul><li>二叉搜索树是一棵排了序的二叉树，可以方便我们做一个数据的查找，二叉搜索树的中序遍历的结果就是一个排好序的结果，我们查找数据沿着根结点遍历，小于这个节点的就到左子树中去查找，大于这个节点的就到右子树中查找。</li><li>二叉搜索树的查找时间复杂度平均 O（log n），但是当这个二叉树退化为链表的，时间复杂度就退化为了O（n）</li><li>所以为了<strong>防止它退化为链表</strong>，就采用了二叉平衡树，<strong>二叉平衡树</strong>确保左右子树的<strong>高度差不超过1</strong>，在插入节点的时候，还需要去平衡二叉树的高度。保证最坏情况下其查找性能也是O（log n）</li></ul><p><strong>有了二叉平衡树，为什么还要红黑树</strong></p><ul><li>AVL 的严格要求左右子树高度差不能超过1，每次进行 插入/删除操作的时候，几乎都需要通过 旋转 操作保持平衡</li><li>所以在<strong>频繁插入/删除</strong>的场景中，<strong>二叉平衡树</strong>的<strong>平衡也严重影响了其性能</strong></li><li>红黑树通过牺牲严格的平衡，换取 插入/删除 时少量的旋转操作，整体性能高于 AVL<ul><li>红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决</li></ul></li><li>红黑树的红黑规则，保证最坏的情况下，也能在O ( log N ) 时间复杂度</li></ul><h4 id="红黑树规则"><a href="#红黑树规则" class="headerlink" title="红黑树规则"></a>红黑树规则</h4><p><strong>红黑树的规则：</strong></p><ul><li><strong>节点不是黑色</strong>，<strong>就是红色</strong></li><li><strong>根节点是黑色</strong></li><li><strong>叶子节点</strong>都是<strong>黑色</strong>（<strong>NIL</strong> / <strong>NULL</strong>）</li><li>从根路径到任意节点，<strong>不能连续出现两个红色节点</strong>（一个节点要是红色，其子节点都要是黑色）</li><li><strong>每个节点到叶子节点的所有路径</strong>，都<strong>包含相同数目的黑色节点</strong></li></ul><p>红黑树的红黑规则，保证最坏的情况下，也能在O ( log N ) 时间复杂度</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Hashtable是synchronized版的HashMap，但是它性能太低了，所以有了ConcurrentHashMap</p><ol><li><p>JDK 7</p><p>在JDK 7的时候，它的设计是采用<strong>Segment分段锁</strong>去实现的，有多个Segment，一个<strong>Segment</strong>就是一个<strong>ReentrantLock</strong>，因为它继承了ReentrantLock，加锁的时候就是<strong>对Segment进行加锁</strong>，这样<strong>不同Segment的操作</strong>就可以<strong>不用加锁</strong>，达到并发的效果。</p><p>它的put流程就是说先根据<strong>SegmentShift</strong>和<strong>SegmentMask</strong>计算出<strong>Segment</strong>的<strong>下标</strong>，然后拿着这个下标先去判断，<strong>Segment</strong>是不是null，在<strong>确保为null</strong>之后就采用<strong>CAS去创建Segment对象</strong>，然后<strong>进入segment的put流程</strong>，首先<strong>尝试给segment加锁tryLock()<strong>，加锁</strong>不成功</strong>，就进入scanAndLockForPut方法<strong>多次尝试加锁</strong>，在<strong>尝试期间</strong>，还会去看<strong>节点</strong>有没有创建出来，如果没有则还会去<strong>创建</strong>出来。</p><p><strong>加锁成功</strong>后，就可以安全的执行后续的put操作了，看<strong>有没有这个key</strong>，就看<strong>要不要覆盖值</strong>，没有就是新增，<strong>判断节点有没有被创建出来</strong>，因为刚才说了有可能在循环获取锁的时候可能会去创建出节点，然后看<strong>要不要扩容</strong></p></li><li><p>JDK 8</p><p>JDK 8采用的是<strong>CAS+synchronized</strong>来实现线程安全性，它的put流程主要如下，</p><p>获取到key的<strong>hash值</strong>，然后<strong>看tab有没有创建出来</strong>，tab<strong>没创建</strong>出来就走<strong>initTable()创建tab</strong>，initTable()里面会先去判断有不有其他线程正在创建tab，如果有就当前线程循环yield，让出CPU的使用权，否则就使用CAS替换sizeCtl的值尝试获取锁然后创建tab；如果tab创建出来了，就去判断对应tab[]下面的<strong>头节点有没有创建出来</strong>，如果<strong>没有</strong>，则<strong>新增的节点</strong>直接就是作为<strong>头结点</strong>，否则就看头结点<strong>是不是被搬迁过 MOVED</strong>，如果是说明<strong>正在扩容</strong>，那么就要去<strong>帮忙扩容helpTransfer()</strong></p><p>最后else说明<strong>tab创建完了</strong>，<strong>头结点也不为null</strong>，并且<strong>也不是forwarddingNode正在扩容</strong>，那么就加锁，<strong>synchronized锁住头结点</strong>，再次判断节点是否被移动，如果是<strong>链表</strong>，就走链表的put，<strong>遍历链表</strong>，找有不有重复，记录链表元素个数，如果是<strong>红黑树</strong>，走红黑树的put，最后<strong>看需不需要去树化</strong>，然后增加size计数</p></li></ol><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="流的划分"><a href="#流的划分" class="headerlink" title="流的划分"></a>流的划分</h3><ul><li>按照流的流向：输入流和输出流</li><li>按照流的操作单元：字符流和字节流</li><li>按照流的角色：节点流和处理流</li></ul><p><strong>字节流：</strong></p><ul><li>字节流就是每次处理单元是一个字节，主要用于二进制数据的读取，实际上它可以读取任意类型的数据，但是它不支持直接写入或者读取Unicode码元。<strong>字节流默认不使用缓冲区</strong>。字节输入流和输出流分别对应InputStream和OutputStream</li></ul><p><strong>字符流：</strong></p><ul><li>字符流每次处理单元是两个字节的一个Unicode字符。<strong>字符流使用缓冲区</strong>。字符输入流和输出流分别对应InputReader和OutputWriter</li></ul><p>节点流：可以从或向一个特定的地方（节点）读写数据。直接对数据源（文件，数组之类存放数据的地方）进行操作。常见的有 FileReader，FileWriter，FileInputStream，FileOutputStream</p><p>处理流：对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。处理流的构造方法总是要带一个其他的流对象做参数。常见的有 BufferedReader，BufferedWriter，BufferedInputStream，BufferedOutputStream。</p><p>比如<code>BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath))</code></p><p>Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO流的40多个类都是从如下4个抽象类基类中派生出来的</p><ul><li><strong>InputStream/Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流</li><li> <strong>OutputStream/Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流</li></ul><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220215183701632.png" alt="image-20220215183701632"></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220215183940215.png" alt="image-20220215183940215"></p><h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul><li>Files. exists()：检测文件路径是否存在</li><li>Files. createFile()：创建文件 </li><li>Files. createDirectory()：创建文件夹</li><li>Files. delete()：删除一个文件或目录</li><li>Files. copy()：复制文件</li><li>Files. move()：移动文件</li><li>Files. size()：查看文件个数</li><li>Files. read()：读取文件</li><li>Files. write()：写入文件</li></ul><h3 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO,NIO,AIO"></a>BIO,NIO,AIO</h3><ul><li>BIO：Block IO 同步阻塞式IO，就是我们平时使用的传统IO，它的特点是模式简单使用方便，但并发处理能力低</li><li>NIO：Non IO 同步非阻塞IO，是传统IO的升级，客户端和服务端通过Channel（通道）通讯，实现了多路复用</li><li>AIO：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制</li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>在Unix系统中，一切都是文件。文件就是流的概念，在进行信息的交流过程中，对这些流进行数据的收发操作就是IO操作</p><blockquote><p>我们都知道unix(like)世界里，一切皆文件，而文件是什么呢？文件就是一串二进制流而已，不管socket，还是FIFO、管道、终端，对我们来说，一切都是文件，一切都是流。在信息交换的过程中，我们都是对这些流进行数据的收发操作，简称为 <strong>I/O 操作</strong>(input and output)，往<strong>流中读出数据</strong>，系统调用<strong>read</strong>，<strong>写入数据</strong>，系统调用<strong>write</strong>。不过话说回来了 ，计算机里有这么多的流，我怎么知道要操作哪个流呢？对，就是<strong>文件描述符</strong>，即通常所说的 <strong>fd</strong> ，一个 **fd **就是一个整数，所以，对这个整数的操作，就是对这个文件（流）的操作。我们创建一个socket，通过系统调用会返回一个文件描述符，那么剩下对socket的操作就会转化为对这个描述符的操作。不能不说这又是一种分层和抽象的思想。</p></blockquote><h3 id="磁盘IO为什么慢"><a href="#磁盘IO为什么慢" class="headerlink" title="磁盘IO为什么慢"></a>磁盘IO为什么慢</h3><p>我们要到磁盘上查找数据的话，内核会给磁盘映射一个地址，然后磁盘定位到盘片上，就让磁头去寻找具体数据读取出来。</p><p>磁盘IO的速度主要在于两个方面：</p><ol><li><strong>让磁头定位到指定位置的时间</strong></li><li><strong>磁头从盘片上读出数据的时间</strong></li></ol><h3 id="同步-与-异步"><a href="#同步-与-异步" class="headerlink" title="同步 与 异步"></a>同步 与 异步</h3><p>同步： 执行一个操作后，进程<strong>触发IO操作</strong>（其中要么就是等待数据的到达，也就是阻塞模式；要么通过轮询去查看数据是否到达也就是非阻塞忙轮询模式的）等待或者轮询 IO 操作是否就绪。</p><p>异步： 执行一个操作后，<strong>触发IO操作后不会导致请求进程阻塞</strong>。也就是说数据从内核到用户缓冲区的整个过程都是交给内核去完成的，用户进程无需阻塞一直等到IO操作完成，它只要执行一个操作<strong>触发IO操作后</strong>就可以继续<strong>执行其他操作</strong>，直到IO操作结束后，<strong>等到被通知</strong>就可以了。所以从根本来说异步从等待数据到把数据从内核空间拷贝到用户空间的过程中没有阻塞，只有发起该操作，和被通知该操作完成。所以异步是真正的没有阻塞在IO操作上的</p><h3 id="IO-阻塞-与-非阻塞"><a href="#IO-阻塞-与-非阻塞" class="headerlink" title="IO 阻塞 与 非阻塞"></a>IO 阻塞 与 非阻塞</h3><p><strong>阻塞</strong>：阻塞就是说在执行 IO 操作的时候，调用者一直等待请求结果返回，当前线程一直等待无法从事其他工作，只有当条件就绪时，才可以继续执行</p><p><strong>非阻塞</strong>：非阻塞则相反，不用一直等待请求结果返回，可以先去做别的事情</p><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO 也就是 Blocking IO，<strong>同步阻塞I/O模式</strong>，数据的读取写入<strong>必须阻塞在一个线程内等待其完成</strong>。</p><p>就是我们平时使用的传统IO，它的特点是模式简单使用方便，但并发处理能力低</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO 同时支持 阻塞和非阻塞</p><p><strong>同步非阻塞</strong>指的是：一个线程进行数据的读取写入的时候，<strong>不必一直阻塞等待</strong>，可以去做别的任务，只<strong>需要</strong>不停的<strong>轮询</strong>一下数据处理情况，如果数据处理完毕，也就可以执行下一步任务了。</p><p><strong>缺点</strong>：<strong>服务端</strong>要<strong>轮询</strong>所有连接的客户端拿数据（<code>recv</code>调用），很多调用是无意义的，这样会导致频繁的<strong>用户态切换成内核态</strong>，导致性能变差。</p><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>AIO （Asynchronous I/O）：异步非阻塞IO，异步IO肯定就是非阻塞的IO，只需要执行一个操作触发IO就可以去执行其他操作了，也不用一直轮询IO操作的状态，等IO操作结束后，只需要等待IO通知。</p><p>无论NIO，SELECT还是POLL，<strong>都是要遍历所有IO，询问状态,只不过遍历这件事到底是内核来做还是应用程序来做而已</strong></p><h3 id="Java-NIO-底层实现"><a href="#Java-NIO-底层实现" class="headerlink" title="Java NIO 底层实现"></a>Java NIO 底层实现</h3><p>Java  NIO 底层基于 epoll 的多路复用技术实现，与 select poll 不同的是，select poll 都是每次调用 select、poll 就把文件描述符从用户态拷贝到内核态，供修改，然后select 采用数组的形式 遍历数组作为一个监听，poll 采用链表的形式 作为监听 解决了select 的数组大小限制问题，但是他们都面临着一个遍历问题，就是都要遍历一次数组或者链表，来查看对应的 fd，时间复杂度O（n），epoll 则是在调用 epoll_ctl 的时候进行 fd 的拷贝，并且给每个 fd 注册指定一个回调函数，当准备就绪的时候，回调函数就会把 就绪的 fd 放到 就绪链表中去，epoll_wait 就等待 就绪链表有 就绪的fd 的时候。这样不用遍历，复杂度 O（1）</p><h3 id="多路-IO复用"><a href="#多路-IO复用" class="headerlink" title="多路 IO复用"></a>多路 IO复用</h3><p><strong>多路IO复用</strong>采用 select、poll、epoll 的三种方式，这个三个函数本质上都是同步I/O，因为他们都需要在读写事件就绪后再自己进行读写，也就是说这个读写过程是阻塞的</p><p>select 先阻塞，有活动套接字才返回，只不过 <strong>select</strong> 采用<strong>数组</strong>存文件描述符 <strong>fd</strong>，<strong>poll</strong> 采用<strong>链表</strong>存 文件描述符，和 阻塞IO 不相同的是，这个几个函数可以阻塞多个IO操作，而且可以同时对多个读操作，多个写操作的IO函数进行检测，修改 fd 来表示数据的准备情况</p><p>正因为 <strong>阻塞IO</strong> 只能<strong>阻塞 一个 IO 操作</strong>，而 <strong>IO复用模型</strong> 能<strong>阻塞多个 IO 操作</strong>，所以叫多路复用。</p><p>也就是说，<strong>IO 多路复用并不是非阻塞</strong>，<strong>只是它可以同时处理多个请求</strong>，<strong>原本的 单路IO 是一个处理完才能接入新的连接</strong>，多路复用就是<strong>可以同时接入多个连接</strong>。</p><p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程</strong></p><p>多路复用技术可以<strong>解决 NIO 的需要轮询客户端状态</strong>，<strong>造成用户态到内核态切换的问题</strong>。多个IO通过一个系统调用获得其中的IO状态，然后由程序对有状态的IO进行读写操作。在Linux系统中，多路复用的实现有：</p><ul><li><p><strong>select</strong></p><p><strong>select 监控</strong> 三类文件描述符，<strong>writefds</strong>、<strong>readfds</strong>、<strong>exceptfds</strong>，select 采用数组的形式存储这三类描述符，select 一直遍历这个描述符数组，内核在将数据准备好后或者应该说修改对应的描述符为1后，select 遍历到有描述符就绪，就知道这些数据是准备好的，然后将函数返回，返回后再接收数据</p><p><strong>缺点</strong>：</p><ul><li>文件描述符的数量，默认 <strong>1024</strong> 个</li><li><strong>开销会随着文件描述符线性增长</strong>，O（n）</li></ul></li><li><p><strong>poll</strong></p><p>poll 是为了解决 select 的数组数量有限的情况，所以 poll 采用<strong>链表</strong>的形式，这样在大小上就不会存在限制</p><p><strong>缺点</strong>：</p><ul><li><strong>仍然存在开销随着文件描述符线性增长</strong>，O（n）</li></ul></li><li><p><strong>epoll</strong></p><p>epoll 就解决了开销随文件描述符增长的情况。epoll 采用<strong>监听回调的机制</strong>，<strong>每当 fd 就绪</strong>，系统注册的<strong>回调函数</strong>就会被<strong>调用</strong>，就<strong>将就绪 fd 放到 就绪链表</strong>，<strong>epoll_wait</strong> 就去<strong>就绪链表中查看</strong>有不有就绪的fd（不用遍历所有的 fd，直接找到哪些 fd 就绪），<strong>epoll_ctl</strong> 注册监听对应的事件，拷贝fd到内核，epoll_wait 不拷贝</p><p>时间复杂度 O（1）</p><p>epoll对文件描述符的操作有两种模式：<strong>LT</strong>（level trigger）和<strong>ET</strong>（edge trigger），LT模式是默认模式，LT模式与ET模式的区别如下：</p><p>LT模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></p><p>ET模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</strong></p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</p></li></ul><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220408104126857.png" alt="image-20220408104126857"></p><p>Select</p><p>基于 Select 调用的 I/O 复用模型如下：</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220408091713550.png" alt="image-20220408091713550"></p><p>应用进程 select 调用，没有数据报准备好，到数据报准备完毕，进程一直阻塞等待，等待可能多个套接字中的任一个变为可读状态。等待内核返回可读条件的时，应用进程 recvfrom 再次发送系统调用拷贝数据报（将数据从内核拷贝到用户空间），拷贝完成返回成功，然后应用进程就可以继续执行操作了。</p><p><strong>select poll epoll的区别</strong></p><p>Nginx实现网络通讯时使用的是异步网络模型：<strong>epoll模型</strong></p><p><strong>select、poll、epoll都是I/O多路复用机制</strong>，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪，就能够通过程序进行相应的读写操作</p><p>select、poll、epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后再自己进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无须自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间</p><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><ul><li><p>select()函数监视的文件描述符分为三类，分别是writefds、readfds、exceptfds，调用后select()函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可）函数就会返回</p></li><li><p>首先会将多个文件描述符标志位存入一个数组中，当函数返回时，该数组中<strong>就绪的文件描述符便会被内核修改标志位</strong>，使得进程可以获得这些文件描述符从而进行后续的读写操作</p></li><li><p>然后select函数就会遍历文件描述符数组，如果读到标志位为1，则知道这些数据是准备好了的，然后对其进行读写</p><p><strong>缺点：</strong></p></li><li><p>文件描述符的数量默认为1024个</p></li><li><p>开销会随着文件描述符线性增长（遍历一遍需要很长时间 O(n)）</p></li></ul><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><ul><li><p>和select的执行过程是差不多的，但是数据结构改变了，poll机制中将select机制的文件描述符数组改善为了链表，将文件描述符标志位存入链表中</p></li><li><p>因为链表是可以无限延伸的，因此poll对于select来说，使得文件描述符的数量不再被限制</p><p><strong>缺点：</strong></p><p>开销会随着文件描述符线性增长（同样需要和select机制一样遍历一遍 O(n)）</p></li></ul><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><ul><li><p>epoll是select和poll的增强版本，相对于select和poll来说，epoll更加灵活，没有描述符限制</p></li><li><p>当调用epoll_wait()函数获得就绪文件描述符的时候，返回的不是实际的文件描述符，而是一个代表就绪描述符数量的值，<strong>这个时候只需要去epoll指定的一个准备就绪链表中遍历一遍这些文件描述符就可以了</strong></p></li><li><p>epoll提供了三个函数：<code>epoll_create、epoll_ctl、epoll_wait</code></p><p>epoll_create是创建一个epoll句柄</p><p>epoll_ctl是注册要监听的事件类型</p><ul><li>在调用epoll_ctl()时把所有fd拷贝进内核，并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表（<strong>此处去掉了遍历文件描述符，而是通过监听回调的的机制</strong>，这正是epoll的魅力所在）</li><li>epoll_wait则是等待事件的产生，它的实际工作就是在查看在就绪链表中有没有就绪的fd</li></ul></li></ul><p>epoll的开销对于select和poll来说省下了许多，<strong>时间复杂度只需要O(1)</strong></p><h5 id="LT-ET"><a href="#LT-ET" class="headerlink" title="LT/ET"></a>LT/ET</h5><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger），LT模式是默认模式，LT模式与ET模式的区别如下：</p><p>LT模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</strong></p><p>ET模式：<strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</strong></p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射机制"><a href="#什么是反射机制" class="headerlink" title="什么是反射机制"></a>什么是反射机制</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；<strong>这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制</strong></p><p>静态编译：在编译时确定类型，绑定对象</p><p>动态编译：在运行时确定类型，绑定对象</p><h3 id="反射优缺点"><a href="#反射优缺点" class="headerlink" title="反射优缺点"></a>反射优缺点</h3><ul><li>优点：运行期类型的判断，动态加载类，提高代码的灵活度</li><li>缺点：性能瓶颈，反射相当于一系列解释操作，通知JVM要做的事，性能比直接的Java代码要慢</li></ul><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>反射的框架设计的灵魂</p><p>我在项目中采用Redis用Hash的结构存入一个用户的授权对象，然后调用<code>redisTemplate.boundHashOps(uuid).entries()</code>取出来的时候需要将其从Map集合转换为一个对象，这个时候就编写了一个工具类就是运用反射将Map中的entry转换为一个实例对象</p><ol><li>在采用JDBC连接数据库的时候采用Class.forName()通过反射加载数据库的驱动</li><li>Spring中运用到的反射，最经典的就是xml的配置，Spring通过XML配置解析装载Bean<ul><li>将程序内所有XML或Properties配置文件加载入内存中</li><li>Java类里面解析XML或者Properties里面的内容，得到对应实体类的字节码字符串以及相关属性信息</li><li>使用反射机制，根据这个字符串获得某个类的实例</li><li>动态配置实例的属性</li></ul></li></ol><h3 id="反射的三种方法"><a href="#反射的三种方法" class="headerlink" title="反射的三种方法"></a>反射的三种方法</h3><p>假设有一个com.zc.test包下有类Student</p><ol><li>Class.forName(“com.zc.test.student”);</li><li>student.getClass();</li><li>Student.class;</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解的三种保留策略"><a href="#注解的三种保留策略" class="headerlink" title="注解的三种保留策略"></a>注解的三种保留策略</h3><p><strong>SOURCE</strong>：此类会被编译器丢弃，不将它保留到编译后的class文件</p><p><strong>CLASS</strong>：将注解保留到编译后的class文件，但是在运行时忽略它</p><p><strong>RUNTIME</strong>：将注解保留到编译后的class文件，并且会在第一次类加载的时候读取它</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220405185705147.png" alt="image-20220405185705147"></p><h3 id="注解的使用范围"><a href="#注解的使用范围" class="headerlink" title="注解的使用范围"></a>注解的使用范围</h3><p>@Traget 注解中的<code>ElementType[] value();</code>，ElementType 描述了注解的修饰范围</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任何类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol><li>形式上：字符常量是单引号引出来的一个字符，字符串是双引号引出的</li><li>含义上：字符串是相当于一个整型值（ASCII值），可以参加表达式运算，字符串常量代表一个地址值（该字符串在内存中存放位置）</li><li>占内存大小：字符常量只占一个字节，字符串常量占若干个字节（至少一个字符结束标志）</li></ol><h4 id="什么是字符串常量池"><a href="#什么是字符串常量池" class="headerlink" title="什么是字符串常量池"></a>什么是字符串常量池</h4><p><strong>字符串常量池</strong>位于<strong>堆内存</strong>中，专门用来<strong>存储字符串常量</strong>，可以提高内存的利用率，<strong>避免开辟多块空间存储相同的字符串</strong>，在<strong>创建字符串</strong>时<strong>JVM</strong>会首先<strong>检查字符串常量池</strong>，如果该<strong>字符串已经存在池中</strong>，则<strong>返回它的引用</strong>，如果<strong>不存在</strong>，则<strong>实例化</strong>一个<strong>字符串</strong>放到池中，并返回其引用。</p><h4 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h4><ol><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据 的一致性。</li><li>常量池优化：：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ol><h4 id="String真的是不可变的吗"><a href="#String真的是不可变的吗" class="headerlink" title="String真的是不可变的吗"></a>String真的是不可变的吗</h4><ol><li><p>String不可变但不代表引用不可以变 </p><p>String str =”Hello”;str = str +” World”; System.out.println(“str=”+ str);</p><p>结果：str=Hello World</p><p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已， 也就是说多开辟了一块内存区域给”Hello World”字符串。</p></li><li><p>通过反射可以修改所谓的“不可变”对象</p><p>通过反射打破封装，访问String对象的<code>char[] value</code>属性，修改其值</p></li></ol><h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 =<span class="string">&quot;hello&quot;</span>;<span class="comment">//str1指向静态区</span></span><br><span class="line">String str2 =<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);<span class="comment">//str2指向堆上的对象</span></span><br><span class="line">String str3 =<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str4=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str4));<span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2 ==<span class="string">&quot;hello&quot;</span>);<span class="comment">//false</span></span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 ==<span class="string">&quot;hello&quot;</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="如何将字符串反转"><a href="#如何将字符串反转" class="headerlink" title="如何将字符串反转"></a>如何将字符串反转</h4><p>使用StringBuilder或者StringBuffer的reverse()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure><h4 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h4><ul><li>indexOf()：返回指定字符的索引</li><li>charAt()：返回指定索引处的字符</li><li>replace()：字符串替换</li><li>trim()：去除字符串两端空白</li><li>split()：分割字符串，返回一个分割后的字符串数组</li><li>getBytes()：返回字符串的byte类型数组</li><li>length()：返回字符串长度</li><li>toLowerCase()：字符串转成小写字母</li><li>toUpperCase()：将字符串转成大写字母</li><li>substring()：截取字符串</li><li>equals()：字符串比较</li></ul><h3 id="在使用HashMap的时候，用String做Key有什么好处"><a href="#在使用HashMap的时候，用String做Key有什么好处" class="headerlink" title="在使用HashMap的时候，用String做Key有什么好处"></a>在使用HashMap的时候，用String做Key有什么好处</h3><p>HashMap内部实现是通过Key的hashcode来确定value的存储位置的，因为字符串是不可变的，所有当创建字符串时，它的<strong>hashcode被缓存下来，不需要再次计算，所以相比于其他对象更快</strong></p><h3 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h3><ol><li><p>可变性</p><p>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与 StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p></li><li><p>线程安全性</p><p>String中的对象是不可变的，也就可以理解为常量，线程安全。<strong>AbstractStringBuilder</strong>是<strong>StringBuilder</strong>与<strong>StringBuffer</strong> 的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。 StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><p>StringBuilder非线程安全，StringBuffer线程安全</p></li><li><p>性能</p><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer 每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p></li></ol><p>对于三者使用的总结：</p><p><strong>如果要操作少量的数据用</strong> = String </p><p><strong>单线程操作字符串缓冲区 下操作大量数据</strong> = StringBuilder </p><p><strong>多线程操作字符串缓冲区 下操作大量数据</strong> = StringBuffer</p><h2 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h2><p>Date、SimpleDateFormat、LocalDate、LocalTime、LocalDateTime、Calendar抽象类，Calendar.getInstance()获取一个实例</p><p>LocalDateTime可以用来获取指定时间的时间，里面封装一些方法，可以做一些时间的运算，比如加1周，等等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如何让每周四18:00:00 定时执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    LocalDateTime now= LocalDateTime.now();</span><br><span class="line">    <span class="comment">//获取当前周的周四时间</span></span><br><span class="line">    LocalDateTime time = now.withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>).with(DayOfWeek.THURSDAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前时间大于本周周四，必须找到下周的周四</span></span><br><span class="line">    <span class="keyword">if</span> (now.compareTo(time)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        time = time.plusWeeks(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialDelay 代表当前时间和周四的时间差</span></span><br><span class="line">    <span class="comment">// period 一周的间隔时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算两个时间的差值</span></span><br><span class="line">    <span class="keyword">long</span> initialDelay = Duration.between(now, time).toMillis();</span><br><span class="line">    <span class="keyword">long</span> period = <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>;</span><br><span class="line">    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    &#125;,initialDelay,period, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Duration表示一个连续的时间段，可以用来做时间上的计算</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration.between(now, time).toMillis();</span><br><span class="line"><span class="comment">// 3 s 和 5 ns 的 Duration </span></span><br><span class="line">Duration duration = Duration.ofSeconds(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">Duration oneDay = Duration.between(today, yesterday);</span><br><span class="line"><span class="comment">// A duration of 3 seconds and 5 nanoseconds</span></span><br><span class="line">Duration duration = Duration.ofSeconds(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">Duration oneDay = Duration.between(today, yesterday);</span><br></pre></td></tr></table></figure><h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p>装箱：将基本类型用它们对应的引用类型包装起来；</p><p>拆箱：将包装类型转换为基本数据类型；</p><p>对于<strong>对象引用类型</strong>：==比较的是对象的<strong>内存地址</strong>。 </p><p>对于<strong>基本数据类型</strong>：==比较的是<strong>值</strong>。</p><p> 如果整型字面量的值在**-128到127<strong>之间，那么自动装箱时</strong>不会new新的Integer对象**，而是直接引用常量池中的Integer 对象，超过范围。</p><p>a1==b1的结果是false</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">    Integer b =<span class="number">3</span>;<span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">    <span class="keyword">int</span> c =<span class="number">3</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">// false 两个引用没有引用同一对象 </span></span><br><span class="line">    System.out.println(a == c);<span class="comment">// true a自动拆箱成int类型再和c比较 </span></span><br><span class="line">    System.out.println(b == c);<span class="comment">// true </span></span><br><span class="line">    Integer a1 =<span class="number">128</span>; </span><br><span class="line">    Integer b1 =<span class="number">128</span>; </span><br><span class="line">    System.out.println(a1 == b1);<span class="comment">// false </span></span><br><span class="line">    Integer a2 =<span class="number">127</span>; </span><br><span class="line">    Integer b2 =<span class="number">127</span>; </span><br><span class="line">    System.out.println(a2 == b2);<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="五种单例模式"><a href="#五种单例模式" class="headerlink" title="五种单例模式"></a><strong>五种单例模式</strong></h3><p>单例模式有<strong>饿汉式、懒汉式、枚举类(饿汉)、静态内部类</strong></p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：为什么<strong>类要加 final</strong></p><ul><li>防止子类继承后重写方法破坏单例</li></ul><p>问题2：如果实现了序列化接口，还要做什么来<strong>防止反序列化破坏单例</strong></p><ul><li>反序列化时候生成的对象可能会破坏单例，直接在类里加一个**public Object readResolve() {}**方法，可以让反序列化的时候调用这个方法返回单例的实例</li></ul><p>问题3：为什么<strong>构造方法设置为私有</strong>?</p><ul><li>避免其他类使用new生成新的实例，并不能防止反射创建新的实例，因为反射可以打破封装</li></ul><p>问题4：这样初始化是否能保证单例对象创建时的线程安全？</p><ul><li>可以保证，因为实例在<strong>类加载</strong>的时候就<strong>初始化</strong>，JVM会保证其线程安全性</li></ul><p>问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</p><ul><li>1.提供更好的<strong>封装性</strong>；2.提供<strong>泛型</strong>的支持</li></ul></blockquote><h4 id="饿汉式之枚举"><a href="#饿汉式之枚举" class="headerlink" title="饿汉式之枚举"></a>饿汉式之枚举</h4><p>饿汉式：因为枚举的变量，底层是通过public static final来修饰的，类加载就创建了，所以是饿汉式</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220122210404242.png" alt="image-20220122210404242"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span>+<span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingletonEnum instance = SingletonEnum.INSTANCE;</span><br><span class="line">        SingletonEnum instance1 = SingletonEnum.INSTANCE;</span><br><span class="line">        System.out.println(instance==instance1);</span><br><span class="line">        instance.print();</span><br><span class="line">        instance1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">------<span class="number">1163157884</span></span><br><span class="line">------<span class="number">1163157884</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> EnumSingleton instance;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//JVM保证只执行一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：枚举单例是如何限制实例个数的</p><ul><li><strong>创建枚举类的时候就已经定义好了</strong>，每个枚举常量其实就是枚举类的一个静态成员变量</li></ul><p>问题2：枚举单例在创建时是否有并发问题</p><ul><li>没有并发问题，是线程安全的，因为枚举单例底层是一个静态成员变量，它是通过类加载器的加载而创建的，确保了线程安全</li></ul><p>问题3：枚举单例能否被反射破坏单例</p><ul><li><p><strong>反射无法破坏枚举单例</strong>, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">this</span>.clazz.getModifiers() &amp; <span class="number">16384</span>) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(“Cannot reflectively create <span class="class"><span class="keyword">enum</span> <span class="title">objects</span>”)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>问题4：枚举单例能否被反序列化破坏单例</p><ul><li><strong>反序列化不能破坏</strong>，枚举类默认也实现了序列号接口。但枚举类考虑到了这个问题，不会破坏单例。</li></ul><p>问题 5：枚举单例属于懒汉式还是饿汉式</p><ul><li>属于<strong>饿汉式</strong>, 静态成员变量, 通过类加载器的时候就加载了。</li></ul><p>问题 6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</p><ul><li>加构造方法，枚举也可以写构造方法，普通方法等</li></ul></blockquote><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点：</span></span><br><span class="line">    <span class="comment">// synchronized加在静态方法上，可以保证线程安全。缺点就是锁粒度大，效率低。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h4><p>DCL：double-check-locking</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：解释为什么要加 volatile</p><ul><li>因为在synchronized外部使用到了共享变量INSTANCE，可能存在一个线程先初始化了instance，但是别的线程没有从主存中获取instance，而是从工作内存中获取instance，仍然为空，volatile保证了可见性，保证读取变量的时候都从主存中去获取，这样就不会存在已经创建了实例，但读取到实例仍然为空的情况</li></ul><p>问题2：对比上面的懒汉式，说出这样做的意义</p><ul><li>增加了双重判断，如果存在了单例对象，别的线程再进来就无需加锁判断，<strong>提升效率</strong></li></ul><p>问题3：为什么还要加为空判断, 之前不是判断过了吗</p><ul><li>主要原因还是因为并发的时候产生线程不安全的问题</li><li>考虑这么一种情况：<ul><li>线程1第一次进入了synchronized代码，获取到了锁，判断到instance为null，然后就去创建实例</li><li>线程2此时已经进行了第一次判断为空，然后等待线程1释放锁。</li><li>如果不加判断，线程1创建完后释放锁，线程2进入同步代码块，此时没有了第二重为空判断，就会直接创建实例，此时就重复创建了实例，破坏了单例</li></ul></li></ul></blockquote><h4 id="懒汉式之静态内部类"><a href="#懒汉式之静态内部类" class="headerlink" title="懒汉式之静态内部类"></a>懒汉式之静态内部类</h4><p>通过静态内部类来创建单例，对外不可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：属于懒汉式还是饿汉式</p><ul><li>懒汉式，因为这是个静态内部类，类加载本身就是懒惰的，在没有用到这个类的时候，是不会进行类加载的，因此没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul><p>问题2：在创建时是否有并发问题</p><ul><li>没有并发问题，仍然是单例的。因为类加载是懒惰的，没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul></blockquote><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>静态代理：</strong></p><ul><li>静态代理就是代理对象和被代理对象实现相同的接口，然后代理对象关联一个被代理对象，然后代理对象的方法中就除了可以调用被代理对象的方法以外，还可以完成对方法的增强。之所以叫静态代理就是因为在<strong>编译期就已经决定好了代理对象的字节码</strong>，将被代理对象的字节码加入到代理对象中</li></ul><p><strong>动态代理：</strong></p><ul><li><strong>JDK动态代理</strong><ul><li>JDK动态代理也是基于接口的方式实现的，因为静态代理的缺陷很明显，要是我还有别的对象要代理，这样我还需要很多个代理对象去完成，极其不易扩展，那动态代理就是说通过反射机制，在运行期间动态的去完成对目标对象的一个代理。我们在代理类中关联一个Object对象，然后通过Proxy动态的在内存中拿着目标对象的信息去newInstance。最终它会生成一个继承了Proxy实现了目标对象的接口的子类，这也是为什么JDK动态代理需要基于接口去实现的原因，因为Java不支持多继承</li></ul></li><li><strong>CGLIB动态代理</strong><ul><li>CGLIB动态代理是为了解决JDK动态代理的缺陷，要是一个类确实不用实现其他的接口，这个时候就需要用CGLIB动态代理了，CGLIB底层是采用的字节码处理框架ASM去动态的对目标对象字节码完成一个转换，最终生成一个子类完成代理</li></ul></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><strong>简单工厂模式：</strong></p><ul><li><strong>简单工厂模式又叫静态工厂方法模式</strong>，在简单工厂模式中，可以<strong>根据参数的不同返回不同的实例类型</strong>。简单工厂模式<strong>专门定义一个类来负责创建其他类的实例</strong>，被创建的实例通常都有共同的父类。DateTime里面就是根据timeStyle来创建不同的对象实例的</li></ul><p><strong>工厂方法模式：</strong></p><ul><li><p><strong>定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法模式使一个类的实例化延迟到其子类。</strong></p></li><li><p>提供一个工厂的接口，具体的工厂由具体的子类去完成，像Collection接口就是一个工厂，Iterator迭代器就是产品，不同的工厂ArrayList产生自己的迭代器Itr产品、LinkedList产生自己的迭代器Itr产品</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306182342146.png" alt="image-20220306182342146"></p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306182404398.png" alt="image-20220306182404398"></p></li></ul><p><strong>抽象工厂模式：</strong></p><ul><li><p><strong>抽象工厂模式就是在工厂方法模式上的一个扩展</strong>，工厂方法模式是一个产品体系，抽象工厂模式则对应一个产品族，可以提供多个产品体系</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220306183258293.png" alt="image-20220306183258293"></p></li></ul><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p><strong>装饰器模式就是说装饰一个类，对其完成功能的扩展。他不同于继承的方式，继承是直接继承然后获得父类的方法，然后自己添加方法完成扩展，装饰器模式则是实现某个接口，同时又关联一个接口的对象，这样就可以利用动态，在运行时动态的决定装饰哪个对象，除了可以调用接口的方法以外，同时可以完成增强。</strong></p><p>装饰器模式就是可以扩展某个类的功能，他不同于继承的方式子类添加方法去完成方法扩展，他是通过关联一个<strong>顶层接口的对象</strong>，这样就可以利用多态，同时又实现接口，这样既能持有接口的方法，然后在还可以完成扩展</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式定义了一种一对多的对象间的依赖关系，让多个观察者对象同时监听某一个主体对象。当这个主体对象的状态发生变化的时候，就通知所有监听的观察者对象，从而做出对应的响应</p><p>在用 Java 实现文件监控系统的时候，采用WatchService类</p><p>在Commons-IO的一个工具类中，在实现其中的FileMonitor的时候，就使用到了观察者模式。</p><ol><li>首先，创建文件观察者，FileAlterationObserver，Observer里面维护了一个list，就是用来存对应的 listener 监听器的</li><li>然后，继承文件变动监听适配器 FileAlterationListenerAdaptor 自定义一个文件变动后对应的操作，里面重写对应的文件发生变动的方法，比如要把对应事件存到数据库</li><li>给创建的Observer注册对应的监听器，<code>observer.addListener(new FileListener());</code></li><li>最后，就拿着这个Observer去创建一个线程实现监控</li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同表示</strong></p><p>使用场景： </p><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式</li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.interview;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String sex=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=builder.name;</span><br><span class="line">        <span class="keyword">this</span>.num=builder.num;</span><br><span class="line">        <span class="keyword">this</span>.sex=builder.sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num=-<span class="number">1</span>;</span><br><span class="line">        String sex=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sex = sex;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Student <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, num=&quot;</span> + num +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Build</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student zs = <span class="keyword">new</span> Student.Builder().setName(<span class="string">&quot;张三&quot;</span>).setNum(<span class="number">123</span>).setSex(<span class="string">&quot;男&quot;</span>).build();</span><br><span class="line">        System.out.println(zs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><ul><li><p>进程</p><p>进程是一个在内存运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。比如在windows系统中，一个运行的xx.exe程序就是一个进程</p></li><li><p>线程</p><p>线程是进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据</p></li></ul><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p><strong>线程间通信</strong>无非就是要<strong>实现对共享资源的控制</strong></p><ol><li><strong>同步</strong>：采用synchronized关键字、对共享数据加锁等方式实现线程间的同步</li><li><strong>wait-notify等待唤醒机制</strong>：对共享数据进行同步，采用wait-notify来让某个线程等待，唤醒某个线程</li><li><strong>CAS</strong>：CASwhile循环，尝试操作共享数据</li></ol><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><p><strong>常见的进程通信方式：</strong></p><ol><li><strong>普通管道pipe</strong>：管道是一种<strong>半双工</strong>的通信方式，<strong>数据只能单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指<strong>父子进程关系</strong></li><li><strong>命名管道FIFO</strong>：去除了第二种限制,可以在许多并不相关的进程之间进行通讯</li><li><strong>信号量</strong>：它是一个<strong>计数器</strong>，<strong>记录资源能被多少个进程同时访问</strong>。用于控制多进程对临界资源的访问（同步)，并且是非负值。主要作为<strong>进程间</strong>以及<strong>同一进程的不同线程间</strong>的<strong>同步</strong>手段。比如<strong>操作系统中的P，V操作</strong>。临界资源：同一时刻，只能被一个进程访问的资源；临界区：访问临界资源的代码区；原子操作：任何情况下不能被打断的操作</li><li><strong>消息队列MessageQueue</strong>：消息队列是<strong>消息的链表</strong>，是存放<strong>在内核中</strong>并由<strong>消息队列标识符标识</strong>。因此是随内核持续的，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。消息队列<strong>克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区受限</strong>等特点。允许不同进程将格式化的数据流以消息队列形式发送给任意进程，对消息队列具有操作权限的进程都可以使用msgget完成对消息队列的操作控制，通过使用消息类型，进程可以按顺序读信息，或为消息安排优先级顺序</li><li><strong>共享存储SharedMemory</strong>：<strong>共享内存</strong>就是映射一段<strong>能被其他进程所访问的内存</strong>，这段<strong>共享内存由一个进程创建，但多个进程都可以访问</strong>。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li></ol><h3 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h3><ol><li><strong>根本区别</strong>：<strong>进程</strong>是操作系统<strong>资源分配</strong>的<strong>基本单位</strong>，<strong>线程</strong>是<strong>处理器任务调度和执行的基本单位</strong></li><li><strong>资源开销</strong>：每个<strong>进程</strong>都有<strong>独立的代码和数据空间</strong>（程序上下文），<strong>程序之间的切换会有较大的开销</strong>；<strong>线程</strong>可以看做轻量级的进程，同一类线程共享代码和数据空间，<strong>每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</strong></li><li>包含关系：一个进程可以包含多个线程，多个线程共同完成进程的任务。一个线程只属于一个进程</li><li>内存分配：同一个进程内的线程的资源是共享的，而进程之间的地址空间和资源是相互独立的</li><li>执行过程：每个<strong>独立的进程都有程序运行的入口</strong>、顺序执行序列和程序出口。但是<strong>线程不能独立执行</strong>，必须依赖于应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li></ol><h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3><p>当前线程任务获取到CPU时间片，当分配的CPU时间片用完或者说线程阻塞后，线程会保存当前状态以便下次再次切回这个任务时，能再次加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><h3 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h3><ul><li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li><li>守护(Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。<strong>一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</strong></li></ul><p><strong>注意事项：</strong> </p><ol><li>setDaemon(true)必须在start()方法前执行，否则会抛出 IllegalThreadStateException 异常 </li><li>在守护线程中产生的新线程也是守护线程</li><li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li><li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。<strong>finally语句块中的语句也不一定被执行</strong></li></ol><h3 id="windows和linux查看进程和线程"><a href="#windows和linux查看进程和线程" class="headerlink" title="windows和linux查看进程和线程"></a>windows和linux查看进程和线程</h3><ol><li>windows<ul><li>任务管理器查看进程和线程，杀死进程</li><li><code>tasklist</code> 查看进程</li><li><code>taskkill /F /PID 进程号</code> 杀死进程</li></ul></li><li>linux<ul><li><code>ps -fe </code>查看所有进程</li><li><code>ps -ft -p &lt;PID&gt;</code> 查看某个进程的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>pkill -9 &lt;PID&gt;</code> 杀死进程，-9代表一类操作，杀死进程</li><li><code>top</code> 查看进程信息</li><li><code>top -H -P &lt;PID&gt;</code> 查看某个进程PID的所有线程</li></ul></li><li>Java<ul><li><code>jps</code> 查看所有Java进程</li><li><code>jstack &lt;PID&gt;</code> 查看某个Java进程的所有线程状态</li><li><code>jconsole</code> 连接查看某个Java进程中线程的运行情况（Windows直接win+r 输入jconsole，图形界面）</li></ul></li></ol><h3 id="形成死锁的4个必要条件"><a href="#形成死锁的4个必要条件" class="headerlink" title="形成死锁的4个必要条件"></a>形成死锁的4个必要条件</h3><ol><li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能 被一个线程(进程)占用，直到被该线程(进程)释放</li><li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源</li><li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路 （类似于死循环），造成永久阻塞</li></ol><h3 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a><strong>线程池相关</strong></h3><h4 id="创建线程的4种方式"><a href="#创建线程的4种方式" class="headerlink" title="创建线程的4种方式"></a>创建线程的<strong>4种方式</strong></h4><ol><li><p>通过继承Thread创建线程</p><p>使用继承的好处就是在线程run()直接用this就可以代表当前线程了，也不用Thread.currentThread()方法</p><p>不好的地方就在于有很大的局限性，Java中不支持多继承，所以说继承了Thread就不能继承其他的类了。另外任务和代码没有分离，相当于多个线程执行一样的任务时需要多份任务代码</p></li><li><p>使用Runnable接口创建Thread</p><p>可以实现Runnable接口，重写里面的run方法，来编写任务代码。</p><p>使用Runnable创建的时候，相当于一个任务被分配给多个线程去执行了，多个线程获取到的是相同的资源。继承Thread创建线程相当于多个线程多个任务，每个线程都接收到相同的任务</p><p><strong>分析 Thread 的源码，查看与 Runnable 的关系</strong>，可以发现采用Runnable的方式最终new Thread的时候最终就是把实现Runnable作为Thread中的target成员，然后判断如果target不为null，就运行target的run()方法，也就是Runnable的run方法</p><ul><li>继承Thread方式: 是把线程和任务合并在了一起</li><li>实现Runnable方式: 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul></li><li><p>使用FutureTask与Thread结合</p><p>使用<strong>FutureTask可以用泛型指定线程的返回值类型</strong>（Runnable的run方法没有返回值），FutureTask实现了RunnableFuture，RunnableFuture继承了Runnable接口。</p><p>task.get()可以获得线程执行完毕后的返回值，如果还没执行完毕get()方法会阻塞起来等待线程执行完才返回结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread r1 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">r1.start();</span><br><span class="line"><span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池创建线程</p><p>好处：</p><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p></li></ol><ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？四种！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>ThreadPoolExecutor使用int的高3位来表现线程池的状态，低29位来表示线程数量</p><p><strong>RUNNING</strong>    111    接收新任务，同时处理任务队列中的任务</p><p><strong>SHUTDOWN</strong>    000    <strong>不接收</strong>新任务，但是<strong>处理</strong>任务队列中的任务</p><p><strong>STOP</strong>    001    <strong>中断正在执行的任务</strong>，同时<strong>抛弃</strong>阻塞队列中的任务</p><p><strong>TIDYING</strong>    010    任务执行完毕，<strong>活动线程为0</strong>，<strong>即将进入终结</strong>阶段</p><p><strong>TERMINATED</strong>    011    线程池进入<strong>终结</strong>阶段</p><h4 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h4><ol><li>提交任务给线程池</li><li>判断核心线程corePoolSize有没有用完</li><li>核心线程没用完，创建一个新的核心线程完成任务</li><li>核心线程使用完了，判断阻塞队列是否已满</li><li>阻塞队列不满，放入阻塞队列中，等待空闲线程执行</li><li>阻塞队列满了，判断最大线程数和核心线程数，也即是看有不有救急线程可用</li><li>有救急线程可用，救急线程执行任务</li><li>无救急线程可用，采用拒绝策略</li></ol><h4 id="如何实现线程复用"><a href="#如何实现线程复用" class="headerlink" title="如何实现线程复用"></a><strong>如何实现线程复用</strong></h4><p>实现线程复用，看源码主要是这样的：</p><p>有一个 <strong>worker</strong>，<strong>实现</strong>了 <strong>Runnable</strong>，所以这个 woker 就可以看做一个线程，它的 <strong>run()</strong> 方法，里面主要先<strong>循环</strong>去<strong>判断</strong>，当前要运行的<strong>初始任务是不是空</strong>（因为在创建 worker 的时候会同时传进一个 Runnable 任务 firstTask ），或者说 从<strong>阻塞队列中取出任务</strong> getTask() 方法如果<strong>不为null</strong>，就一直去<strong>执行任务</strong>。然而在 <strong>getTask()</strong> 方法中，里面一个<strong>死循环 for( ; ; )</strong> 主要去从阻塞队列 <strong>workQueue</strong> 中去 <strong>take</strong>（不带超时） 或者 <strong>poll</strong>（带超时）一个任务出来，会一直阻塞直到队列中有任务返回，然后return 到 runWoker() 方法的 while 循环里去执行，如果阻塞队列中为空，就进入。</p><p>因此，其实现 线程复用 的原理主要就是：while 循环一直去 阻塞队列中获取任务 getTask()，死循环<strong>直到</strong>阻塞队列中<strong>成功获取任务</strong> workQueue.take() ，成功获取就返回，到while 中去执行，进入下一次while 循环，又去 getTask()</p><h4 id="核心线程可以过期吗"><a href="#核心线程可以过期吗" class="headerlink" title="核心线程可以过期吗"></a><strong>核心线程</strong>可以过期吗</h4><p>可以过期，有一个allowCoreThreadTimeout()方法，会将救急线程的keepAliveTime设置为核心线程的过期时间</p><h4 id="有哪几种阻塞队列"><a href="#有哪几种阻塞队列" class="headerlink" title="有哪几种阻塞队列"></a>有哪几种阻塞队列</h4><ol><li><strong>LinkedBlockingQueue</strong><ul><li>这种阻塞队列基于链表实现的，构造的时候有一个dummy节点，用来占位，第一个入队就把节点放到dummy的next，然后出队，就把dummy节点换成本来该出队的节点，然后拿着要出队的节点的值返回，把下一个节点的item设为null，就成为新的dummy节点</li><li>它采用两把锁，一把putLock和一把takeLock，分别锁住头结点和尾节点，put和take这样锁住不同的对象，可以实现生产的时候同时消费</li><li>入队 先 加锁，加锁之后 判断队列满了没有，如果队列满了，就等待队列不满，调用notFull条件变量的 wait方法</li><li>队列不满的时候，就入队，入完队容量加1，然后再1看能不能再put一个，能就notFull条件的signal 唤醒，解锁</li></ul></li><li><strong>ArrayBlockingQueue</strong><ul><li>这种队列基于数组的实现，需要事先指定好队列的大小，因为数组需要指定大小，它采用的是一把锁，不能同时生产和消费</li><li><strong>性能比较</strong><ul><li>Linked支持有界，Array强制有界，毕竟是数组，创建需要有个大小限制</li><li>Linked是链表实现的，Array是数组</li><li>Linked是懒惰创建的，Array在初始化时就创建完所有的Node</li><li>Linked每次入队会生成一个新Node，而Array的Node是提前创建好的</li><li>Linked使用两把锁，一个锁住头，一个锁住尾，Array只使用了一把锁</li></ul></li></ul></li><li><strong>SynchronousQueue</strong><ul><li>这个阻塞队列是一种特殊的队列，没有容量，没有线程取的话是放不进去的，就类似于一手交钱一手交货</li></ul></li><li>DelayedWorkQueue</li><li><strong>ConcurrentLinkedQueue</strong><ul><li>和LinkedBlockingQueue非常相似</li><li>采用两把锁，同一时刻，可以允许两个线程同时（一个生产者一个消费者）执行</li><li>dummy节点的引入让两把锁锁住的不是同一个对象，避免竞争</li><li>只是ConcurrentLinkedQueue采用CAS来实现锁</li></ul></li></ol><h4 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h4><ol><li><strong>核心线程数</strong></li><li><strong>最大线程数</strong></li><li>救急线程的<strong>存活时间</strong></li><li>时间<strong>单位</strong></li><li><strong>阻塞队列</strong></li><li><strong>线程工厂</strong></li><li><strong>拒绝策略</strong><ul><li>Abort 直接抛弃，同时抛出异常</li><li>Discard 直接抛弃，不抛出异常</li><li>DiscardOldest 抛弃，最老的任务，即队列头</li><li>CallersRuns 调用者去处理</li></ul></li></ol><h4 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂 ThreadFactory"></a>线程工厂 ThreadFactory</h4><p>线程工厂就是用来创建线程的，像 <strong>SimpleThreadFactory</strong> 就是一个简单的new Thread，在 线程池中 如果没有指定线程工厂使用的是默认的 DefaultThreadFactory，里面创建非守护线程，控制了一下优先级设置，统计了线程个数等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="线程池刚初始化有线程吗，可以指定初始化有线程吗"><a href="#线程池刚初始化有线程吗，可以指定初始化有线程吗" class="headerlink" title="线程池刚初始化有线程吗，可以指定初始化有线程吗"></a>线程池刚初始化有线程吗，可以指定初始化有线程吗</h4><h3 id="线程相关（run、start、Callable、Future）"><a href="#线程相关（run、start、Callable、Future）" class="headerlink" title="线程相关（run、start、Callable、Future）"></a>线程相关（run、start、Callable、Future）</h3><h4 id="调用sleep-0-方法有什么作用"><a href="#调用sleep-0-方法有什么作用" class="headerlink" title="调用sleep(0)方法有什么作用"></a>调用sleep(0)方法有什么作用</h4><p>sleep(0)，睡眠0s可以触发一次CPU的竞争，sleep让当前线程放弃CPU使用权，睡眠一定时间，这样可以在服务压力大的时候，某个线程一直占用某个资源，占用时间过长了，可以一定程度上避免饥饿现象</p><h4 id="线程的run-和start-有什么区别"><a href="#线程的run-和start-有什么区别" class="headerlink" title="线程的run()和start()有什么区别"></a>线程的run()和start()有什么区别</h4><p>每个线程最终都是要调用其中的run()放来执行任务的。调用Thread类的start()方法来启动一个线程，调用了start()方法后，线程进入就绪状态，此刻还没有执行，等待CPU分配时间片然后继续执行。如果直接调用run()方法不调用start方法，这跟调用普通方法差不多，并没有开启多线程的运行，而只是普普通通的执行了一个run()方法而已</p><p>start()方法只能调用一次，源码会判断线程状态是否是0即新建状态，不是则抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br></pre></td></tr></table></figure><h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>new一个Thread，进入新建状态。调用start会启动一个线程进入就绪状态，等待分配时间片，分配到时间片后就可以开始运行了。start()之后会执行到run()方法完成任务。如果直接调用run()方法跟调用一个普通方法没啥区别，就是一个普通方法执行了而已，并没有开启多线程</p><h4 id="什么是-Callable-和-Future"><a href="#什么是-Callable-和-Future" class="headerlink" title="什么是 Callable 和 Future?"></a>什么是 Callable 和 Future?</h4><p>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 <strong>Runnable</strong> <strong>不会返回结果</strong>，并且<strong>无法抛出返回结果的异常</strong>，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值</p><p>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 <strong>Callable用于产生结果，Future 用于获取结果。</strong></p><h4 id="什么是-FutureTask"><a href="#什么是-FutureTask" class="headerlink" title="什么是 FutureTask"></a>什么是 FutureTask</h4><p>FutureTask 表示一个异步运算的任务。<strong>FutureTask 里面可以传入一个 Callable 的具体实现类</strong>，可以对这个异步运算的任务的结果进行<strong>等待获取</strong>、<strong>判断是否已经完成</strong>、<strong>取消任务</strong>等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所 以 FutureTask 也可以放入线程池中</p><h4 id="什么叫线程安全？servlet-是线程安全吗"><a href="#什么叫线程安全？servlet-是线程安全吗" class="headerlink" title="什么叫线程安全？servlet 是线程安全吗?"></a>什么叫线程安全？servlet 是线程安全吗?</h4><p>指某个方法在多线程环境中被调用时，能够正确地处 理多个线程之间的共享变量，使程序功能正确完成。 Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一 个方法，是不能保证共享变量的线程安全性的。</p><p>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</p><h4 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h4><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程 会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低 优先级，10 代表最高优先级。 Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><h4 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h4><p>总的来说就是哪里new的，就是哪里调用的</p><p>假设 Thread2 中 new 了 Thread1，main 函数中 new 了 Thread2，那么： </p><p>（1）Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方 法是Thread2 自己调用的 （2）Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法 是Thread1 自己调用的</p><h4 id="Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取-线程堆栈？"><a href="#Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取-线程堆栈？" class="headerlink" title="Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取 线程堆栈？"></a>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取 线程堆栈？</h4><p>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump 文件中。</p><p> 在 <strong>Linux</strong> 下，你可以通过命令 <strong>kill -3 PID</strong> （Java 进程的进程 ID）来获取 Java应用的 dump 文件。 </p><p>在 Windows 下，你可以按下 <strong>Ctrl + Break</strong> 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件 中，具体位置依赖应用的配置。</p><h4 id="一个线程运行时发生异常会怎样"><a href="#一个线程运行时发生异常会怎样" class="headerlink" title="一个线程运行时发生异常会怎样"></a>一个线程运行时发生异常会怎样</h4><p>如果异常<strong>没有被捕获该线程将会停止执行</strong></p><p> Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理</p><h4 id="Java-线程数过多会造成什么异常？"><a href="#Java-线程数过多会造成什么异常？" class="headerlink" title="Java 线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h4><ul><li>线程的生命周期开销非常高 </li><li>消耗过多的 CPU</li><li>降低稳定性JVM</li></ul><h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><p><strong>synchronized底层原理</strong>其实就是 每个<strong>Java对象</strong>，都有一个<strong>对象头</strong>，对象头包含mark word和Klass word，<strong>每个对象</strong>都可以<strong>关联一个Monitor</strong>，当进入synchronized同步代码块的时候，该锁对象就把它的<strong>markword值设置为</strong>关联的对应<strong>monitor的地址值</strong>，然后把monitor的<strong>owner线程</strong>设为当前线程。后面有别的线程进入synchronized，会发现obj已经有一个关联的monitor，其owner线程为之前的线程，他就会进入monitor对象的EntryList中等待</p><p>它加锁依赖于底层操作系统的指令，会造成用户态和内核态之间的切换，比较耗性能</p><p>在JDK 6的时候采用了偏向锁和轻量级锁进行优化</p><p><strong>轻量级锁用于优化重量级锁</strong>，轻量级锁<strong>主要用于</strong>有一个线程要加锁，别的线程也需要，但是他们的加锁时间是错开的，就是说<strong>没有竞争的情况</strong>，会在线程栈帧中创建一个<strong>lock record 锁记录</strong>，然后把锁对象的<strong>markword</strong> 和 <strong>锁记录地址</strong>进行一个<strong>CAS交换</strong>，交换成功就是加锁成功，这样markword存的是锁记录的地址，锁记录地址就是对象的markword。如果后面又有线程来<strong>CAS加锁</strong>，那么就是可能出现<strong>锁膨胀</strong>或者<strong>锁重入</strong>的情况，锁膨胀就是说发生了竞争，这个时候就要升级为重量级锁了</p><p><strong>偏向锁</strong>主要用于<strong>优化轻量级锁</strong>，主要场景是：没有竞争的时候，一个线程多次进入<strong>synchronized需要重入加锁</strong>的时候，<strong>将进入临界区的线程的ID, 直接设置给锁对象的Mark word,</strong> 下次该线程<strong>又获取锁</strong>, 发现<strong>线程ID是自己</strong>, 就<strong>不需要CAS</strong>了</p><p><img src="/../../img/markdown_img/Java%E5%9F%BA%E7%A1%80.assets/image-20220416220641010.png" alt="image-20220416220641010"></p><p>synchronized最开始其实是重量级锁，在JDK6以后引入了轻量级锁和偏向锁的概念，它们只是jvm上的逻辑，避免了重量级锁频繁且不必须的在用户态和内核态之间的切换。</p><p>首先线程执行到synchronized同步代码块，会在栈帧中创建一个锁记录Lock Record，锁记录主要有两部分，一部分存放锁记录地址+00两位标识，还有一部分存储锁对象的地址。尝试加锁，首先会去将锁记录和锁对象的Mark Word进行CAS交换，第一次因为没人加锁，所以交换成功，然后锁记录里就存放着锁对象的markword和锁对象的地址。而锁对象的markword现在存放的是锁记录的地址。</p><p>如果后续当前加锁的线程还没释放锁，又准备进行一次加锁，即发生锁重入，线程首先也会创建锁记录，然后尝试一次CAS，这次加锁失败了，因为发现锁对象markword中记录的指向就是自己线程中的锁记录，所以就会把新建的锁记录地址设置为null，然后object reference指向锁对象。退出同步代码块的时候，发现锁记录的锁记录地址是null，说明有锁重入，计数器减去1，到最后发现不为null，就CAS交换回锁对象的markword。</p><p>锁膨胀：在Thread0线程还没释放锁的时候，如果又有一个线程Thread1执行到同步代码块，准备加锁，发现锁对象的markword已经是00了，说明已经是轻量级锁了，这个时候会进入锁膨胀的过程，生成一个monitor对象，将锁对象关联到monitor对象，然后将锁对象的markword重新指向monitor的地址，然后把monitor的Owner设置为Thread0，当前加锁失败的线程就进入Monitor的EntryList等待</p><p>Thread0线程执行完后，发现锁对象的markword已经是01了，已经是重量级锁，说明发生了锁膨胀，这样就进入重量级锁的解锁流程，根据锁对象的markword找到对应的monitor，然后设置Owner线程为null，唤醒EntryList中的Thread1</p><h3 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park Unpark"></a>Park Unpark</h3><p>park和unpark原理：每个线程都有一个parker对象，这个对象主要有3个值_counter、 _mutex、 _cond</p><p>park的时候先检查_counter的值是否为0，如果为0，就进入 _cond等待队列阻塞，如果为1，就继续运行，设置 _counter为0</p><p>unpark直接设置_counter值为1，唤醒 _cond中的线程，线程恢复运行设置counter为0</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile <strong>原子性、可见性、有序性的概念</strong> —–&gt; <strong>读写屏障</strong>保证可见性、有序性<strong>原理</strong> —–&gt;<strong>CAS 保证原子性</strong>，<strong>volatile保证 可见性、有序性</strong> <strong>乐观锁实现无锁并发</strong> ——&gt; CAS的<strong>底层lock指令</strong> —–&gt; API 层面的<strong>compareAndSwap方法</strong> —–&gt; <strong>缺点一直重试</strong>，竞争激烈效率反而降低，并且会有<strong>ABA问题</strong> —–&gt; <strong>优点</strong> 没有synchronized<strong>悲观的思想</strong>，<strong>没有线程上下文的切换</strong></p><p>volatile 关键字主要用于来保证多线程共享数据的安全性问题，主要保证其有序性和可见性。三个特性：原子性指程序代码的执行不会受到线程上下文切换的影响，这个主要采用加锁来保证。可见性指程序代码的执行不会受到缓存的影响，JIT即时编译器对于程序代码的优化，保证去主存中读取数据，更新数据到主存中。有序性指程序代码的执行不会受到CPU优化的影响，比如指令重排。因为CPU的指令是类似一条流水线，一个周期，多个指令。</p><p>volatile通过内存屏障来保证有序性和可见性。</p><p>保证可见性：就是在读数据的加一个读屏障，保证读取共享的数据的时候都去主存中读取，然后再加一个写屏障，保证更新数据都把数据更新到主存中</p><p>保证有序性：也是通过读写屏障，读屏障保证读屏障之后的代码不会重排到前面。写屏障保证写屏障之前的代码不会重排到写屏障后面。</p><p>结合CAS+volatile关键字就可以实现无锁并发。volatile保证有序性、可见性。CAS保证原子性</p><p>CAS底层采用一个lock指令，在多线程下能保证 比较-交换 操作的原子性。它会把CPU总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程不会被多线程调度机制所打断</p><p>在Java API层面就对应一个CompareAndSwap()方法，它需要一个期望的值，以及要修改的值，先拿着期望的值去主存中的值作比较，如果相等就去修改值，要是不相等，就代表CAS失败，这个时候就加一个while循环，让其一直尝试CAS去比较并交换。</p><p>可以发现它没有阻塞，而是一直去尝试更新值，更新不成功就再CAS一次。这种也会带来一定的开销，因为在竞争激烈的时候它可能一直CAS失败，效率反而会降低。不过它避免了synchronized的悲观锁的思想，避免了线程上下文的切换造成的开销。</p><p>此外CAS 还有可能造成ABA问题</p><h3 id="原子包装类"><a href="#原子包装类" class="headerlink" title="原子包装类"></a>原子包装类</h3><p><strong>java.util.concurrent.atomic</strong>提供的是一些原子类，都是基于CAS + volatile 来实现的</p><p><strong>原子整数类：</strong></p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p><strong>原子引用类：</strong>原子引用保证引用类型的共享变量是线程安全的，刚才的是规定了数据类型比如为Integer</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicMarkableReference</code>：原子更新带有<strong>标记</strong>的引用类型。该类并不关心中途修改了多少次，只关心有没有修改过，所以只需要用一个 boolean 标记与引用关联起来，可以解决ABA 问题</li><li><code>AtomicStampedReference</code> ：原子更新带有<strong>版本号</strong>的引用类型。用版本号一般是整型来标识是否被修改过，用来解决 ABA 问题</li></ul><p><strong>原子数组类：</strong>原子数组用来保证数组内的元素的线程安全，使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><h3 id="AQS、ReentrantLock-条件变量-使用、ReentrantLock-原理"><a href="#AQS、ReentrantLock-条件变量-使用、ReentrantLock-原理" class="headerlink" title="AQS、ReentrantLock 条件变量 使用、ReentrantLock 原理"></a>AQS、ReentrantLock 条件变量 使用、ReentrantLock 原理</h3><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p><strong>AQS</strong>是<strong>抽象的队列同步器</strong>，是<strong>JDK1.5</strong>提供的一套<strong>实现阻塞锁</strong>的并且<strong>依赖于FIFO队列 CLH 队列 的同步器</strong>，<strong>AQS定义</strong>了一套<strong>多线程访问共享资源的方法</strong>，<strong>提供</strong>了一个<strong>等待队列</strong>，<strong>类似于</strong>Monitor中的<strong>EntryList</strong>。里面<strong>可以</strong>去<strong>获得锁</strong>，<strong>加锁</strong>，<strong>释放锁</strong>等一些<strong>操作</strong>，但是有的方法比如 <code>tryAcquire()</code> 是由其子类去实现的。AQS 主要还是起到一个模板的作用。像 通常都 创建一个 Sync 然后 继承 AQS，同时里面去实现一些自己的方法，然后 Sync 又对应 NonfairSync 和 FairSync，里面去实现其 自己的 tryAcquire() 方法。使用了 <strong>模板方法设计模式</strong></p><p>它<strong>用state属性</strong>来<strong>表示资源的状态</strong>，子类需要定义如何<strong>维护这个状态</strong>，<strong>控制</strong>如何<strong>获取锁和释放锁</strong>，比如<strong>state为0</strong>就是<strong>没有线程持有锁</strong>，<strong>把state改为1就是有线程持有锁</strong>，采用<strong>CAS来更新state</strong>的值</p><p><strong>AQS锁</strong>分为<strong>独占锁</strong>和<strong>共享锁</strong>，<strong>独占锁</strong>的实现主要有<strong>ReentrantLock</strong>，<strong>共享锁</strong>的实现主要有<strong>CountDownLatch</strong>、<strong>ReentrantReadWriteLock中的读锁</strong>。</p><h3 id="ReentrantLock-加锁"><a href="#ReentrantLock-加锁" class="headerlink" title="ReentrantLock 加锁"></a>ReentrantLock 加锁</h3><p>ReentrantLock 默认是非公平锁实现，构造方法就是构造一个非公平同步器，加锁就调用同步器的lock()方法。lock()方法先用CAS尝试将state的值改为1，如果修改成功，就设置独占锁线程为当前线程。假设第一个竞争出现，已经有Thread0加锁成功，那么当前线程Thread1cas失败，就<strong>加锁失败</strong>。进入acquire()方法，会<strong>再次尝试去获取一次锁，调用tryAquire()方法</strong>，如果仍然获取失败，就尝试加入到等待队列里去，加入返回true就调用selfInterrupt把该线程打断。</p><p>尝试加入等待队列中调用acquireQueued方法，等待队列是一个Node双向链表队列，首先会判断没获得锁的情况下，是否下一个就是自己，如果是就<strong>再一次尝试获取锁，调用tryAcquire()尝试加锁</strong>，这次成功了就把自己设置为Head节点。这次加锁失败，那么就应该<strong>在加锁失败后park住shouldParkAfterFailedAcquire</strong>这个方法会将前驱节点即head的waitStatus值改为-1，-1表示前面线程有责任唤醒后面的线程。最后返回false，结束判断后又进入for循环去尝试获取一次锁，假设又失败，那么又进入shouldParkAfterFailedAcquire方法，因为前面已经修改waitStatus值为-1，这次肯定设置失败，返回true，返回true后就进入parkAndCheckInterrupt把当前线程park住</p><h3 id="ReentrantLock-释放锁"><a href="#ReentrantLock-释放锁" class="headerlink" title="ReentrantLock 释放锁"></a>ReentrantLock 释放锁</h3><p>ReentrantLock 释放锁 release 方法，首先进入 tryRelease 方法，把 state 的值减去1，如果 state 的值为0，则将独占锁的Owner线程设置为null。如果全部释放了，就去 unparkSuccessor 唤醒队列中等待线程</p><h3 id="ReentrantLock-可打断与不可打断"><a href="#ReentrantLock-可打断与不可打断" class="headerlink" title="ReentrantLock 可打断与不可打断"></a>ReentrantLock 可打断与不可打断</h3><p>synchronized 的打断指的是获取到了锁以后，可以进行打断，打断正在运行的线程或者说打断在sleep，wait，join的线程</p><p>ReentrantLock 的打断指的是没获得到锁，被park阻塞住以后，可以打断它的阻塞</p><ol><li><strong>不可打断</strong><ul><li>ReentrantLock的可打断指的是在线程没获取到锁，去阻塞队列里等待的时候，是可以打断阻塞的</li><li>其实现原理：在线程正常尝试获取锁，获取失败后，进入parkAndCheckInterrupt方法park住的时候，方法的返回值是<code>return Thread.interrupted();</code>。这个方法会返回线程的打断标记，并且清除打断标记，也就是说线程在park被打断后，会返回true，然后打断标记重新置为false；从这个方法里面出来后，就把方法里的局部变量interrupted设置为true，然后下一次循环，获取到锁，回到acquire()方法，再进行一次自我打断selfInterrupt()，重新打断一次，如果是正常运行状态不是sleep中就不会抛打断异常</li></ul></li><li><strong>可打断</strong><ul><li>可打断是因为在park住后被唤醒了，返回线程是不是被打断，同时清除打断标记，如果要是被打断过了，返回为true，那就进入if代码块内部，抛出异常，否则返回false，直接进入下一次循环</li></ul></li></ol><h3 id="ReentrantLock-可重入"><a href="#ReentrantLock-可重入" class="headerlink" title="ReentrantLock 可重入"></a>ReentrantLock 可重入</h3><p>ReentrantLock 可重入主要基于它的 state 值，它tryAcquire方法会去判断要加锁的线程是不是当前线程，如果是，就把state的值+1，释放锁的时候，会一直把state的值减到0</p><h3 id="ReentrantLock-公平与非公平锁"><a href="#ReentrantLock-公平与非公平锁" class="headerlink" title="ReentrantLock 公平与非公平锁"></a>ReentrantLock 公平与非公平锁</h3><p>ReentrantLock 下面有不同的同步器实现，FairSycn或者nonFairSycn，</p><p>公平锁与非公平锁的实现区别主要在tryAcquire方法里，在使用CAS state的值之前，会先去判断队列里面是否还有前驱节点，也就是说还有不有线程关联的节点在排队，如果有，直接就返回false了。否则才去尝试 CAS</p><h3 id="ReentrantLock-条件变量"><a href="#ReentrantLock-条件变量" class="headerlink" title="ReentrantLock 条件变量"></a>ReentrantLock 条件变量</h3><p>AQS 中有个ConditionObject是实现了Condition的公共内部类，每个条件变量对对应着一个ConditionObject，每个ConditionObject 维护了一个等待队列</p><p><strong>await</strong>：</p><ul><li>线程持有锁的情况下，在调用条件变量的 await 方法时，首先将当前线程关联一个在ConditionObject中的一个节点，加入等待队列的尾部，然后 fullyRelease 释放所有的锁，最后再唤醒 AQS 队列中的下一个节点</li></ul><p><strong>signal</strong>：</p><ul><li>先判断是否持有独占锁，只有持有锁，才能去唤醒条件变量中的线程；然后每次取条件变量队列中的第一个 node ，然后就把这个节点断开，把这个节点加入到 ReentrantLock 的等待队列中去，把上一个节点的 waitStatus 值设置为-1</li></ul><h3 id="多线程顺序打印"><a href="#多线程顺序打印" class="headerlink" title="多线程顺序打印"></a>多线程顺序打印</h3><h3 id="多线程交替输出"><a href="#多线程交替输出" class="headerlink" title="多线程交替输出"></a>多线程交替输出</h3><h3 id="Semaphore、CountDownLatch、CycleBarrier"><a href="#Semaphore、CountDownLatch、CycleBarrier" class="headerlink" title="Semaphore、CountDownLatch、CycleBarrier"></a>Semaphore、CountDownLatch、CycleBarrier</h3><p><strong>Semaphore</strong> 信号量，可以用来控制同一时间有多少个线程能够执行，构造方法传入允许的 permits 最大的限制数。首先获取共享锁，将state-1看state是否小于0，如果是小于，那么就放入队列中等待，如果不是小于0，就尝试CAS把state的值减去1，CAS成功就成功返回。释放了一个线程后归还一个信号量，那么下一个线程才能执行。</p><p><strong>CountDownLatch</strong> 倒计时锁，维护一个计数器，当计数器的值不为0时，调用 await 方法就可以进行阻塞，每次使用就 countDown 计数减1，当计数器为0，所有阻塞的线程从 await 中返回执行</p><p>利用这个特性我们可以用来合并多个线程最终的结果，或者以此来模拟并发请求调用等等，如下并发请求代码</p><h3 id="CopyOnWriteArrayList原理"><a href="#CopyOnWriteArrayList原理" class="headerlink" title="CopyOnWriteArrayList原理"></a>CopyOnWriteArrayList原理</h3><p>CopyOnWriteArrayList写时复制list，是一个<strong>线程安全的list</strong>，底层通过<strong>复制数组</strong>的方式来实现。当我们往<strong>容器添加元素</strong>时，不直接往容器中添加，而是先将当前容器进行复制，<strong>复制出一个新的容器</strong>，<strong>然后往新的容器添加元素</strong>，添加完元素之后，再将原容器引用指向新容器。</p><p><strong>比较适合 读多写少 的场景，因为本身这样不能保证数据的强一致性，可能读到旧数据；此外，如果频繁的写入的话，因为它会创建出一个新的数组，写多，创建的新的数组就多，很容易就触发GC</strong></p><p>这样做的好处就是可以对CopyOnWrite容器进行并发的读而不需要加锁，因为当前容器不会被修改。</p><p>缺点：</p><ul><li>写时复制的机制，进行写操作的时候，内存里会同时驻扎两个对象的内存，也就是会同时存在两个容器</li><li>CopyOnWriteArrayList不能保证数据的实时一致性，可能读到旧数据</li></ul><h3 id="什么是ConcurrentHashMap？"><a href="#什么是ConcurrentHashMap？" class="headerlink" title="什么是ConcurrentHashMap？"></a>什么是ConcurrentHashMap？</h3><p>ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现。涉及高并发如果要用map结构，那第一时间想到的就是它。相对于hashmap来说，ConcurrentHashMap就是线程安全的map，其中利用了锁分段的思想提高了并发度。</p><p>JDK 1.6版本关键要素：</p><ul><li>segment继承了ReentrantLock充当锁的角色，为每一个segment提 供了线程安全的保障； </li><li>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。 </li></ul><p>JDK1.8后，ConcurrentHashMap抛弃了原有的Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p><h3 id="SynchronizedMap和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap和 ConcurrentHashMap 有什么区别？</h3><p>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访问map。</p><p>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。 ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。</p><p>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中， 当iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时 new 新的数据从 而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【<strong>资源对象</strong>】的<strong>线程隔离</strong>，让<strong>每个线程各用各的</strong>【<strong>资源对象</strong>】，<strong>避免争用</strong>引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个<strong>线程内</strong>有一个 <strong>ThreadLocalMap</strong> 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li>初始容量 16，扩容因子 2/3，扩容容量翻倍</li><li>key 索引冲突后用开放寻址法解决冲突</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2022/05/17/JUC/ThreadLocal/"/>
      <url>/2022/05/17/JUC/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal 可以实现 <strong>线程间</strong> 的 <strong>资源隔离</strong>，让每个线程各用各的 资源对象，避免争用引发的线程安全问题</p><p>局部变量也是每个方法一个资源，但是局部变量的缺点就是 不能实现方法外的 其他方法对资源的调用。</p><p>所以 ThreadLocal 同时实现了**线程内 **的 <strong>资源共享</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+Utils.getConnection());</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+Utils.getConnection());</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+Utils.getConnection());</span><br><span class="line">            &#125;,<span class="string">&quot;t&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                Connection connection = Utils.getConnection();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+connection);</span><br><span class="line">            &#125;,<span class="string">&quot;t&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 从当前线程的 threadLocalMap 中获取</span></span><br><span class="line">            Connection conn = tl.get();</span><br><span class="line">            <span class="keyword">if</span> (conn==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建新的 connection 对象</span></span><br><span class="line">                conn = innerGetConnection();</span><br><span class="line">                <span class="comment">// 存入当前线程</span></span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">innerGetConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h2><p>其原理是，每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象。</p><p>下面是 <strong>Thread</strong> 类 里 带有的 <strong>ThreadLocalMap threadLocals 成员</strong>，由ThreadLocal 维护</p><p><img src="/../../img/markdown_img/ThreadLocal.assets/image-20220416093811433.png" alt="image-20220416093811433"></p><ol><li><p>调用 set 方法，先获取到 当前线程的 ThreadLocalMap ，当前线程的 ThreadLocalMap 还没被创建出来，就去<code>createMap</code>，同时<strong>设置 key value</strong>；如果 ThreadLocalMap 已经创建出来了，就以 ThreadLocal 作为 Key，资源对象 作为 value，放入当前线程的 ThreadLocalMap 集合中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>调用 get 方法，同样获取到 当前线程的 ThreadLocalMap，然后以 ThreadLocal 作为 Key，到当前线程的 ThreadLocalMap 中 查找关联的资源值value</p><p><strong>get方法与其他 map 不同的是，如果发现 get 的key  就不存在 ，它仍然会 设置 key 为 threadlocal，只不过 value 为null</strong></p></li><li><p>调用 remove 方法，获取到 当前线程的 ThreadLocalMap，以 ThreadLocal 作为 key，移除当前线程关联的资源值</p></li></ol><p>所以 起到 线程间隔离 作用的是 每个线程内的 ThreadLocalMap ，而 ThreadLocal 则是用来 关联资源对象的</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><ul><li>ThreadLocalMap 初始大小 16，扩容因子 2/3</li><li>key 的 hash 值 统一分配，每次获取 nextHashcode，桶下标 就和 tab 的 长度-1 &amp; 运算</li><li>扩容容量翻倍</li><li>key 索引冲突后采用 <strong>开放寻址法</strong> 解决冲突</li></ul><h2 id="弱引用-key"><a href="#弱引用-key" class="headerlink" title="弱引用 key"></a><strong>弱引用 key</strong></h2><p>ThreadLocalMap 中的 <strong>key</strong> 被设计为 <strong>弱引用（内存不足的时候就会回收）</strong>，原因如下：</p><ul><li><p>只要 别的地方的引用 没有引用到ThreadLocal了，那么 ThreadLocalMap 中 key 设计的为弱引用，所以垃圾回收的时候就可以直接进行回收。如果是强引用，key 引用了，ThreadLocal 是不会回收的</p></li><li><p>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时 释放其占用的内存</p></li></ul><p>只有其 Key 设置为了 弱引用，其 value 还是强引用，那么 其 value 的内存释放时机如下</p><h2 id="value-内存释放时机"><a href="#value-内存释放时机" class="headerlink" title="value 内存释放时机"></a><strong>value 内存释放时机</strong></h2><ol><li>获取 key 时 发现 null key<ul><li>只是 发现 key 为null，会把 对应的 value 清理掉，同时 把 key 设置为 threadLocal</li></ul></li><li>set key value 时，会使用启发式扫描，清除临近的 null key，启发次数与元素个数，是否发现 null key 有关</li><li>remove 时（推荐），因为一般使用 ThreadLocal 时都把它作为 静态变量，因此 GC 无法回收，所以一般都 手动 remove</li></ol><p>使用 ThreadLocal 的时候一般都把它作为 static final 变量，所以 是无法进行 GC回收的，因此 value 内存释放的时候前两种 发现 null key 进行回收是回收不了的</p><p>所以必须要手动 remove ，否则就会发生内存泄露</p><h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>ThreadLocalMap 的生命周期和 Thread 是一致的，因此 尽管 ThreadLocalMap 里的 key 是弱引用，理论上 作为 key 的 thread local 可以回收，但是 static final 的 ThreadLocal 强引用还是存在的，所以回收不了，其中 Entry 的 value 也就回收不了，因此，只能我们手动去 remove 掉 Entry对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    <span class="comment">// Reference 类中 clear，this.referent = null;</span></span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>使用 ThreadLocal 来数据库的Connection 对象，可以避免多次获取数据库连接对象</p><p>使用 ThreadLocal 来保存会话 Session 信息，可以避免 在把 session 对象 各处传递，就可以把 Session 对象放到 ThreadLocal 里面</p>]]></content>
      
      
      <categories>
          
          <category> JUC并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2022/05/17/JUC/ConcurrentHashMap/"/>
      <url>/2022/05/17/JUC/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK-8-ConcurrentHashMap"><a href="#JDK-8-ConcurrentHashMap" class="headerlink" title="JDK 8 ConcurrentHashMap"></a>JDK 8 ConcurrentHashMap</h2><h3 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReservationNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span></span></span><br></pre></td></tr></table></figure><h3 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h3><p>initialCapacity初始容量至少得有concurrencyLevel并发度的大小，如果小于，则赋值为并发度。</p><p>懒惰初始化，在<strong>构造方法中仅仅计算了table的大小</strong>，以后在第一次使用的时候才会真正创建</p><p><code>concurrencyLevel</code>并发度，可以理解为分段Segment的个数，这个初始化之后就不会改变了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">// （1+8/0.75) = 11</span></span><br><span class="line">        <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">//  tableSizeFor 是保证计算的大小是 2^n, 即 16,32,64 ...</span></span><br><span class="line">    <span class="comment">// 16</span></span><br><span class="line">        <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">     <span class="comment">// spread 方法能确保返回结果是正数</span></span><br><span class="line">     <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">     (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 如果头结点已经是要查找的 key</span></span><br><span class="line">         <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">         <span class="keyword">return</span> e.val;</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="comment">// hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找</span></span><br><span class="line">        <span class="comment">// 扩容中为forwarddingNode 为-1 treebin 为-2</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 正常遍历链表, 用 equals 比较</span></span><br><span class="line">     <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">     ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">     <span class="keyword">return</span> e.val;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put流程"><a href="#put流程" class="headerlink" title="put流程"></a>put流程</h3><p>put流程先获取得到hash值，然后看<strong>tab有没有创建</strong>了，因为是懒惰初始化，<strong>没有创建</strong>就走<strong>initTable</strong>流程，如果<strong>创建出来了就去判断头结点为null</strong>，就不用遍历直接<strong>采用CAS把头结点换成要put的节点</strong>，否则看<strong>头结点</strong>是不是<strong>MOVED</strong> 也就是<strong>forwardding Node</strong>，如果是就说明正在扩容，去**帮忙扩容helpTransfer()**。</p><p>最后就说明table已经创建，头结点也不为null，那么就<strong>synchronized加锁头结点</strong>，<strong>再次判断头结点</strong>是否被<strong>移动</strong>，然后如果是链表就去遍历链表，创建node或者覆盖node，如果是红黑树就走红黑树的流程，期间采用<strong>bitCount计数</strong>，<strong>判断链表的大小是否超过树化阈值</strong>，如果超过，走treefiyBin流程。</p><p>最后<strong>addCount</strong>，采用<strong>LongAdder</strong>的思想，使用<strong>CounterCells</strong>做<strong>累加计数</strong>，size+1；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认putIfAbsent false 即默认是覆盖值的 如果为true，不会覆盖值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 获得hash spread会综合高低位，具有更好的hash性</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 死循环扩容</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">// 看tab有没有创建，因为懒惰初始化</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 初始化table 使用了CAS去初始化</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">// 如果对应的头结点为null 不用遍历 就CAS把头结点换成要put的就ok</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 看hash值是不是MOVED(-1) 如果是说明当前节点处下面的正在被扩容，就帮忙扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明已经初始化 已经有头结点，没有在扩容</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 锁住链表的头结点</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">//再次判断头结点是否被移动</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">// 如果是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// binCount 计数 可以理解为链表的长度</span></span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">// 遍历链表</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="comment">// 看key是否重复</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="comment">// key不重复 new Node到链表尾</span></span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果是红黑树</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            <span class="comment">// 设置binCount为2</span></span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不等于0说明有冲突</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 有冲突 看binCount长度是不是大于树化阈值</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加size计数</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h3><p>初始化表，判断如果sizeCtl为-1，就说明有人正在创建tab，yield()让出CPU使用权，否则CAS设置sizeCtl的值，获得锁，创建table。创建完后sizeCtl就代表了下一次要扩容的阈值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是sizeCtl为-1 说明有人正在创建了 就yield() 让出CPU使用权</span></span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="comment">// CAS将sizeCtl设置为-1 （表示初始化table）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 获得锁，创建table，这时候其他线程会在while循环中yield</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        <span class="comment">// 现在 sc sizeCtl 代表下一次要扩容的阈值</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h3><h3 id="size计算"><a href="#size计算" class="headerlink" title="size计算"></a>size计算</h3><p>size计算实际发生在put和remove改变集合元素的操作之中</p><ul><li>没有竞争发生，向baseCount累加计数</li><li>有竞争发生，新建CounterCells，向其中的一个cell累加计数<ul><li>counterCells初始有两个cell</li><li>如果计数竞争比较激烈，会创建新的cell来累加计数</li></ul></li><li>因此，累加计数其实可能是有一定的错误的，尽管已经采用了CounterCells来做优化</li></ul><h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h3><p>首先**<code>if(nextTab=null)</code><strong>判断如果要搬迁的链表为空，就创建一个大小为<code>n&gt;&gt;1</code>右移1位也就是</strong>扩大两倍的新的tab**</p><p>**<code>else if((f=tabAt(tab,i))==null)</code>**表示如果整个链表都搬迁完了，那就把原来tab的节点换成forwardingNode</p><p><code>else if((fh=f.hash)==MOVED)</code>表示如果已经搬迁过了，因为会有帮忙扩容的流程，MOVED是forwarding node 的hash值 -1</p><p>否则就对链表头加锁，如果是链表就走链表的搬迁流程，如果是TreeBin就走树的流程</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319092911812.png" alt="image-20220319092911812"></p><h3 id="JDK-8-ConcurrentHashMap-1"><a href="#JDK-8-ConcurrentHashMap-1" class="headerlink" title="JDK 8 ConcurrentHashMap"></a>JDK 8 ConcurrentHashMap</h3><p>JDK 8 数组（Node）+（链表 Node | 红黑树 TreeNode）</p><ul><li><p><strong>初始化</strong>，使用<strong>CAS来保证并发安全</strong>，<strong>懒惰初始化table</strong>，判断tab的sizectl，当前有没有正在创建table，有就把当前线程yield，让出CPU使用权，循环yield直到tab被初始化完成，最后sizeCtl的值为下一次要扩容的值</p></li><li><p><strong>树化</strong>，当<strong>table.length &lt; 64** ，会先**尝试扩容**，**超过64**，并且链表的**长度 &gt;8</strong>，会将链表<strong>树化</strong>，树化过程会用<strong>synchronized锁住链表头</strong></p></li><li><p><strong>put</strong>，看table是否创建，懒惰创建table，再看链表是否创建，如果未创建就<strong>cas创建链表</strong>，看头结点是不是null，不是null看是不是forwarddingNode；如果已有链表，后续锁住链表头进行put操作，元素添加到链表的尾部</p></li><li><p><strong>get</strong>，<strong>无锁读操作</strong>，仅需要保证<strong>可见性</strong>，扩容过程中如果get操作拿到的是ForwardingNode它会让get操作去新的table中进行搜索</p></li><li><p><strong>扩容transfer</strong>，扩容时以链表为单位，对<strong>链表头进行synchronized加锁</strong>，但是这个时候其他竞争线程不是无事可做，它们会帮助其他链表进行扩容，扩容时平均只有1/6的节点会把复制到新table中</p><p>先看有不有其他线程在扩容，sizectl是不是&lt;0，小于0说明有，那就yield</p></li><li><p>size，元素个数保存在baseCount中，并发时的个数变动保存在CounterCell[]中，最后统计数量累加</p></li></ul><h2 id="JDK-7-ConcurrentHashMap"><a href="#JDK-7-ConcurrentHashMap" class="headerlink" title="JDK 7 ConcurrentHashMap"></a>JDK 7 ConcurrentHashMap</h2><p>它维护了一个Segment数组，每个Segment对应一把锁，继承了ReentrantLock</p><ul><li>优点：如果多个线程访问不同的Segment，实际上是没有冲突的，这与JDK 8类似</li><li>缺点：<strong>Segments数组默认大小为16</strong>，这个<strong>容量初始化指定后就不能改变</strong>了，并且<strong>不是懒惰初始化</strong>的</li></ul><h3 id="构造器分析-1"><a href="#构造器分析-1" class="headerlink" title="构造器分析"></a>构造器分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"> <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line"> concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"> <span class="comment">// ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小</span></span><br><span class="line">     <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">     ++sshift;</span><br><span class="line">     ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// segmentShift 默认是 32 - 4 = 28</span></span><br><span class="line"> <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// segmentMask 默认是 15 即 0000 0000 0000 1111</span></span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"> <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line"> ++c;</span><br><span class="line"> <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line"> <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line"> cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 创建 segments and segments[0]</span></span><br><span class="line"> Segment&lt;K,V&gt; s0 =</span><br><span class="line"> <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">  (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line"> Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[]) <span class="keyword">new</span> Segment[ssize];</span><br><span class="line"> UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line"> <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后构造出来Segments数组16个Segment默认，</p><p>可以发现ConcurrentHashMap没有实现懒惰初始化，空间占用不友好，其中<strong>this.segmentShift和this.segmentMask的作用是决定将key的hash结果匹配到哪个segment。</strong></p><h3 id="put流程-1"><a href="#put流程-1" class="headerlink" title="put流程"></a>put流程</h3><p>put流程先利用segmentShift和segmentMask计算出对应的segment下标j，然后拿着下标j去判断对应的segment是不是为null，如果是null，就创建该segment，然后用<code>ensureSegment(j)</code>方法利用CAS确保segment的安全性，因为其他线程也可能发现segment为null</p><p>最后走segment的put流程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> Segment&lt;K,V&gt; s;</span><br><span class="line"> <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> <span class="keyword">int</span> hash = hash(key);</span><br><span class="line"> <span class="comment">// 计算出 segment 下标</span></span><br><span class="line"> <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 获得 segment 对象, 判断是否为 null, 是则创建该 segment</span></span><br><span class="line"> <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject </span><br><span class="line"> (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 这时不能确定是否真的为 null, 因为其它线程也发现该 segment 为 null,</span></span><br><span class="line"> <span class="comment">// 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性</span></span><br><span class="line"> s = ensureSegment(j);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 进入 segment 的put 流程</span></span><br><span class="line"> <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>segment 继承了可重入锁（ReentrantLock），它的 put 方法为</p><p>首先尝试给segment加锁，加锁不成功进入scanAndLockForPut流程，里面会while循环尝试lock，并且尝试期间还顺便看该节点有没有被创建出来，没有就顺便创建出来</p><p>加锁成功就走遍历entry的流程，判断key存不存在，存在就覆盖，不存在就新增node到链表头</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 尝试加锁</span></span><br><span class="line"> HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line"> <span class="comment">// 如果不成功, 进入 scanAndLockForPut 流程</span></span><br><span class="line"> <span class="comment">// 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程</span></span><br><span class="line"> <span class="comment">// 在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来</span></span><br><span class="line"> scanAndLockForPut(key, hash, value);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 执行到这里 segment 已经被成功加锁, 可以安全执行</span></span><br><span class="line"> V oldValue;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line"> <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line"> HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line"> <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line"> <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 更新</span></span><br><span class="line"> K k;</span><br><span class="line"> <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line"> (e.hash == hash &amp;&amp; key.equals(k))) &#123; </span><br><span class="line"> oldValue = e.value;</span><br><span class="line"> <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line"> e.value = value;</span><br><span class="line"> ++modCount;</span><br><span class="line"> &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> e = e.next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 新增</span></span><br><span class="line"> <span class="comment">// 1) 之前等待锁时, node 已经被创建, next 指向链表头</span></span><br><span class="line"> <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line"> node.setNext(first);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="comment">// 2) 创建新 node</span></span><br><span class="line"> node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line"> <span class="keyword">int</span> c = count + <span class="number">1</span>; </span><br><span class="line"> <span class="comment">// 3) 扩容</span></span><br><span class="line"> <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">        <span class="comment">// rehash()</span></span><br><span class="line"> rehash(node);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="comment">// 将 node 作为链表头</span></span><br><span class="line"> setEntryAt(tab, index, node);</span><br><span class="line"> ++modCount;</span><br><span class="line"> count = c;</span><br><span class="line"> oldValue = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rehash流程"><a href="#rehash流程" class="headerlink" title="rehash流程"></a>rehash流程</h3><p>rehash发生在put流程的新增并且扩容中，才会进行rehash，做“搬迁”操作，</p><p>这个<strong>搬迁操作</strong>对于那些节点来说，<strong>有的节点</strong>是<strong>直接搬迁</strong>到新table，而<strong>有的节点</strong>则是<strong>创建出一个新的node</strong>放到新的table，这样原来的table上还存在原来的旧节点</p><ul><li>如果发现链表的下一个为null，也就是说<strong>链表中只有一个节点</strong>，那么就直接原节点搬迁到新的table中</li><li>否则，遍历一次链表，尽可能把rehash之后，idx不变的节点直接搬迁，也就是说rehash之后<strong>原来对应的table下标和新的table下标相同</strong>的<strong>直接搬迁</strong></li><li>剩下的节点就需要创建了</li></ul><p>完成扩容后，最后再把put进来的新node添加到对应table下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line"> HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line"> <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line"> <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line"> threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line"> HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line"> (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line"> <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line"> HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line"> <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"> HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line"> <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line"> <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="comment">// Single node on list</span></span><br><span class="line"> newTable[idx] = e;</span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line"> HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                    <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line"> <span class="comment">// 过一遍链表, 尽可能把 rehash 后 idx 不变的节点重用</span></span><br><span class="line"> <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line"> last != <span class="keyword">null</span>;last = last.next) &#123;</span><br><span class="line"> <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line"><span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">lastIdx = k;</span><br><span class="line"> lastRun = last;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> newTable[lastIdx] = lastRun;</span><br><span class="line"> <span class="comment">// 剩余节点需要新建</span></span><br><span class="line"> <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                     V v = p.value;</span><br><span class="line">                     <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                     <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                     HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                     newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 扩容完成, 才加入新的节点</span></span><br><span class="line"><span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line"> node.setNext(newTable[nodeIndex]);</span><br><span class="line"> newTable[nodeIndex] = node;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 替换为新的 HashEntry table</span></span><br><span class="line"> table = newTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="get流程-1"><a href="#get流程-1" class="headerlink" title="get流程"></a>get流程</h3><p>get的时候并没有加锁，采用<strong>UNSAFE的getObjectVolatile</strong>方法保证可见性，<strong>get先发生就从旧表中读取内容，get后发生就去新表中取内容</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">  HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">     <span class="keyword">int</span> h = hash(key);</span><br><span class="line">     <span class="comment">// u 为 segment 对象在数组中的偏移量</span></span><br><span class="line">     <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">     <span class="comment">// s 即为 segment</span></span><br><span class="line">     <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">     (tab = s.table) != <span class="keyword">null</span>) </span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">     e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">        &#123;</span><br><span class="line">     K k;</span><br><span class="line">     <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">     <span class="keyword">return</span> e.value;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size计算流程"><a href="#size计算流程" class="headerlink" title="size计算流程"></a>size计算流程</h3><ul><li><strong>计算元素个数前</strong>，<strong>先不加锁计算</strong>两次，如果<strong>前后两次结果</strong>一样，认为<strong>个数正确返回</strong></li><li>如果<strong>不一样</strong>，进行<strong>重试</strong>，重试次数<strong>超过3次</strong>，则<strong>将所有的Segment加锁</strong>，然后<strong>重新计数返回</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">     <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">     <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">     <span class="keyword">int</span> size;</span><br><span class="line">     <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">     <span class="keyword">long</span> sum; <span class="comment">// sum of modCounts</span></span><br><span class="line">     <span class="keyword">long</span> last = <span class="number">0L</span>; <span class="comment">// previous sum</span></span><br><span class="line">     <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">     <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK)</span><br><span class="line">            &#123;</span><br><span class="line">     <span class="comment">// 超过重试次数, 需要创建所有 segment 并加锁</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">     ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">     &#125;</span><br><span class="line">      sum = <span class="number">0L</span>;</span><br><span class="line">         size = <span class="number">0</span>;</span><br><span class="line">         overflow = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">         &#123;</span><br><span class="line">          Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">          <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">         sum += seg.modCount;</span><br><span class="line">         <span class="keyword">int</span> c = seg.count;</span><br><span class="line">         <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">         overflow = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">         <span class="keyword">if</span> (sum == last)</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">      last = sum;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 如果重试次数 &gt; RETRIES_BEFORE_LOCK说明加过锁，就释放锁</span></span><br><span class="line">     <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK)</span><br><span class="line">        &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">     segmentAt(segments, j).unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue原理"><a href="#LinkedBlockingQueue原理" class="headerlink" title="LinkedBlockingQueue原理"></a>LinkedBlockingQueue原理</h2><h3 id="基本的出队入队"><a href="#基本的出队入队" class="headerlink" title="基本的出队入队"></a>基本的出队入队</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * next 可能的三种情况：</span></span><br><span class="line"><span class="comment">        *  - next指向真正的后继节点</span></span><br><span class="line"><span class="comment">        *  - next指向自己，发生在出队时</span></span><br><span class="line"><span class="comment">        *  - next为null，表示没有后继节点，到最后了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><strong>初始化链表</strong>，<code>last = head = new Node&lt;E&gt;(null);</code>创建一个null节点，称为<strong>dummy节点</strong>，用来<strong>占位</strong>，item为null</li></ol><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319140544412.png" alt="image-20220319140544412"></p><ol start="2"><li><p>入队，<code>last = last.next = node;</code>，两个赋值操作，把last的next设置为node，last指向node</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319140824636.png" alt="image-20220319140824636"></p></li><li><p>第二个节点入队，<code>last = last.next = node;</code></p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319140908114.png" alt="image-20220319140908114"></p></li><li><p>出队</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert head.item == null;</span></span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        Node&lt;E&gt; first = h.next;</span><br><span class="line">        h.next = h; <span class="comment">// help GC</span></span><br><span class="line">        head = first;</span><br><span class="line">        E x = first.item;</span><br><span class="line">        first.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>h=head;</code> h 临时节点指向dummy</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141049604.png" alt="image-20220319141049604"></p><p><code>first=h.next;</code> first指向dummy的next</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141124537.png" alt="image-20220319141124537"></p><p><code>h.next=h;</code> 帮助回收，把next指向自己</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141305471.png" alt="image-20220319141305471"></p><p><code>head=first;</code> 把first节点作为头节点，后面会将这个节点直接设置为null，成为新的dummy节点</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141446363.png" alt="image-20220319141446363"></p><p><code>E x = first.item;</code> <code>first.item=null</code> <code>return x;</code></p><p>x 记录first节点的item，然后把这个节点做为dummy节点，设置item为null，返回x</p><p><img src="/../../img/markdown_img/ConcurrentHashMap.assets/image-20220319141549779.png" alt="image-20220319141549779"></p></li></ol><h3 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h3><p><strong>LinkedBlockingQueue</strong>主要在于使用了两把锁和dummy节点</p><ul><li>同一把锁，同一时刻，只允许一个线程（生产者或者消费者）执行</li><li>两把锁，同一时刻，可以运行两个线程（一个生产者和一个消费者）共同执行<ul><li>消费者和消费者线程仍然串行</li><li>生产者和生产者线程仍然串行</li></ul></li></ul><p><strong>线程安全分析</strong>：</p><ul><li>当节点了总数大于2时（包括dummy节点），<strong>putLock</strong>保证的是 <strong>last</strong> 节点的线程安全，<strong>takeLock</strong>保证的是 <strong>head</strong> 节点的线程安全，两把锁保证入队和出队之间没有竞争</li><li>当节点总数等于2时（包括dummy节点），<strong>putLock</strong>和<strong>takeLock</strong>仍然是两个锁对象，不会竞争</li><li>当节点总数等于1时（只有一个dummy节点），这时 <strong>take</strong> 线程会被 <strong>isEmpty</strong> 条件阻塞，有竞争，会阻塞</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>put操作：</p><ul><li>加锁，判断队列是不是满了，如果满了就去notFull条件变量中等待</li><li>队列没满的时候，就<code>enqueue()</code>入队</li><li>入完队后判断是否还能再入队，如果能就去notFull条件变量中<code>signal()</code></li><li>解锁，判断如果当前有元素就去notEmpty条件变量中唤醒一个消费者take</li></ul><p><code>put(E e) </code> 和 <code>offer(E e)</code>的区别就是put方法在队列已经满的时候会去条件变量中等待被唤醒，而offer方法如果队列已经满了则会直接返回false不会去条件变量中等待被唤醒</p><p><code>offer(E e,TimeUnit unit)</code>则会去条件变量中等待unit时间，没等到自动被唤醒再次去尝试入队</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// c 表示当前队列的大小，初始化为-1</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">// count 维护元素计数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 加的可打断锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列满了 等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 等待队列不满 nutFull</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等到了 入队</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 入完队后当前的队列容量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 如果当前容量还可以再put一个元素，那就去notFull条件变量中唤醒一个</span></span><br><span class="line">        <span class="comment">// 这里使用的signal()而不是signalAll() 为了避免把全部唤醒后大家去竞争</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中有一个元素，叫醒take</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里调用的是notEmpty.signal()而不是notEmpty.signalAll()</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h4><p>take()同put()的操作相对应</p><ul><li>请求消费，如果队列没有元素，去notEmpty条件变量中等待队列里有元素</li><li>队列中有元素，出队，判断出队后的队列的剩余元素是不是大于1，大于1说明还可以消费就去唤醒一个notEmpty条件变量中的线程</li><li>解锁，然后判断是不是可以去唤醒生产者notFull条件变量中的put线程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue和ArrayBlockingQueue"><a href="#LinkedBlockingQueue和ArrayBlockingQueue" class="headerlink" title="LinkedBlockingQueue和ArrayBlockingQueue"></a>LinkedBlockingQueue和ArrayBlockingQueue</h2><p>性能比较</p><ul><li>Linked支持有界，Array强制有界，毕竟是数组，创建需要有个大小限制</li><li>Linked是链表实现的，Array是数组</li><li>Linked是懒惰创建的，Array在初始化时就创建完所有的Node</li><li>Linked每次入队会生成一个新Node，而Array的Node是提前创建好的</li><li>Linked使用两把锁，一个锁住头，一个锁住尾，Array只使用了一把锁</li></ul><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue的设计和LinkedBlockingQueue非常相似</p><ul><li>两把锁，同一时刻，可以允许两个线程同时（一个生产者一个消费者）执行</li><li>dummy节点的引入让两把锁的锁住的不是同一个对象，避免竞争</li><li>只是ConcurrentLinkedQueue采用CAS来实现锁的</li></ul><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>写时复制ArrayList，可以保证写时复制，读写分离，但是会有弱一致性的问题</p><p>JDK 8 中采用的是ReentrantLock来实现加锁，JDK 11 采用synchronized来实现的</p><p>添加元素的流程就是：**ReentrantLock加锁后，去getArray()获取到数组，然后使用Array.copyof()复制出一个新的数组，然后在新数组里做修改操作，修改完成后再去setArray()**同步</p><p>读取的时候不加锁，实现并发的读，但是就有<strong>可能读到不一致的数据</strong>，所以具有<strong>弱一致性</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划算法</title>
      <link href="/2022/05/17/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/05/17/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="leetcode-300-最长递增子序列"><a href="#leetcode-300-最长递增子序列" class="headerlink" title="leetcode 300 最长递增子序列"></a>leetcode 300 最长递增子序列</h2><ul><li><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></li><li><p>示例 1：</p><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p><p>示例 2：</p><p>输入：nums = [0,1,0,3,2,3]<br>输出：4</p><p>示例 3：</p><p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li><p>首先，看着好像滑动窗口，但是仔细一想，滑动窗口，window 滑动的条件确定不了，也就是什么时候扩大窗口，什么时候缩小窗口</p></li><li><p>动态规划：</p><ul><li><p><strong>状态转移方程</strong></p><p>dp[i] 为 以 nums[i] 结尾的最长严格递增子序列的长度，要 根据dp[i-1] 去计算出 dp[i]。</p><p>可以联想到跟 nums[i] 有关。我们 <strong>要找到前面那些 结尾 比nums[i] 小的子序列，然后把 3 接到这些子序列的末尾，这样就构成了一个新的递增子序列，而且这个新的子序列长度+1。</strong></p><p><strong>找到 j∈(0,i) nums[j] 小于 nums[i] 的 j，然后 找到最大的一个 dp[j]，再把 nums[i] 拼接到后面</strong></p></li><li><p>dp[i] = Math.max(dp[i] , dp[j]+1)，其中 j∈(0,i) 且 nums[j] &lt; nums[i] </p></li><li><p>比如 下面的 nums[5]，找到 &lt; nums[5] 的，nums[1,4]，则其中最大的 dp[j]+1就是dp[i]；</p></li><li><p><strong>base case</strong></p><p>最小的dp 值 肯定至少为1，算上nums[i] 本身就是1，所以初始化dp数组最小值为1</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20220506154635172.png" alt="image-20220506154635172"></p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dp[i]  以 第 i 位结尾的最长递增子序列</span></span><br><span class="line"><span class="comment">     * 要 根据 dp[i-1] 计算出 dp[i]</span></span><br><span class="line"><span class="comment">     * 先找到 nums 中 比 nums[i] 小的数的下标 j</span></span><br><span class="line"><span class="comment">     * dp[i] = max(dp[j]) + 1</span></span><br><span class="line"><span class="comment">     * dp[i] = max(dp[i],dp[j] + 1 )</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 肯定最小值为1</span></span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 找到 结尾比nums[i]小的 然后 加1，</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]&gt;max)</span><br><span class="line">                max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最大的dp</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>该题还可以通过二分查找算法来解决。类似扑克牌游戏，从左到右，拿出一个数字，作为一个堆，下一个数字如果比上一个数字小，则可以直接放在这个堆上。如果没有堆可放，就创建一个新的堆来放。要保证下面的数字是大于上面的数字的</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20220506155240845.png" alt="image-20220506155240845"></p><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><ol start="5"><li>最长回文子串</li></ol><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p><strong>示例 1：</strong></p><ul><li>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案</li></ul><p><strong>示例 2：</strong></p><ul><li>输入：s = “cbbd”<br>输出：”bb”</li></ul><h3 id="动态规划解法："><a href="#动态规划解法：" class="headerlink" title="动态规划解法："></a><strong>动态规划解法：</strong></h3><p>回文串具有天然的动态规划性质</p><p>用一个 boolean 类型的二维数组作为 dp数组，dp[i] [j] 表示 s[i…j] 是回文串。那么状态转移方程就很明确，主要是如何去根据 状态转移方程 遍历这个dp数组</p><p><strong>状态转移</strong>：</p><ul><li>总的来说就是：dp[i] [j] = dp[i+1] [j-1] &amp;&amp; s[i] == s[j]</li><li>如果 s[i] == s[j] 的话，dp[i] [j] 是不是回文串由dp[i+1] [j-1]决定</li><li>同时，如果 i 到 j 长度只有 2 或者 3 的话 即 j-i+1 == 2 或者 j-i+1==3 —&gt; j-i&lt;3，那么又有  s[i] == s[j] ，则 s[i…j] 一定是回文串</li></ul><p><strong>遍历方式</strong>：</p><ul><li>dp[i] [j] 与 dp[i+1] [j-1] 有关，只能竖着遍历</li><li>如果 dp[i] [j] 为 true，那么就更新 记录 一下 起始位置 和 最大长度</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s = &quot;babad&quot;  ---&gt; bab  aba</span></span><br><span class="line">        <span class="comment">// dp[i][j] s[i...j] 是回文子串</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i+1][j-1] &amp;&amp; s[i] == s[j]</span></span><br><span class="line">        <span class="comment">// base case dp[i][i] = true</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最大长度为 1，单个字符</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp[i+1][j-1] 要一列一列的遍历 那就固定 j 从1开始</span></span><br><span class="line">        <span class="comment">// 一列一列的遍历 但是在对角线上方 所以 i&lt;j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i)!=s.charAt(j))</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当 s[i...j] 的长度等于 2 或者 3的时候</span></span><br><span class="line">                    <span class="comment">// s[i...j] 是否是回文串，由s[i] 是否等于 s[j] 决定</span></span><br><span class="line">                    <span class="comment">// 即 aba 或者 aa</span></span><br><span class="line">                    <span class="comment">// s[i...j] 之间的长度为 j-i+1 == 2 || j-i+1 == 3</span></span><br><span class="line">                    <span class="comment">// j-i==1 || j-i==2  ---&gt; j-i&lt;3</span></span><br><span class="line">                    <span class="keyword">if</span> (j-i &lt; <span class="number">3</span>)</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 是回文串  更新</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j-i+<span class="number">1</span>&gt;maxLen)</span><br><span class="line">                    &#123;</span><br><span class="line">                        maxLen = j-i+<span class="number">1</span>;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+maxLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="双指针解法："><a href="#双指针解法：" class="headerlink" title="双指针解法："></a><strong>双指针解法：</strong></h3><p>对于字符串 s ，从 0 到 n-1，将 每一个字符 s[i]（或者 每两个字符，因为回文串可以为奇数也可以为偶数） 作为中心，计算 以 s[i] （或者s[i]  s[i+1]） 为中心的最大的回文子串，最后 取 大的那个最为 res，这样，把字符串遍历一遍，也就 找到了 最长的回文子串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String s1 = palindrome(s, i, i);</span><br><span class="line">            String s2 = palindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">            res = res.length() &gt;s1.length() ? res:s1;</span><br><span class="line">            res = res.length() &gt;s2.length() ? res:s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找 s 中 以 i j 为中心的 回文串 的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">palindrome</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;s.length()</span><br><span class="line">        &amp;&amp; s.charAt(i) == s.charAt(j))</span><br><span class="line">        &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><ul><li><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p></li><li><p>示例 1：</p><p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>解决两个字符串的动态规划问题，常用两个指针 <strong>i，j 分别指向两个字符串的最后</strong>，然后一步步往前移动，缩小问题的规模。</p><p>这道题中两个字符串 s1，s2，我们用 i ，j 两个指针从后往前开始：</p><ol><li>如果 s1[i] == s2[j] ，相等 就不用变动，什么都不做，继续调用 dp 函数即可</li><li>s1[i] != s2[j]，不相等，就采用三种方式，增、删、替换的方式分别去执行，最后返回三个中的最小值即可</li><li><strong>base case</strong>：<ul><li>走到最后（假设将s1变为s2），那么 当 i 走完0的时候，j 还没走完，那么只能把 s2 剩下的全部插入到 s1 中，所以就返回 j+1；</li><li>当 j 走完 0 的时候，i 还没走完，那么只能把 s1 中剩下的删除所以就返回 i+1；</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditDistance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(word1,word2,word1.length()-<span class="number">1</span>,word2.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(String word1, String word2, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="comment">// i 走完了 j 还没走完，就只能把 j 剩余的插入到 s1</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// j 走完了 i 还没走完，就只能把s1 i 剩余的删除</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j))</span><br><span class="line">            <span class="keyword">return</span> dp(word1, word2, i-<span class="number">1</span>, j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(</span><br><span class="line">                dp(word1, word2, i, j - <span class="number">1</span>) + <span class="number">1</span>,<span class="comment">// 插入</span></span><br><span class="line">                dp(word1, word2, i - <span class="number">1</span>, j) + <span class="number">1</span>,<span class="comment">// 删除</span></span><br><span class="line">                dp(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span><span class="comment">// 替换</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a,Math.min(b,c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h3><p>上面是采用 递归的方法，对于这种递归，存在重叠子问题，因为dp(i,j-1) dp(i-1,j) 会出现调用同一个dp()函数，所以可以采用 <strong>备忘录</strong> 的形式，记录下来 dp[ i ] [ j ]</p><p>动态规划，自底向上的方式迭代求解</p><ol><li><p><strong>状态定义</strong></p><ul><li>dp[i] [j] 表示 s1[0…i-1]  s2[0…j-1] 的最小编辑距离</li></ul></li><li><p><strong>状态转移</strong></p><ul><li><p>s1[i] s2[j]相等的时候，什么都不用做，所以 dp[i] [j] = dp[i-1] [j-1]</p></li><li><p>否则，做增删替换三种操作，选择最小值，即：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = min(</span><br><span class="line">     <span class="comment">// 增 在s1 i的后面 插入一个 所以 dp[i][j]的最小编辑距离 应该是j的前一个</span></span><br><span class="line">    <span class="comment">// 比如 ....b ..a  有 b!=a，所以 在....b增加一个a 成为 ....ba</span></span><br><span class="line">    <span class="comment">// 此时 ....ba 和 ..a 这样 i+1 和 j 是相等的，</span></span><br><span class="line">    <span class="comment">// i还是对应的b，j对应a，a 已经添加了对应成功了，所以对应 j-1</span></span><br><span class="line">        dp[i][j-<span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">        dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, <span class="comment">// 删除</span></span><br><span class="line">        dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span> <span class="comment">//替换</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归 return recursion(word1,word2,word1.length()-1,word2.length()-1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s1[0...i-1] s2[0...j-1] 的最小编辑距离</span></span><br><span class="line">    <span class="comment">// 最后就要 返回 dp[m][n] 所以new m+1 n+1</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">// 注意这里是 i-1,j-1 而不是 i,j</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(</span><br><span class="line">                            dp[i][j-<span class="number">1</span>] + <span class="number">1</span>, <span class="comment">// 增</span></span><br><span class="line">                            dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, <span class="comment">// 删除</span></span><br><span class="line">                            dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span> <span class="comment">//替换</span></span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="931-下降路径最小和"><a href="#931-下降路径最小和" class="headerlink" title="931 下降路径最小和"></a>931 下降路径最小和</h2><p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">https://leetcode-cn.com/problems/minimum-falling-path-sum/</a></p><p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p><p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>这题用个二维dp，很容易就能想到状态转移方程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = 到 i 行 j 列的下降路径最小和</span><br><span class="line">dp[i][j] = min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j+<span class="number">1</span>],dp[i-<span class="number">1</span>][j])+matrix[i][j]</span><br></pre></td></tr></table></figure><p>这题的关键是，对于 base case 的处理，显然初始化第一行，就是输入矩阵的第一行</p><p>对于<strong>第一列</strong>，和<strong>最后一列</strong>的数据，有点特殊，它<strong>只需要比较两个地方</strong>的就可以了，因此，我们可以在进行 dp 的时候，对这两个条件进行一个过滤，或者说在初始化的时候将-1 列 和 n列初始化为一个最大数比如99999，为Integer.MAX_VALUE 会发生溢出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] = 到 i 行 j 列的下降路径最小和</span></span><br><span class="line">        <span class="comment">// dp[i][j] = min(dp[i-1][j-1],dp[i-1][j+1],dp[i-1][j])+matrix[i][j]</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][n] = <span class="number">99999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j+<span class="number">1</span>])+matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j+<span class="number">1</span>])+matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到最后一行的最小值</span></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            res = Math.min(res,dp[m-<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(i,Math.min(i1,i2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者 用 if 进行过滤</p><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><ol start="53"><li>最大子数组和</li></ol><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>思路一：</strong></p><ul><li>设 dp[i] 为 nums[0…i] 中的最大和</li><li>这样定义 dp 数组的问题在于，没有办法根据 dp[i-1] 推出 dp[i]</li></ul><p><strong>思路二：</strong></p><ul><li>设 dp[i] <strong>以 i 结尾的最大和</strong></li><li>dp[i] 是以 i 结尾，根据dp[i-1] 推出 dp[i] 只有两种情况，要么 把 nums[i] 接到 dp[i-1] 的后面，要么 dp[i] 就是最大的</li><li>dp[i] = max(nums[i]，dp[i-1] + nums[i] )</li><li>因为 dp[i] 只和 dp[i-1] 有关，所以可以用两个 dp 变量递推，不用 dp 数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i] 到 第 i 位的最大和</span></span><br><span class="line">        <span class="comment">// if nums[i] &lt; 0 dp[i] = dp[i-1] 可以发现 无法根据 dp[i-1] 推出 dp[i]</span></span><br><span class="line">        <span class="comment">// dp[i] 以 i 结尾的最大和</span></span><br><span class="line">        <span class="comment">// 根据dp[i-1] 推出 dp[i] 只有两种情况</span></span><br><span class="line">        <span class="comment">// 要么 nums[i] 接到 dp[i-1]的后面 要么 dp[i] 就是最大的 = nums[i]</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp_0=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp_1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp_1 = Math.max(nums[i],dp_0+nums[i]);</span><br><span class="line">            dp_0 = dp_1;</span><br><span class="line">            res = Math.max(res,dp_1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i] 到 第 i 位的最大和</span></span><br><span class="line">    <span class="comment">// if nums[i] &lt; 0 dp[i] = dp[i-1] 可以发现 无法根据 dp[i-1] 推出 dp[i]</span></span><br><span class="line">    <span class="comment">// dp[i] 以 i 结尾的最大和</span></span><br><span class="line">    <span class="comment">// 根据dp[i-1] 推出 dp[i] 只有两种情况</span></span><br><span class="line">    <span class="comment">// 要么 nums[i] 接到 dp[i-1]的后面 要么 dp[i] 就是最大的 = nums[i]</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp =<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(nums[i],dp[i-<span class="number">1</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : dp) &#123;</span><br><span class="line">        res = Math.max(res,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><p>关键还是在于 怎么列状态转移方程，实际上，这种子序列问题，一般都需要 <strong>从 i 到 j</strong>，毕竟子序列嘛，i 到 j 才是子序列，这种子序列的动态规划也是一样，时间复杂度一般都在O(n2)。</p><p>对于这种子序列问题，一般有 <strong>两种思路</strong></p><p><strong>思路一：</strong></p><p><strong>一个一维的 dp 数组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = array.length;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在 **最长递增子序列 **中，我们定义 dp数组：</p><p>dp[i] 为 以 nums[i] 结尾的最长严格递增子序列的长度</p><p><strong>思路二：</strong></p><p><strong>一个二维的 dp 数组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = arr.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[n][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种一般较为常用，比如 <strong>最长公共子序列</strong>。 这里将 <strong>dp数组含义又分为 只涉及一个字符串 和 涉及两个字符串</strong> 两种情况</p><ol><li><p><strong>涉及两个字符串/数组</strong>时（比如 <strong>最长公共子序列、编辑距离</strong>），dp 数组的含义如下：</p><p>在子数组 <strong>arr1[0..i]</strong> 和子数组 <strong>arr2[0..j]</strong> 中，我们要求的<strong>子序列</strong>（最长公共子序列）<strong>长度</strong>为 <strong>dp[i]</strong></p></li><li><p><strong>只涉及一个字符串/数组</strong>时（比如 <strong>最长回文子序列</strong>），dp 数组的含义如下：</p><p>在子数组 <strong>array[ i…j ]</strong> 中，我们要求的<strong>子序列</strong>（最长回文子序列）的<strong>长度</strong>为 <strong>dp[i] [j]</strong></p></li></ol><h2 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h2><ol start="1143"><li>最长公共子序列</li></ol><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1</strong>：</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p><h3 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>状态定义</strong>：</p><ul><li>dp[i] [j] 为 s1[0…i] 和 s2[0…j] 的最长公共子串 LCS</li></ul><p>接下来推状态转移方程，如果一时不知道怎么递推，那么可以先初始化 dp 数组，看看 dp 初始化后是个什么样子，就可以大概看出递推关系</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20220508164210014.png" alt="image-20220508164210014"></p><p><strong>状态转移</strong>：</p><ul><li>if s1[i] == s[j] dp[i] [j] = dp[i-1] [j-1] + 1</li><li>else dp[i] [j] = max(dp[i-1] [j] , dp[i] [j-1])</li></ul><p><strong>base case</strong> ：</p><ul><li>dp[0] [j] = 0,dp[i] [0] = 0;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://labuladong.github.io/algo/3/24/79/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i][j] s1 以i 结尾，s2 以j 结尾的最长公共子序列</span></span><br><span class="line">    <span class="comment">// dp[i][j]</span></span><br><span class="line">    <span class="comment">// if s1[i] == s2[j] dp[i][j] = dp[i-1][j-1]+1;</span></span><br><span class="line">    <span class="comment">// else dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])</span></span><br><span class="line">    <span class="comment">// 初始化 dp[0][j] = 0,dp[i][0] = 0;</span></span><br><span class="line">    <span class="keyword">int</span> m = text1.length();</span><br><span class="line">    <span class="keyword">int</span> n = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case dp[0][j] = 0,dp[i][0] = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="comment">//char c1 = text1.charAt(i-1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">//char c2 = text2.charAt(j-1);</span></span><br><span class="line">            <span class="comment">// if (c1==c2)</span></span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个字符串的删除操作-LCS解决"><a href="#两个字符串的删除操作-LCS解决" class="headerlink" title="两个字符串的删除操作 (LCS解决)"></a>两个字符串的删除操作 (LCS解决)</h2><ol start="583"><li>两个字符串的删除操作</li></ol><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。</p><p>每步 可以删除任意一个字符串中的一个字符。</p><p><strong>示例 1</strong>：</p><p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2<br>解释: 第一步将 “sea” 变为 “ea” ，第二步将 “eat “变为 “ea”</p><p><strong>示例  2</strong>:</p><p>输入：word1 = “leetcode”, word2 = “etco”<br>输出：4</p><h3 id="LCS解决"><a href="#LCS解决" class="headerlink" title="LCS解决"></a>LCS解决</h3><p>最后删除完事结果就是两个字符串的最长公共子序列，所以返回LCS 的长度，最后减去即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最后 删除的结果 剩下的就是 word1 与 word2 的最长公共子序列</span></span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span> subsequenceLen = longestCommonSubsequence(word1,word2);</span><br><span class="line">        <span class="keyword">return</span> m - subsequenceLen + n - subsequenceLen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="两个字符串的最小ASCII删除和（LCS-解决）"><a href="#两个字符串的最小ASCII删除和（LCS-解决）" class="headerlink" title="两个字符串的最小ASCII删除和（LCS 解决）"></a>两个字符串的最小ASCII删除和（LCS 解决）</h2><ol start="712"><li>两个字符串的最小ASCII删除和</li></ol><p>给定两个字符串s1 和 s2，返回 使两个字符串相等所需删除字符的 ASCII 值的最小和 。</p><p><strong>示例 1</strong>：</p><p>输入: s1 = “sea”, s2 = “eat”<br>输出: 231</p><p>解释: 在 “sea” 中删除 “s” 并将 “s” 的值(115)加入总和<br>在 “eat” 中删除 “t” 并将 116 加入总和<br>结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和</p><p><strong>示例 2</strong>：</p><p>输入: s1 = “delete”, s2 = “leet”<br>输出: 403</p><p>解释: 在 “delete” 中删除 “dee” 字符串变成 “let”，<br>将 100[d]+101[e]+101[e] 加入总和。在 “leet” 中删除 “e” 将 101[e] 加入总和<br>结束时，两个字符串都等于 “let”，结果即为 100+101+101+101 = 403<br>如果改为将两个字符串转换为 “lee” 或 “eet”，我们会得到 433 或 417 的结果，比答案更大</p><h3 id="LCS-解决"><a href="#LCS-解决" class="headerlink" title="LCS 解决"></a>LCS 解决</h3><p>同理 LCS ，只不过要求返回的是最小ASCII值的最小和，而不最长子序列的长度了，但是大致 dp 思路一样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] ---&gt; s1[0...i-1] s2[0...j-1] minimumDeleteSum</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// base case dp[0][j] = s2[1...j] 的 ASCII 值和, dp[i][0] 同</span></span><br><span class="line">        <span class="keyword">int</span> m = s1.length();</span><br><span class="line">        <span class="keyword">int</span> n = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + s2.codePointAt(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + s1.codePointAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j] + s1.codePointAt(i),dp[i][j-<span class="number">1</span>] + s2.codePointAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><ol start="516"><li>最长回文子序列</li></ol><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列</p><p><strong>示例 1</strong>：</p><p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” </p><p><strong>示例 2</strong>：</p><p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” </p><h3 id="子序列问题-1"><a href="#子序列问题-1" class="headerlink" title="子序列问题"></a>子序列问题</h3><p>关键还是在于 怎么列状态转移方程，实际上，这种子序列问题，一般都需要 <strong>从 i 到 j</strong>，毕竟子序列嘛，i 到 j 才是子序列，这种子序列的动态规划也是一样，时间复杂度一般都在O(n2)。</p><p>对于这种子序列问题，一般有 <strong>两种思路</strong></p><p><strong>思路一：</strong></p><p><strong>一个一维的 dp 数组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = array.length;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] = 最值(dp[i], dp[j] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在 **最长递增子序列 **中，我们定义 dp数组：</p><p>在 子数组 array[0…i] 中，我们要求的子序列（最长递增子序列）的长度是 dp[i]。</p><p><strong>思路二：</strong></p><p><strong>一个二维的 dp 数组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = arr.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> dp[n][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) </span><br><span class="line">            dp[i][j] = dp[i][j] + ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种一般较为常用，比如 <strong>最长公共子序列</strong>。 这里将 <strong>dp数组含义又分为 只涉及一个字符串 和 涉及两个字符串</strong> 两种情况</p><ol><li><p><strong>涉及两个字符串/数组</strong>时（比如 <strong>最长公共子序列、编辑距离</strong>），dp 数组的含义如下：</p><p>在子数组 <strong>arr1[0..i]</strong> 和子数组 <strong>arr2[0..j]</strong> 中，我们要求的<strong>子序列</strong>（最长公共子序列）<strong>长度</strong>为 <strong>dp[i]</strong></p></li><li><p><strong>只涉及一个字符串/数组</strong>时（比如 <strong>最长回文子序列</strong>），dp 数组的含义如下：</p><p>在子数组 <strong>array[ i…j ]</strong> 中，我们要求的<strong>子序列</strong>（最长回文子序列）的<strong>长度</strong>为 <strong>dp[i] [j]</strong></p></li></ol><h3 id="动态规划解决"><a href="#动态规划解决" class="headerlink" title="动态规划解决"></a>动态规划解决</h3><ol><li><p><strong>定义 dp</strong> 数组</p><p>这是 <strong>只涉及到一个字符串</strong> 的子序列问题</p><p>考虑 <strong>设 s[i…j] 的最长回文子序列长度为 dp[i] [j]</strong></p></li><li><p><strong>状态转移</strong></p><p>当 s[i] == s[j] 的时候，说明 s[i…j] 的最长回文子序列 长度 是 s[i+1…j-1] 的长度 加上它两；</p><p>如果 它两不相等，那么 s[i] 和 s[j] 只可能出现在一个子序列中，不会同时出现，要么 是在 s[i+1…j] 的子序列中，要么 是在 s[i…j-1] 的子序列中</p><p>所以</p><ul><li><strong>if  s[i] == s[j]  dp[i] [j] = dp[i+1] [j-1] + 2</strong></li><li><strong>else dp[i] [j] = Math.max( dp[i+1] [j] , dp[i] [j-1])</strong> </li></ul></li><li><p><strong>base case</strong></p><p> 很明显，dp[i] [i] == 1，从 s[i…i] 为1，其他的初始化就为0,</p></li><li><p><strong>遍历方式</strong></p><p>可以发现 base case 主要是二维数组的 对角线，在 根据 dp[i] [j] 与其他 dp[] [] 的关系，可以发现，要能遍历出来，对遍历顺序是有一定要求的，只能选择 斜着遍历 或者 反着遍历。</p><p><strong>为了保证每次计算 <code>dp[i][j]</code>，左下右方向的位置已经被计算出来，只能斜着遍历或者反着遍历</strong>：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20220510154359407.png" alt="image-20220510154359407"></p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// bbabab</span></span><br><span class="line">        <span class="comment">// dp[i][j] 为 子串s[i...j] 的 最长回文子序列长度</span></span><br><span class="line">        <span class="comment">// dp[i][j]</span></span><br><span class="line">        <span class="comment">// if s[i] == s[j] dp[i][j] = dp[i+1][j-1] + 2;</span></span><br><span class="line">        <span class="comment">// else dp[i][j] = Math.max(dp[i+1][j],dp[i,j-1]);</span></span><br><span class="line">        <span class="comment">// base case dp[i][i] = 1;</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为 dp[i+1][j-1] [i+1][j] dp[i,j-1] </span></span><br><span class="line">    <span class="comment">//所以只能选择 斜着遍历 或者 反着遍历，才能推出dp[i][j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="让字符串成为回文串的最少插入次数"><a href="#让字符串成为回文串的最少插入次数" class="headerlink" title="让字符串成为回文串的最少插入次数"></a>让字符串成为回文串的最少插入次数</h2><ol start="1312"><li>让字符串成为回文串的最少插入次数</li></ol><p>给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。</p><p>请你返回让 s 成为回文串的 最少操作次数 。</p><ul><li><p><strong>示例 1</strong>：</p><p>输入：s = “zzazz”<br>输出：0<br>解释：字符串 “zzazz” 已经是回文串了，所以不需要做任何插入操作</p></li><li><p><strong>示例 2</strong>：</p><p>输入：s = “mbadm”<br>输出：2<br>解释：字符串可变为 “mbdadbm” 或者 “mdbabdm” </p></li></ul><ol><li><p>状态定义</p><p><strong>dp[i] [j] 为 s[i…j] 成为回文串的最小插入次数</strong></p></li><li><p>状态转移</p><p><strong>if s[i] == s[j] dp[i] [j] = dp[i+1] [j-1]</strong></p><p><strong>else dp[i] [j] = min(dp[i+1] [j],dp[i] [j-1]) + 1</strong></p><p>这里不能是 **else dp[i] [j] = Math.min(dp[i-1] [j]+1, dp[i] [j+1]+1)**，这样会发现没办法遍历 dp</p><p>并且：mbadm 在 b 的前面插入d，这个时候mdbadm，i 成为了d，那么 i+1 就是b，所以是dp[i+1] [j]</p></li><li><p>base case 对角线为0</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j]: s[i...j] 为回文串的最小插入次数</span></span><br><span class="line">        <span class="comment">// if s[i] == s[j] dp[i][j] = dp[i+1][j-1]</span></span><br><span class="line">        <span class="comment">// else dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j+1]+1)</span></span><br><span class="line">        <span class="comment">// mbadm 1.在 b 的前面插入d 这个时候mdbadm i就是d，那么 i+1 就是b所以dp[i+1][j]</span></span><br><span class="line">        <span class="comment">// else dp[i][j] = min(dp[i+1][j],dp[i][j-1]) + 1</span></span><br><span class="line">        <span class="comment">// base case dp[i][i] = 0</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏</h2><ol start="174"><li>地下城游戏</li></ol><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><p><strong>错误思路：</strong></p><ul><li><p>这题 最开始我的思路是，设dp[i] [j] 为 从起点到 dungeon[i] [j] 所需要的最低 HP</p></li><li><p>接下来找状态转移方程，发现状态转移方程没法找，因为中间可能会有 大于 0 的 dungeon，那这样就应该加 HP，dp[i] [j]  与 dp[i-1] [j] 、dp[i] [j-1]  的关系 根本无法确定 </p></li><li><p>```java<br>// dp[i][j] 到 dungeon[i][j] 所需的最低 HP</p><pre><code>    // if dungeon[i][j] &lt; 0    // dp[i][j] = dp[i-1][j] + abs(dungeon[i][j])    // else dp[i][j] = dp[i-1][j]    // if dungeon[i][j] &lt; 0    // dp[i][j] = dp[i][j-1] + abs(dungeon[i][j])    // else dp[i][j] = dp[i][j-1]    // dp[i][j] = max(   )    // base case dp[0][0]</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**正确思路：**</span><br><span class="line"></span><br><span class="line">* 定义 dp[i] [j]  为 从 dungeon[i] [j] 到终点（右下角）所需的最小生命值</span><br><span class="line">* 这样就可以找状态转移表达式了，dp[i] [j] &#x3D; dp[i] [j] 下方 和 dp[i] [j] 右边 中到终点所需HP最小的那一个，再减去当前dungeon 的hp ，即 - dungeon[i] [j];</span><br><span class="line">* 这样 dp[i] [j] 到 终点 所需的最小生命值 也是最小的</span><br><span class="line">* 当然 减去dungeon[i] [j]后，如果为 &lt;&#x3D;0，说明不需要额外的HP就行，只需要起始的 1 HP就 ok</span><br><span class="line"></span><br><span class="line">**base case**：</span><br><span class="line"></span><br><span class="line">* 显然需要倒着遍历，从最后一行到第一行，所以 dp[i] [n] &#x3D; Integer.MAX_VALUE; dp[m] [i] &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F; 选择 所需最小的一个,再加上当前 要[掉]的HP，或者减去 要[加]的HP</span><br><span class="line">int res &#x3D; Math.min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];</span><br><span class="line">&#x2F;&#x2F; 如果 减去 结果 为 &lt;&#x3D;0 非正数，说明不需要额外HP，来个 起始 HP 1就 ok</span><br><span class="line">dp[i][j] &#x3D; res &lt;&#x3D; 0 ? 1:res;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] 从 dungeon[i][j] 到 终点 所需的最小生命值</span></span><br><span class="line">        <span class="comment">// dp[i][j] =</span></span><br><span class="line">        <span class="comment">// base case dp[n-1][n-1] =</span></span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[m-<span class="number">1</span>][n-<span class="number">1</span>] = dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>] &lt; <span class="number">0</span> ? -dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][n] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[m][i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>; j &gt;=<span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="comment">// dp[m-1][n-1] 已经计算过了</span></span><br><span class="line">                <span class="keyword">if</span> (i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 选择 所需最小的一个,再加上当前 要[掉]的HP，或者减去 要[加]的HP</span></span><br><span class="line">                <span class="keyword">int</span> res = Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">                <span class="comment">// 如果 减去 结果 为 &lt;=0 非正数，说明不需要额外HP，来个 起始 HP 1就 ok</span></span><br><span class="line">                dp[i][j] = res &lt;= <span class="number">0</span> ? <span class="number">1</span>:res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存模型</title>
      <link href="/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/02/09/JUC/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p><strong>JMM</strong> 即 <strong>Java Memory Model</strong> ，它从Java层面定义了<strong>主存</strong>、<strong>工作内存</strong>抽象概念，底层对应着CPU 寄存器、缓存、硬件内存、CPU 指令优化等。JMM 体现在以下几个方面</p><ul><li><strong>原子性</strong> - 保证指令不会受 线程上下文切换的影响</li><li><strong>可见性</strong> - 保证指令不会受 cpu 缓存的影响 (JIT对热点代码的缓存优化)</li><li><strong>有序性</strong> - 保证指令不会受 cpu 指令并行优化的影响</li></ul><p><strong>Java内存模型</strong>描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。<br>在内存模型中，所有的变量都存储在主内存中。<strong>每个线程都有自己独立的工作内存</strong>，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)。</p><p><strong>JMM线程操作内存的两条基本的规定:</strong></p><ol><li>关于线程与主内存：线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写</li><li>关于线程间工作内存：不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要经过主内存来完成。</li></ol><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><code>在主线程中修改的静态变量的值，对应t线程来说是不可见的</code></p><p>这是因为t线程的run方法是个<code>while (run)</code>循环，JIT即使编译器会对t线程中的run变量进行缓存到本地工作内存，不去主存中取run的值，这样可以加快执行速度。也就是JVM达到一定阈值时，<code>while (run)</code>循环变成了<strong>热点代码</strong>， 所以一直访问的都是缓存到本地工作内存(局部)中的run。当主线程修改<strong>主存中的run变量</strong>的时候，t1线程一直访问的是自己缓存的, 所以不认为run已经改为false了。 所以一直运行并不会结束循环，我们为主存(成员变量)进行<strong>volatile</strong>修饰, 增加变量的可见性, 当主线程修改run为false, t1线程对run的值可见。这样就可以退出循环。</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120131625943.png" alt="image-20220120131625943"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (run)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;停止 t线程&quot;</span>);</span><br><span class="line">    run=<span class="keyword">false</span>;<span class="comment">// 没有volatile，事实上并不会退出t线程</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用<strong>volatile解决</strong>以外还可以使用<strong>synchronized解决</strong>问题</p><ul><li><strong>在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存，然后主内存中拷贝最新变量的副本到工作内存 ，执行完代码后，将更改后的共享变量的值刷新到主内存中，最后释放互斥锁。</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1s内,一直都在无限循环获取锁. 1s后主线程抢到锁,修改为false, 此时t1线程抢到锁对象,while循环也退出</span></span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!run)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 当主线程获取到锁的时候, 就修改为false了</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            run = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul><li>前面例子体现的实际就是<code>可见性</code>，<strong>它保证的是在多个线程之间一个线程对 volatile 变量的修改对另一个线程可见</strong>， <strong>而不能保证原子性</strong>。volatile用在一个写线程，多个读线程的情况, 比较合适。 上例从字节码理解是这样的：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true</span></span><br><span class="line">putstatic run <span class="comment">// 线程 main 修改 run 为 false， 仅此一次</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run false </span></span><br></pre></td></tr></table></figure><ul><li>比较一下之前线程安全时的例子：两个线程一个 <strong>i++</strong> 一个 <strong>i–</strong> ，只能<strong>保证</strong>看到最新值(<strong>可见性</strong>)，<strong>不能</strong>解决<strong>指令交错(原子性)</strong></li></ul><p><strong>注意</strong> ：</p><ul><li><strong>synchronized</strong> 语句块既可以<strong>保证</strong>代码块的<strong>原子性</strong>，也同时<strong>保证</strong>代码块内变量的<strong>可见性</strong>。但缺点是 synchronized 是属于重量级操作，性能相对更低。</li><li> 如果在前面示例的死循环中加入 <strong>System.out.println()</strong> 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了</li><li>因为<strong>System.out.println() 方法里面有synchronized修饰</strong>。</li></ul><h2 id="volatile实现模式之两阶段终止"><a href="#volatile实现模式之两阶段终止" class="headerlink" title="volatile实现模式之两阶段终止"></a>volatile实现模式之两阶段终止</h2><ul><li>当我们在执行线程一时，想要终止线程二，这是就需要使用<code>interrupt方法</code>来优雅的停止线程二。这是之前的做法</li></ul><ul><li>使用volatile关键字来实现两阶段终止模式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面是两个线程操作共享变量stop</span></span><br><span class="line">        Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        monitor.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;Monitor&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private boolean stop = false; // 不会停止程序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>; <span class="comment">// 会停止程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动监控器线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread monitor = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//开始不停的监控</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于停止监控器线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式之-Balking"><a href="#模式之-Balking" class="headerlink" title="模式之 Balking"></a>模式之 Balking</h2><ul><li>定义：<code>Balking （犹豫）模式</code>用在 <strong><code>一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</code>。有点类似于单例。</strong></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>JIT即时编译器的优化，可能会导致<strong>指令重排</strong>。为什么要优化? 因为CPU 支持多级指令流水线，例如支持同时执行 <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 的处理器，效率更快 </p><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120155001076.png" alt="image-20220120155001076"></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="指令重排序导致错误结果"><a href="#指令重排序导致错误结果" class="headerlink" title="指令重排序导致错误结果"></a>指令重排序导致错误结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span></span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;</span><br><span class="line"> r.r1 = num + num;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> num = <span class="number">2</span>;</span><br><span class="line"> ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程1执行actor1方法, 线程2执行actor2方法</p><p>但是最终的结果还有可能让r.r1=0</p><ul><li><p>这样情况是在actor2方法进行了<strong>指令重排序</strong>，因为<code> num = 2;</code>和<code>ready = true;</code>互相之间看起来并没有影响，因此先执行<code>ready = true;</code>，这时候num=2还没执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num = <span class="number">2</span>;</span><br><span class="line">ready = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重排序后</span></span><br><span class="line">ready = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//此时发生线程切换</span></span><br><span class="line">num = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>此时，发送线程上下文切换，<code>ready = true;</code>，线程1判断为true，就<code>r.r1=num+num</code>，最后r.r1=0;</p></li></ul><p>这种现象叫做指令重排，是JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现，可以使用jcstress工具进行测试。上面仅是从代码层面体现出了有序性问题，下面的 <strong>double-checked locking</strong> (双重检查锁)还会从java字节码的层面了解有序性的问题。</p><p><strong>指令重排序</strong>操作<strong>不会对</strong>存在<strong>数据依赖关系</strong>的操作进行<strong>重排序</strong>。比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p>重排序是为了优化性能，但是不管怎么重排序，<strong>单线程</strong>下程序的执行结果<strong>不会被改变</strong>。</p><p><strong>指令重排序 在 单线程模式下是一定会保证最终结果的正确性，</strong> 但是在多线程环境下，问题就出来了。</p><p><strong>解决方法</strong>：<code>volatile 修饰的变量，可以禁用指令重排</code></p><h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p><strong>volatile</strong> 的<strong>底层实现</strong>原理是<strong>内存屏障</strong>，<strong>Memory Barrier</strong>（Memory Fence）</p><p>对 volatile 变量的<strong>写指令</strong>后会加入<strong>写屏障</strong>。(保证写屏障之前的写操作, <strong>都能同步到主存中</strong>)</p><p>对 volatile 变量的<strong>读指令</strong>前会加入<strong>读屏障</strong>。(保证读屏障之后的读操作, <strong>都能读到主存的数据</strong>)</p><h3 id="volatile保证可见性原理"><a href="#volatile保证可见性原理" class="headerlink" title="volatile保证可见性原理"></a>volatile保证可见性原理</h3><ul><li><p><strong>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">     num = <span class="number">2</span>;</span><br><span class="line">     ready = <span class="keyword">true</span>; <span class="comment">// ready是被volatile修饰的 ，赋值带写屏障</span></span><br><span class="line">     <span class="comment">// 写屏障(在ready=true写指令之后加的, </span></span><br><span class="line">     <span class="comment">//在该屏障之前对共享变量的改动, 都同步到主存中，包括num)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 读屏障</span></span><br><span class="line"> <span class="comment">//  ready是被volatile修饰的 ，读取值带读屏障</span></span><br><span class="line"> <span class="keyword">if</span>(ready) &#123;<span class="comment">// ready, 读取的就是主存中的新值</span></span><br><span class="line"> r.r1 = num + num; <span class="comment">// num, 读取的也是主存中的新值</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> r.r1 = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="volatile保证有序性原理"><a href="#volatile保证有序性原理" class="headerlink" title="volatile保证有序性原理"></a>volatile保证有序性原理</h3><ul><li><strong>写屏障</strong>会确保<strong>指令重排序</strong>时，<strong>不会将写屏障之前的代码排在写屏障之后</strong></li><li><strong>读屏障</strong>会确保<strong>指令重排序</strong>时，<strong>不会将读屏障之后的代码排在读屏障之前</strong></li></ul><h3 id="volatile不能解决指令交错-不能解决原子性-："><a href="#volatile不能解决指令交错-不能解决原子性-：" class="headerlink" title="volatile不能解决指令交错 (不能解决原子性)："></a>volatile不能解决<strong>指令交错</strong> (不能解决<strong>原子性</strong>)：</h3><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其它线程的读, 跑到它前面去</li><li><strong>有序性的保证也只是保证了本线程内相关代码不被重排序</strong>，并不能保证指令的交错</li><li>比如线程2先读到i，然后被切换成了线程1执行完后，线程2还是把i当做没更新的i值执行。可以使用<code>synchronized</code>来解决原子性</li></ul><h2 id="double-checked-locking-双重检查锁"><a href="#double-checked-locking-双重检查锁" class="headerlink" title="double-checked locking (双重检查锁)"></a>double-checked locking (双重检查锁)</h2><p>首先<strong>synchronized</strong>可以<strong>保证</strong>它的临界区的资源是<strong>原子性、可见性、有序性</strong>的, <strong>有序性的前提</strong>是, 在synchronized代码块中的共享变量, 不会在代码块外使用到, 否则<strong>有序性</strong>不能被保证, 只能使用<strong>volatile</strong>来保证有序性。<br>下面代码的第二个双重检查单例，就出现了这个问题(在synchronized外使用到了INSTANCE)，此时synchronized就不能防止指令重排，确保不了指令的有序性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最开始的单例模式是这样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      多线程同时调用getInstance(), 如果不加synchronized锁, 此时两个线程同时</span></span><br><span class="line"><span class="comment">      判断INSTANCE为空, 此时都会new Singleton(), 此时就破坏单例了.所以要加锁,</span></span><br><span class="line"><span class="comment">      防止多线程操作共享资源,造成的安全问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//INSTANCE没有加volatile</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是上面的<code>if(INSTANCE == null)</code>判断代码没有在同步代码块synchronized中，不能享有synchronized保证的原子性、可见性、以及有序性</strong>。所以可能会导致指令重排。</p><p>上述方法的字节码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span> <span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="comment">// ldc是获得类对象</span></span><br><span class="line">6: ldc #3 // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="comment">// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份</span></span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="comment">// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span></span><br><span class="line"><span class="comment">// 将类对象的引用地址存储了一份，是为了将来解锁用</span></span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line">11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="comment">// 新建一个实例</span></span><br><span class="line">17: new #3 // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="comment">// 复制了一个实例的引用</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="comment">// 通过这个复制的引用调用它的构造方法</span></span><br><span class="line">21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"><span class="comment">// 最开始的这个引用用来进行赋值操作</span></span><br><span class="line">24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line">37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><p>上述字节码最关键的地方在于17-&gt;24</p><ul><li><p><strong>正常情况</strong>先新建一个实例，然后复制实例的引用，再通过这个复制的引用调用它的构造方法，最后进行赋值操作赋值给instance。</p></li><li><p>但是JVM可能会优化这里的代码：<code>先执行 24(赋值)，再执行 21(构造方法)</code>。也就是先给instance赋值，这样instance并不为null，这个时候t2线程进入，第一个判断，<code> if(INSTANCE == null)</code>，ifnonnull，发现不为null，跳转到37行，最终获取到一个假的不为null的对象。</p></li><li><p>如果两个线程 t1，t2 按如下时间序列执行：</p></li></ul><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120171355261.png" alt="image-20220120171355261"></p><p>所以最终的问题</p><ul><li><code>INSTANCE = new Singleton();</code>操作不是一个<strong>原子操作</strong>, 它总共被分为4个指令，<code>21, 24两个指令</code>此时可能就会<strong>发生指令重排</strong>的问题。</li><li>此时又因为 <code>0: getstatic</code> 这行代码在 monitor 控制之外，也就是说第一次判断null的时候没有在synchronized控制下，其他线程可以来获取，判断instance的值</li><li>synchronized是可以保证变量的原子性、有序性和可见性，不会出现因为指令重排而产生错误，<strong>前提是</strong>：synchronized必须把这个变量完全的管理住。上面的问题就是因为第一次判空是没有被synchronized所管理到的。</li></ul><p>因此，解决方案就是加个volatile，<code>private static volatile Singleton INSTANCE = null</code>。加了<strong>volatile之后就会在putstatic加个写屏障，这样写屏障之前的指令就不会被重排序。</strong></p><p>读写 volatile 变量操作（即getstatic操作和putstatic操作）时会加入<strong>内存屏障</strong>，保证下面两点：</p><ul><li><strong>可见性</strong><br>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中<br>读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li><li><strong>有序性</strong><br>写屏障 会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后<br>读屏障 会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性<br>加上volatile之后, 保证了指令的有序性, 不会发生指令重排, 21就不会跑到24之后执行了</li></ul><p><strong>synchronized 既能保证原子性、可见性、有序性，其中有序性是在该共享变量完全被synchronized 所接管（包括共享变量的读写操作），上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。</strong></p><p><strong>对共享变量加volatile关键字可以保证可见性和有序性，但是不能保证<code>原子性</code>（即不能防止<code>指令交错</code>）。</strong></p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120172649628.png" alt="image-20220120172649628"></p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220120172629908.png" alt="image-20220120172629908"></p><h2 id="Happens-before规则"><a href="#Happens-before规则" class="headerlink" title="Happens-before规则"></a>Happens-before规则</h2><p>happens-before规定了多共享变量的写操作对于其他线程的读操作的可见性。抛开以下规则，JVM并不能保证一个线程对共享变量的写操作对于其它线程对该共享变量的读可见。</p><h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>对于synchronized锁，会保证每次去主存中读取数据，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="volatile-变量"><a href="#volatile-变量" class="headerlink" title="volatile 变量"></a>volatile 变量</h3><ul><li><p>线程对volatile 变量的写，对接下来其它线程对该变量的读可见</p><p><strong>volatile修饰的变量, 通过<code>写屏障</code>, 共享到主存中, 其他线程通过<code>读屏障</code>, 读取主存的数据</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="start-前的写操作"><a href="#start-前的写操作" class="headerlink" title="start() 前的写操作"></a>start() 前的写操作</h3><ul><li><p>线程 start() 前对变量的写，对该线程开始后对该变量的读可见</p><p>线程还没启动时, 修改变量的值, 在启动线程后, 获取的变量值, 肯定是修改过的</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">   System.out.println(x);</span><br><span class="line">  &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="t1-isAlive-或-t1-join-等待结束"><a href="#t1-isAlive-或-t1-join-等待结束" class="headerlink" title="t1.isAlive() 或 t1.join()等待结束"></a>t1.isAlive() 或 t1.join()等待结束</h3><ul><li><p>线程结束前 对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</p><p>主线程获取的x值, 是线程执行完对x的写操作之后的值。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure><h3 id="interrupt打断"><a href="#interrupt打断" class="headerlink" title="interrupt打断"></a>interrupt打断</h3><ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后, 对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(x); <span class="comment">// 10, 打断了, 读取的也是打断前修改的值</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);<span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><ul><li>对变量默认值（0，false，null）的写，对其它线程对该变量的 读可见 (最基本)</li><li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</li><li>因为x加了volatile, 所以在volatile static int x 代码的上面添加了读屏障, 保证读到的x和y的变化是可见的(包括y, 只要是读屏障下面都OK); 通过传递性, t2线程对x,y的写操作, 都是可见的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">y = <span class="number">10</span>;</span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span> ).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">//x=20对t2可见，同时y=10 也对t2可见</span></span><br><span class="line">    system.out. print1n(x);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span> ).start();</span><br></pre></td></tr></table></figure><p><strong><code>volatile</code>主要用在<code>一个线程改,多个线程读时的来保证可见性</code>，和<code>double-checked locking模式中保证synchronized代码块外的共享变量的</code>指令重排序<code>问题</code></strong></p><h2 id="五种单例模式"><a href="#五种单例模式" class="headerlink" title="五种单例模式"></a><strong>五种单例模式</strong></h2><p>单例模式有<strong>饿汉式、懒汉式、枚举类(饿汉)、静态内部类</strong></p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有?</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：为什么<strong>类要加 final</strong></p><ul><li>防止子类继承后重写方法破坏单例</li></ul><p>问题2：如果实现了序列化接口，还要做什么来<strong>防止反序列化破坏单例</strong></p><ul><li>反序列化时候生成的对象可能会破坏单例，直接在类里加一个**public Object readResolve() {}**方法，可以让反序列化的时候调用这个方法返回单例的实例</li></ul><p>问题3：为什么<strong>构造方法设置为私有</strong>?</p><ul><li>避免其他类使用new生成新的实例，并不能防止反射创建新的实例，因为反射可以打破封装</li></ul><p>问题4：这样初始化是否能保证单例对象创建时的线程安全？</p><ul><li>可以保证，因为实例在<strong>类加载</strong>的时候就<strong>初始化</strong>，JVM会保证其线程安全性</li></ul><p>问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</p><ul><li>1.提供更好的<strong>封装性</strong>；2.提供<strong>泛型</strong>的支持</li></ul></blockquote><h3 id="饿汉式之枚举"><a href="#饿汉式之枚举" class="headerlink" title="饿汉式之枚举"></a>饿汉式之枚举</h3><p>饿汉式：因为枚举的变量，底层是通过public static final来修饰的，类加载就创建了，所以是饿汉式</p><p><img src="/../../img/markdown_img/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1.assets/image-20220122210404242.png" alt="image-20220122210404242"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：枚举单例是如何限制实例个数的</p><ul><li><strong>创建枚举类的时候就已经定义好了</strong>，每个枚举常量其实就是枚举类的一个静态成员变量</li></ul><p>问题2：枚举单例在创建时是否有并发问题</p><ul><li>没有并发问题，是线程安全的，因为枚举单例底层是一个静态成员变量，它是通过类加载器的加载而创建的，确保了线程安全</li></ul><p>问题3：枚举单例能否被反射破坏单例</p><ul><li><p><strong>反射无法破坏枚举单例</strong>, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">this</span>.clazz.getModifiers() &amp; <span class="number">16384</span>) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(“Cannot reflectively create <span class="class"><span class="keyword">enum</span> <span class="title">objects</span>”)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>问题4：枚举单例能否被反序列化破坏单例</p><ul><li><strong>反序列化不能破坏</strong>，枚举类默认也实现了序列号接口。但枚举类考虑到了这个问题，不会破坏单例。</li></ul><p>问题 5：枚举单例属于懒汉式还是饿汉式</p><ul><li>属于<strong>饿汉式</strong>, 静态成员变量, 通过类加载器的时候就加载了。</li></ul><p>问题 6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做</p><ul><li>加构造方法，枚举也可以写构造方法，普通方法等</li></ul></blockquote><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点：</span></span><br><span class="line">    <span class="comment">// synchronized加载静态方法上，可以保证线程安全。缺点就是锁粒度大，效率低。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DCL懒汉式"><a href="#DCL懒汉式" class="headerlink" title="DCL懒汉式"></a>DCL懒汉式</h3><p>DCL：double-check-locking</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="keyword">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：解释为什么要加 volatile</p><ul><li>因为在synchronized外部使用到了共享变量INSTANCE，可能存在一个线程先初始化了instance，但是别的线程没有从主存中获取instance，而是从工作内存中获取instance，仍然为空，volatile保证了可见性，保证读取变量的时候都从主存中去获取，这样就不会存在已经创建了实例，但读取到实例仍然为空的情况</li></ul><p>问题2：对比上面的懒汉式，说出这样做的意义</p><ul><li>增加了双重判断，如果存在了单例对象，别的线程再进来就无需加锁判断，<strong>提升效率</strong></li></ul><p>问题3：为什么还要加为空判断, 之前不是判断过了吗</p><ul><li>主要原因还是因为并发的时候产生线程不安全的问题</li><li>考虑这么一种情况：<ul><li>线程1第一次进入了synchronized代码，获取到了锁，判断到instance为null，然后就去创建实例</li><li>线程2此时已经进行了第一次判断为空，然后等待线程1释放锁。</li><li>如果不加判断，线程1创建完后释放锁，线程2进入同步代码块，此时没有了第二重为空判断，就会直接创建实例，此时就重复创建了实例，破坏了单例</li></ul></li></ul></blockquote><h3 id="懒汉式之静态内部类"><a href="#懒汉式之静态内部类" class="headerlink" title="懒汉式之静态内部类"></a>懒汉式之静态内部类</h3><p>通过静态内部类来创建单例，对外不可见</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题1：属于懒汉式还是饿汉式</p><ul><li>懒汉式，因为这是个静态内部类，类加载本身就是懒惰的，在没有用到这个类的时候，是不会进行类加载的，因此没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul><p>问题2：在创建时是否有并发问题</p><ul><li>没有并发问题，仍然是单例的。因为类加载是懒惰的，没有用到静态内部类，就不会进行内部类类加载，既然没有进行LazyHolder的类加载操作，就不会用LazyHolder对于外部类实例INSTANCE的初始化操作。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> JUC并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS</title>
      <link href="/2022/02/09/JUC/AQS%20ReentrantLock%E5%8E%9F%E7%90%86/"/>
      <url>/2022/02/09/JUC/AQS%20ReentrantLock%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h3><p>AQS全称<strong>AbstractQueueSynchronizer</strong>，抽象的队列的同步器，是JDK1.5提供的一套实现阻塞锁和一系列依赖FIFO等待队列的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类的实现都依赖于它，比如常用的ReentrantLock/ Semaphore/ CountDownLatch等。具体用法是通过<strong>继承AQS</strong>，<strong>实现</strong>其模板<strong>方法</strong>，来达到同步状态的管理。</p><h3 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h3><p>AQS在功能上可以分为</p><ul><li><strong>独占锁</strong>：每次只能有一个线程持有锁，比如ReentrantLock</li><li><strong>共享锁</strong>：允许多个线程同时获得锁，并发访问共享资源，比如ReentrantReadWriteLock中的读锁、CountDownLatch</li></ul><p>特点：</p><ul><li><p>用state属性来表示资源的状态（分独占模式和共享模型），子类需要定义如何维护这个状态，控制如何获取锁和释放锁，比如state为0就是没有线程持有锁，把state改为1就是有线程持有锁</p><ul><li>getState：获取state状态</li><li>setState：设置state状态</li><li>compareAndSetState：cas机制设置state状态，这里的cas只是原子性的来修改state的值，AQS仍然是一个阻塞式的，尝试设置失败后会进入阻塞的队列里去</li><li>独占模式是只有一个线程能访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li><p>提供了基于FIFO的等待队列，类似Monitor的EntryList</p></li><li><p>条件变量来实现等待，唤醒机制，支持多个条件变量，类似于Monitor的WaitSet</p></li></ul><p>子类主要需要实现下面一些方法</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared：获取共享锁</li><li>tryReleaseShared：释放共享锁</li><li>isHeldExclusively：是否用于独占锁</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取锁的姿势</span></span><br><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁的姿势</span></span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承AQS自定义不可重入锁"><a href="#继承AQS自定义不可重入锁" class="headerlink" title="继承AQS自定义不可重入锁"></a>继承AQS自定义不可重入锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;TestAQS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            <span class="comment">// 不可重入锁</span></span><br><span class="line"><span class="comment">//            lock.lock();</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;locking...&quot;);</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义锁（不可重入锁）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占锁  同步器类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 确保原子性</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里不需要保证原子性, 因为是持锁者进行释放</span></span><br><span class="line">            <span class="comment">// 在setState(0)上面设置Owner为null, 防止指令重排序带来的问题</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// state是volatile修饰的, 在setState(0)前面的属性修改, 对于其他线程也是可见的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁（不成功会进入等待队列）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 加锁，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁（一次）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 尝试加锁，带超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 创建条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><p>ReentrantLock实现了Lock接口，同步内部还有一个自定义的抽象同步器Sync，Sync又包含了公平和非公平同步器，FairSync和NonfairSync都是ReentrantLock的static final 内部类，Sync是抽象的static 内部类继承自AQS</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129101733186.png" alt="image-20220129101733186"></p><h3 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h3><p>从构造方法来看，<strong>默认是非公平锁NonfairSync</strong>实现，NonfairSync继承了AQS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其lock方法调用的是同步器的lock方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看非公平同步器的lock方法，加锁流程就是现在cas机制原子性设置state值从0变为1，如果成功，就把独占锁Owner设置为当前线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有竞争时，Thread0进来加锁，把state变量为1，同时把独占锁Owner线程设置为Thread0</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129102122337.png" alt="image-20220129102122337"></p><p>第一个竞争出现时，假设已经有Thread0加锁成功，那么当前线程Thread1就<strong>加锁失败</strong>。</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129103843420.png" alt="image-20220129103843420"></p><p>加锁失败则进入AQS的acquire方法，会再一次尝试去获取锁，调用tryAcquire()，如果仍然获取失败，就尝试加入到等待队列里去，加入返回true就调用selfInterrupt把该线程打断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的addWaiter就是构造一个Node 双向链表队列</p><ol><li>下图中黄色三角表示该 Node 的<strong>waitStatus</strong>状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li><strong>第一次创建其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</strong></li></ol><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129104152327.png" alt="image-20220129104152327"></p><p>然后进入acquireQueued方法，这个方法内部是一个死for循环，获取当前线程关联节点的前驱节点p，<strong>如果p等于head，也就是说如果自己是紧邻着head（注意看图上的箭头，head指向的是node）</strong>，讲道理下一个就可以获得锁，那么Thread1就再一次的tryAcquire尝试去加锁；如果这次加锁成功了就把自己设置为Head节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果这次加锁失败或者p!=head，那么就应该在加锁失败后park住<strong>shouldParkAfterFailedAcquire</strong>，这个方法会将前驱节点即<strong>head</strong>的<strong>waitStatus</strong>修改为-1，**-1表示前面线程有责任唤醒后面的线程，也就是Thread1获取失败了，进入阻塞，把waitStatus设为-1 即将进入阻塞那么Thread0，就要有责任将Thread1唤醒<strong>，然后</strong>返回false**。</p><p>返回false后结束判断又进入for循环去尝试获取一次，假设<strong>又失败</strong>，那么又进入shouldParkAfterFailedAcquire方法，<strong>因为之前已经将waitStatus的值设置为-1了，这次肯定设置失败了，所以就返回了true</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">    * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>返回true后就进入<strong>parkAndCheckInterrupt</strong>方法，把当前线程park阻塞住</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129110313691.png" alt="image-20220129110313691"></p><p>假设有多个线程经历上述过程加锁失败，变成下图：</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129110452722.png" alt="image-20220129110452722"></p><h3 id="释放锁的流程"><a href="#释放锁的流程" class="headerlink" title="释放锁的流程"></a>释放锁的流程</h3><p>Thread0释放锁，进入tryRelease流程，将OwnerThread设置为null，state设置为0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后判断head是否为空，并且waitStatus==-1，进入unparkSuccessor方法，会找到离head最近的一个node(没取消的)，unpark唤醒。因此就是Thread1会被唤醒，然后Thread1继续执行acquireQueued方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Thread1加锁成功，设置</p><ol><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ol><p>如果有Thread4前来竞争，Thread1又加锁失败，Thread1再次进入acquireQueued流程，获取锁失败，重新进入park阻塞</p><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>以非公平锁NonfairSync的源码为例，NonfairSync在进行获取锁nonfairTryAcquire的时候，其实就是对state的值做一个判断，如果state的值为0，说明没线程加过锁；如果state的值不是0，说明已经有线程加过锁了，那就判断一下这个加锁的线程是不是当前线程，如果是当前线程那就<strong>把state的值再加1</strong>，<strong>表示当前线程又加了一次锁</strong></p><p>释放锁的时候相反，先让获取state的值，然后减去1，看看值是不是为0，为0才表示这个线程没有锁了，如果不为0，那就更新一下state的值就ok</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是Sync 继承过来的方法，实际上NonfairSync的tryAcquire里面也就是直接调用的这个nonfairTryAcquire方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 正常加锁流程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><p>ReentrantLock默认是不可打断的，不可打断指的是，某个线程在尝试获取锁，然后获取锁失败了会进入parkAndCheckInterrupt()方法被park阻塞，这个时候是不可打断的。</p><h4 id="不可打断"><a href="#不可打断" class="headerlink" title="不可打断"></a>不可打断</h4><p>当在parkAndCheckInterrupt方法中park阻塞住，然后被打断后，会<strong>Thread.interrupted()清除打断标记</strong>，让下次park仍然可以阻塞。当被打断后，线程醒过来会接着执行return Thread.interrupted()，这个时候就会<strong>返回true</strong>，但同时会清除<strong>打断标记</strong>，也就是<strong>置为false</strong>，这样下次<strong>仍可以park</strong>阻塞住。</p><p>返回为true后，执行interrupted = true，然后<strong>又进入循环</strong>，看能否获取锁，不能获取又进入park阻塞。如果这次能获取锁了，interrupted = true，最后acquireQueued方法返回的就是interrupted=true。也就是说需要获取到锁之后，才能返回打断状态。</p><p>然后就从acquireQueued方法出来，<strong>也就是获取到锁之后进行一次selfInterrupt()，重新打断一次，如果是正常运行状态不是sleep中就不会抛打断异常</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        <span class="comment">// 被park阻塞的线程, 可以被别的线程调用它的interrupt方法打断该park阻塞</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted会返回是否被打断过，同时会清除打断标记; 下次park仍然可以阻塞</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)&amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>可打断则是在park方法被打断之后，执行完了parkAndCheckInterrupt方法，进入if内部，<strong>直接抛出异常，不会再次执行for循环</strong>，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入可打断的获取锁流程</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><p>与非公平锁的区别主要在tryAcquire方法里，公平锁并不会直接cas 去设置state的值，它会先去检查一下AQS队列中有不有前驱节点，也就是说还有不有线程在等待，如果有就退出if，获取锁失败，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">           <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(current);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                (<span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">            (s = h.next) == <span class="keyword">null</span> || <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">                                s.thread != Thread.currentThread()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>在AQS中ConditionObject是一个实现了Condition的公共内部类，每个条件变量其实就对应着一个ConditionObject，ConditionObject维护了一个等待队列</p><h4 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a>await流程</h4><p>下面是ConditionObject中的await方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>开始 Thread0 持有锁，conditionObject对象调用 await</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145922395.png" alt="image-20220129145922395"></p><p>进入 ConditionObject 的 addConditionWaiter方法，这个方法会将Thread0在ConditionObject 的等待队列中关联一个节点，首先创建新的Node状态为 -2(Node.CONDITION)，关联 Thread-0，加入等待队列尾部。</p><p>然后fullyRelease()，释放掉Thread0的所有锁，因为是可重入的</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145830741.png" alt="image-20220129145830741"></p><p>内部调用release(args)方法，unparkSuccessor(h)，唤醒AQS队列中的下一个节点，竞争锁</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129145906453.png" alt="image-20220129145906453"></p><p>最后会进入await方法中的while循环，park阻塞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h4 id="signal流程"><a href="#signal流程" class="headerlink" title="signal流程"></a>signal流程</h4><p>下面是ConditionObject的<strong>signal</strong>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>假设Thread1要来唤醒Thread0</p><p>首先判断Thread1是否持有独占锁if (!<strong>isHeldExclusively</strong>())，只有持有锁，才能去唤醒条件变量里的线程</p><p>然后<strong>每次都取条件变量中等待队列的第一个</strong><code>Node first = firstWaiter</code>，如果存在等待线程，就dosignal方法</p><p><strong>dosignal</strong> 先做些事后处理，判断是否还有下一个node，并且端口thread0的节点</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129151114179.png" alt="image-20220129151114179"></p><p>然后<strong>transferForSignal</strong>()，这个方法会将要唤醒Node加入到AQS的等待队列里去，并且将等待队列中最后一个node(即是图上的Thread3)的waitStatus修改为-1，因为要唤醒的node加入到它后面了</p><p><img src="/../../img/markdown_img/AQS%20ReentrantLock%E5%8E%9F%E7%90%86.assets/image-20220129151221485.png" alt="image-20220129151221485"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/2022/02/09/JUC/CAS/"/>
      <url>/2022/02/09/JUC/CAS/</url>
      
        <content type="html"><![CDATA[<ul><li>Java中 <strong>synchronized</strong> 和 <strong>ReentrantLock</strong> 等独占锁是 <strong>悲观锁</strong> 思想的实现</li><li>在Java中<strong>java.util.concurrent.atomic包下面的原子变量类</strong>是使用了乐观锁的一种实现方式 <strong><code>CAS</code></strong> 实现</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li>有如下需求，保证account.withdraw()取款方法的线程安全, 下面使用<code>synchronized</code>保证线程安全</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account.demo(<span class="keyword">new</span> AccountUnsafe(<span class="number">10000</span>));</span><br><span class="line">        Account.demo(<span class="keyword">new</span> AccountCas(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountUnsafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java8之后接口新特性, 可以添加默认方法、静态方法</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 1000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(thread -&gt; thread.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end - start) / <span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS解决"><a href="#CAS解决" class="headerlink" title="CAS解决"></a>CAS解决</h2><ul><li>上面的代码中使用synchronized加锁操作来保证线程安全，但是 **synchronized加锁操作太耗费资源 (线程上下文切换)**，我们还可以使用 <strong>无锁CAS</strong> 来解决此问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountCas</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用原子整数</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AccountCas</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//得到原子整数的值</span></span><br><span class="line"><span class="keyword">return</span> balance.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//获得修改前的值</span></span><br><span class="line"><span class="keyword">int</span> prev = balance.get();</span><br><span class="line"><span class="comment">//获得修改后的值</span></span><br><span class="line"><span class="keyword">int</span> next = prev - amount;</span><br><span class="line"><span class="comment">//比较并设置值</span></span><br><span class="line">            <span class="comment">//一个原子操作，比较并设置。会先去比较一下线程当前知道的值prev和主存中的balance</span></span><br><span class="line">            <span class="comment">//比较发现如果相等就设置balance的值为next，然后返回true，不相等就直接返回false</span></span><br><span class="line"><span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h2><p>使用原子操作CAS来保证线程访问共享资源的安全性，需要保证共享变量的可见性</p><h3 id="保证账户余额线程安全原理"><a href="#保证账户余额线程安全原理" class="headerlink" title="保证账户余额线程安全原理"></a>保证账户余额线程安全原理</h3><p><strong>compareAndSet</strong> 保证共享变量安全性：</p><ul><li>调用compareAndSet方法, 会先去比较一下线程当前知道的值prev和主存中的balance，比较发现如果相等就设置balance的值为next，然后返回true，不相等就直接返回false<br>如果不相同，表示其他线程也修改了balance值，此时就设置next值失败，然后进入while循环，重新获取balance.get()的值，计算出next值。并判断本次的prev和balnce的值是否相同</li></ul><p>其实 <strong>CAS</strong> 的底层是 <strong>lock cmpxchg 指令（X86 架构）</strong>，在单核 CPU 和多核 CPU 下都能够保证比较-交换的原子性。<br>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p><h3 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h3><p>在上面代码中的<strong>AtomicInteger</strong>类，内部的<strong>value</strong>属性使用了<strong>volatile</strong> 修饰。获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰，这样能保证线程对属性的修改对其他线程可见。(volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>使用<strong>CAS</strong>+重试无锁情况下，即使重试失败，<strong>线程</strong>始终在<strong>高速运行</strong>，没有停歇，而 <strong>synchronized</strong>会让线程在没有获得锁的时候，发生<strong>上下文切换</strong>，进入<strong>阻塞</strong>。</p><p>打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</p><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p><p>因此，CAS这种方式也比较依靠CPU核心数，如果CPU核心数不够，即使有再多的线程，线程分不到时间片，一样会阻塞住，一样会上下文切换，所以最好线程数不要大于CPU核心数。</p><h3 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，<strong>适用于线程数少、多核 CPU</strong> 的场景下。</p><p><strong>CAS</strong> 是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，那就再尝试一次。<br><strong>synchronized</strong>是基于<strong>悲观锁</strong>的思想：最悲观的估计，保证不让其它线程来修改共享变量，上了锁其他线程都不能操作，修改完了解开锁，其他线程才有机会。<br><strong>CAS 体现的是无锁并发、无阻塞并发</strong>，因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一，**但如果竞争激烈(写操作多)**，可以想到重试必然频繁发生，反而效率会受影响</p><h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p><strong>java.util.concurrent.atomic</strong>提供的是一些原子类，</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p>上面三个类提供的方法几乎相同，以 <strong>AtomicInteger</strong>为例。<br>通过观察源码可以发现AtomicInteger 内部是通过cas的来实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">    System.out.println(i.getAndIncrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">    System.out.println(i.incrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">    System.out.println(i.decrementAndGet());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">    System.out.println(i.getAndDecrement());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">    System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line">    <span class="comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">    <span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line">    <span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">    System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span></span><br><span class="line">    System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i.getAndAccumulate(10, (p, x) -&gt; p + x)</code>：函数式编程接口，(p, x) -&gt; p + x做为一个参数可以理解为实现了某一种方法，这种方式就是返回p+x的值</p><p><code>updateAndGet</code>方法的实现：实际上是相当于把匿名内部类简化了一下，以函数式的风格就可以调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    updateAndGet(i, <span class="keyword">new</span> IntUnaryOperator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(<span class="keyword">int</span> operand)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> operand / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i.get()); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateAndGet</span><span class="params">(AtomicInteger i, IntUnaryOperator operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = i.get(); <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">int</span> next = operator.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span> (i.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子引用-AtomicReference"><a href="#原子引用-AtomicReference" class="headerlink" title="原子引用 (AtomicReference)"></a>原子引用 (AtomicReference)</h2><p>原子引用保证引用类型的共享变量是线程安全的，刚才的是规定了数据类型比如为Integer</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicMarkableReference</code>：原子更新带有版本号的引用类型。用版本号一般是整型来标识是否被修改过，用来解决 ABA 问题。</li><li><code>AtomicStampedReference</code> 原子更新带有标记的引用类型。该类并不关心中途修改了多少次，只关心有没有修改过，所以只需要用一个 boolean 标记与引用关联起来，可以解决ABA 问题。</li></ul><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>ABA问题就是说在采用原子类型操作的时候，比如如果用上面的AtomicInteger，一个线程想把1改为3，但这个线程成功之前，线程2先把1改为了2，然后某个线程又把2改回了1，这时候想改为3的线程虽然也能改成功，因为它从主存中获取到的值仍然为1，但是实际上已经被其他线程修改过了，这就是ABA问题，简单点来说就是A修改到B后又修改回了A，但是其他线程并不知道修改过了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String pre = ref.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//把ref中的A改为C，也会修改成功，这就是ABA问题 仍然是true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C &quot;</span> + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 线程start后主线程sleep了，所以这个线程把A-&gt;B，并且能改成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 再将B-&gt;A，同样也能修改成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A &quot;</span> + ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicStampedReference-版本号解决ABA问题"><a href="#AtomicStampedReference-版本号解决ABA问题" class="headerlink" title="AtomicStampedReference (版本号解决ABA问题)"></a>AtomicStampedReference (版本号解决ABA问题)</h3><p><strong>AtomicStampedReference</strong> 可以加一个版本号，来解决ABA问题，在构造的时候初始化一个版本号，如果有线程修改了就版本号加1，这样其他线程就能根据这个版本号来判断是否被修改过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String pre = ref.getReference();</span><br><span class="line">            <span class="comment">//获得版本号</span></span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp(); <span class="comment">// 此时的版本号还是第一次获取的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                other();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把ref中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;C stamp &quot;</span> + stamp + ref.compareAndSet(pre, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change A-&gt;B stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;change B-&gt;A stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicMarkableReference-boolean解决ABA问题"><a href="#AtomicMarkableReference-boolean解决ABA问题" class="headerlink" title="AtomicMarkableReference (boolean解决ABA问题)"></a>AtomicMarkableReference (boolean解决ABA问题)</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; </p><p>A -&gt;C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，就可以使用<strong>AtomicMarkableReference</strong></p><h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><p><strong>原子数组用来保证数组内的元素的线程安全，使用原子的方式更新数组里的某个元素</strong></p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><p>下面<strong>不安全的示例</strong>中采用了函数式编程，可以理解为demo(…)方法里的参数，都是一种方法，在调用demo方法的时候实现好方法的内容，然后直接返回给参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        demo(</span><br><span class="line">                () -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>],</span><br><span class="line">                array -&gt; array.length,</span><br><span class="line">                (array, index) -&gt; array[index]++,</span><br><span class="line">                array -&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment">     * 参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment">     * 参数3，自增方法，回传 array, index</span></span><br><span class="line"><span class="comment">     * 参数4，打印数组的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line">    <span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line">    <span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;void</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;T, Integer&gt; putConsumer, </span></span></span><br><span class="line"><span class="function"><span class="params">        Consumer&lt;T&gt; printConsumer)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        T array = arraySupplier.get();</span><br><span class="line">        <span class="keyword">int</span> length = lengthFun.apply(array);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建10个线程, 每个线程对数组作 10000 次操作</span></span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    putConsumer.accept(array, j % length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ts.forEach(t -&gt; t.start()); <span class="comment">// 启动所有线程</span></span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 等所有线程结束</span></span><br><span class="line"></span><br><span class="line">        printConsumer.accept(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安全的实现只需要用AtomicIntegerArray数组来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo(</span><br><span class="line">        ()-&gt; <span class="keyword">new</span> AtomicIntegerArray(<span class="number">10</span>),</span><br><span class="line">        (array) -&gt; array.length(),</span><br><span class="line">        (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">        array -&gt; System.out.println(array)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><p><strong>保证多线程访问同一个对象的成员变量时，成员变量的线程安全性。</strong></p><ul><li>AtomicReferenceFieldUpdater：引用类型</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>注意：利用字段更新器，可以针对对象的某个域或者叫属性（Field）进行原子操作，但是<strong>属性需要被volatile 修饰</strong>，否则会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Must be <span class="keyword">volatile</span> type</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicFieldTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">// 获得原子更新器</span></span><br><span class="line">      <span class="comment">// 泛型</span></span><br><span class="line">      <span class="comment">// 参数1 newUpdater(类的字节码对象,被更新的属性的字节码对象,属性的名称)</span></span><br><span class="line">        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//最初为null，想要修改为&quot;张三&quot;</span></span><br><span class="line">        System.out.println(updater.compareAndSet(stu, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(updater.compareAndSet(stu, stu.name, <span class="string">&quot;王五&quot;</span>));</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子累加器-LongAddr"><a href="#原子累加器-LongAddr" class="headerlink" title="原子累加器 (LongAddr)"></a>原子累加器 (LongAddr)</h2><p>原子累加器是jdk8的新的几个类，它优化了原始原子整数的方法，能够得到更快的效率</p><ul><li>LongAddr</li><li>LongAccumulator</li><li>DoubleAddr</li><li>DoubleAccumulator</li></ul><p><strong>AtomicLong和LongAddr的性能比较</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----AtomicLong----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----LongAdder----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            demo(() -&gt; <span class="keyword">new</span> LongAdder(), adder -&gt; adder.increment());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">        T adder = adderSupplier.get();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                    action.accept(adder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(t -&gt; t.start());</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start) / <span class="number">1000_000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LongAddr性能提升的原因"><a href="#LongAddr性能提升的原因" class="headerlink" title="LongAddr性能提升的原因"></a><strong>LongAddr性能提升的原因</strong></h3><ul><li>就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 失败的次数，从而提高性能。</li></ul><p>AtomicLong等都是在一个共享资源变量上进行竞争, while(true)循环进行CAS，性能没有LongAdder高</p><h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><ul><li><strong>Unsafe</strong> 对象提供了非常底层的操作内存和线程的方法，Unsafe 对象<strong>不能直接调用</strong>，<strong>只能</strong>通过<strong>反射</strong></li><li>可以发现AtomicInteger以及其他的原子类, 底层都会使用一个Unsafe的属性</li></ul><h3 id="使用Unsafe实现原子操作"><a href="#使用Unsafe实现原子操作" class="headerlink" title="使用Unsafe实现原子操作"></a>使用Unsafe实现原子操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射获得Unsafe对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Person对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获得其属性 name 的偏移量（相对于类的属性值的地址偏移量）</span></span><br><span class="line">        <span class="keyword">long</span> nameOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="keyword">long</span> ageOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过unsafe的CAS操作改变值</span></span><br><span class="line">        unsafe.compareAndSwapObject(person, nameOffset, <span class="keyword">null</span>, <span class="string">&quot;guizy&quot;</span>);</span><br><span class="line">        unsafe.compareAndSwapInt(person, ageOffset, <span class="number">0</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配合CAS操作，必须用volatile修饰</span></span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock</title>
      <link href="/2022/02/09/JUC/ReentrantLock/"/>
      <url>/2022/02/09/JUC/ReentrantLock/</url>
      
        <content type="html"><![CDATA[<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><p>一个并发应用程序能及时执行的能力称为活跃性</p><ul><li>活跃性相关的一系列问题都可以用 ReentrantLock 进行解决。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br>如：线程1获取A对象锁, 线程2获取B对象锁; 此时线程1又想获取B对象锁, 线程2又想获取A对象锁; 它们都等着对象释放锁, 此时就称为死锁</p><h3 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h3><ol><li>互斥条件<br>在一段时间内，一种资源只能被一个进程所使用</li><li>请求和保持条件<br>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进阻塞状态，并且不释放自己已有的资源</li><li>不可抢占条件<br>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li><li>循环等待条件<br>发生死锁时，必然存在一个进程——资源的循环链</li></ol><h3 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h3><h4 id="JPS-JStack进程ID"><a href="#JPS-JStack进程ID" class="headerlink" title="JPS+JStack进程ID"></a>JPS+JStack进程ID</h4><p>首先JPS找到JVM进程，JStack +进程ID查看进程状态</p><h4 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h4><p>jconsole连接进程，检测死锁</p><h4 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h4><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li><li>当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。</li></ul><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁出现在两个线程互相改变对方的结束条件，谁也无法结束。</p><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><ul><li>某些线程因为优先级太低，导致一直无法获得资源的现象。</li></ul><ul><li>在使用顺序加锁时，可能会出现饥饿现象</li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock特点：</p><ul><li>可中断</li><li>可设置超时时间</li><li>可设置为公平锁</li><li>支持多个条件变量，根据不同条件加锁</li></ul><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line">   lock.lock();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//需要执行的代码</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//需要执行的代码</span></span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>ReentrantLock是可以中断的，调用reentrantLock. lockInterruptibly()，那么这个reentrantLock就是一个可打断的锁；如果这个锁没有竞争，那么它跟正常的lock方法是没有区别的。但是如果发生了竞争并且线程进入了阻塞队列，那么这个阻塞状态是可以被其他线程打断的。避免了一直阻塞。</p><ul><li><strong>synchronized</strong>是获得了锁以后，可以进行打断，<strong>打断正在运行的线程或者说打断在sleep，wait，join的线程</strong></li><li><strong>ReentrantLock</strong>的可<strong>打断</strong>的意思是没获得锁，前往阻塞队列，可以<strong>打断它的阻塞</strong>，<strong>避免一直获取不到锁而阻塞，可以用来避免死锁</strong>，**<code>防止死锁的思想还是避免一直等待</code>**</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//lockInterruptibly方法表示是可中断的</span></span><br><span class="line">            <span class="comment">// 也就是说reentrantLock还没获得锁，竞争后进入了阻塞队列，别的线程可以打断reentrantLock的阻塞</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有竞争这个方法跟lock()是一样的</span></span><br><span class="line">                <span class="comment">//如果有竞争进入阻塞队列，可以被其他线程打断</span></span><br><span class="line">                System.out.println(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">                reentrantLock.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有获取锁，返回&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在t1线程获取到锁前先锁住</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打断t1&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">尝试获取锁</span><br><span class="line">打断t1</span><br><span class="line">没有获取锁，返回</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly (AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly( AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">at com.zc.reentrantlock.Test.lambda$main$<span class="number">0</span>(Test.java:<span class="number">22</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>如果是reentrantLock.lock()方法，则是不可打断的；会发现先尝试获取锁，获取不到，然后就阻塞，接下来主线程打断t1，但是没有打断成功，程序一直运行。</li></ul><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p><strong>锁超时</strong>是指用ReentrantLock的**tryLock()**方法上锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>tryLock()<strong>方法返回boolean值，会</strong>先判断能否成功获取锁</strong>，不能则返回false。</li><li>**tryLock(long timeout, TimeUnit unit)**表示在一定timeout时间内去尝试获取锁，在这时间段仍获取不到锁则返回false。同样这个方法同lockInterruptibly()方法一样，也是一个可打断的方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!reentrantLock.tryLock()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取不到锁，返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    reentrantLock.lock();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t1.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trylock-解决哲学家就餐问题"><a href="#trylock-解决哲学家就餐问题" class="headerlink" title="trylock()解决哲学家就餐问题"></a>trylock()解决哲学家就餐问题</h3><p>哲学家在拿到左边的筷子的时候也就是左边筷子加锁，然后准备给右边筷子加锁，采用trylock()保证其不会一直占着左边的筷子不放，如果没能成功给右边筷子加锁，那么就会释放左边的筷子。</p><p>原来采用synchronized会产生死锁是因为synchronized给左边的的筷子加锁后，又想给右边筷子加锁，右边筷子加锁要是不成功，就不会继续往下执行，也就是不会释放左边筷子的锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哲学家就餐问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;PhilosopherEatingProblem.class&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhilosopherEatingProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Chopstick c2 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Chopstick c3 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        Chopstick c4 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Chopstick c5 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">        <span class="keyword">new</span> Philosopher(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Chopstick left;</span><br><span class="line">    <span class="keyword">final</span> Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//获得左手边筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//获得成功，获取右边筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承ReentrantLock, 让筷子类成为锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopstick</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock<strong>默认</strong>是<strong>非公平锁</strong>，可以在<strong>构造方法</strong>的时候指定其为<strong>公平锁</strong>；</p><p>在线程获取锁失败，进入阻塞队列时，先进入的会在锁被释放后先获得锁。这样的获取方式就是公平的。一般不设置ReentrantLock为公平的, 会降低并发度。</p><p>Synchronized底层的Monitor锁就是不公平的, 和谁先进入阻塞队列是没有关系的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>公平锁可以解决饥饿问题，也就是说不会存在某个线程一直获取不到锁。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li>synchronized中也有条件变量，当条件不满足的时候，进入waitSet集合，但是它的waitSet只有一个</li><li>ReentrantLock可以有多个条件变量，也就是说可以有多个waitSet，不同条件的进入不同的waitSet等待，这样可以<strong>避免虚假唤醒</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">//条件变量一</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Condition condition1= lock.newCondition();</span><br><span class="line">   <span class="comment">//条件变量2</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Condition condition2= lock.newCondition();</span><br></pre></td></tr></table></figure><ul><li>condition.await()方法进入对应条件的waitSet</li><li>condition.signal()方法唤醒对应条件的waitSet中的一个线程</li><li>condition.signalAll()方法唤醒对应条件的waitSet中的所有线程</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasTakeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 等待烟的休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitCigaretteSet = lock.newCondition();</span><br><span class="line">    <span class="comment">// 等外卖的休息室</span></span><br><span class="line">    <span class="keyword">static</span> Condition waitTakeoutSet = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小南进入到等烟的休息室</span></span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;烟来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 此时小女进入到等外卖的休息室</span></span><br><span class="line">                        waitTakeoutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖来咯, 可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送外卖的来咯~&quot;</span>);</span><br><span class="line">                hasTakeout = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等外卖的小女线程</span></span><br><span class="line">                waitTakeoutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;送烟的来咯~&quot;</span>);</span><br><span class="line">                hasCigarette = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等烟的小南线程</span></span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="顺序打印"><a href="#顺序打印" class="headerlink" title="顺序打印"></a>顺序打印</h3><ul><li>要求两个线程先打印2，再打印1</li></ul><h4 id="wait-notify实现"><a href="#wait-notify实现" class="headerlink" title="wait-notify实现"></a>wait-notify实现</h4><p>设置一个标记变量，只有2还没打印，就wait，2打印完了，唤醒1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSeqPrint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> has2Printed=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">while</span> (!has2Printed) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)</span><br><span class="line">            &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">                has2Printed=<span class="keyword">true</span>;</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock的await-signal实现"><a href="#ReentrantLock的await-signal实现" class="headerlink" title="ReentrantLock的await/signal实现"></a>ReentrantLock的await/signal实现</h4><p>不满足条件去其条件变量中等待</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (!has2Printed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">        has2Printed=<span class="keyword">true</span>;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="LockSupport的park和unpark实现"><a href="#LockSupport的park和unpark实现" class="headerlink" title="LockSupport的park和unpark实现"></a>LockSupport的park和unpark实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;打印1&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;打印2&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();;</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><ul><li>要求线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。</li></ul><h4 id="wait-notify实现-1"><a href="#wait-notify实现-1" class="headerlink" title="wait-notify实现"></a>wait-notify实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;a线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;b线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            waitNotify.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;c线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出内容    等待标记    下一个标记</span></span><br><span class="line"><span class="comment">        a           1          2</span></span><br><span class="line"><span class="comment">        b           2          3</span></span><br><span class="line"><span class="comment">        c           3          1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, <span class="keyword">int</span> waitFlag, <span class="keyword">int</span> nextFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (waitFlag != <span class="keyword">this</span>.flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                <span class="keyword">this</span>.flag = nextFlag;</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：abcabcabcabcabc</p><h4 id="condition-await-signal实现"><a href="#condition-await-signal实现" class="headerlink" title="condition.await/signal实现"></a>condition.await/signal实现</h4><p>设置3个条件变量，去各自的waitSet中等待，先让3个线程都阻塞，然后开始唤醒a，直接a唤醒b，b唤醒c</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAwaitSignal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);</span><br><span class="line">        Condition a_condition = awaitSignal.newCondition();</span><br><span class="line">        Condition b_condition = awaitSignal.newCondition();</span><br><span class="line">        Condition c_condition = awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a_condition, b_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b_condition, c_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c_condition, a_condition);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==========开始=========&quot;</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a_condition.signal();  <span class="comment">//首先唤醒a线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Condition condition, Condition next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.out.print(str);</span><br><span class="line">                    next.signal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LockSupport的park-unpark实现"><a href="#LockSupport的park-unpark实现" class="headerlink" title="LockSupport的park/unpark实现"></a>LockSupport的park/unpark实现</h4><p>先全部阻塞，然后唤醒a，接着a唤醒b，b唤醒c，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread a;</span><br><span class="line">    <span class="keyword">static</span> Thread b;</span><br><span class="line">    <span class="keyword">static</span> Thread c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkUnpark parkUnpark = <span class="keyword">new</span> ParkUnpark(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;a&quot;</span>, b);</span><br><span class="line">        &#125;, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;b&quot;</span>, c);</span><br><span class="line">        &#125;, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;c&quot;</span>, a);</span><br><span class="line">        &#125;, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkUnpark</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkUnpark</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str, Thread nextThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h2><p><img src="/../../img/markdown_img/ReentrantLock.assets/image-20220118111830515.png" alt="image-20220118111830515"></p>]]></content>
      
      
      <categories>
          
          <category> JUC并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的安全性问题</title>
      <link href="/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<ul><li>线程安全问题</li><li>synchronized保证线程安全</li><li>private或final的重要性</li><li>线程八锁问题分析</li><li>变量的线程安全分析</li></ul><h2 id="临界区与竞态条件"><a href="#临界区与竞态条件" class="headerlink" title="临界区与竞态条件"></a>临界区与竞态条件</h2><p>一个程序运行多线程本身是没有问题的，问题出现在多个线程共享资源(临界资源)的时候</p><p>多个线程同时对共享资源进行读操作本身也没有问题 - 对读操作没问题</p><p>问题出现在对对共享资源同时进行读写操作时就有问题了 - 同时读写操作有问题</p><p>先定义一个叫做临界区的概念：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为<strong>临界区</strong>; 共享资源也成为<strong>临界资源</strong></p><ul><li>多个线程在<code>临界区</code>执行，那么由于<strong>代码指令的执行不确定而导致的结果问题</strong>，称为<code>竞态条件</code></li></ul><p>为了避免临界区中的竞态条件发生，由多种手段可以达到</p><ul><li>阻塞式解决方案： synchronized , Lock (ReentrantLock)</li><li>非阻塞式解决方案： 原子变量 (CAS)</li></ul><p>使用synchronized来进行解决，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><p>注意: 虽然Java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码。同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</p><h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><ul><li>其实就是考察<code>synchronized 锁住的是哪个对象</code>, 如果锁住的是<code>同一对象</code>, 就不会出现<code>线程安全</code>问题</li></ul><h3 id="锁住同一个对象都是this，结果为：1-2或者2-1"><a href="#锁住同一个对象都是this，结果为：1-2或者2-1" class="headerlink" title="锁住同一个对象都是this，结果为：1,2或者2,1"></a>锁住同一个对象都是this，结果为：1,2或者2,1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1/2 或 2/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁住同一个对象都是this，结果为：1s后1-2-2-1s后1"><a href="#锁住同一个对象都是this，结果为：1s后1-2-2-1s后1" class="headerlink" title="锁住同一个对象都是this，结果为：1s后1,2 || 2,1s后1"></a>锁住同一个对象都是this，结果为：1s后1,2 || 2,1s后1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1s后1,2 || 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a，b锁住同一个对象都是this，c没有上锁。"><a href="#a，b锁住同一个对象都是this，c没有上锁。" class="headerlink" title="a，b锁住同一个对象都是this，c没有上锁。"></a>a，b锁住同一个对象都是this，c没有上锁。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会出现安全问题, 因为前两个线程, 执行run方法时, 都对相同的对象加锁;</span></span><br><span class="line"><span class="comment"> *              而第三个线程,调用的方法c, 并没有加锁, 所以它可以同前两个线程并行执行;</span></span><br><span class="line"><span class="comment"> *  打印结果顺序为: 分析: 因为线程3和线程1,2肯定是并行执行的, 所以有以下情况</span></span><br><span class="line"><span class="comment"> *               3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1</span></span><br><span class="line"><span class="comment"> *               至于 1,3,2的情况是不会发生的, 可以先调用到1,但需要sleep一秒.3肯定先执行了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象就是this, 也就是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象也是this, e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                e1.a();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.c()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住对象this，b锁住对象this"><a href="#a锁住对象this，b锁住对象this" class="headerlink" title="a锁住对象this，b锁住对象this"></a>a锁住对象this，b锁住对象this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会出现安全问题, 线程1的锁对象为e1, 线程2的锁对象为e2. 所以他们会同一时刻执行1,2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是e1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是e2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住的是类-b锁住的是this"><a href="#a锁住的是类-b锁住的是this" class="headerlink" title="a锁住的是类, b锁住的是this"></a>a锁住的是类, b锁住的是this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是e2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-b锁住的是类-会发生互斥"><a href="#a-b锁住的是类-会发生互斥" class="headerlink" title="a,b锁住的是类, 会发生互斥"></a>a,b锁住的是类, 会发生互斥</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span></span><br><span class="line"><span class="comment"> *              结果: 2,1s后1 || 1s后1,2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a锁住的是类-b锁住的是this-1"><a href="#a锁住的是类-b锁住的是this-1" class="headerlink" title="a锁住的是类, b锁住的是this"></a>a锁住的是类, b锁住的是this</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是this,e2对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-b锁住的是类-会发生互斥-1"><a href="#a-b锁住的是类-会发生互斥-1" class="headerlink" title="a,b锁住的是类, 会发生互斥"></a>a,b锁住的是类, 会发生互斥</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span></span><br><span class="line"><span class="comment"> * 结果: 2,1s后1 || 1s后1,2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;zc.EightLockTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象是EightLockTest.class类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightLockTest e1 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        EightLockTest e2 = <span class="keyword">new</span> EightLockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e1.a()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; e2.b()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><h3 id="成员变量和静态变量的线程安全分析"><a href="#成员变量和静态变量的线程安全分析" class="headerlink" title="成员变量和静态变量的线程安全分析"></a>成员变量和静态变量的线程安全分析</h3><p>如果变量没有在线程间共享，那么变量是安全的<br>如果变量在线程间共享<br>如果只有读操作，则线程安全<br>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p><h3 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h3><p>局部变量【局部变量被初始化为基本数据类型】是安全的<br>但<strong>局部变量引用的对象</strong>则未必线程安全 （要看该对象是否被共享且被执行了读写操作）</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul><li>如果<code>局部变量引用的对象逃离方法的范围</code>，那么<code>要考虑线程安全问题</code>的，代码示例如下</li></ul><blockquote><p>循环创建了100个线程, 在线程体里面都调用了method1方法, 在method1方法中又循环调用了100次method2,method3方法，也即是arrayList 的add和remove；这里的arrayList 是多线程中共享的变量，因为都是unsafeTest，对于这个共享的变量，虽然arrayList 的操作是加了同步代码块的，但是arrayList.add()和arrayList.remove()并不能保证也是同步的，这样必然会出现线程安全问题，最后以异常的形式抛出。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeTest unsafeTest = <span class="keyword">new</span> UnsafeTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                unsafeTest.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;线程1&quot;</span> Exception in thread <span class="string">&quot;线程2&quot;</span> java.lang.ArrayIndexOutOfBoundsException: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>解决方法就是可以将arrayList作为局部变量，放在method1内部，这样arrayList就可以认为是一个线程私有的。局部变量存放在<strong>栈帧</strong>中, 栈帧又存放在<code>虚拟机栈</code>中, <strong>虚拟机栈是作为线程私有的;</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            method2(arrayList);</span><br><span class="line">            method3(arrayList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(List&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        arrayList.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(List&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private-或-final的作用"><a href="#private-或-final的作用" class="headerlink" title="private 或 final的作用"></a><code>private</code> 或 <code>final</code>的作用</h3><p>使用这两个修饰符可以提高线程的安全性，private和final让子类不能重写父类的方法，当我们的方法如果是public，也即是上面的代码method2,method3都是public时，虽然上面代码不会出现线程安全问题，如果有一个子类继承了这个UnsafeTest类，然后又因为是public方法，就可以重写覆盖父类的方法，此时在子类中开多线程操作list对象，就有可能造成线程安全问题：子类和父类共享了list对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSafe threadSafe = <span class="keyword">new</span> ThreadSafeSubClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                threadSafe.method1(<span class="number">10</span>);</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见线程安全类-1"><a href="#常见线程安全类-1" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类 JUC</li></ul><p>这里说它们是线程安全的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong> , 也可以理解为 <strong>它们的每个方法是原子的</strong>，因为方法都被加上了synchronized</p><p>但注意它们的<code>多个方法的组合不是原子的</code>，所以可能<strong>会出现线程安全问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> JUC并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/01/17/JUC/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程与进程、并行并发、同步异步概念"><a href="#线程与进程、并行并发、同步异步概念" class="headerlink" title="线程与进程、并行并发、同步异步概念"></a>线程与进程、并行并发、同步异步概念</h2><ul><li>线程创建</li><li>线程重要api，如start，run，sleep, join，interrupt等</li><li>线程状态</li><li>应用方面<ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li>原理方面<ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式的源码</li></ul></li><li><font color="green">模式方面</font><ul><li>两阶段终止</li></ul></li></ul><h2 id="进程与进程"><a href="#进程与进程" class="headerlink" title="进程与进程"></a>进程与进程</h2><p>进程: 资源分配的最小单位</p><p>进程是线程的容器, 一个进程中包含多个线程, 真正执行任务的是线程<br>线程: 资源调度的最小单位</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序由指令和数据组成，但是这些 指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令,管理内存,管理IO的<br>当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程<br>进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程之内可以分为多个线程。<br>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行<br>Java 中，线程作为资源的最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。</p><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集<br>进程拥有共享的资源，如内存空间等，供其内部的线程共享; 进程间通信较为复杂<br>同一台计算机的进程通信称为 IPC（Inter-process communication）<br>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP<br>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<br>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>并发: 在单核CPU下, 一定是并发执行的, 也就是在同一个时间段内一起执行. 实际还是串行执行, CPU的时间片切换非常快, 给人一种同时运行的感觉。</p><p>并行: 在多核CPU下, 能真正意义上实现并行执行, 在同一个时刻, 多个线程同时执行; 比如说2核cpu, 同时执行4个线程. 理论上同时可以有2个线程是并行执行的. 此时还是存在并发, 因为2个cpu也会同时切换不同的线程执行任务罢了</p><h3 id="并发-concurrent"><a href="#并发-concurrent" class="headerlink" title="并发 (concurrent)"></a>并发 (concurrent)</h3><p>微观串行, 宏观并行<br>在单核 cpu下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于cpu 在线程间（时间片很短）的切换非常快，给人的感觉是同时运行的 。一般会将这种线程轮流使用 CPU的做法称为并发（concurrent）<br>将线程轮流使用cput称为并发(concurrent)</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p><h3 id="二者对比-1"><a href="#二者对比-1" class="headerlink" title="二者对比"></a>二者对比</h3><p>引用 Rob Pike 的一段描述：<br>并发（concurrent）: 是同一时间应对（dealing with）多件事情的能力<br>并行（parallel）: 是同一时间动手做（doing）多件事情的能力<br>例子</p><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发<br>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）<br>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是 并行</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>以调用方的角度讲</p><ul><li>如果需要等待结果返回才能继续运行的话就是同步</li><li>如果不需要等待就是异步</li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这5秒cpu什么都做不了，其它代码都得暂停</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>UI 程序中，开线程进行其他操作，避免阻塞 UI 线程</li></ul><h2 id="线程的创建-重点"><a href="#线程的创建-重点" class="headerlink" title="线程的创建 (重点)"></a>线程的创建 (重点)</h2><h3 id="创建一个线程（非主线程）"><a href="#创建一个线程（非主线程）" class="headerlink" title="创建一个线程（非主线程）"></a>创建一个线程（非主线程）</h3><h4 id="通过继承Thread创建线程"><a href="#通过继承Thread创建线程" class="headerlink" title="通过继承Thread创建线程"></a>通过继承Thread创建线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">myThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用继承方式的好处是，在run()方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread()方法；不好的地方是<strong>Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</strong></li></ul><h4 id="使用Runnable配合Thread-推荐"><a href="#使用Runnable配合Thread-推荐" class="headerlink" title="使用Runnable配合Thread (推荐)"></a>使用Runnable配合Thread (推荐)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread2</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;my runnable running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">      thread.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</li></ul><h5 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h5><ul><li><p>当一个接口带有**@FunctionalInterface**注解时，是可以使用lambda来简化操作的</p></li><li><p>所以方法二中的代码可以被简化为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="comment">//直接写方法体即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Thread-与-Runnable的关系"><a href="#Thread-与-Runnable的关系" class="headerlink" title="Thread 与 Runnable的关系"></a>Thread 与 Runnable的关系</h5><p>分析 Thread 的源码，查看与 Runnable 的关系，可以发现采用Runnable的方式最终new Thread的时候最终就是把实现Runnable作为Thread中的target成员，然后判断如果target不为null，就运行target的run()方法，也就是Runnable的run方法。</p><ul><li>继承Thread方式: 是把线程和任务合并在了一起</li><li>实现Runnable方式: 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h4 id="使用FutureTask与Thread结合"><a href="#使用FutureTask与Thread结合" class="headerlink" title="使用FutureTask与Thread结合"></a>使用FutureTask与Thread结合</h4><p>使用<strong>FutureTask可以用泛型指定线程的返回值类型</strong>（Runnable的run方法没有返回值），FutureTask实现了RunnableFuture，FutureRunable继承了Runnable接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread r1 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">r1.start();</span><br><span class="line"><span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseFutureTask</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">      FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCall());</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">      thread.start();</span><br><span class="line">      <span class="comment">// 获得线程运行后的返回值</span></span><br><span class="line">      System.out.println(futureTask.get());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用线程池来创建线程"><a href="#使用线程池来创建线程" class="headerlink" title="使用线程池来创建线程"></a>使用线程池来创建线程</h4><p>创建线程的方式四：使用线程池</p><p>好处：</p><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p></li></ol><ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：创建多线程有几种方式？四种！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：创建多线程有几种方式？四种！"><a href="#面试题：创建多线程有几种方式？四种！" class="headerlink" title="面试题：创建多线程有几种方式？四种！"></a>面试题：创建多线程有几种方式？四种！</h4><p>总结</p><ul><li>使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</li><li>开发中一般使用线程池的方式</li></ul><h2 id="三、Linux-Windows命令查看进程和线程"><a href="#三、Linux-Windows命令查看进程和线程" class="headerlink" title="三、Linux Windows命令查看进程和线程"></a>三、Linux Windows命令查看进程和线程</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul><li>任务管理器查看进程和线程，杀死进程</li><li> <code>tasklist</code> 查看进程</li><li><code>taskkill /F /PID 进程号</code> 杀死进程</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><code>ps -fe </code>查看所有进程</li><li><code>ps -ft -p &lt;PID&gt;</code> 查看某个进程的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>pkill -9 &lt;PID&gt;</code> 杀死进程，-9代表一类操作，杀死进程</li><li><code>top</code> 查看进程信息</li><li><code>top -H -P &lt;PID&gt;</code> 查看某个进程PID的所有线程</li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><code>jps</code> 查看所有Java进程</li><li><code>jstack &lt;PID&gt;</code> 查看某个Java进程的所有线程状态</li><li><code>jconsole</code> 连接查看某个Java进程中线程的运行情况（Windows直接win+r 输入jconsole，图形界面）</li></ul><h2 id="线程运行原理-重点"><a href="#线程运行原理-重点" class="headerlink" title="线程运行原理 (重点)"></a>线程运行原理 (<code>重点</code>)</h2><h3 id="虚拟机栈与栈帧"><a href="#虚拟机栈与栈帧" class="headerlink" title="虚拟机栈与栈帧"></a>虚拟机栈与栈帧</h3><ul><li>虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法被执行</strong>的时候都会同时创建一个<strong>栈帧(stack frame)<strong>用于</strong>存储局部变量表</strong>、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。当Java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧(在栈顶)，<strong>对应着当前正在执行的那个方法</strong>。</li><li>每个线程都拥有自己的一个栈内存，里面对应着多个栈帧。可以用IDEA开启线程模式的调试功能。</li></ul><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101108334.png" alt="image-20220115101108334"></p><p>t1线程的多个栈帧：</p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115100910857.png" alt="image-20220115100910857"></p><p>主线程的多个栈帧：</p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115101011097.png" alt="image-20220115101011097"></p><h3 id="线程上下文切换（Thread-Context-Switch"><a href="#线程上下文切换（Thread-Context-Switch" class="headerlink" title="线程上下文切换（Thread Context Switch)"></a>线程上下文切换（Thread Context Switch)</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程</p><ul><li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当Thread Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>线程的状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能，所以线程数也不能过多，如果线程数大于CPU核心数，可能并不会提升性能</li></ul><h3 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h3><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111642378.png" alt="image-20220115111642378"></p><p><img src="/../../img/markdown_img/%E7%BA%BF%E7%A8%8B.assets/image-20220115111913619.png" alt="image-20220115111913619"></p><h4 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h4><h5 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h5><p>调用 sleep() 会让当前线程从 Running(运行状态) 进入 Timed Waiting 状态（阻塞）<br>其它线程可以使用interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 InterruptedException异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】<br>睡眠结束后的线程未必会立刻得到执行 (需要分配到cpu时间片)<br>建议用 TimeUnit 的 sleep() 代替 Thread 的 sleep()来获得更好的可读性</p><h5 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h5><p>调用 yield 会让当前线程从Running 进入 Runnable 就绪状态，然后调度执行其它线程</p><p>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</p><p>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>线程<code>优先级</code>会<code>提示（hint）调度器优先调度该线程</code>，但它仅仅是一个提示，调度器可以忽略它, 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><ul><li>在<code>主线程</code>中调用<code>t1.join</code>，则<code>主线程</code>会<code>等待t1线程执行完之后</code>再<code>继续执行</code></li></ul><h4 id="interrupt-方法详解"><a href="#interrupt-方法详解" class="headerlink" title="interrupt 方法详解"></a>interrupt 方法详解</h4><p>该方法用于打断 sleep，wait，join的线程, 在阻塞期间cpu不会分配给时间片</p><ul><li><p>如果一个线程在在运行中被打断，打断标记会被置为true</p></li><li><p>如果是打断因sleep wait join方法而被阻塞的线程，只是会抛出一个Interrupted 异常，以这个异常来表示线程被打断了，打断标记仍然是false</p></li></ul><p>sleep，wait，join的线程，这几个方法都会让线程进入阻塞状态，join方法底层就是用的wait方法，以 sleep 为例，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>); <span class="comment">// wait, join</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;iterrupt..&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.isInterrupted()); <span class="comment">// 如果是打断sleep,wait,join的线程, 即使打断了, 标记也为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sleep...</span><br><span class="line">iterrupt..</span><br><span class="line">打断标记为:<span class="keyword">false</span></span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at com.zc.ThreadPrintDemo.lambda$main$<span class="number">0</span>(ThreadPrintDemo.java:<span class="number">14</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h5><ul><li>调用Interrupt方法去打断一个正在运行的线程，就好比是一个打断请求，只是把其打断标记记为True，实际上是不是要被打断由线程自己决定，线程并不会直接暂停。我们可以判断<code>Thread.currentThread().isInterrupted();</code>的值来手动停止线程</li><li>这样可以方便当线程被打断时做一些后续的操作，料理线程后事</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被打断了, 退出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;打断标记为: &quot;</span>+t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interrupt</span><br><span class="line">被打断了, 退出循环</span><br><span class="line">打断标记为: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="终止模式之两阶段终止模式-多线程设计模式"><a href="#终止模式之两阶段终止模式-多线程设计模式" class="headerlink" title="终止模式之两阶段终止模式(多线程设计模式)"></a>终止模式之两阶段终止模式(多线程设计模式)</h4><p>当我们在执行线程一时，想要终止线程二，这时就需要使用interrupt方法来优雅的停止线程二。</p><h5 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h5><ul><li><p>使用线程对象的stop()方法停止线程</p><p>stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</p></li><li><p>使用System.exit(int)方法停止线程</p><p>目的仅是停止一个线程，但这种做法会让整个程序都停止</p></li></ul><p>如下所示：那么线程的isInterrupted()方法可以取得线程的打断标记</p><p>如果线程在睡眠sleep期间被打断，打断标记是不会变的，为false，但是sleep期间被打断会抛出异常，我们据此手动设置打断标记为true；<br>如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为true。处理好这两种情况那我们就可以放心地来料理后事啦！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Monitor monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">monitor.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">monitor.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置线控器线程，用于监控线程状态</span></span><br><span class="line">monitor = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//开始不停的监控</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">//判断当前线程是否被打断了</span></span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;处理后续任务&quot;</span>);</span><br><span class="line">                        <span class="comment">//终止线程执行</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;监控器运行中...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//线程休眠</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span></span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">monitor.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于停止监控器线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//打断线程</span></span><br><span class="line">monitor.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sleep，yiled，wait，join-对比"><a href="#sleep，yiled，wait，join-对比" class="headerlink" title="sleep，yiled，wait，join 对比"></a>sleep，yiled，wait，join 对比</h4><ul><li>sleep，join，yield，interrupted是Thread类中的方法</li><li>wait/notify是object中的方法</li><li>sleep 不释放锁、释放cpu</li><li>join 释放锁、抢占cpu</li><li>yiled 不释放锁、释放cpu</li><li>wait 释放锁、释放cpu</li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>当Java进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，Java进程才会结束。但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</p><p>注意:</p><p>垃圾回收器线程就是一种守护线程<br>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会继续等待</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即Thread thread = new Thread();，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行</p><ul><li>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li><p>阻塞状态<br>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】<br>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p><p>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</p></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h3 id="Java-API层面"><a href="#Java-API层面" class="headerlink" title="Java API层面"></a>Java API层面</h3><p>根据<code>Thread.State 枚举，分为六种状态</code></p><ul><li><strong><code>新建状态</code>、<code>运行状态</code>(就绪状态, 运行中状态)、<code>阻塞状态</code>、<code>等待状态</code>、<code>定时等待状态</code>、<code>终止状态</code></strong></li></ul><ul><li><strong>NEW (新建状态)</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE (运行状态)</strong> 当调用了 start() 方法之后，注意，Java API 层面的<strong>RUNNABLE 状态</strong>涵盖了操作系统层面的 <strong>【就绪状态】、【运行中状态】和【阻塞状态】</strong>（由于 BIO 导致的线程阻塞，比如在读取文件时的操作系统层面的阻塞，也认为是运行状态，在 Java 里无法区分，仍然认为是可运行）</li><li><strong>BLOCKED (阻塞状态)</strong> ， <strong>WAITING (等待状态)</strong> ， <strong>TIMED_WAITING(定时等待状态)</strong> 都是 Java API 层面对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。</li><li><strong>TERMINATED (结束状态)</strong> 当线程代码运行结束</li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized底层原理</title>
      <link href="/2022/01/17/JUC/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/"/>
      <url>/2022/01/17/JUC/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</url>
      
        <content type="html"><![CDATA[<ul><li>Synchronized底层原理</li><li>Monitor 监视器、管程</li><li>轻量级锁</li><li>重量级锁</li><li>偏向锁</li></ul><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p><strong>对象头</strong>包含两部分：Mark Word和<strong>类型指针</strong> (Klass Word)</p><ol><li>Mark Word<ul><li>哈希值（HashCode），可以看作是堆中对象的地址</li><li>GC分代年龄（年龄计数器） (用于新生代from/to区晋升老年代的标准, 阈值为15)</li><li>锁状态标志 (用于JDK1.6对synchronized的优化 -&gt; 轻量级锁)</li><li>线程持有的锁</li><li>偏向线程ID (用于JDK1.6对synchronized的优化 -&gt; 偏向锁)</li><li>偏向时间戳</li></ul></li><li>类型指针<ul><li>确定该对象所属的类型。指向的其实是方法区中存放的类元信息<code>Class</code>字节码信息</li></ul></li></ol><p>说明：<strong>如果对象是数组，还需要记录数组的长度</strong></p><ul><li>以 <strong>32 位虚拟机</strong>为例,普通对象的对象头结构如下，其中的Klass Word为类型指针，指向方法区`对应的Class对象；</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230503852.png" alt="image-20220115230503852"></p><ul><li>数组对象</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230515921.png" alt="image-20220115230515921"></p><ul><li><strong>其中 Mark Word 结构为: 无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)</strong></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230553563.png" alt="image-20220115230553563"></p><ul><li>所以一个对象的结构如下：</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115230631675.png" alt="image-20220115230631675"></p><h2 id="Monitor-原理-Synchronized底层实现-重量级锁"><a href="#Monitor-原理-Synchronized底层实现-重量级锁" class="headerlink" title="Monitor 原理 (Synchronized底层实现-重量级锁)"></a>Monitor 原理 (Synchronized底层实现-重量级锁)</h2><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p><strong>多线程同时访问临界区: 使用重量级锁</strong></p><ul><li>JDK6对Synchronized的优先状态：<code>偏向锁–&gt;轻量级锁–&gt;重量级锁</code></li></ul><p>每个Java对象都可以关联一个(操作系统的)<strong>Monitor</strong>。如果使用synchronized给对象上锁（<strong>重量级</strong>），该对象头的MarkWord中就被设置为指向Monitor对象的指针。</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220115231347421.png" alt="image-20220115231347421"></p><p>上图是关联Monitor的原理图，可以理解为：</p><ul><li>Thread2最初执行到<strong>锁对象synchronized(obj)<strong>，会尝试让锁对象synchronized(obj)<strong>关联Monitor</strong>，如果</strong>关联成功</strong>，则将obj对象头的<strong>MarkWord</strong>字段<strong>指向Monitor的地址</strong>，同时将其后两位从<strong>00</strong>设置为10，<strong>Thread2</strong>会成为对应Monitor的<strong>Owner</strong>；</li><li>后续有<strong>Thread1</strong>也执行到了synchronized(obj)，会检查发现obj<strong>已经</strong>有了一个关联的monitor，其<strong>Owner为Thread2</strong>，然后Thread1也会同Monitor关联起来，只不过是<strong>和EntryList关联</strong>，会进入Monitor的EntryList<strong>阻塞（BLOCKED）</strong>起来，等待；</li><li>当<strong>Thread2执行完</strong>临界区代码后，Monitor的Owner就会空出来，此时就会<strong>通知EntryList阻塞队列</strong>的线程，这些线程经过<strong>竞争</strong>，得出新的<strong>Owner</strong>；</li><li>图中 WaitSet 中的线程是之前获得过锁，但条件不满足调用锁对象的wait方法进入 WAITING 状态的线程</li></ul><p><strong>注意：</strong></p><ul><li>synchronized 必须是进入同一个锁对象的 Monitor 才有上述的效果；也就要使用同一把锁</li><li>不加 synchronized的锁对象不会关联监视器，不遵从以上规则</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>它加锁就是依赖底层操作系统的 <code>mutex</code>相关指令实现, 所以会造成<code>用户态和内核态之间的切换</code>, 非常耗性能 !</p><ul><li>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗。</li></ul><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反编译的字节码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">stack&#x3D;2，locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">0: getstatic#2&#x2F;&#x2F; &lt;- lock引用( synchronized开始)</span><br><span class="line">3: dup</span><br><span class="line">4: astore_1&#x2F;&#x2F; lock引用-&gt; slot 1</span><br><span class="line">5: monitorenter&#x2F;&#x2F; 将lock对象Markword置为Monitor指针</span><br><span class="line">6: getstatic#3&#x2F;&#x2F; &lt;- i</span><br><span class="line">9: iconst_1&#x2F;&#x2F; 准备常数1</span><br><span class="line">10: iadd&#x2F;&#x2F; +1</span><br><span class="line">11: putstatic#3&#x2F;&#x2F; -&gt; i</span><br><span class="line">14: aload_1&#x2F;&#x2F; &lt;- lock引用</span><br><span class="line">15: monitorexit&#x2F;&#x2F; 将lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">16: goto24</span><br><span class="line">19: astore_2&#x2F;&#x2F; e -&gt; slot 2</span><br><span class="line">20: aload_1&#x2F;&#x2F; &lt;- lock引用</span><br><span class="line">21: monitorexit&#x2F;&#x2F; 将lock对象MarkWord重置，唤醒EntryList</span><br><span class="line">22: aload_2&#x2F;&#x2F; &lt;- slot 2 (e)</span><br><span class="line">23: athrow&#x2F;&#x2F; throw e</span><br><span class="line">24: return</span><br><span class="line">    Exception table:</span><br><span class="line">        fromtotargettype</span><br><span class="line">            61619any</span><br><span class="line">            192219any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 6</span><br><span class="line">        line 10: 14</span><br><span class="line">        line 11: 24</span><br><span class="line">    LocalVariableTable:</span><br></pre></td></tr></table></figure><p>上面除了体现了正常执行的代码以外，还体现了异常情况。在16的时候goto到24。Exception table描述了异常的情况处理从19到22。</p><p>方法级别的 synchronized 不会在字节码指令中有所体现</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗。所以MarkWord对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁</p><p>轻量级锁用于优化重量级锁</p><p>通过<code>锁记录</code>的方式, 场景 : <strong>多个线程交替进入临界区</strong></p><ul><li><strong><code>轻量级锁的使用场景</code>: 如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用<code>轻量级锁来进行优化</code>。</strong></li></ul><ul><li>轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code> (jdk6对synchronized的优化)，假设有两个方法同步块，利用同一个对象加锁</li></ul><p>在method1加完锁的同时，调用了method2又会加锁synchronized(obj)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 A</span></span><br><span class="line">         method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">         <span class="comment">// 同步块 B</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次执行到synchronized代码块时，都会在<code>栈帧中</code>创建<code>锁记录（Lock Record）对象</code>，锁记录内部最开始储存的是<code>lock record的地址 00</code>和<code>锁对象引用reference</code>。还有一个Object锁对象，锁对象头中存储的<strong>MarkWord</strong>（MarkWord包含了HashCode，分代年龄，偏向锁，加锁状态位），Klass Word表示是哪一类的对象。</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092015889.png" alt="image-20220116092015889"></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092231673.png" alt="image-20220116092231673"></p><ul><li>让锁记录中的<strong>Object reference</strong>指向<strong>锁对象地址</strong>，并且尝试用<strong>CAS(compare and swap)<strong>将栈帧中的</strong>锁记录的的地址</strong>(lock record 地址 00)替换Object对象的<strong>Mark Word</strong>，将Mark Word 的值存入锁记录原先存地址的地方(lock record地址 00)，这个交换是一个原子性的操作。这两个字段的后两位标识着一个状态，起到一个标志作用。01表示无锁，00表示轻量级锁，所以在交换成功后，Object存Mark Word的地方后两位就变成了00，就是一个轻量级锁的状态</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116092637419.png" alt="image-20220116092637419"></p><p>如果cas<strong>替换成功</strong>，那么对象的对象头储存的就是锁记录的地址和状态00，表示由该线程给对象加锁</p><ul><li>线程中锁记录，记录了锁对象的锁状态标志；锁对象的对象头中存储了锁记录的地址和状态, 标志哪个线程获得了锁</li><li>此时栈帧中存储了对象的对象头中的锁状态标志,年龄计数器,哈希值等; 对象的对象头中就存储了栈帧中锁记录的地址和状态00, 这样的话对象就知道了是哪个线程锁住自己。</li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116093326551.png" alt="image-20220116093326551"></p><p>如果cas<strong>替换失败</strong>，有两种情况 : ① 锁膨胀 ② 重入锁失败</p><p>1、如果是其它线程已经持有了该Object的轻量级锁（观察到Object对象头中已经存储了别的线程的锁记录地址 00,指向了其他线程），表示有竞争，将进入锁膨胀阶段</p><p>2、如果是自己的线程已经执行了synchronized进行加锁，那么再添加一条 Lock Record 作为重入锁的计数，同样按照正常的流程去cas交换，但这次交换肯定是失败的，发现这个锁是自己这个线程加的，其中记录锁地址的地方为null。（线程多次加锁, <strong>锁重入</strong>）</p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116093748640.png" alt="image-20220116093748640"></p><p>在上面代码中,临界区中又调用了method2，method2中又进行了一次synchronized加锁操作， 此时就会在虚拟机栈中再开辟一个method2方法对应的栈帧(栈顶)， 该栈帧中又会存在一个独立的Lock Record，此时它发现对象的对象头中指向的就是自己线程中栈帧的锁记录; 加锁也就失败了。这种现象就叫做<strong>锁重入</strong>，线程中有多少个锁记录，就能表明该线程对这个对象加了几次锁 (锁重入计数)</p><ul><li><p>当<code>线程退出synchronized代码块</code>的时候，如果获取的是取值为 null 的锁记录，表示有<code>锁重入</code>，这时重置锁记录，表示重入计数减一</p></li><li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null；那么使用cas将Mark Word的值恢复给对象，将直接替换的内容还原。</p><ul><li>成功则解锁成功 (轻量级锁解锁成功)</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程 (Monitor流程)</li></ul></li></ul><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>锁膨胀就是当Thread0已经让某个对象加了轻量级锁，Thread0里的锁记录存着对象的MarkWord，锁对象obj的MarkWord又存着锁记录的地址，这个时候有一个Thread1也执行到了synchronized，也想对obj进行加锁，但是肯定是加锁失败的，Thread1发现锁对象的MarkWord里已经是00了，即已经是轻量级锁了。</p><ul><li><p><strong>因为轻量级锁没有阻塞队列的概念，因此会进入锁膨胀的过程，让锁成为一个重量级锁。</strong>这时Thread1就会为锁对象obj申请一个monitor，让obj的MarkWord执行monitor的地址，并且后两位为01表示重量级锁，monitor将Owner设为Thread0，Thread1则进入Monitor的EntryList阻塞起来</p></li><li><p>在<strong>Thread0执行完毕</strong>后，想要恢复锁记录的地址和MarkWord的时候，肯定会恢复失败，发现原来obj的MarkWord已经是<strong>01重量级锁</strong>了，即进行了<strong>锁膨胀</strong>，因此Thread0<strong>进入重量级锁的解锁流程</strong>，会根据<strong>obj的MarkWord</strong>（这时指向的是对象obj的Monitor）找到对应的monitor，将monitor的Owner设为空，<strong>唤醒EntryList</strong>中的<strong>Thread1</strong>。</p></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116100043133.png" alt="image-20220116100043133"></p><h2 id="自旋锁优化（优化重量级锁竞争）"><a href="#自旋锁优化（优化重量级锁竞争）" class="headerlink" title="自旋锁优化（优化重量级锁竞争）"></a>自旋锁优化（优化重量级锁竞争）</h2><ul><li>发生<strong>重量级锁竞争</strong>的时候，还可以使用<strong>自旋</strong>来进行优化 (不加入Monitor的阻塞队列EntryList中)，如果当前线程<strong>自旋成功</strong>（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以<strong>不用进行上下文切换</strong>(持锁线程执行完synchronized同步块后，释放锁，Owner为空，唤醒阻塞队列来竞争，胜出的线程得到cpu执行权的过程) 就获得了锁</li><li>优化的点: <strong>不用将线程加入到阻塞队列, 减少cpu切换</strong>。</li></ul><p><strong>自旋成功的情况：</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116101816612.png" alt="image-20220116101816612"></p><p><strong>自旋失败的情况：</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116101902140.png" alt="image-20220116101902140"></p><ul><li><p><strong>自旋会<code>占用 CPU 时间</code>，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势</strong>。</p></li><li><p>在 <code>Java 6 之后自旋锁是自适应</code>的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能。</p></li></ul><h2 id="偏向锁-biased-lock-用于优化轻量级锁重入"><a href="#偏向锁-biased-lock-用于优化轻量级锁重入" class="headerlink" title="偏向锁 (biased lock) (用于优化轻量级锁重入)"></a>偏向锁 (biased lock) (用于优化轻量级锁重入)</h2><ul><li>场景: 没有竞争的时候, 一个线程中多次使用synchronized需要重入加锁的情况; (只有一个线程进入临界区)</li></ul><p>在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭，将进入临界区的线程的ID, 直接设置给锁对象的Mark Word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了。</p><ul><li>在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行CAS替换操作，这是有点耗时。</li><li>那么java6开始引入了偏向锁，将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了</li><li><strong>升级为轻量级锁</strong>的情况 (会进行偏向锁撤销)：获取偏向锁的时候, 发现线程ID不是自己的, 此时通过<strong>CAS替换操作, 操作成功</strong>了, 此时该线程就获得了锁对象。( <strong>此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁</strong>)</li><li><strong>升级为重量级锁</strong>的情况 (会进行偏向锁撤销) : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过<strong>CAS替换操作, 操作失败</strong>了, 此时说明发生了锁竞争。( <strong>此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁</strong>)</li></ul><h2 id="偏向、轻量级、重量级锁关系"><a href="#偏向、轻量级、重量级锁关系" class="headerlink" title="偏向、轻量级、重量级锁关系"></a>偏向、轻量级、重量级锁关系</h2><p>最开始synchronized锁只有重量级锁，依赖操作系统的mutex指令，需要用户态和内核态切换，性能损耗明显。重量级锁需要用到monitor对象，而偏向锁则是MarkWord中记录线程的ID，如果某个线程发现Mark Word线程的ID是自己，就不需cas交换锁记录地址和MarkWord。如果不是发现对象的MarkWord中线程ID不是自己，此时就需要通过CAS替换操作，如果<strong>操作成功</strong>，就说明有<strong>多个线程访问临界区</strong>，但是是<strong>交替进行</strong>的，就<strong>撤销偏向锁</strong>，<strong>升级为轻量级锁</strong>，如果<strong>操作失败</strong>，就说明有<strong>多个线程方法临界区</strong>，并且存<strong>在锁竞争</strong>，就撤销偏向锁，<strong>升级为重量级锁</strong>。</p><p><strong>偏向锁</strong>是将锁对象<strong>MarkWord的线程ID</strong>和自己的线程<strong>ID比对</strong>，<strong>轻量级锁</strong>则是将MarkWord和Lock Record进行交换，采用<strong>CAS+自旋</strong>的方式判断是否存在竞争，然后加重量级锁，<strong>重量级锁</strong>则是采用<strong>Monitor</strong>，用<strong>阻塞队列</strong>的形式，将后续线程阻塞起来。</p><ol><li>只有一个线程进入临界区—&gt;偏向锁</li><li>多个线程交替进入临界区—&gt;轻量级锁</li><li>多个线程竞争进入临界区—&gt;重量级锁</li></ol><h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p><strong>64bit虚拟机</strong></p><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116112754583.png" alt="image-20220116112754583"></p><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</li></ul><ul><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，最后2位为状态（00）</li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，最后2位为状态(10)</li></ul><p>如果开启了<strong>偏向锁</strong>（<strong>默认开启偏向锁</strong>），在创建对象时，对象的Mark Word后三位应该是101</p><p>但是偏向锁<strong>默认是有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态。如果想避免延迟，可以添加虚拟机参数来禁用延迟：</p><p><strong><code>-XX:BiasedLockingStartupDelay=0</code></strong></p><p>打印出101，这时它的hashcode、age都为0，表示它现在是一种<strong>可以偏向的状态</strong>，或者叫匿名偏向锁的状态，也就是说biased_lock位是1，可以偏向，要<strong>真正加锁</strong>还**需要加上synchronized(obj)**。</p><p>这加了synchronized(obj)之后，才是真正加了偏向锁的状态。</p><p>可以用org.openjdk.jol包打印信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">log.debug( classLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line"><span class="keyword">synchronized</span> (d)&#123;</span><br><span class="line">log.debug( ClassLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">log.debug( classLayout.parseInstance(d).toPrintable( withoutHex: <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="撤销偏向锁-hashcode方法-了解"><a href="#撤销偏向锁-hashcode方法-了解" class="headerlink" title="撤销偏向锁-hashcode方法 (了解)"></a>撤销偏向锁-hashcode方法 (了解)</h3><ul><li>测试 <code>hashCode</code>：当<code>调用对象的hashcode方法</code>的时候就会<code>撤销这个对象的偏向锁</code>，<strong>因为使用偏向锁时没有位置存<code>hashcode</code>的值了</strong></li></ul><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220116115419509.png" alt="image-20220116115419509"></p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>在下面的代码中，b方法采用了synchronized，但可以发现它加的对象锁其实并没有启到作用。</p><p>JIT即时编译器会优化热点代码，JIT借助<strong>逃逸分析</strong>发现对象o不能逃离这个方法，对这样的对象加锁是没有意义的，因此JIT即时编译器会把synchronized优化掉，进行锁消除。</p><p>我们也可以在测试的时候加上JVM参数，让它不进行锁消除，<code>-XX:-EliminateLocks</code></p><p>字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，**<code>同步省略（锁消除）操作是在解释运行时发生的</code>**</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">            x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="wait、notify"><a href="#wait、notify" class="headerlink" title="wait、notify"></a>wait、notify</h2><p><img src="/../../img/markdown_img/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.assets/image-20220117094637795.png" alt="image-20220117094637795"></p><p>Thread0线程<strong>获取到了对象Obj的锁</strong>，成为Monitor的Owner时候，发现自己执行synchronized代码块条件不满足，这时它就会调用**obj.wait()**方法，进入到Monitor的WaitSet集合，此时Thread0处于WAITING状态。</p><ul><li>处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。</li><li>但是有所区别：<ul><li>BLOCKED状态的线程是在竞争锁对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身的原因无法执行synchroized的临界区资源需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li><li><strong>BLOCKED线程</strong>会在<strong>Owner线程释放锁</strong>的时候被<strong>唤醒</strong></li><li><strong>WATITING线程</strong>会在Owner线程调用锁对象的<strong>notify</strong>或者<strong>notifyALL</strong>方法时唤醒，但唤醒后并不意味着立刻获得锁，仍需<strong>进入EntryList重新竞争</strong></li></ul></li></ul><h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><p>下面的三个方法都是Object中的方法; 通过锁对象来调用</p><p>**wait()**：让获得对象锁的线程到waitSet中一直等待</p><p>**wait(long n)**：当该等待线程没有被notify, 等待时间到了之后, 也会自动唤醒</p><p>**notify()**：让获得对象锁的线程, 使用锁对象调用notify去waitSet的等待线程中挑一个唤醒</p><p>**notifyAll()**：让获得对象锁的线程, 使用锁对象调用notifyAll去唤醒waitSet中所有的等待线程</p><p>它们都是线程之间进行协作的手段, 都属于Object对象的方法, 必须获得此对象的锁, 才能调用这些方法</p><p><strong>注：只有当对象被锁以后(成为Owner)，才能调用wait和notify方法</strong></p><p>拥有锁才能wait</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">LOCK.wait();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sleep-long-n-和-Wait-long-n-的区别"><a href="#Sleep-long-n-和-Wait-long-n-的区别" class="headerlink" title="Sleep(long n) 和 Wait(long n)的区别"></a>Sleep(long n) 和 Wait(long n)的区别</h3><ul><li><p>不同点</p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li><strong>Sleep</strong>在阻塞的时候<strong>不会释放锁</strong>，而<strong>Wait</strong>在阻塞的时候会<strong>释放锁</strong> (不释放锁的话, 其他线程就无法唤醒该线程了)</li><li>Sleep方法不需要与synchronized一起使用，而Wait方法需要与synchronized一起使用（wait/notify等方法, <strong>必须要使用对象锁来调用</strong>）</li></ul></li><li><p>相同点</p><ul><li>阻塞状态都为TIMED_WAITING (限时等待)</li></ul></li></ul><h3 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3><p>对象的WaitSet中有多个等待线程，而<strong>notify只能挑一个唤醒</strong>，并<strong>不能指定唤醒线程</strong>，所以有可能会出现<strong>虚假唤醒的状态</strong>。采用notifyAll会唤醒所有线程，但是这样会把其他条件可能仍然不满足的线程唤醒。对于那些线程来说也是一个虚假唤醒。</p><p>因此，那些线程必须得把<strong>If(条件)+wait的方法</strong>改为<strong>while(条件)+wait</strong>的方法，避免采用if判断语句被虚假唤醒后直接结束了，让其<strong>被虚假唤醒后</strong>发现仍然条件不满足，会<strong>继续调用wait方法</strong>再次等待。</p><h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><p>这是一种多线程设计模式，rpc框架的调用中就使用到了这种模式。</p><p>一个线程等待另一个线程的执行结果，一对一的情况，也就是一个生产者对应一个消费者。</p><p>线程2等待线程1执行完毕，线程1执行完后会改变它俩共享变量的状态，线程2据此来判断消费。同时还可以设置超时时间，线程2等到一定时间后就不再等待，退出while循环。</p><p>**join(long millis)**方法和future的原理都用到了这种模式</p><p>join方法设置了超时时间millis，判断是否isAlive()，如果线程还存活，就最多等待millis，<strong>注意每次循环等待时间为delay而不是millis</strong>，防止被虚假唤醒后，下次的等待时间仍然是millis，这显然不对</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多任务版的保护性暂停就需要把公共的锁对象GuardedObject，抽象出来到一个整体，比如一个邮箱，然后里面的每一个对应的信件GuardedObject就是一个锁。</strong></p><h2 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h2><p>这种生产者/消费者模式<strong>不需要一一对应</strong>，也就是说不需要一个生产者对应一个消费者，可以是多个生产者生产，只要生产了，消费者都能用。</p><p>左边三个生产者，生产了就put进中间的<strong>消息队列</strong>，消息队列存放生产者生产出的产品，那右边就一个消费者，只要消息队列里面有产品，那就可以消费。</p><p>这样生产者只关注自己能不能产生结果，消费者只关注自己能不能消费结果。</p><p>消息队列是有容量限制的，不能消费空数据，容量满也不能产生新数据。</p><p>RabbitMQ的原理也类似，但是MQ是实现进程之间的通信。</p><h2 id="park和unpark方法"><a href="#park和unpark方法" class="headerlink" title="park和unpark方法"></a>park和unpark方法</h2><ul><li>park和unpark是LockSupport的方法，可以<strong>指定线程</strong>唤醒。</li><li>park方法是让当前线程进入WAITING状态，unpark方法是让指定线程唤醒</li></ul><p><strong>但是unpark方法可以先执行，后再进行park</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Thread t1 start&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure><h3 id="park、unpark原理"><a href="#park、unpark原理" class="headerlink" title="park、unpark原理"></a>park、unpark原理</h3><p>每一个线程都有自己的<strong>Parker对象</strong>，由三部分组成：</p><ul><li>_counter：相当于一个信号量，只有0和1的状态</li><li>_cond：条件变量，相当于线程的阻塞队列</li><li>_mutex：互斥锁，关联一个 _cond</li></ul><h4 id="先调用park再调用unpark"><a href="#先调用park再调用unpark" class="headerlink" title="先调用park再调用unpark"></a>先调用park再调用unpark</h4><p>调用<strong>park</strong>方法：</p><ul><li><strong>线程t1</strong>，先<strong>调用park方法</strong>，检查_counter的值，发现为0，这时会获得一个互斥锁 _mutex，然后线程进入cond等待队列阻塞，同时还需要<strong>再设置counter为0</strong></li></ul><p>调用**unpark(t1)**方法：</p><ul><li><strong>设置counter为1</strong>，<strong>唤醒</strong>cond中的<strong>线程t1</strong>，t1恢复运行，设置counter为0</li></ul><h4 id="先调用unpark再调用park"><a href="#先调用unpark再调用park" class="headerlink" title="先调用unpark再调用park"></a>先调用unpark再调用park</h4><ul><li>设置counter为1，当前线程调用park方法，检查counter，无需阻塞继续运行，设置counter为0</li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2>]]></content>
      
      
      <categories>
          
          <category> JUC并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/11/Bug%E4%B9%8B%E7%8E%8B/log4j%E7%9A%84mave%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
      <url>/2022/01/11/Bug%E4%B9%8B%E7%8E%8B/log4j%E7%9A%84mave%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="ClassNotFoundException：org-apache-log4j-logger"><a href="#ClassNotFoundException：org-apache-log4j-logger" class="headerlink" title="ClassNotFoundException：org.apache.log4j.logger"></a>ClassNotFoundException：org.apache.log4j.logger</h3><p>最初的问题是报错ClassNotFoundException：org.apache.log4j.logger</p><p>说明在maven依赖中有某个依赖用到了org.apache.log4j.logger，而maven依赖中又没有引入log4j</p><p>我的项目中是有一个dubbo的依赖，排除了servlet-api防止依赖冲突，没有排除log4j，并且没有引入log4j</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dubbo.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，解决方法有两种</p><ol><li>直接把dubbo依赖中的log4j排除</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--dubbo--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.dubbo.springboot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>不排除dubbo中的log4j，增加一个log4j依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="IllegalArgumentException-LoggerFactory-is-not-a-Logback-LoggerContext-but-Logback-is-on-the-classpath"><a href="#IllegalArgumentException-LoggerFactory-is-not-a-Logback-LoggerContext-but-Logback-is-on-the-classpath" class="headerlink" title="IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath."></a>IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath.</h3><p>完整报错信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;ASUS&#x2F;.m2&#x2F;repository&#x2F;org&#x2F;slf4j&#x2F;slf4j-log4j12&#x2F;1.7.30&#x2F;slf4j-log4j12-1.7.30.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;C:&#x2F;Users&#x2F;ASUS&#x2F;.m2&#x2F;repository&#x2F;ch&#x2F;qos&#x2F;logback&#x2F;logback-classic&#x2F;1.2.3&#x2F;logback-classic-1.2.3.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: LoggerFactory is not a Logback LoggerContext but Logback is on the classpath. Either remove Logback or the competing implementation</span><br></pre></td></tr></table></figure><p>这个问题是因为slf4j的依赖冲突，spring-boot-starter正常打印日志是采用的logback，在引入了slf4j-log4j12的情况下会有两个绑定，</p><p>根据提示信息就可以发现，有两种解决方案：</p><ol><li>移除slf4j-log4j12</li><li>把spring-boot-starter-logging移除</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>经典排序算法</title>
      <link href="/2022/01/09/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/09/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="部分排序算法"><a href="#部分排序算法" class="headerlink" title="部分排序算法"></a>部分排序算法</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆是一种数据结构，一种叫做完全二叉树的数据结构。</p><p>大顶堆：每个节点的值都大于或者等于它的左右子节点的值。</p><p>小顶堆：每个节点的值都小于或者等于它的左右子节点的值。</p><h3 id="最大堆的构建过程"><a href="#最大堆的构建过程" class="headerlink" title="最大堆的构建过程"></a>最大堆的构建过程</h3><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110195006939.png" alt="image-20211110195006939"></p><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110194953869.png" alt="image-20211110194953869"></p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ol><li>将待排序的序列构建成一棵树，然后最大堆化，形成一个大顶堆。这样，大顶堆的根结点一定是当前序列中最大的一个元素。</li><li>将根结点取出，将堆的最后一个元素换到根结点处，然后重新构建成一个大顶堆，同样使得最大的元素位于根结点。</li><li>重复步骤2，每次都能获得一个最大值，这样就排成了一个有序的序列。</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">&#123;</span><br><span class="line">l&lt;-LEFT(i)</span><br><span class="line"> r&lt;-RIGHT(i)</span><br><span class="line"><span class="keyword">if</span> l &lt;= heap-size[A] and A[l]&gt;A[i]</span><br><span class="line">then largest&lt;-l</span><br><span class="line"><span class="keyword">else</span> largest&lt;-i</span><br><span class="line"><span class="keyword">if</span> r &lt;= heap-size[A] and A[r]&gt;A[largest]</span><br><span class="line">then largest&lt;-r</span><br><span class="line"><span class="keyword">if</span> largest ≠ i</span><br><span class="line">then exchange A[i]&lt;-&gt;A[largest]</span><br><span class="line">MAX-HEAPIFY(A,largest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">&#123;</span><br><span class="line">heap-size[A] &lt;- length [A]</span><br><span class="line"> <span class="keyword">for</span> i &lt;- length[A]/<span class="number">2</span> downto <span class="number">1</span></span><br><span class="line"><span class="keyword">do</span> MAX-HEAPIFY(A,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HEAPSORT(A)</span><br><span class="line">&#123;</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line"><span class="keyword">for</span> i length[A] downto <span class="number">2</span></span><br><span class="line"><span class="keyword">do</span> exchange A[<span class="number">1</span>] A[i]</span><br><span class="line">heap-size[A]  heap-size[A]-<span class="number">1</span></span><br><span class="line">MAX-HEAPIFY(A,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>计数排序不基于比较，它只适用于待排序序列数值范围相差不大的情况下，否则，会造成大量的数组空间的浪费。</p><p>待排序序列A[1:n]，将辅助空间数组C[1:k]初始化为0，其中k为A[1:n]的最大取值，也可以直接设为n。对数组A的每一个数遍历一次，将数作为数组C[1:k]的的下标值，将对应值加1，这样，数组C[1:k]就记录了数组A[1:n]中每个数的出现次数，即A[i]的出现次数为C[ A[i] ]。然后，只需要对数组C遍历，每次遍历到C[i]用一个while循环，做C[i]–，直到C[i]=0。</p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="/../../img/markdown_img/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20211110204919521.png" alt="image-20211110204919521"></p><p>插入排序    稳定</p><p>快速排序    不稳定    在位</p><p>归并排序    稳定        不在位</p><p>堆排序        不稳定    在位</p><p>计数排序    稳定        不在位</p><p>基数排序    稳定        不在位</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2022/01/09/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/09/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="回溯法的基本思想"><a href="#回溯法的基本思想" class="headerlink" title="回溯法的基本思想"></a>回溯法的基本思想</h2><p>回溯法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。</p><p>回溯法从开始结点（根结点）出发，以深度优先方式搜索整个解空间。这个开始结点成为活结点，同时也成为当前的扩展结点。在当前扩展结点处，搜索向纵深方向移至一个新结点，同时，也成为当前的扩展结点。</p><h2 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h2><p>当所给的问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间树称为子集树。</p><p>例如：n个物品的0-1背包问题所相应的解空间树是一棵子集树，这类子集树通常有2^n个叶结点，其结点总数为2^(n+1)-1。遍历子集树的算法需要Ω(2^n)计算时间。但是，回溯法我们一般可以通过一种剪枝策略对这棵树进行剪枝，从而减少遍历的时间。</p><p>用回溯法搜索子集树的一般算法可以描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        output(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t]=i;</span><br><span class="line">        <span class="keyword">if</span>(constraint(t)&amp;&amp;bound(t))</span><br><span class="line">            backtrack(t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h2><p>当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。</p><p>排列树通常有n!个叶结点，因此遍历需要Ω(n!)计算时间。同样，我们可以通过一种剪枝策略对这棵树进行剪枝，从而减少遍历的时间。</p><p>用回溯法搜索排列树的一般算法可以描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        output(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(x[t],x[i]);</span><br><span class="line">        <span class="keyword">if</span>(constraint(t)&amp;&amp;bound(t))</span><br><span class="line">            backtrack(t+<span class="number">1</span>);</span><br><span class="line">        swap(x[t],x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P和NP问题"><a href="#P和NP问题" class="headerlink" title="P和NP问题"></a>P和NP问题</h1><p>如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。</p><p>NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法</title>
      <link href="/2022/01/09/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/09/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>二分搜索算法是分治法的一个典型策略。</p><p>给定已经排好序的n个元素a[0 : n-1]，现在要从中找出一个特定的元素x。</p><p>首先容易想到的是用顺序搜索方法，逐个比较a[0 : n-1]中元素，直到找到x或者搜索遍整个数组后确定x不在其中。这个方法没有很好地利用n个元素已经排好序这个条件，因此在最坏的情况下，顺序搜索方法需要O(n)次比较。</p><p>二分搜索方法充分利用了元素间的次序关系，采用分治策略，可以在最坏情况下用O(log n)时间找到元素x。</p><p>它的基本思想是：将这n个元素分成个数大致相同的两半，取a[n/2]与x进行比较，如果a[n/2]==x，则程序结束；如果x&lt;a[n/2]，只需要在a[0 : n/2]中再利用这种方法进行搜索；如果x&gt;a[n/2]，只需要在a[n/2 : n]中再利用这种方法进行搜索；</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==a[middle]) <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;a[middle]) right=middle-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left=middle+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易看出，每执行一次算法的while循环，待搜索的数组就将减少一半。因此，在最坏的情况下，while循环被执行O(log n)次。循环体内运算需要O(1)时间，因此整个算法在最坏的情况下时间复杂性为O(log n)。</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>合并排序算法是用分治策略实现对n个元素进行排序的算法。</p><p>其基本思想是：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并为所要求排好序的集合。下图可以很好的理解合并算法的分治思想。</p><blockquote><p>注：图源网络(dreamcatcher-cx)</p></blockquote><p><img src="/../../img/markdown_img/%E7%AE%97%E6%B3%95.assets/image-20211106093310191.png" alt="image-20211106093310191"></p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(a,left,mid-<span class="number">1</span>);</span><br><span class="line">        mergeSort(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(a,b,left,mid,right);<span class="comment">//合并到数组b</span></span><br><span class="line">        copy(a,b,left,right);<span class="comment">//复制回数组a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">                b[t++] = a[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b[t++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//左边剩余元素</span></span><br><span class="line">            b[t++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//右边剩余元素</span></span><br><span class="line">            b[t++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的merge方法，就是将一组一组子集合递归的合并到数组b。合并排序算法对n个元素进行排序，在最坏情况下所需的计算时间为T(n)满足：<strong>T(n)=2T(n/2)+O(n)  n&gt;1</strong></p><p>求解递归方程可知T(n)=O(n log n)。但是排序算法的时间下界为Ω(n log n)，故合并排序算法是渐进最优算法。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>快速排序算法是基于分治算法的另一个排序算法。</p><p>对于输入的子数组a[p : r]，按以下步骤进行排序：</p><ol><li>分解：以a[p]为基准元素将a[p : r]划分为3段a[p : q-1]，a[q]和a[q+1 : r]，并且让a[p : q-1]中的任何元素都小于等于a[q]，a[q+1 : r]中的任何元素都大于等于a[q]。通俗的来说就是，小于基准的放左边，大于基准的放右边。</li><li>递归求解：通过递归的调用快排算法，分别对a[p : q-1]，a[q+1 : r]两段递归调用算法。</li><li>合并：对于a[p : q-1]，a[q+1 : r]的排序是就地进行的，所以在a[p : q-1]，a[q+1 : r]排好序后不需要执行任何计算，原数组就排好序。</li></ol><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=partition(p,r);</span><br><span class="line">        qSort(p,q-<span class="number">1</span>);</span><br><span class="line">        qSort(q+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=p;</span><br><span class="line">    <span class="keyword">int</span> right=r;</span><br><span class="line">    <span class="keyword">int</span> x=a[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=x)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            a[left]=a[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;=x)</span><br><span class="line">            left--; </span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            a[right]=a[left];</span><br><span class="line">    &#125;</span><br><span class="line">    a[left]=x;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的关键在于partition中以确定的基准元素a[p]进行划分。partition方法每次都以x=a[p]为基准，然后左边left和右边right移位，右边开始，如果a[right]比基准元素x大或者等于，那么right继续移位；如果a[right]&lt;x，那么则将当前的a[right]赋值到a[left]，因为left此时并未开始移位，未动，因此是就地排序。赋值完成后left就开始移动，同理。</p><p>快速排序最差情况划分过程产生的两个区域分别包含n-1个元素和1个元素，并且每一次都出现这种不对称的划分，则有T(n)=T(n-1)+O(n)；解得最坏情况下T(n)=O(n^2)；</p><p>快排最好和平均情况下的时间复杂度都是O(n log n)；</p><p>快速排序算法是不稳定的算法。</p><h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><p>元素选择的问题一般是：给定线性序列有n个元素，一个整数k，找到这n个元素中第k小的元素。</p><p>线性时间选择算法实际上是模仿快速排序算法设计出来的。其基本思想也是对输入数组进行递归划分。随机选择一个下标 i 作为基准 a[i]，将小于 a[i] 的放左边，大于 a[i] 的放在右边。j 为划分后左边有的元素个数，这样只需要比较k和j的大小，如果k &lt;= j，那么说明第k小的元素一定在基准左边，接下来就只需要对左半部分递归找第 k 小的元素即可；同理，如果<strong>k&gt;j</strong>，说明，第k小的元素在基准右边，那么就对右半部分递归找第<strong>k-j</strong>小的元素即可。</p><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomizedSelect</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=randomizedPartition(p,r);</span><br><span class="line">    <span class="keyword">int</span> j=i-p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=j)</span><br><span class="line">        <span class="keyword">return</span> randomizedSelect(p,i,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> randomizedSelect(i+<span class="number">1</span>,r,k-j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomizedPartition</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=random(p,r);</span><br><span class="line">    MyMath.swap(a,i,p);</span><br><span class="line">    <span class="keyword">return</span> partiton(p,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，最坏情况下randomizedSelect需要Ω(n^2)计算时间，这里的partition函数同快速排序算法的partition函数是一致的。由于随机划分算法randomizedPartition使用了随机数产生器random，它能随机的产生p和r之间的一个随机整数，因此，randomizedPartition产生的划分基准是随机的，在这个条件下，可以证明，算法randomizedSelect可以在O(n)平均时间内找出n个输入元素中第k小的数。</p><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>问题描述：</p><p>给定由n个整数(可负)组成的序列a1 ,a2 ,…,an，求该序列形如∑ak的子段和的最大值。当所有整数均为负整数时定义其最大子段和为0。 依此定义，所求的最优值为<img src="/%E5%88%86%E6%B2%BB%E6%B3%95%E5%85%B8%E5%9E%8B../../img/markdown_img/%E7%AE%97%E6%B3%95.assets/image-20211106133058064.png" alt="image-20211106133058064"></p><p>例如,当(a1 ,a2 ,…,a6 ）= (-2, 11, -4, 13, -5, -2)时，最大子段和为 20 ( 11, -4, 13)。</p><h3 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h3><p>如果将所给的序列a[1 :  n]分为长度相同的两段a[1 : n/2]、a[n/2+1 : n]，分别求出这两段的最大子段和，则a[1 : n]的最大子段和分为三种情况：</p><ol><li>a[1 : n]的最大子段和同a[1 : n/2]的最大子段和相同。</li><li>a[1 : n]的最大子段和同a[n/2 : n]的最大子段和相同。</li><li>a[1 : n]的最大子段和等于位于a[1 : n/2]的子段和和位于a[n/2+1 : n]的子段和的和</li></ol><p>1和2的情况可以直接递归求得，第3种情况，a[n/2]和a[n/2+1]在最优子序列之中，我们只需要计算出左边a[1 : n/2]从n/2开始的最大子段和s1，右边a[ n/2+1 : n]从n/2+1开始的最大子段和，然后将两者相加s=s1+s2；s即为第3种情况的最优值。</p><h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MaxSubSum</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)</span><br><span class="line">        <span class="keyword">return</span> a[left]&gt;<span class="number">0</span>?a[left]:sum;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftSum=MaxSubSum(a,left,mid);</span><br><span class="line">        <span class="keyword">int</span> rightSum=MaxSubSum(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempS=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=left;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tempS+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(tempS&gt;s1)</span><br><span class="line">                s1=tempS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s2=<span class="number">0</span>;</span><br><span class="line">        tempS=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=right;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempS+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(tempS&gt;s2)</span><br><span class="line">                s2=tempS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回三者中最大的</span></span><br><span class="line">        <span class="keyword">return</span> max(leftSum,rightSum,s1+s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(n)=2T(n/2)+O(n)，因此时间复杂度为O(n log n)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划算法</title>
      <link href="/2022/01/09/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/09/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适用于动态规划法求解的问题，经分解得到的子问题往往不是相互独立的。在用分治法求解的时候，有些子问题被重复计算了许多次。如果能够保存已解决的子问题的答案，而在需要的时候再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间的算法。</p><p>动态规划算法适用于解最优化问题，通常可以按以下步骤设计的动态规划算法：</p><ol><li>找出最优解的性质，并刻画其结果特征。</li><li>递归地定义最优值。</li><li>以自底向上的方式计算出最优值。</li><li>根据计算最优值时得到的信息，构造最优解。</li></ol><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>先来看一下最大子段和用分治法思想的分析：</p><p>如果将所给的序列a[1 :  n]分为长度相同的两段a[1 : n/2]、a[n/2+1 : n]，分别求出这两段的最大子段和，则a[1 : n]的最大子段和分为三种情况：</p><ol><li>a[1 : n]的最大子段和同a[1 : n/2]的最大子段和相同。</li><li>a[1 : n]的最大子段和同a[n/2 : n]的最大子段和相同。</li><li>a[1 : n]的最大子段和等于位于a[1 : n/2]的子段和和位于a[n/2+1 : n]的子段和的和</li></ol><p>1和2的情况可以直接递归求得，第3种情况，a[n/2]和a[n/2+1]在最优子序列之中，我们只需要计算出左边a[1 : n/2]从n/2开始的最大子段和s1，右边a[ n/2+1 : n]从n/2+1开始的最大子段和，然后将两者相加s=s1+s2；s即为第3种情况的最优值。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>从上述分治法思想注意到，我们可以记b[ j ]为1 ~ j 中的最大子段和，其中j∈[1，n]；<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106135813232.png" alt="image-20211106135813232"></p><p>这样，那么所求的1 ~ n 中的最大子段和就为 i~j 的和可以表示为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106135834099.png" alt="image-20211106135834099"></p><p>意思就是，j从1到n，依次找到最大子段和。</p><p>由b[ j ]的定义易知，当b[ j-1 ]&gt;0 时b[ j ]= b[ j-1 ] +a[j]，否则 b[ j ]=a[ j ]。 由此可得计算b[j]的动态规划递归式：</p><p><strong>b[j] = max {b[j-1] +a[j], a[j] } ，1≤j ≤ n</strong></p><p>当前的最优解，就等于前一个最优解加上当前值和当前值中的较大者。</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106141924973.png" alt="image-20211106141924973"></p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">            b+=a[i];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            b=a[i];</span><br><span class="line">        <span class="keyword">if</span>(b&gt;sum)</span><br><span class="line">            sum=b;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><p>给定n个矩阵{A1，A2……An} ， 其中Ai与Ai+1可乘，i=1,2,3…n-1 。 如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。</p><p>考察这n个矩阵的连乘积     A1A2…An</p><p>由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。 </p><p>若一个矩阵连乘积的计算次序完全确定，也就是说该连乘积已完全加括号，则可以依此次序反复调用2个矩阵相乘的标准算法计算出矩阵连乘积。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>将矩阵连乘积 AiAi+1…Aj简记为A[i:j] ，这里i ≤ j  考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵 Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106143929876.png" alt="image-20211106143929876"></p><p>计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上 A[i:k]和A[k+1:j]相乘的计算量。</p><p><strong>最优解结构</strong>：</p><ul><li><p>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。 </p></li><li><p>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。</p></li></ul><p><strong>建立递归关系</strong>：</p><ol><li><p>设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]</p></li><li><p>当i=j时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n</p></li><li><p>当i&lt;j时，m[i , j]=m[i , k] + m[k+1 , j] + pi-1 * pk * pj ，这里Ai的维数为pi-1 * pi</p></li><li><p>递归的定义m[i , j]为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106144514820.png" alt="image-20211106144514820"></p><p>k的位置只有j-i种可能。</p></li></ol><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150225461.png" alt="image-20211106150225461"></p><p>计算的时候是斜着对角进行计算的，这样再计算下一轮的时候就可以用到前面已经求得的值。</p><p>计算过程：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150353882.png" alt="image-20211106150353882"></p><p>比如m[2] [5]就可以表示为：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106150243929.png" alt="image-20211106150243929"></p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matrixChain</span><span class="params">(<span class="keyword">int</span> []p,<span class="keyword">int</span> n,<span class="keyword">int</span> [][]m,<span class="keyword">int</span> [][]s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化对角线全为0 因为当i=j时，A[i:j]=Ai，因此，m[i,i]=0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) m[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">2</span>;r&lt;=n;r++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-r+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//这是把 m[i][j]分成i-&gt;i i+1-&gt;j的情形，m[i][i]=0</span></span><br><span class="line">            <span class="comment">//m[i , j]=m[i , k] + m[k+1 , j] + pi-1 * pk * pj</span></span><br><span class="line">            m[i][j]= m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="comment">//这里就是除了i-&gt;i i+1-&gt;j的情形以外的情况，要找到最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析： 算法matrixChain的主要计算量取决于算法中对r，i 和 k 的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n^3 )。因此算法的计算时间上界为O(n^3 )。算法所占用的空间显然为O(n^2 )。</p><h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><p>若给定序列X={x1 ,x2 ,…,xm}，则另一序列 Z={z1 ,z2 ,…,zk }，是X的子序列是指存在一个严格递增 下标序列{i1 ,i2 ,…,ik }使得对于所有j=1,2,…,k有：zj=xi。 例如，序列Z={B，C，D，B}是序列X={A，B，C，B， D，A，B}的子序列，相应的递增下标序列为{2，3，5， 7}。</p><p>给定2个序列X和Y，当另一序列Z既是X的子序列又是 Y的子序列时，称Z是序列X和Y的公共子序列。</p><p>给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，找 出X和Y的最长公共子序列。</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>设序列X={x1 ,x2 ,…,xm}和Y={y1 ,y2 ,…,yn }的最长公共子序列为 Z={z1 ,z2 ,…,zk } ，则</p><ul><li>若xm==yn，则zk=xm=yn。X与Y的最长公共子序列为{x1 ,x2 ,…,x(m-1)}，{y1 ,y2 ,…,y(n-1) }的最长公共子序列+xm</li><li>若xm!=yn且zk!=xm，则X与Y的最长公共子序列为{x1 ,x2 ,…,x(m-1)}，{y1 ,y2 ,…,yn }的最长公共子序列</li><li>若xm!=yn且zk!=yn，则X与Y的最长公共子序列为{x1 ,x2 ,…,xm}，{y1 ,y2 ,…,y(n-1) }的最长公共子序列</li></ul><p>由此可见，2个序列的最长公共子序列包含了这2个序列的前缀 的最长公共子序列。因此，最长公共子序列问题具有最优子结 构性质。</p><p>由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。用c[i] [j]记录序列和的最长公共子序列的长度。其中，Xi={x1 ,x2 ,…,xi }；Yj={y1 ,y2 ,…,yj }。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时C[i] [j]=0。其它情况下，由最优子结构性质可建立递归关系如下：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106152638761.png" alt="image-20211106152638761"></p><p>Algorithms和alchemist：</p><p>i=0和j=0，则c[i] [j]为0；然后，首先X1  A 和Y1  A相同，那么就取左上方c[i-1] [j-1]+1 ；接下来，X1 A和Y2 L不同，则c[i] [j] 就等于左边c[i] [j-1] 和 上边 c[i-1] [j] 中的较大者。</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106155347486.png" alt="image-20211106155347486"></p><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LCSLength</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">char</span> []x,<span class="keyword">char</span> []y,<span class="keyword">int</span> [][]c,<span class="keyword">int</span> [][]b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//i=0或者j=0，空序列为最长公共子序列，因此c[i][j]=0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (x[i]==y[j]) </span><br><span class="line">            &#123; </span><br><span class="line">c[i][j]=c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>; </span><br><span class="line">                <span class="comment">//记录</span></span><br><span class="line">                b[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c[i-<span class="number">1</span>][j]&gt;=c[i][j-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i-<span class="number">1</span>][j];</span><br><span class="line">            b[i][j]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=c[i][j-<span class="number">1</span>]; </span><br><span class="line">                b[i][j]=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造最长公共子序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LCS</span><span class="params">(<span class="keyword">int</span> i，<span class="keyword">int</span> j，<span class="keyword">char</span> []x，<span class="keyword">int</span> []b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i ==<span class="number">0</span> || j==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (b[i][j]== <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        LCS(i-<span class="number">1</span>，j-<span class="number">1</span>，x，b); </span><br><span class="line">        System.out.print(x[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b[i][j]== <span class="number">2</span>) </span><br><span class="line">        LCS(i-<span class="number">1</span>，j，x，b);</span><br><span class="line"><span class="keyword">else</span> LCS(i，j-<span class="number">1</span>，x，b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法LCSLength耗时O(m*n)，算法LCS的计算时间为O(m+n)。</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>设所给0-1背包问题的子问题<img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106191015562.png" alt="image-20211106191015562"></p><p>的最优值为m[i] [j]，即m(i,j)是背包容量为j，可选择物品为i，i+1，…，n时0-1背包问题的最优值。</p><p>由0-1背包问题的最优子结构性质，可以建立如下计算m(i，j)的递归式：</p><p><img src="/../../img/markdown_img/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95.assets/image-20211106191335277.png" alt="image-20211106191335277"></p><p>递归式的意思就是：如果当前背包容量小于当前物品的重量，那么就是不能装下，这样就等于下一个到m(i+1 , j)。如果当前背包容量能大于当前物品的重量，那么就是能装下，这样就只需要比较装下该物品（如果选择装下该物品，那么前面物品的总价值就会被压缩，因为该物品占了重量所以要去找m(i+1 , j-wi)然后再加上刚装下物品的价值）或者不装该物品，哪一个得到的价值更大。</p><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> []v,<span class="keyword">int</span> []w,<span class="keyword">int</span> c,<span class="keyword">int</span> [][]m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=v.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">        m[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        m[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&gt;=c;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">                m[i][j]=max(m[i-<span class="number">1</span>][j],m[i-<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[i][j]=m[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用m[i] [j]=max(m[i-1] [j],m[i-1] [j-w[i]]+v[i]);同上方i+1意思是一样的，只不过初始化不同。</p><p>时间复杂度O(nc)；</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2022/01/09/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
      <url>/2022/01/09/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优 解。如单源最短路经问题，最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p><h2 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h2><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式 作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</p><h2 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h2><p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。</p><p>对于一个具体问题，要确定它是否具有贪心选择性质， 必须证明每一步所作的贪心选择最终导致问题的整体最优解。</p><h3 id="贪心选择性质证明"><a href="#贪心选择性质证明" class="headerlink" title="贪心选择性质证明"></a>贪心选择性质证明</h3><h4 id="货币系统"><a href="#货币系统" class="headerlink" title="货币系统"></a>货币系统</h4><p>设某种货币系统为(1, 5, 10, 25)四种币值（单位：元），要用最少的币数找出n元钱，问：能否用贪心算法进行求解，并证明。（不要求写算法）</p><p>贪心性质（最大面额优先选最多）证明：</p><p>对n&lt;=25的情况，易由穷举得证。</p><p>当n&gt;25时，设n=1<em>a1+5</em>a2+10<em>a3+25</em>a4</p><p>为了使a1+a2+a3+a4最小，易知：</p><p>a1&lt;5，若a1&gt;=5，可将5个1元兑换为1个5元，币数减少。</p><p>a2&lt;2，若a2&gt;=2，可将2个5元兑换为1个10元，币数减少。</p><p>当a2=0时，a3&lt;3，若a3&gt;=3，可将3个10元兑换为1个5元和1个25元，币数减少。</p><p>当a2&gt;0时，a3&lt;2，若a2&gt;=2，可将1个5元和2个10元兑换为1个25元，币数减少。</p><p>即，为了使a1+a2+a3+a4最小，所使用的1、5、10元币的币数的上限为：</p><p>a1=4, a2=0, a3=2 或 a1=4, a2=1, a3=1</p><p>则所使用的1、5、10元币的币值上限为：</p><p>4<em>1+0</em>5+2<em>10 = 24 或 4</em>1+1<em>5+1</em>10 = 19</p><p>均不超过25，因此，为了使a1+a2+a3+a4最小，应使a4达到最大。贪心选择性质得证。</p><p>最优子结构性质证明：</p><p>当a4的值确定后，为了使a1+a2+a3+a4达到最小，须使a1+a2+a3达到最小，仍为同型的最优问题。</p><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p>算法思想：先将所有物品按其单位重量的价值进行排序，然后，按照贪心策略，将尽可能多的单位重量价值最高的物品装入；若装入后，背包内的物品总重量未超过C，则选择单位重量价值次高的物品尽可能多地装入。依此策略一直进行下去，直到背包装满或物品装完为止。</p><p>贪心性质证明：</p><p>不失一般性，只要对第一个步骤进行证明即可。</p><p>设按以上方法第一个步骤装入地重量为w1’。（对单位价值最大的物品）</p><p>若存在一种装入方式，单位价值最大的物品装入数为w1‘’&lt;w1’ ，且得到了最优结果。</p><p>不妨设其他的物品被装入重量为w2’’,…,wn’’。</p><p>现对该方案作部分调整，将单位价值最高的物品的装入量改为w1’，而将由此产生的超重w1’-w1’’在后面的各物品上分摊（减少），这样的方案获得的价值必然超过原方案价值且不超重，与假设矛盾。故单位价值最大的物品的装入数必然为w1’ 。</p><h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><p>活动安排问题就是要在所给的活动集合中选出 最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。</p><p>设有n个活动的集合E={1,2,…,n}，其中每个活动都要 求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资 源的起始时间si和一个结束时间fi,且si&lt;fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>输入的活动以其完成时间的非减序排列， 算法每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。</p><h3 id="贪心选择性质-1"><a href="#贪心选择性质-1" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h3><p>假设有一个最大相容活动集，Ei1,Ei2,…,Eik**(**已按结束时间排序)<strong>，</strong>活动数为K。现在证明按照贪心策略一定可以找到同样数量的相容活动集。</p><p>假设i1&gt;1，则将活动Ei1换成E1后依然是相容的（因为E1更早结束）；</p><p>依次类推，只要不符合贪心策略，就可按贪心策略进行活动替换，得到数量相等的相容基。这说明按照贪心策略一定可以得到最大相容集。因此，按照以上贪心策略，进行局部最优选择，一定可以导致最终得到整体最优解。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>各活动的起始时间和结束时间存储于数组s和f中且按结束时间的非减序排列。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="keyword">int</span> n, T s[], T f[], bool A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A[<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (s[i]&gt;=f[j]) </span><br><span class="line"> &#123; </span><br><span class="line"> A[i]=<span class="keyword">true</span>; </span><br><span class="line"> j=i; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> A[i]=<span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法greedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。</p><h2 id="背包问题-1"><a href="#背包问题-1" class="headerlink" title="背包问题"></a>背包问题</h2><p>与0-1背包问题类似，所不同的是在选择物品i装入背包时，可以选择物品i的一部分，而不一定要全部装 入背包，1≤i≤n。 这2类问题都具有最优子结构性质，极为相似，但背 包问题可以用贪心算法求解，而0-1背包问题却不能用贪心算法求解。</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先计算每种物品单位重量的价值Vi/Wi，然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。 若将这种物品全部装入背包后，背包内的物品总重量未超过 C，则选择单位重量价值次高的物品并尽可能多地装入背包。 依此策略一直地进行下去，直到背包装满为止。</p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">float</span> M,<span class="keyword">float</span> v[],<span class="keyword">float</span> w[],<span class="keyword">float</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按照单位重量的价值从大到小排序</span></span><br><span class="line">    sort(n,v,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        x[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> c=M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i]&gt;c)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        x[i]=<span class="number">1</span>;</span><br><span class="line">        c-=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;n)</span><br><span class="line">        x[i]=c/w[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先计算每种物品单位重量的价值Vi/Wi，然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。 若将这种物品全部装入背包后，背包内的物品总重量未超过C，则选择单位重量价值次高的物品并尽可能多地装入背包。 依此策略一直地进行下去，直到背包装满为止。如果到最后装入某物品后背包内的物品总重量超过C，则选择将物品不全部装入，但占用背包剩余的全部容量。</p><p>对于0-1背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。事实上， 在考虑0-1背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。由此就导出许多互相重叠的子问题。这正是该问题可用动态规划算法-求解的另一重要特征。 </p><p>实际上也是如此，动态规划算法的确可以有效地解0- 1背包问题。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHA-1算法的Java实现</title>
      <link href="/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/SHA-1/"/>
      <url>/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/SHA-1/</url>
      
        <content type="html"><![CDATA[<h2 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h2><p>SHA-1把长度小于2^64次方的输入进行分组，512bit为一组。</p><p>采用Merkle提出的安全Hash模型</p><p><img src="/../../img/markdown_img/SHA-1.assets/image-20220104084936990.png" alt="image-20220104084936990"></p><h2 id="填充方案"><a href="#填充方案" class="headerlink" title="填充方案"></a>填充方案</h2><p>先在后面补一个1，然后补0一直到448bit，最后加上64bit的原始x长度的二进制表示</p><p>举例：</p><ol><li><p>原始消息为”abc”，则其bit序列为01100001 01100010 01100011</p></li><li><p>补位，最高位补1，其余补0，补位到448bit</p><ul><li>原始序列：01100001 01100010 01100011</li><li>补位序列：01100001 01100010 01100011 10000000 00000000 … 00000000 （共448bit）</li></ul></li><li><p>原始数据长度的二进制补位</p><ul><li><p>换为16进制：61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000</p></li><li><p>原始消息的长度为24，补位</p><p>61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000018 </p></li></ul></li></ol><p>至此填充完毕，|y|=|x|+1+(447-|x|)+|l|=512</p><h2 id="初始化缓冲区"><a href="#初始化缓冲区" class="headerlink" title="初始化缓冲区"></a>初始化缓冲区</h2><p>缓冲区由5个32位的寄存器（A,B,C,D,E）组成，用于保存160位的中间结果和最终结果</p><p>寄存器初始化为：</p><ul><li>A：67452301</li><li>B：EFCDAB89</li><li>C：98BADCFE</li><li>D：10325476</li><li>E：C3D2E1F0</li></ul><h2 id="主处理"><a href="#主处理" class="headerlink" title="主处理"></a>主处理</h2><p>主处理是SHA-1的核心，每次处理一个512bit分组，链接迭代处理所有L个分组数</p><p>压缩函数是主处理的核心，它由4层运算，每层20步迭代，共80步迭代组成，4层运算结构相同。</p><p>每轮的输入是当前512bit分组BLK和160bit缓冲区ABCDE的内容，并且每轮都对ABCDE的内容更新，而且每轮使用的逻辑函数f不相同，分为f1,f2,f3,f4</p><p>第四轮的输出与第一轮的输入相加得到压缩函数的输出</p><p><img src="/../../img/markdown_img/SHA-1.assets/image-20220104090917830.png" alt="image-20220104090917830"></p><p>&lt;&lt;s 表示32位的变量循环左移s位</p><p>Wt 表示从当前分组BLK导出的32位的字</p><p>Kt 表示加法常量，共使用4个不同的加法常量，每一层一个</p><p>ft 逻辑函数</p><h2 id="逻辑函数ft"><a href="#逻辑函数ft" class="headerlink" title="逻辑函数ft"></a>逻辑函数ft</h2><p>每一轮使用一个逻辑函数，共4个，其输入均为B,C,D(每个32位)，输出为一个32位的字。</p><ul><li>0 ≤ t ≤ 19    f1=ft(B,C,D) = (B ∧C) ∨((¬ B) ∧ D)</li><li>20 ≤ t ≤ 39 f2=ft(B,C,D) = B ⊕ C ⊕ D</li><li>40 ≤ t ≤ 59 f3=ft(B,C,D) = (B ∧ C) ∨(B ∧ D) ∨ (C∧D)</li><li>60≤ t ≤ 79 f4=ft(B,C,D) = B ⊕ C ⊕ D</li></ul><p>f2和f4都是线性函数</p><h2 id="加法常量Kt"><a href="#加法常量Kt" class="headerlink" title="加法常量Kt"></a>加法常量Kt</h2><p>每层使用一个加法常量，各轮使用的加法常量：</p><p>K1 0 ≤ t ≤ 19    5A827999</p><p>K2 20 ≤ t ≤ 39    6ED9EBA1</p><p>K3 40 ≤ t ≤ 59    8F1BBCDC</p><p>K4 60≤ t ≤ 79    CA62C1D6</p><p>压缩字Kt的作用范围太小，只影响输出A，不影响B,C,D,E。</p><h2 id="压缩字Wt"><a href="#压缩字Wt" class="headerlink" title="压缩字Wt"></a>压缩字Wt</h2><p>每步迭代都需要用到一个字，共有80个步，需要80个字。因此将输入BLK（512位，16个字）扩展成80个32位的字。消息M共16个字。</p><p>扩展过程：</p><ul><li>0 ≤ t ≤ 15 Wt=Mt</li><li>16 ≤ t ≤ 79 Wt=（Wt-16 ⊕ Wt-14 ⊕ Wt-8 ⊕ Wt-3）&lt;&lt;1</li></ul><p>压缩字的扩展函数为线性函数</p><p>Wt作用范围太小，只影响输出A，不影响B,C,D,E。</p><h2 id="主处理过程"><a href="#主处理过程" class="headerlink" title="主处理过程"></a>主处理过程</h2><h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h3><p>填充后的消息M，共16个字</p><p>61626380 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000018 </p><p>对M扩展成80个字</p><p>Wt = S1(Wt-3 ⊕Wt-8 ⊕Wt-14 ⊕Wt-16) (16  ≤ t ≤ 79)</p><h3 id="初始化缓冲区-1"><a href="#初始化缓冲区-1" class="headerlink" title="初始化缓冲区"></a>初始化缓冲区</h3><p>初始化MD缓冲区{Hi}，160bit(5个32的寄存器)。</p><p>A=H0= 0x67452301 </p><p>B=H1 = 0xEFCDAB89 </p><p>C=H2= 0x98BADCFE </p><p>D=H3= 0x10325476 </p><p>E=H4= 0xC3D2E1F0</p><p>每轮的常数K为：  </p><p>Kt = 5A827999 ( 0 ≤ t ≤ 19) </p><p>Kt = 6ED9EBA1 (20 ≤ t ≤ 39) </p><p>Kt = 8F1BBCDC (40 ≤ t ≤ 59) </p><p>Kt = CA62C1D6 (60 ≤ t ≤ 79)</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ul><li><p>TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt</p></li><li><p>E = D ; D = C ; C = S30(B) ; B = A ; A = TEMP</p></li><li><p>H0 = H0 + A  H1 = H1 + B H2 = H2 + C  H3 = H3 + D H4 = H4 + E</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java小功能实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java小功能实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现文件监控系统</title>
      <link href="/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/01/05/java%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/Java%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>用Java实现文件监控一般有三种方式，第一种是使用WatchService，但是WatchService只能监视当前目录下的文件和目录，不能监视子目录，如果需要监视，则需要遍历根目录下的所有目录，第二种就是利用commons-io监控，最后还可以用JNofiy实现，这里只使用了前两种</p><h2 id="WatchService实现文件监控"><a href="#WatchService实现文件监控" class="headerlink" title="WatchService实现文件监控"></a>WatchService实现文件监控</h2><p>WatchService是jdk7之后nio包中的新功能。可以看作是文件监控器，通过操作系统原生文件系统来运行。 针对单点多appkey的情况，可以注册开启多个监控器。 每个监控器可看作是后台线程，通过监控文件发出的信号来实现监控。</p><p>应用场景：可以监控配置文件的变化，修改配置文件内容即时生效，无需重启服务；监控磁盘文件的变化</p><p>WatchService监控目录文件操作的流程大致如下：</p><ol><li>获取WatchService</li><li>注册指定目录的监视器</li><li>开启线程，等等目录下的文件发生变化</li><li>对发送变化的文件进行记录</li></ol><h3 id="获取WatchService实例"><a href="#获取WatchService实例" class="headerlink" title="获取WatchService实例"></a>获取WatchService实例</h3><p>WatchService是对原生操作系统文件监视器的封装，因为不需要遍历文件所以整体效率上会高很多。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService = FileSystems.getDefault().newWatchService();</span><br></pre></td></tr></table></figure><p>FileSystems.getDefault().newWatchService();直接封装了WatchService的获取方法。</p><p>可以查看它的源码，getDefault()方法的返回值是一个FileSystem，FileSystem提供一个访问文件系统的接口，是对象访问文件系统中的文件和其他对象的工厂，进入getDefault()方法，看看它default了个啥。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileSystem <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DefaultFileSystemHolder.defaultFileSystem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用了DefaultFileSystemHolder，DefaultFileSystemHolder是FileSystems中的一个静态内部类，而defaultFileSystem是DefaultFileSystemHolder的一个用static修饰的属性，然后调用了defaultFileSystem()方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> FileSystem defaultFileSystem = defaultFileSystem();</span><br></pre></td></tr></table></figure><p>defaultFileSystem方法里面用匿名内部类的形式返回了一个FileSystemProvider，它是文件系统的服务提供者类，用它可以获取由provider创建的一个FileSystem。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// returns default file system</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FileSystem <span class="title">defaultFileSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// load default provider</span></span><br><span class="line">    FileSystemProvider provider = AccessController</span><br><span class="line">        .doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;FileSystemProvider&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileSystemProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getDefaultProvider();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return file system</span></span><br><span class="line">    <span class="keyword">return</span> provider.getFileSystem(URI.create(<span class="string">&quot;file:///&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类中，获取了一个defaultProvider，WindowsFileSystemProvider，然后由这个provider获取了一个文件系统，WindowsFileSystemProvider中初始化文件系统。然后调用newWatchService方法就可以获取到WindowsWatchService对象了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WindowsFileSystem theFileSystem = <span class="keyword">new</span> WindowsFileSystem(<span class="keyword">this</span>, System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br></pre></td></tr></table></figure><p>实际上调用此方法后也就是WindowsWatchService的构造方法中，程序会新开一个线程，监视文件变化发出的信号，此时线程尚未就绪。Poller是WindowsWatchService中的一个内部类，WindowsWatchService也有一个poller属性，Poller继承了AbstractPoller，AbstractPoller是实现了Runnable接口，创建了一个守护线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread var1 = <span class="keyword">new</span> Thread(AbstractPoller.<span class="keyword">this</span>);</span><br><span class="line">            var1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            var1.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册目录监视器"><a href="#注册目录监视器" class="headerlink" title="注册目录监视器"></a>注册目录监视器</h3><p>注册监视器需要用到 Path 实例，该实例对应的必须是一个目录，不允许是一个文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要监视的文件目录</span></span><br><span class="line">        String strPath=<span class="string">&quot;D:/FileSystemMonitorTest&quot;</span>;</span><br><span class="line">        <span class="comment">//Path继承了Watchable接口，因此才可以通过Path类来对文件目录进行监听</span></span><br><span class="line">        Path path= Paths.get(strPath);</span><br><span class="line">        <span class="comment">//注册监控服务，监控新增、修改、删除事件，也可以只监控一个事件</span></span><br><span class="line">        path.register(watchService,StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br></pre></td></tr></table></figure><p>StandardWatchEventKinds是文件对应的操作事件，包括修改，创建，删除，它看起来像是枚举类型，但实际上并不是。WatchEvent.Kind<T>是一个接口，对应事件种类名和WatchEvent#context的类型，StdWatchEventKind是它的实现类，StdWatchEventKind<T>也是StandardWatchEventKinds中的内部静态类，StandardWatchEventKinds中的属性调用StdWatchEventKind的构造创建对应的观察事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> WatchEvent.Kind&lt;Path&gt; ENTRY_CREATE =</span><br><span class="line">    <span class="keyword">new</span> StdWatchEventKind&lt;Path&gt;(<span class="string">&quot;ENTRY_CREATE&quot;</span>, Path.class);</span><br></pre></td></tr></table></figure><h3 id="获取目录下的变化"><a href="#获取目录下的变化" class="headerlink" title="获取目录下的变化"></a>获取目录下的变化</h3><p>获取目录的变化需要使用 WatchService 的 take() 方法或 poll() 方法。</p><p>take() 是一个阻塞方法，会等待监视器发出的信号才返回。</p><p>poll() 是一个非阻塞方法，会立即返回当时监视器中是否有信号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    WatchKey watchKey = watchService.take();</span><br><span class="line">    <span class="comment">//轮询</span></span><br><span class="line">    List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">    <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">        System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">    &#125;</span><br><span class="line">    watchKey.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 WatchKey 对象，实际上是一个单例，和之前 path.register() 方法返回的实例是同一个。它只能保存某一时间点的文件变化信息。在AbstractPoller中可以看到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">awaitResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> var1 = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!<span class="keyword">this</span>.completed) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException var5) &#123;</span><br><span class="line">                        var1 = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (var1) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>pollEvents() 用于获取文件变化事件，只能获取一次，不能重复获取，类似队列的形式。</p><p>context() 返回触发该事件的那个文件或目录的路径(相对路径)</p><p>reset() 每次调用 WatchService 的 take() 或 poll() 方法时需要通过本方法重置。</p><h3 id="文件变化记录"><a href="#文件变化记录" class="headerlink" title="文件变化记录"></a>文件变化记录</h3><p>开启一个线程一直监控文件的变化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建监视服务类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService=FileSystems.getDefault().newWatchService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainMonitor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//需要监视的文件目录</span></span><br><span class="line">        String strPath=<span class="string">&quot;D:/FileSystemMonitorTest&quot;</span>;</span><br><span class="line">        <span class="comment">//Path继承了Watchable接口，因此才可以通过Path类来对文件目录进行监听</span></span><br><span class="line">        Path path= Paths.get(strPath);</span><br><span class="line">        <span class="comment">//注册监控服务，监控新增、修改、删除事件，也可以只监控一个事件</span></span><br><span class="line">        path.register(watchService,StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">        WatchServiceRunnable watchServiceRunnable = <span class="keyword">new</span> WatchServiceRunnable(watchService, strPath);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(watchServiceRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.FileMonitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchEvent;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchService;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控线程重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchServiceRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchServiceRunnable</span><span class="params">(WatchService watchService,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.watchService=watchService;</span><br><span class="line">        <span class="keyword">this</span>.path=path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                WatchKey watchKey = watchService.take();</span><br><span class="line">                <span class="comment">//轮询</span></span><br><span class="line">                List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">                <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">                    System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                            <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">                &#125;</span><br><span class="line">                watchKey.reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WatchService监控根目录以及子目录"><a href="#WatchService监控根目录以及子目录" class="headerlink" title="WatchService监控根目录以及子目录"></a>WatchService监控根目录以及子目录</h3><p>这样的话就需要遍历子目录，每个目录都注册一个监控事件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历根目录及其子目录，全都注册监听服务</span></span><br><span class="line">LinkedList&lt;File&gt; fileLinkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加根目录到链表尾</span></span><br><span class="line">fileLinkedList.addLast(file);</span><br><span class="line"><span class="comment">//去除并且链表头的文件对象，查看其子目录下文件，能注册服务就注册WatchService</span></span><br><span class="line"><span class="keyword">while</span> (fileLinkedList.size()&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    File f=fileLinkedList.removeFirst();</span><br><span class="line">    File[] files1 = f.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file1 : files1) &#123;</span><br><span class="line">        <span class="comment">//如果是目录，则可以注册监听服务</span></span><br><span class="line">        <span class="keyword">if</span> (file1.isDirectory())&#123;</span><br><span class="line">            fileLinkedList.addLast(file1);</span><br><span class="line">            file1.toPath().register(watchService, StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">                    StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在使用Junit测试的时候会遇到Junit测试多线程的限制，不能直接测试，可以看另一篇，Junit测试多线程的问题。</p><h2 id="Commons-IO实现文件监控"><a href="#Commons-IO实现文件监控" class="headerlink" title="Commons-IO实现文件监控"></a>Commons-IO实现文件监控</h2><p>Commons-IO是一个针对开发IO流功能的工具库，主要包括6个部分</p><ol><li>Utility classes：工具类，包括一些静态方法来执行常用任务</li><li>Input：输入，InputStream 和 Reader 实现</li><li>Output：输出，OutputStream 和 Writer 实现</li><li>Filters：过滤器，多种文件过滤器实现(定义了 IOFileFilter接口,同时继承了 FileFilter 和 FilenameFilter 接口)</li><li>Comparators： 比较器，用于文件比较的多种java.util.Comparatot实现</li><li>File Monitor： 文件监控</li></ol><p>使用Commons-IO来实现文件监控主要就是基于观察者模式，也叫发/布订阅模式。</p><p>主要的类有：</p><p>FileAlterationObserver：观察者，观察文件的变化</p><p>FileAlterationListener：文件变化的通知对象，监听器</p><p>FileAlterationListenerAdaptor：FileAlterationListener的实现类，里面方法都没仅仅有个方法体，没有具体的实现，我们一般需要继承FileAlterationListenerAdaptor，然后做具体的实现，比如监控到文件变化打印日志等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File system observer started checking event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> observer The file system observer (ignored)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileAlterationMonitor ：线程监控，实现了Runnable接口，可以以一个固定的时间间隔监听注册到观察者FileAlterationObserver的事件</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>首先由文件监控类FileAlterationMonitor中的线程不停的扫描文件观察器FileAlterationObserver</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> FileAlterationObserver observer : observers) &#123;</span><br><span class="line">            observer.checkAndNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(interval);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FileAlterationObserver中，有一个无参的checkAndNotify()方法，就是用来检查文件和它的子文件有没有变化。</p><p>在该方法中，首先将Observer的所有listener开启onStart方法，表示开始Observer开始检查事件了。然后调用checkAndNotify()的重载方法，根据文件的Comparators比较器，判断文件发生哪种变化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkAndNotify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAndNotify</span><span class="params">(<span class="keyword">final</span> FileEntry parent, <span class="keyword">final</span> FileEntry[] previous, <span class="keyword">final</span> File[] files)</span></span></span><br><span class="line"><span class="function"><span class="title">doCreate</span><span class="params">(current[c])</span></span>;<span class="comment">//创建</span></span><br><span class="line">doMatch(entry, files[c]);<span class="comment">//修改</span></span><br><span class="line">doDelete(entry);<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><h3 id="自定义监听器FileAlterationListener"><a href="#自定义监听器FileAlterationListener" class="headerlink" title="自定义监听器FileAlterationListener"></a>自定义监听器FileAlterationListener</h3><p>通过实现FileAlterationListener或者说继承FileAlterationListenerAdaptor来自定义一个监听器，重写其中文件或者目录发生改变的方法，记录日志。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.commons_io_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationListenerAdaptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationObserver;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListener</span> <span class="keyword">extends</span> <span class="title">FileAlterationListenerAdaptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger=Logger.getLogger(FileListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;新建文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;修改文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;删除文件：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryCreate</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;新建目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryChange</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;修改目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryDelete</span><span class="params">(File directory)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;删除目录：&quot;</span>+directory.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建监听器FileAlterationMonitor"><a href="#创建监听器FileAlterationMonitor" class="headerlink" title="创建监听器FileAlterationMonitor"></a>创建监听器FileAlterationMonitor</h3><p>首先给定一个需要监听的文件目录，配置一个观察者FileAlterationObserver，添加观察者的监听器，最后再new一个线程监控FileAlterationMonitor。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.commons_io_monitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.FileFilterUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.HiddenFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.IOFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationMonitor;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.monitor.FileAlterationObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileListenerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String dir=<span class="string">&quot;D:\\FileSystemMonitorTest&quot;</span>;</span><br><span class="line">    <span class="comment">//设置轮询间隔 1s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> interval = TimeUnit.SECONDS.toMillis(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileAlterationMonitor <span class="title">getMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//装配过滤器</span></span><br><span class="line">        FileAlterationObserver observer = <span class="keyword">new</span> FileAlterationObserver(<span class="keyword">new</span> File(dir));</span><br><span class="line">        <span class="comment">//添加监听器</span></span><br><span class="line">        observer.addListener(<span class="keyword">new</span> FileListener());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileAlterationMonitor(interval,observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileMonitorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileAlterationMonitor monitor = <span class="keyword">new</span> FileListenerFactory().getMonitor();</span><br><span class="line">            monitor.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java小功能实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java小功能实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit测试多线程的问题</title>
      <link href="/2022/01/04/Bug%E4%B9%8B%E7%8E%8B/%E5%85%B3%E4%BA%8EJunit%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B5%8B%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/01/04/Bug%E4%B9%8B%E7%8E%8B/%E5%85%B3%E4%BA%8EJunit%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B5%8B%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Junit测试多线程的问题"><a href="#Junit测试多线程的问题" class="headerlink" title="Junit测试多线程的问题"></a>Junit测试多线程的问题</h1><p>今天在用写一个用WatchService做文件监控的时候使用Junit测试，实现Runnable接口，重写run方法，明明run方法里写的死循环，使用Junit一测试，啥都没干，自动给我执行完了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainMonitor mainMonitor = <span class="keyword">new</span> MainMonitor();</span><br><span class="line">        mainMonitor.monitor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监控线程重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchServiceRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchService watchService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchServiceRunnable</span><span class="params">(WatchService watchService,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.watchService=watchService;</span><br><span class="line">        <span class="keyword">this</span>.path=path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                WatchKey watchKey = watchService.take();</span><br><span class="line">                List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchKey.pollEvents();</span><br><span class="line">                <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</span><br><span class="line">                    System.out.println(watchEvent.kind()+<span class="string">&quot;事件：&quot;</span>+path+</span><br><span class="line">                            <span class="string">&quot;/&quot;</span>+watchEvent.context());</span><br><span class="line">                &#125;</span><br><span class="line">                watchKey.reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我直接重新写一个for循环，打印数字，也不能正常输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">                Thread.currentThread().setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在输出&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整了半天，发现Junit并不能直接测试多线程。Junit单元测试当主线程执行完毕时，主线程会关闭，并且关闭子线程。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>使用join()等待子线程执行完毕</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    thread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainMonitor mainMonitor = <span class="keyword">new</span> MainMonitor();</span><br><span class="line">        mainMonitor.monitor();</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>还可以使用CountDownLatch类</li></ol><p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件系统安全</title>
      <link href="/2021/12/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
      <url>/2021/12/26/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-软件、程序、软件工程、软件系统、软件质量"><a href="#1-软件、程序、软件工程、软件系统、软件质量" class="headerlink" title="1.   软件、程序、软件工程、软件系统、软件质量"></a>1.   软件、程序、软件工程、软件系统、软件质量</h3><p>软件：程序+文档 程序：算法+数据结构</p><p>软件工程包含的研究内容：软件开发模型、软件开发方法，软件支持过程，软件管理过程。</p><p>软件系统是指由系统软件、支撑软件和应用软件组成的计算机软件系统，它是计算机系统中由软件组成的部分。</p><p>软件质量是指软件符合</p><ul><li>明确定义的功能和性能需求</li><li>明确规定的开发标准和准则</li><li>满足隐含要求的其它特性的程度</li></ul><p>软件质量是反映软件产品满足规定和潜在需求能力的特性的总和，描述和评价软件产品质量的一组属性常称为软件质量特性。</p><h3 id="2-软件构造过程存在哪些安全隐患"><a href="#2-软件构造过程存在哪些安全隐患" class="headerlink" title="2.   软件构造过程存在哪些安全隐患"></a>2.   软件构造过程存在哪些安全隐患</h3><p>软件安全主要包括的三个方面：</p><p>软件自身安全(软件缺陷与漏洞)：软件在开发时可能由于不安全编码等因素造成的软件在特定方面的缺陷与漏洞</p><p>恶意软件攻击：攻击者会利用软件的漏洞植入恶意代码，或者通过恶意的软件病毒比如木马，后门，蠕虫等等对系统进行攻击</p><p>软件逆向分析(软件破解)：通过对软件进行逆向分析，发现软件的注册机制，从而破解软件</p><h3 id="3-软件系统存在安全问题的本因"><a href="#3-软件系统存在安全问题的本因" class="headerlink" title="3.   软件系统存在安全问题的本因"></a>3.   软件系统存在安全问题的本因</h3><p>在软件设计之处，并没有结合到实际完全考虑到软件自身运行情况和可能面临的互联网环境下的复杂性，导致软件开发后存在不少的漏洞与缺陷，在面临异常环境时无法按照正常的预期的流程运行，降低了软件的动态行为可信性。</p><h3 id="4-从软件工程的视角如何预防软件系统安全缺陷"><a href="#4-从软件工程的视角如何预防软件系统安全缺陷" class="headerlink" title="4.   从软件工程的视角如何预防软件系统安全缺陷"></a>4.   从软件工程的视角如何预防软件系统安全缺陷</h3><p>强化软件工程思想，将安全问题融入到软件的开发管理流程之中，在软件开发阶段尽量减少软件缺陷和漏洞的数量。采用标准的软件工程开发模型与流程，合理的风险评估，严格要求整个开发生命周期，做到软件缺陷与漏洞的最小化。</p><h3 id="5-软件危机"><a href="#5-软件危机" class="headerlink" title="5.   软件危机"></a>5.   软件危机</h3><p>计算机软件的开发和维护过程中遇到的一系列严重问题。</p><ul><li>主要表现：<ul><li>开发成本和进度估计不准确</li><li>用户对已完成的软件不满意</li><li>软件产品质量不高</li><li>软件常常不可维护</li><li>软件没有文档资料</li><li>软件成本在总成本中占比上升</li><li>软件开发生产率赶不上硬件的发展速度也跟不上计算机应用普及的速度。</li></ul></li></ul><h3 id="6-可信软件"><a href="#6-可信软件" class="headerlink" title="6.可信软件"></a>6.可信软件</h3><p>软件系统的运行行为及其结果总是符合人们的预期，在受到干扰时仍能提供连续的服务。</p><p>包含安全性(safety，security)、可靠性、可用性、可维护性、机密性、完整性、可控性等等。</p><ul><li>safety：软件运行不引起危险、灾难的能力</li><li>security：软件系统对数据和信息提供保密性、 完整性、可用性、真实性保障的能力</li><li>reliability：在给定的环境下特定的时间内软件无失效运行的概率</li><li>maintainability：软件系统或部件修改错误、提高性能和属性，或是适应新环境的难易程度</li><li>survivability：（网络）软件在受到攻击或失效时提供基本服务并在规定时间内恢复所有服务的能力</li></ul><h3 id="7-软件安全"><a href="#7-软件安全" class="headerlink" title="7.软件安全"></a>7.软件安全</h3><p>软件规模的扩大，软件开发集成和演化越来越复杂，导致软件产品推出时会有已知或者未知的缺陷。就好比现在操作系统都是先推出使用后续再慢慢维护，更新。</p><p>软件的运行和开发环境从传统的静态转换到了动态的互联网环境下，安全风险更大。</p><p>计算机病毒和黑客地下产业链活动，软件漏洞增多，传播速度加大。</p><h3 id="8-信息与信息安全"><a href="#8-信息与信息安全" class="headerlink" title="8.信息与信息安全"></a>8.信息与信息安全</h3><p>信息以物质介质为载体，传递和反映世界各种事物存在的方式和运动状态的特征。信息是比较抽象的，有人说具有价值的消息就是信息，总之关键词就是价值、消除不确定性。</p><p>信息安全是对信息的保密性、完整性和可用性的保持。</p><h3 id="9-软件安全威胁及其来源；"><a href="#9-软件安全威胁及其来源；" class="headerlink" title="9.软件安全威胁及其来源；"></a>9.软件安全威胁及其来源；</h3><ul><li>软件缺陷与漏洞：软件开发时对软件自身运行环境和外部因素考虑不周导致出现的缺陷和漏洞。</li><li>恶意软件攻击：为了实现一些恶意目的的软件程序，比如计算机病毒、特洛伊木马、后门等等。</li><li>软件破解：对软件的逆向分析，破解软件的使用。</li></ul><h3 id="10-如何加强软件安全保护"><a href="#10-如何加强软件安全保护" class="headerlink" title="10.如何加强软件安全保护"></a>10.如何加强软件安全保护</h3><ul><li>从<strong>软件工程</strong>的角度来说，加强软件工程思想，让软件开发走标准的软件工程过程，将安全问题融入到软件的开发流程管理之中，在软件开发阶段尽量减少软件缺陷和漏洞的数量。</li><li>保证软件自身运行环境，加强系统自身的<strong>数据完整性校验</strong>。</li><li>加强系统自身软件的行为认证——<strong>软件动态可信认证</strong></li><li>恶意软件检测与查杀</li><li>黑客攻击防护——主机防火墙，HTPS</li><li>系统还原</li><li>虚拟机、沙箱技术</li></ul><h3 id="11-计算机的引导过程（简答）"><a href="#11-计算机的引导过程（简答）" class="headerlink" title="11.计算机的引导过程（简答）"></a>11.计算机的引导过程（简答）</h3><p>主要可分为四个阶段</p><ul><li>BIOS：首先进行硬件自检(POST power on self test)，如果发现有硬件故障会通过喇叭发声，然后按照启动顺序选择从哪个设备启动。</li><li>主引导记录(MBR)：读取设备的前512字节，判断设备能否启动，不能启动则按启动顺序尝试启动下一个设备。然后BIOS会一次遍历主分区找到激活分区。</li><li>硬盘启动：计算机会读取激活分区的第一个扇区即卷引导记录(VBR)，VBR告诉计算机操作系统位于该分区的哪个位置，然后计算机就可以开始加载操作系统了。</li><li>操作系统：首先载入操作系统的内核，然后加载各个模块，驱动程序以及服务启动，最后系统自启动程序。</li></ul><h3 id="12-PE文件格式"><a href="#12-PE文件格式" class="headerlink" title="12.PE文件格式"></a>12.PE文件格式</h3><p>PE是Win32环境自身所带的可执行的文件格式。它的一些特性继承自UNIX的COFF文件格式。</p><p>可移植的执行体意味着此文件格式是跨Win32平台的，即使Windows运行在非Intel的CPU上，任何Win32平台的PE装载器都能识别和使用该文件格式。</p><p>移植到不同的CPU上PE执行体必须得有一些改变。除了VxD和16位的DLL外，所有Win32执行文件都使用PE文件格式。因此，研究PE文件格式是我们洞悉 Windows结构的良机。</p><h3 id="13-软件漏洞成因分析"><a href="#13-软件漏洞成因分析" class="headerlink" title="13.软件漏洞成因分析"></a>13.软件漏洞成因分析</h3><p>软件脆弱性成因即形成软件脆弱性的原因。<strong>软件脆弱性成因</strong>包括导致软件脆弱性形成的<strong>内部因素</strong>和<strong>外部因素</strong>两个方面。</p><ul><li>内部因素主要是软件本身的<strong>不安全编码</strong>导致的内部安全缺陷，数据校验不当，类型初始化不当，空指针使用不当</li><li>外部环境因素指的是<strong>软件运行所在的外部环境因素</strong>，其主要包括接口参数(IP)，机器内存(M)，进程(PRS)，注册信息(REG)，代码(CD)，网络(NET)，磁盘文件系统(DF)等方面。因此外部环境因素可以进一步表示为以下形式：EM = {IP，M，DF，PRS，NET，REG，CD}。</li></ul><h3 id="14-漏洞按照成因分类"><a href="#14-漏洞按照成因分类" class="headerlink" title="14.漏洞按照成因分类"></a>14.漏洞按照成因分类</h3><p>按照漏洞的成因分类：输入验证错误、访问验证错误、竞争条件错误、意外情况处理错误、设计错误、配置错误以及环境错误。</p><h3 id="15-漏洞的一般特征及其描述"><a href="#15-漏洞的一般特征及其描述" class="headerlink" title="15.漏洞的一般特征及其描述"></a>15.漏洞的一般特征及其描述</h3><ol><li>脆弱性是软件系统中一个隐藏的弱点（Fault，F），它本身并不会造成错误，但被攻击者利用之后可能会产生严重的安全后果（Result，R），形式化的表示为：F→R</li><li>在软件开发过程中，开发人员自觉或不自觉的引入的逻辑错误（LF）是大多数脆弱性（SV）的根本来源，形式化的表示为：LF→SV</li><li>脆弱性的特征还与系统本身运行时的环境（EM）有关，不同的运行环境也有可能造成不同的脆弱性问题，形式化的表示为：EM→SV</li><li>旧的脆弱性（FSV）遭到修复后也有可能引入新的脆弱性（CSV）问题，形式化的表示为：FSV→CSV</li></ol><h3 id="16-漏洞分类及其标准"><a href="#16-漏洞分类及其标准" class="headerlink" title="16.漏洞分类及其标准"></a>16.漏洞分类及其标准</h3><ul><li>按漏洞可能对系统造成的直接威胁划分<ul><li>获取访问权限漏洞、权限提升漏洞、拒绝服务攻击漏洞、恶意软件植入漏洞、数据丢失或泄露漏洞</li></ul></li><li>按漏洞的成因划分<ul><li>输入验证错误、访问验证错误、竞争条件错误、意外情况处理错误、设计错误、配置错误、环境错误</li></ul></li><li>按漏洞的严重等级<ul><li>高级漏洞：远程和本地管理员权限</li><li>中级漏洞：普通用户权限、权限提升、读取受限文件以及远程和本地拒绝服务</li><li>低级漏洞：服务器信息泄露</li></ul></li><li>按漏洞被利用的方式<ul><li>本地攻击、远程主动攻击、远程被动攻击</li></ul></li></ul><h3 id="17-常见的软件漏洞分类"><a href="#17-常见的软件漏洞分类" class="headerlink" title="17.常见的软件漏洞分类"></a>17.常见的软件漏洞分类</h3><p>常见的软件漏洞大概分为8类：</p><ul><li><strong>代码注入</strong>：恶意代码的注入</li><li>缓冲错误：缓冲区溢出</li><li>跨站脚本：XSS攻击，植入代码脚本，保存型XSS漏洞：先把脚本存在数据库，等读取出来的时候有可能执行脚本</li><li>权限许可和访问控制：未检查返回值导致空指针解引用，空指针异常</li><li>SQL注入：攻击者输入携带可能被执行的危险指令或者恒成立条件进入数据库做正常的查询等操作，导致数据库错误的执行命令。</li><li>输入验证：没有做校验工作，比如没有校验生成的值为0导致0除异常</li><li>格式化字符串：输出非法格式化字符串导致输出了内存中的数据</li><li>竞争条件：并发编程对资源的共享可能造成内存泄露、系统崩溃</li></ul><h3 id="18-不安全编码分类"><a href="#18-不安全编码分类" class="headerlink" title="18.不安全编码分类"></a>18.不安全编码分类</h3><p>数据校验不当DO、类型初始化不当TI、空指针引用不当NP、返回操作不当RV、数字操作不当NO、类与方法操作不当CM、异常处理不当EO、多线程处理不当MT、IO操作不当IO、序列化操作不当SO、权限控制不当RC</p><h3 id="19-典型的软件漏洞机理分析（成因图分析法）"><a href="#19-典型的软件漏洞机理分析（成因图分析法）" class="headerlink" title="19.典型的软件漏洞机理分析（成因图分析法）"></a>19.典型的软件漏洞机理分析（成因图分析法）</h3><p>漏洞成因影响因素表：</p><p><img src="/../../img/markdown_img/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8.assets/image-20211224211315230.png" alt="image-20211224211315230"></p><p>软件脆弱性成因图由两部分构成：内因和外因。</p><ul><li><p>内因：指系统本身的不安全编码。如数据校验不当、类型初始 化不当、空指针使用不当、返回值操作不当、数字操作不当等。</p></li><li><p>外因：主要考虑的是接口参数（IP）、内存(M)、磁盘文件系统(DF)、进程(PRS)、 网络(NET)、注册环境信息(REG)和外部代码(ED)等影响因素。</p></li></ul><p>软件脆弱性的成因复杂，一部分脆弱性是内因作用的结果，另 一部分则是内因和外因共同作用的结果。</p><p>软件漏洞成因影响因素及其简称：</p><p><img src="/../../img/markdown_img/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8.assets/image-20211224212016072.png" alt="image-20211224212016072"></p><h3 id="20-软件漏洞的利用和发现"><a href="#20-软件漏洞的利用和发现" class="headerlink" title="20.软件漏洞的利用和发现"></a>20.软件漏洞的利用和发现</h3><h4 id="Exploit漏洞利用程序"><a href="#Exploit漏洞利用程序" class="headerlink" title="Exploit漏洞利用程序"></a>Exploit漏洞利用程序</h4><p>Exploit(漏洞利用程序)是针对某一特定漏洞或一组漏洞而精心编写的漏洞利用程序。其可以触发特定漏洞从而获得系统的控制权。</p><p>分为两个部分：被注入到目标进程触发漏洞获得执行权限的二进制串，以及代表攻击者意图的代码。</p><h4 id="漏洞利用的具体技术"><a href="#漏洞利用的具体技术" class="headerlink" title="漏洞利用的具体技术"></a>漏洞利用的具体技术</h4><ul><li>修改内存变量</li><li>修改代码逻辑</li><li>修改函数返回地址</li><li>修改函数指针</li><li>攻击异常处理机制</li><li>修改P.E.B中线程同步函数的入口地址</li></ul><h3 id="21-软件漏洞检测方法"><a href="#21-软件漏洞检测方法" class="headerlink" title="21.软件漏洞检测方法"></a>21.软件漏洞检测方法</h3><p>目前主流的软件漏洞挖掘方法有Fuzzing技术、安全扫描技术、静态分析、动态分析、基于二进制的检测分析技术等。</p><p>UltraEdit可以用于打开任意类型的文件，可以以二进制的形式查看文件的内容。可以用UltraEdit来检测文件的类型，包括未知文件类型。</p><p>OllyDBG是一个程序调试器，OllyDBG结合了静态和动态调试的方法，通过实时的反应出内存和程序执行的关系来进行程序的调试，可以用来检测漏洞，比如缓冲区溢出、内存泄露等等。可以编写好带有缓冲区溢出的程序，编译链接成exe文件，然后放到OllyDBG中执行，设置断点，实时观察内存地址、反汇编窗口，信息窗口以及堆栈信息等可以分析出程序的漏洞。</p><h4 id="静态漏洞挖掘工具"><a href="#静态漏洞挖掘工具" class="headerlink" title="静态漏洞挖掘工具"></a>静态漏洞挖掘工具</h4><ol><li>cppcheck<ul><li>静态的C/C++代码分析工具，用以检查内存泄露、缓冲区溢出以及更多问题</li></ul></li><li>SPLINT<ul><li>使用规则检查技术，支持对C/C++使用规则找到大规模程序故障，由于给定规则的限制，也就只能找到给定的故障</li></ul></li><li>FindBugs<ul><li>根据词汇分析和数据流分析，支持对Java的静态代码漏洞挖掘。该工具自带检测器Detector，开发者还可以根据自己的需求设计编写特定的缺陷检测器</li></ul></li><li>PMD<ul><li>也是Java的静态代码分析工具</li></ul></li></ol><h4 id="动态漏洞挖掘工具"><a href="#动态漏洞挖掘工具" class="headerlink" title="动态漏洞挖掘工具"></a>动态漏洞挖掘工具</h4><ol><li>MiniFuzz<ul><li>模糊测试技术(fuzzing)，简单易用，原理清晰</li></ul></li><li>AFL<ul><li>动态二进制插桩技术，比较高效</li></ul></li><li>Hodor<ul><li>污点跟踪技术，应用范围广</li></ul></li><li>Boofuzz<ul><li>模糊测试技术，简单易用，发生错误更少。内置多个模块，比如会话(Session)模块，Session对象是fuzz会话的中心；连接模块，Connection可以选择TCP、UDP等多种套接字连接。运行http用例，boofuzz通过事前约定好的数据进行测试，最后同时也可以在localhost的26000端口网页端查看检测日志。</li></ul></li></ol><h3 id="22-恶意代码分类及各自特点"><a href="#22-恶意代码分类及各自特点" class="headerlink" title="22.恶意代码分类及各自特点"></a>22.恶意代码分类及各自特点</h3><p>恶意代码也叫恶意软件，广义上的计算机病毒。可以分为以下几种：</p><ul><li><p>计算机病毒、蠕虫</p><ul><li><strong>计算机病毒</strong>是一种可以自我传播、需要用户干预（或者说不能独立运行、需要宿主程序激活）来触发执行的破坏性程序或者代码</li><li><strong>网络蠕虫</strong>是一种可以自我传播、但不需要用户干预（或者说可以独立运行）就可以触发执行的破坏性程序或代码</li></ul></li><li><p>木马、后门</p><ul><li><strong>特洛伊木马</strong>指看起来具有正常功能，但实际上却隐藏得有用户不希望的功能程序。通常由控制端和被控制端两端组成</li><li><strong>后门</strong>是使得攻击者可以非法获取到系统的权限来操作系统的一类程序。后门程序包括了木马程序，后门主要是获取到系统的权限就像给攻击者开了一个后门一样，以方便随时利用这个系统，木马就是隐藏在正常程序中的一段有恶意目的的代码或者文件，可以用来记录密码、记录键盘、删除文件等功能。</li></ul></li><li><p>Rootkit</p><ul><li><strong>Rootkit</strong>通过修改现有的操作系统软件，使得攻击者获取访问权并隐藏在计算机中的程序</li></ul></li><li><p>僵尸程序(bot)</p><ul><li><strong>僵尸程序</strong>通过聊天室，文件共享网络感染存在漏洞的计算机，这些感染的计算机就相当于被攻击者控制。</li></ul></li><li><p>流氓软件、间谍软件</p><ul><li><strong>流氓软件</strong>就是具有一定的实用价值但是具备电脑病毒和黑客软件的部分特征的软件（特点就是难以卸载）</li><li><strong>间谍软件</strong>是会收集用户计算机上的信息、机密文件或者隐私数据上报到服务器</li></ul></li><li><p>广告软件、Exploit、黑客工具等</p><ul><li><strong>广告软件</strong>未经过用户允许，直接下载并且安装或者说与其他软件以捆绑软件一起下载下来，一直弹出广告并且难以根除的程序</li><li><strong>Exploit</strong>是精心设计的用于特定漏洞利用来对目标系统实施攻击的程序</li><li><strong>黑客工具</strong>是各类直接或间接用于网络和主机渗透的软件，比如各种扫描器、后门植入工具、密码嗅探器、提权工具等</li></ul></li></ul><h3 id="23-如何更加科学地对恶意软件进行分类和命名"><a href="#23-如何更加科学地对恶意软件进行分类和命名" class="headerlink" title="23.如何更加科学地对恶意软件进行分类和命名"></a>23.如何更加科学地对恶意软件进行分类和命名</h3><p>目前互联网的发展，各种恶意软件层出不穷，防不胜防，一步小心就会给计算机带来麻烦。恶意软件的行为日益泛化，我们要进行分类可以分析软件的原理或者说按照恶意软件的功能就行划分，比如提权类的恶意软件、给普通计算机用户仅仅是造成不良好体验的流氓软件等类似这种功能的方面进行一个分类。其次，我们还可以建立一个恶意软件的标准危险等级，按照它对于计算机的一个威胁程度进行分类，威胁越大的等级越高。最后我们还可以用魔法打败魔法，采用人工智能，基于深度学习来进行恶意代码分类。</p><h3 id="24-流氓软件及其特点"><a href="#24-流氓软件及其特点" class="headerlink" title="24.流氓软件及其特点"></a>24.流氓软件及其特点</h3><p>流氓软件是属于恶意软件中的一种。流氓软件它本身其实是具有一定的实用价值，比如某2345，它本身可以给你提供一些压缩文件或者防病毒的功能，但是它会安装它的全家桶让你实在是难以接受，通常还会类似一个广告软件弹出各种广告。所以流氓软件就是具有一定实用价值具备电脑病毒和黑客软件部分特征的软件。其最大的特点就是对于普通用户来说难以卸载。</p><h3 id="25-网络蠕虫功能结构及工作机制"><a href="#25-网络蠕虫功能结构及工作机制" class="headerlink" title="25.网络蠕虫功能结构及工作机制"></a>25.网络蠕虫功能结构及工作机制</h3><p>蠕虫的功能模型包含有基本功能模块和扩展功能模块。</p><ul><li>基本功能模块包含有：<ul><li>信息收集模块：完成对本地和目标节点主机的信息汇集，为发现易感染目标提供支持</li><li>扫描探测模块：发现易感染主机群体</li><li>攻击渗透模块：利用已发现的服务漏洞实施攻击</li><li>自我推进模块：完成对目标节点的感染</li></ul></li><li>扩展功能模块主要取决于攻击者的目的，通常有：<ul><li>实体隐藏模块：主要提供蠕虫的生存能力。对蠕虫各个实体组成部分的隐藏、加密、变形</li><li>宿主破坏模块：破坏被感染主机网络正常运行，在被感染主机上植入后门</li><li>信息通信模块：使蠕虫间、蠕虫同黑客间进行通信</li><li>远程控制模块：控制被感染主机，执行攻击者下达的指令</li><li>自动升级模块：随时更新模块功能，实现持续攻击</li></ul></li></ul><h3 id="26-蠕虫的检测与防治"><a href="#26-蠕虫的检测与防治" class="headerlink" title="26.蠕虫的检测与防治"></a>26.蠕虫的检测与防治</h3><p>对于网络管理者和安全厂商比较典型的检测技术有流量监测与分析技术、安全软件监测等。当检测出蠕虫后进行防治可以采用网关阻断，补丁下发，网络安全设备阻断，利用客户端安全软件清除蠕虫个体并进行补丁修补。</p><p>对于个人用户来说，检测与防治蠕虫还是通过一些安全防护软件来进行，及时修护漏洞补丁，使用防火墙软件阻断等。</p><h3 id="27-木马的通信方式、连接方式及各自优缺点"><a href="#27-木马的通信方式、连接方式及各自优缺点" class="headerlink" title="27.木马的通信方式、连接方式及各自优缺点"></a>27.木马的通信方式、连接方式及各自优缺点</h3><p>木马的通信方式：传输通道构建信息，IP地址、端口等信息、第三方网站地址等。</p><p>建立通信连接的方式主要有正向连接和反向连接两种，反向连接又分为两种方式</p><ul><li><p>正向连接</p><ul><li><p>控制端（客户端）主动连接被控端（服务端）。创建服务器端TCP套接字，打开端口监听，连接服务器端口，采用TCP建立连接</p></li><li><p>优点：由控制端主动连接被控端，因此攻击者无需外部的IP地址；木马样本不会泄露攻击者的IP地址</p></li><li><p>缺点：可能会被防火墙阻断，被攻击者必须具备外部IP地址，定位被攻击者相对困难</p></li></ul></li><li><p>反向连接-1</p><ul><li>被控端直接连接控制端</li><li>优点：通过防火墙相对容易；攻击目标随时上线、随时控制；可以控制局域网内的目标</li><li>缺点：样本会暴露控制服务器信息(域名或者IP)，攻击者通常要具有外部IP</li></ul></li><li><p>反向连接-2</p><ul><li>被控端通过一个第三方肉鸡(傀儡机，受黑客远程控制的电脑)或者Web服务器和控制端间接的通信。</li><li>优点：可以绕过防火墙，自动连接上线，不易被发现</li><li>缺点：第三方服务器的稳定性需要保证</li></ul></li></ul><h3 id="28-PE病毒感染关键技术及实现过程"><a href="#28-PE病毒感染关键技术及实现过程" class="headerlink" title="28.==PE病毒感染关键技术及实现过程=="></a>28.==PE病毒感染关键技术及实现过程==</h3><ol><li><p>病毒感染重定位</p><p>由于病毒要用到变量（或常量），病毒感染HOST程序后，由于病毒代码的各个变量在内存中的位置会随HOST程序的大小不同而发生变化，因此病毒必须对病毒代码中的变量进行重定位。病毒代码目标寄生位置不固定。</p></li><li><p>获取API函数地址</p><p>病毒代码没有引入函数机制的支持，所以病毒必须自己获取API函数的地址。首先获取Kernel32的基地址，再从Kernel32中得到API函数的地址</p></li><li><p>目标程序遍历搜索</p><p>通常以PE文件格式的文件作为感染目标，进行搜索时调用FindFirstFile和FindNextFile两个API</p></li><li><p>文件感染</p><p>主要包括使病毒代码能够得到运行，并且原程序的正常功能不能被破坏。这就需要感染时记录原始“程序控制点位置”，病毒代码执行完毕后返回控制权。避免重复感染：感染标记</p></li></ol><h3 id="30-Windows-PE病毒的常用感染方式及优缺点"><a href="#30-Windows-PE病毒的常用感染方式及优缺点" class="headerlink" title="30.Windows PE病毒的常用感染方式及优缺点"></a>30.Windows PE病毒的常用感染方式及优缺点</h3><p>添加新节感染：增加新节存放病毒代码，要事先检查节表空间是否足够</p><p>碎片式感染：代码分解插入到节之间的填充部分</p><p>插入式感染：病毒代码插入到HOST文件的代码节，这样会增加HOST程序大小，并且可能会修改HOST程序中的数据导致HOST程序运行失败</p><p>伴随式感染：备份HOST程序，用自身替换HOST程序，病毒代码执行完毕再把控制权交回HOST程序。</p><h3 id="31-宏病毒传播过程"><a href="#31-宏病毒传播过程" class="headerlink" title="31.宏病毒传播过程"></a>31.宏病毒传播过程</h3><p>宏病毒将代码放到数据文件或者模板的宏中，由于这些宏会自动执行，因此获取控制权。宏病毒在单机情况下就是Office文档模板传播，在网络情况下也可能通过邮件进行传播。通过让宏在数据文档和文档模板两类文件之间互相感染进行传播。自我保护、代码导出（到本地文件）、代码导入（到当前活动文档）。</p><h3 id="32-常见的病毒检测技术及优缺点"><a href="#32-常见的病毒检测技术及优缺点" class="headerlink" title="32.常见的病毒检测技术及优缺点"></a>32.常见的病毒检测技术及优缺点</h3><ol><li>特征值检测技术<ul><li>从病毒中提取病毒特征值进行检测，通常是病毒中的一段或者多段字符串或二进制串</li><li>优点：检测速度快，误报率低，技术成熟</li><li>缺点：只能检测已知的恶意代码，容易被免杀绕过</li></ul></li><li>校验和检测技术<ul><li>检查检测对象的实际校验和与预期的是否一致，判断是否感染</li><li>优点：方法简单，能发现未知病毒，目标文件的细微变化也能发现</li><li>缺点：必须预先记录正常文件的校验和才能做对比，误报率高，不能识别病毒名称，效率低</li></ul></li><li>启发式扫描技术<ul><li>恶意代码检测经验和知识的软件实现</li><li>优点：能发现未知病毒</li><li>缺点：误报率高</li></ul></li><li>虚拟机检测技术<ul><li>在内存中模拟一个小的封闭程序执行环境，所有待查的文件在其中被虚拟执行</li><li>优点：有效处理加密类病毒；虚拟机技术+特征值扫描，准确率更高；虚拟机技术+启发式扫描，有利于检测未知变形病毒</li></ul></li><li>主动防御技术<ul><li>也叫行为监控技术，动态监视API接口的调用，判断其程序执行的合法，监控敏感行为</li><li>优点：可发现未知恶意软件，可准确的发现未知恶意软件的恶意行为</li><li>缺点：误报率高，不能识别恶意软件名称，实现困难</li></ul></li></ol><h3 id="33-恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性"><a href="#33-恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性" class="headerlink" title="33.恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性"></a>33.恶意软件为实现自我保护，常见的特征值检测对抗和人工分析对抗中，各自的对抗手段有哪些？这些手段的原理是什么？并分析其难度和有效性</h3><h4 id="特征值检测技术对抗方式"><a href="#特征值检测技术对抗方式" class="headerlink" title="特征值检测技术对抗方式"></a>特征值检测技术对抗方式</h4><ol><li><p>事后对抗，手工修改自身特征：</p><ul><li>首先利用反病毒软件定位特征值，然后做针对性修改。原理就是定位到检测软件检测到的特征值然后做针对性修改来逃过检测。不同的特征值检测方式可能不同，并且也不止一处特征值。需要灵活的使用特征码定位工具。</li></ul></li><li><p>事前对抗，自动修改自身特征：</p><ul><li>通过加密、多态、变形等，对病毒代码进行加密混淆，使其逃过特征值检测软件。编写这种代码非常的耗时，并且仅仅适用于恶意程序自我复制的情况。但现在因为基于行为的反病毒检测手段出现后，这种对抗的有效性也降低了。</li><li>加壳处理，通过对代码加壳实现数据特征的变化，体积的压缩，实现程序的免杀</li></ul></li></ol><h4 id="人工分析对抗"><a href="#人工分析对抗" class="headerlink" title="人工分析对抗"></a>人工分析对抗</h4><ol><li><p>在病毒代码编写过程中加入自我保护手段(反汇编、反调试代码等)</p></li><li><p>直接采用第三方软件（加壳软件）增强病毒程序的人工分析难度。</p><p>所谓加壳就是加入一段程序，专门负责保护其不被非法修改或者反编译的程序。但是采用的加壳软件也可能会有对应的脱壳软件，会反对抗到加壳，使得加壳无效。</p></li></ol><h3 id="34-面对恶意软件样本，分析目标，分析方法"><a href="#34-面对恶意软件样本，分析目标，分析方法" class="headerlink" title="34.面对恶意软件样本，分析目标，分析方法"></a>34.面对恶意软件样本，分析目标，分析方法</h3><ol><li>恶意软件样本分析的分析目标：<ul><li>理解恶意软件的工作原理和行为特征</li><li>实现或完善相应的安全检测机制</li><li>实现对已有恶意软件和未知恶意软件的防御、检测</li></ul></li><li>恶意软件样本分析的分析方法：<ul><li>在线分析：<strong>在线病毒扫描</strong>、<strong>在线行为分析</strong></li><li>本地静态分析：<strong>加壳检测与脱壳</strong>、<strong>反汇编/反编译</strong>、资源分析</li><li>本地动态分析：快照对比分析、<strong>行为监控分析</strong>、<strong>调试跟踪</strong>、<strong>网络监控分析</strong>、<strong>运行环境仿真</strong></li><li>网络交互的动态分析：网络连接选择、网络交互环境仿真、<strong>数据包捕获分析</strong></li></ul></li></ol><h3 id="35-常见的加壳类型检测工具"><a href="#35-常见的加壳类型检测工具" class="headerlink" title="==35.常见的加壳类型检测工具=="></a>==35.常见的加壳类型检测工具==</h3><h3 id="36-针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？"><a href="#36-针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？" class="headerlink" title="36.针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？"></a>36.针对已知病毒如何快速有效检测？针对未知病毒如何进行有效检测？目前支持未知病毒检测方法的优劣，并提出你的方法和思路？</h3><p>对于已知病毒我们可以先查看病毒是否进行过加壳处理，如果加壳了则需要用脱壳技术进行解密，然后可以利用特征值检测技术，或者用虚拟机检测技术进行检测，然后虚拟机检测+特征值结合可以提高检测效率。</p><p>对于未知病毒的检测方法有校验和检测技术，可以发现未知的恶意代码，但是这样的方法需要提前对文件有一个校验和的预期，才能同被植入了恶意代码的文件做对比。其次还可以采用启发式扫描结合虚拟机技术来实现对未知病毒的检测，提高检测的准确率。也可以用主动防御技术，监控程序API接口调用，进行逻辑分析，识别出恶意软件，但是这样的实现有些复杂，比较困难。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件系统安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全协议基本问题</title>
      <link href="/2021/12/24/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/12/24/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="Http和Https协议的端口号："><a href="#Http和Https协议的端口号：" class="headerlink" title="Http和Https协议的端口号："></a>Http和Https协议的端口号：</h3><p>Http：80  Https：443</p><h3 id="网络监听："><a href="#网络监听：" class="headerlink" title="网络监听："></a>网络监听：</h3><p>网络监听是一种监视网络状态、数据流程以及网络上信息传输的工具，它可以将网络界面设定成监听模式，并且可以截获网络上所传输的信息。但是网络监听只能应用于连接同一网段的主机，通常被用来获取用户密码等。也就是说，当黑客登录网络主机并取得超级用户权限后，若要登录其它主机，使用网络监听便可以有效地截获网络上的数据，这是黑客使用最好的方法。</p><h3 id="非对称密码算法："><a href="#非对称密码算法：" class="headerlink" title="非对称密码算法："></a>非对称密码算法：</h3><p>RSA（密钥分配，也能用于加解密数据，“私钥加密，公钥解密”和“公钥加密，私钥解密”）、DH（密钥分配，不能用于加解密）、DSA、ECC算法建立在有限域上椭圆曲线的离散对数问题的难解性。</p><h3 id="攻击行为："><a href="#攻击行为：" class="headerlink" title="攻击行为："></a>攻击行为：</h3><p>窃听 篡改 重放攻击 预重放 反射 类型缺陷攻击 协议交互攻击 拒绝服务攻击 密码分析 协议交互。</p><p>主动攻击是指攻击者对某个连接中通过的协议数据、单元进行各种处理。</p><p>被动攻击是指攻击者通过窃听消息来达到攻击目的；</p><p>选择出主动攻击</p><ul><li><p>被动攻击：截获</p></li><li><p>主动攻击：中断、篡改、伪造</p></li></ul><h3 id="防止用户被冒名所欺骗的方法："><a href="#防止用户被冒名所欺骗的方法：" class="headerlink" title="防止用户被冒名所欺骗的方法："></a>防止用户被冒名所欺骗的方法：</h3><p>对信息源进行身份验证 </p><h3 id="Kerberos认证支持的加密算法："><a href="#Kerberos认证支持的加密算法：" class="headerlink" title="Kerberos认证支持的加密算法："></a>Kerberos认证支持的加密算法：</h3><p>Kerberos采用的加密算法是DES</p><h3 id="ISAKMP安全关联和密钥管理协议："><a href="#ISAKMP安全关联和密钥管理协议：" class="headerlink" title="ISAKMP安全关联和密钥管理协议："></a>ISAKMP安全关联和密钥管理协议：</h3><p>一种协议框架，定义了<strong>有效负载的格式、实现密钥交换协议的机制以及SA协商</strong>。使用<strong>UDP的端口500</strong>，一般使用UDP。</p><p>从宏观上来看，ISAKMP主要做了三件事情：</p><ol><li><p><strong>SA协商</strong></p><p> SA协商的目的是为了在通信双方间协商出一组双方都认可的安全参数。比如两端采用相同的加密算法和完整性算法。</p></li><li><p><strong>密钥交换</strong>  </p><p>密钥交换的目的是为已经协商好的算法生成必要的密钥信息。</p></li><li><p><strong>对等端身份认证</strong></p><p>认证的目的是鉴别对方的身份，保证自己不是在跟一个伪造的对象通信。</p></li></ol><p>这样，通过一系列的消息交互，通信的双方既鉴别了对方的身份，也保证了后继通信的安全性。</p><h3 id="IPSEC的典型应用："><a href="#IPSEC的典型应用：" class="headerlink" title="IPSEC的典型应用："></a>IPSEC的典型应用：</h3><ul><li>端到端安全</li><li>基本VPN支持</li><li>保护移动用户访问内部网</li><li>嵌入式隧道</li></ul><h3 id="Kerberos实体认证采用的身份凭证："><a href="#Kerberos实体认证采用的身份凭证：" class="headerlink" title="Kerberos实体认证采用的身份凭证："></a>Kerberos实体认证采用的身份凭证：</h3><p>口令，票据；虹膜，指纹</p><h3 id="网络安全需求有哪些："><a href="#网络安全需求有哪些：" class="headerlink" title="网络安全需求有哪些："></a>网络安全需求有哪些：</h3><p>机密性、完整性、可控性、不可否认性、可用性</p><h3 id="IPSEC规定的2个组件："><a href="#IPSEC规定的2个组件：" class="headerlink" title="IPSEC规定的2个组件："></a>IPSEC规定的2个组件：</h3><ol><li>SAD（安全关联数据库）</li><li>SPD（安全策略数据库）</li></ol><h3 id="网络安全协议的基础："><a href="#网络安全协议的基础：" class="headerlink" title="网络安全协议的基础："></a>网络安全协议的基础：</h3><p>密码学</p><h3 id="SSL报文最终封装在什么环境："><a href="#SSL报文最终封装在什么环境：" class="headerlink" title="SSL报文最终封装在什么环境："></a>SSL报文最终封装在什么环境：</h3><ul><li>在SSL协议中，所有的传输数据都被封装在<strong>记录</strong>中进行投递</li><li>而对于总体而言，封装在<strong>传输层报文</strong>中传递</li></ul><h2 id="什么是以破坏认证协议为目标的实体"><a href="#什么是以破坏认证协议为目标的实体" class="headerlink" title="什么是以破坏认证协议为目标的实体"></a>什么是以破坏认证协议为目标的实体</h2><p>攻击者是以破坏认证协议为目标的实体</p><h2 id="Kerberos用什么来进行认证"><a href="#Kerberos用什么来进行认证" class="headerlink" title="Kerberos用什么来进行认证"></a>Kerberos用什么来进行认证</h2><p>票据</p><h3 id="IPSec、AH、ESP、IKE："><a href="#IPSec、AH、ESP、IKE：" class="headerlink" title="IPSec、AH、ESP、IKE："></a>IPSec、AH、ESP、IKE：</h3><p>IKE：互联网密钥交换协议，对应IPSec的协商阶段</p><p>AH：认证首部，对应IPSec的数据交互阶段，规定了报文格式以及对报文的处理方式和处理过程。AH只提供认证功能，不加密，仅计算消息验证码（ICV，完整性校验值）</p><p>ESP：封装安全载荷，对应IPSec的数据交互阶段。ESP同时提供机密性和完整性保护，这意味着ESP会加密报文，同时计算ICV。</p><h4 id="AH提供的三类安全服务："><a href="#AH提供的三类安全服务：" class="headerlink" title="AH提供的三类安全服务："></a>AH提供的三类安全服务：</h4><ul><li>数据完整性</li><li>数据源发认证</li><li>抗重放攻击</li></ul><h4 id="ESP提供的五类安全服务："><a href="#ESP提供的五类安全服务：" class="headerlink" title="ESP提供的五类安全服务："></a>ESP提供的五类安全服务：</h4><ul><li>数据完整性</li><li>抗数据源发认证</li><li>抗重放攻击</li><li>机密性</li><li>有限的传输流机密</li></ul><h1 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h1><h3 id="重放攻击："><a href="#重放攻击：" class="headerlink" title="重放攻击："></a>重放攻击：</h3><p>重放攻击是针对安全协议的最常见攻击，重放攻击指的是攻击者参与到协议的交互过程，利用窃听到的已经发送过的部分或全部消息，在交互过程中重新发送，来干涉协议的正常运行。</p><h3 id="前向安全："><a href="#前向安全：" class="headerlink" title="前向安全："></a>前向安全：</h3><p>一个协议具备前向安全，是指即便安全协议中使用的长期密钥被攻击者破获，而由这些长期密钥所建立（通过安全协议建立）的<strong>会话密钥</strong>仍然是安全的。如果对于协议中的任何主体，都能保证他们长期密钥的前向安全，那么这个协议提供了前向安全。</p><h3 id="类型缺陷攻击："><a href="#类型缺陷攻击：" class="headerlink" title="类型缺陷攻击："></a>类型缺陷攻击：</h3><p>消息最终是由一系列的二进制比特串组成的，类型缺陷攻击使得诚实主体对它所接收的消息发送了错误的理解，使得诚实主体把一次性随机数，时间戳或者身份等信息嵌入到某个密钥中去，进而导致协议安全性被破坏。</p><h3 id="并行会话攻击："><a href="#并行会话攻击：" class="headerlink" title="并行会话攻击："></a>并行会话攻击：</h3><p>是指攻击者安排协议的一个或多个会话并行地执行，使得自己能够从一个会话中获得消息，并通过重放到其他并行的会话中以达到自己的目的，如针对NSPK的并行会话攻击。</p><h3 id="中间人攻击："><a href="#中间人攻击：" class="headerlink" title="中间人攻击："></a>中间人攻击：</h3><p>中间人攻击就是攻击者在协议参与者双方分别进行冒充通信。攻击者先冒充参与方A与参与方B进行协议的运行，然后又冒充参与方B与参与方A进行协议的运行，但事实上参与者双方并没有感受到。</p><h3 id="IPSec："><a href="#IPSec：" class="headerlink" title="IPSec："></a>IPSec：</h3><p>TLS（安全传输层协议）可以对应用层的协议加密，并传递给传输层，但在IP层并不做任何安全性处理。IP作为其他高层协议的载体，本身并未考虑安全性问题。IPSec就是用来在IP层进行安全处理，对于高层数据，只要是通过IP传输，都会在IP层进行安全防护，实现IP数据包的机密性、完整性等安全特性，为上层协议提供“透明”的安全服务。</p><h3 id="IPSec协议的组件（什么是IPSec协议，从协议组件上回答）"><a href="#IPSec协议的组件（什么是IPSec协议，从协议组件上回答）" class="headerlink" title="IPSec协议的组件（什么是IPSec协议，从协议组件上回答）"></a>IPSec协议的组件（什么是IPSec协议，从协议组件上回答）</h3><p>IPSec是一个协议套件，<strong>核心协议是IKE、AH和ESP</strong>。其中<strong>IKE</strong>完成通信<strong>对等端身份验证、SA协商和密钥交换功能</strong>，是一个<strong>协商协议</strong>；<strong>AH和ESP是数据通信协议</strong>，他们规定了IPSec的报文格式和报文的处理过程。</p><h3 id="SSL协议："><a href="#SSL协议：" class="headerlink" title="SSL协议："></a>SSL协议：</h3><p>SSL（安全套接字协议）协议是一种增强传输层安全的协议，其协议套件由握手，更改密码规范，警告和记录协议组成。</p><ul><li>握手提供算法协商、密钥生成和身份验证功能。</li><li>更改密码规范协议用以通告对等端用新的安全参数来保护数据。</li><li>警告则同时具备安全断连和错误通告功能。</li><li>记录协议是SSL的数据承载层。</li></ul><h3 id="SSH协议的解释（SSH会话安全）："><a href="#SSH协议的解释（SSH会话安全）：" class="headerlink" title="SSH协议的解释（SSH会话安全）："></a>SSH协议的解释（SSH会话安全）：</h3><p>SSH是一个应用层安全协议，端口号为22。可以对数据进行加密，身份认证，完整性校验等。SSH由传输层协议，用户认证协议和连接协议构成，主要用于远程登录会话和为其他网络服务提供安全性的协议。</p><h3 id="Kerberos协议："><a href="#Kerberos协议：" class="headerlink" title="Kerberos协议："></a>Kerberos协议：</h3><p>Kerberos是一项认证服务。它提供一种验证用户身份的方法。它的实现不依赖于主机操作系统的认证，不基于主机的地址，也不需要有主机物理安全性的保证，并假设网络上传输的包都可以被任意地读取、修改和插入。</p><h3 id="散列函数的特征："><a href="#散列函数的特征：" class="headerlink" title="散列函数的特征："></a>散列函数的特征：</h3><ol><li>映射分布均匀性和差分分布均匀性</li><li>单向性</li><li>抗冲突性</li></ol><h3 id="数据认证性："><a href="#数据认证性：" class="headerlink" title="数据认证性："></a>数据认证性：</h3><p>数据认证性保证数据来源的合法性，通常也包含了对数据完整性的保证，这是因为修改数据相当于改变数据的来源。尽管在理论上，可以在不保证数据认证性的情况下保证数据的完整性，它们仍常通过相同的机制实现。</p><h3 id="密钥建立的目标："><a href="#密钥建立的目标：" class="headerlink" title="密钥建立的目标："></a>密钥建立的目标：</h3><p>密钥建立是一个过程，通过这个过程，可以使得两个或者多个主体拥有良好的共享秘密，以用于后继的密码学运算。</p><h3 id="针对SSL攻击方法："><a href="#针对SSL攻击方法：" class="headerlink" title="针对SSL攻击方法："></a>针对SSL攻击方法：</h3><blockquote><p><strong>中间人攻击，野兽攻击，罪恶攻击，溺水攻击，降级攻击</strong><br>主要是围绕通讯过程，加密方式，旧版本漏洞展开攻击。</p></blockquote><ol><li>中间人攻击：</li></ol><ul><li>SSL sniffing攻击解释为伪装攻击，一般结合ARP欺骗构成一个中间人攻击。它是一种针对ssl协议的应用发起的攻击。</li><li>SSL stripping攻击：是在客户端和服务器端，利用ARP欺骗等技术进行的一个中间人攻击（重定向网址）</li></ul><ol start="2"><li><p>BEAST（野兽攻击）<br>BEAST是一种明文攻击，通过从SSL/TLS加密的会话中获取受害者的COOKIE值（通过进行一次会话劫持攻击），进而篡改一个加密算法的 CBC（密码块链）的模式以实现攻击目录，其主要针对TLS1.0和更早版本的协议中的对称加密算法CBC模式。</p></li><li><p>CRIME（罪恶攻击）<br>CRIME(CVE-2012-4929)，全称Compression Ratio Info-leak Made Easy，<strong>这是一种因SSL压缩造成的安全隐患</strong>，通过它可窃取启用数据压缩特性的HTTPS或SPDY协议传输的私密Web Cookie。在成功读取身份验证Cookie后，攻击者可以实行会话劫持和发动进一步攻击。</p></li><li><p>DROWN（溺水攻击/溺亡攻击）<br>即利用过时的、<strong>弱化的一种RSA加密算法</strong>来解密破解TLS协议中被该算法加密的会话密钥。 具体说来，DROWN漏洞可以利用过时的SSLv2协议来解密与之共享相同RSA私钥的TLS协议所保护的流量。 DROWN攻击依赖于SSLv2协议的设计缺陷以及知名的Bleichenbacher攻击。</p></li><li><p>Downgrade（降级攻击）<br>降级攻击是一种对计算机系统或者通信协议的攻击，在降级攻击中，攻击者故意使系统放弃新式、安全性高的工作方式，反而使用为向下兼容而准备的老式、安全性差的工作方式，降级攻击常被用于中间人攻击，将加密的通信协议安全性大幅削弱，得以进行原本不可能做到的攻击。 在现代的回退防御中，使用单独的信号套件来指示自愿降级行为，需要理解该信号并支持更高协议版本的服务器来终止协商，该套件是TLS_FALLBACK_SCSV(0x5600)</p></li></ol><h3 id="Kerberos的票据和认证符的功能："><a href="#Kerberos的票据和认证符的功能：" class="headerlink" title="Kerberos的票据和认证符的功能："></a>Kerberos的票据和认证符的功能：</h3><ol><li>进行身份认证（用户及服务器）</li><li>防止IP地址伪造和重放攻击</li><li>加密数据</li><li>保护子会话密钥</li></ol><p>票据提供服务器（TGS）</p><p>认证服务器（AS）</p><ul><li>票据：为避免口令认证的缺陷，Kerberos引入票据许可服务，它只向已由AS（认证服务器）认证了身份的客户端颁发票据，避免了明文口令的传输。</li><li>认证符：认证符的作用是验证客户的身份，客户不仅要传输票据，还需要发送额外的信息来证明自己确实是票据的合法拥有者，这个信息就是认证符（authenticator），它使用会话密钥加密，并包含了用户名和时间戳。</li></ul><h1 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h1><h3 id="windows下的IPSec实验："><a href="#windows下的IPSec实验：" class="headerlink" title="windows下的IPSec实验："></a>windows下的IPSec实验：</h3><ol><li>安装Wireshark软件</li><li>操作机配置IPsec加密策略</li><li>目标机配置同样的IPsec加密策略，操作机和目标机同时指派策略，查看之间通信</li><li>用Wireshark查看密钥交换过程</li></ol><h3 id="Windows下的SSL实验："><a href="#Windows下的SSL实验：" class="headerlink" title="Windows下的SSL实验："></a>Windows下的SSL实验：</h3><ol><li>搭建证书服务器</li><li>搭建web服务器端SSL证书应用</li><li>搭建Https的网站</li><li>目标机用Sniffer监测两者间的SSL连接</li></ol><p>优点</p><p>SSL在应用层协议通信前就<strong>已完成加密算法</strong>，<strong>通信密钥的协商</strong>及<strong>服务器认证</strong>工作，此后应用层协议所传送的<strong>所有数据都会被加密</strong>，从而保证通信的安全性。</p><p>缺点</p><p>SSL除了<strong>传输过程外不能提供任何安全保证</strong>；<strong>不能提供交易的不可否认性</strong>；客户认证是可选的，所以无法保证购买者就是该信用卡合法拥有者；SSL不是专为信用卡交易而设计，在多方参与的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。</p><p>工作原理<br>　　客户机向服务器发送SSL版本号和选定的加密算法；服务器回应相同信息外还回送一个含RSA公钥的数字证书；客户机检查收到的证书足否在可信任CA列表中，若在就用对应CA的公钥对证书解密获取服务器公钥，若不在，则断开连接终止会话。客户机随机产生一个DES会话密钥，并用服务器公钥加密后再传给服务器，服务器用私钥解密出会话密钥后发回一个确认报文，以后双方就用会话密钥对传送的报交加密。</p><h1 id="协议分析："><a href="#协议分析：" class="headerlink" title="协议分析："></a>协议分析：</h1><h3 id="NSPK协议的攻击："><a href="#NSPK协议的攻击：" class="headerlink" title="NSPK协议的攻击："></a>NSPK协议的攻击：</h3><p>NSPK协议提供了对主体双方的双向认证。主体A和B交换各自的随机数Na、Nb，从而共享Na和Nb，并将其结合以生成一个新的会话密钥。PKa和PKb分别为A和B的公开密钥。</p><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152024386.png" alt="image-20211105152024386"></p><blockquote><p><strong>并行会话攻击：攻击者Z首先使A发起一个会话，然后在另一个会话中，攻击者成功地冒充了A。</strong></p></blockquote><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152120732.png" alt="image-20211105152120732"></p><h3 id="大嘴青蛙协议的攻击："><a href="#大嘴青蛙协议的攻击：" class="headerlink" title="大嘴青蛙协议的攻击："></a>大嘴青蛙协议的攻击：</h3><p>会话密钥由主体产生，可信第三方将这个会话密钥传送给另外的主体，Ta、Ts分别为A、S根据各自的本地时钟产生的时间戳。S通过Ta来检查Msg1的新鲜性。如果Msg1是新鲜的，S则将密钥Kab连同自己产生的时间戳Ts发送给B。B 收到Msg2后，检查其中的Ts，若Ts位于时间窗口内，B则认为Kab是新鲜的。5</p><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152228421.png" alt="image-20211105152228421"></p><blockquote><p>并行会话攻击：</p><ul><li><p>攻击者冒充B，向S重放S刚刚发送给B的消息。S收到后，由于Ts在时间窗口内，故认可Msg1，并产生 一个新的时间戳Ts‘，发送消息Msg2’。</p></li><li><p>接着，攻击者再冒充A，S会产生一个更新的时间戳 Ts‘’，并发送消息Msg2‘’。</p></li><li><p>这最终导致攻击者能够从S得到一个“时间戳足够新，但Kab足够老”的消息，并将其发送给B，使B接受一个老的密钥</p></li></ul><p><img src="/../../img/markdown_img/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE.assets/image-20211105152250491.png" alt="image-20211105152250491"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDN的TopoGuard解决方案</title>
      <link href="/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/TopoGuard/"/>
      <url>/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/TopoGuard/</url>
      
        <content type="html"><![CDATA[<h1 id="SDN攻击和对策"><a href="#SDN攻击和对策" class="headerlink" title="SDN攻击和对策"></a>SDN攻击和对策</h1><h2 id="SDN攻击"><a href="#SDN攻击" class="headerlink" title="SDN攻击"></a>SDN攻击</h2><h3 id="1-主机位置劫持攻击"><a href="#1-主机位置劫持攻击" class="headerlink" title="1. 主机位置劫持攻击"></a>1. 主机位置劫持攻击</h3><p>对于主机位置的改变，由于SDN控制器缺乏对传输的数据包认证步骤，无法保证拓扑信息的真实性，攻击者通过发送伪装的主机消息，就可以实现对网络中的主机的伪装。如下图所示，攻击者向SDN交换机发送一个全新的数据包，交换机会上报到控制器，因为无法认证数据包的真实性，控制器会依据这个数据包默认网络服务器位置发生移动，然而实际上由于拓扑管理信息中该服务器的位置已经变更为攻击者所在的位置，导致后续正常主机无法访问该服务器。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211118094512908.png" alt="image-20211118094512908"></p><h3 id="2-链路伪造攻击"><a href="#2-链路伪造攻击" class="headerlink" title="2. 链路伪造攻击"></a>2. 链路伪造攻击</h3><p>由于目前广泛使用的SDN控制器源码是开源的，因此任何人都可以获取LLDP包格式和每个字段的语义，并且交换机每个端口都可以发送链路层发现协议（LLDP）包，包括连接着主机的端口。</p><h4 id="伪造LLDP包"><a href="#伪造LLDP包" class="headerlink" title="伪造LLDP包"></a>伪造LLDP包</h4><p>攻击者可以通过监控SDN交换机的流量然后伪造出相应的LLDP包，后续伪造的LLDP将会被发送到控制器，因此控制器便更新一条攻击者伪造的链路。</p><h4 id="重放LLDP包"><a href="#重放LLDP包" class="headerlink" title="重放LLDP包"></a>重放LLDP包</h4><p>从一个目标交换机接收到一个LLDP数据包时，攻击者将直接重放到另一目标交换机，而无需进行任何修改。如下图，攻击者将收到的LLDP包通过隧道、物理链路等方式将LLDP包发送给另一目标交换机，这样攻击者便构造了一个虚假的拓扑视图。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211118094555756.png" alt="image-20211118094555756"></p><h3 id="3-拒绝服务攻击"><a href="#3-拒绝服务攻击" class="headerlink" title="3. 拒绝服务攻击"></a>3. 拒绝服务攻击</h3><p>为了避免boardcast strom，OpenFlow控制器提供生成树服务。当网络拓扑更新时，会触发生成树服务来阻止冗余端口。这种能力可能会被攻击者利用，以发动拒绝服务攻击。比如通过给现有拓扑注入一个虚假的链接，攻击者就可以借用生成树服务来杀死正常开关端口。</p><p>生成树算法总是排除连接最大DPID交换机的链接。攻击者拥有几个连接到入口交换机的几个受损主机，通过收听LLDP数据包，对手就可以获得两个入口交换机的的DPID。然后，攻击控制受损主机通过较低的DPID连接到入口交换机，并注入假LLDP以与目标交换机宣布链接。</p><p>最终将导致两种情况：如果聚合交换机的DPID小于所选交换机的DPID，则攻击者可以关闭目标交换机的任意端口，如图a所示；如果所选择的交换机具有最小的DPID，则目标交换机和聚合交换机之间的链路被排除在生成树之外，并且相应端口也会被阻塞，如图b所示。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211118095722939.png" alt="image-20211118095722939"></p><h3 id="4-中间人攻击"><a href="#4-中间人攻击" class="headerlink" title="4. 中间人攻击"></a>4. 中间人攻击</h3><p>虚假的链路可以干扰最短路径路由服务。攻击者可以构建一个LLDP channel来欺骗OpenFlow控制器，让控制器感觉在两个目标交换机之间还存在一个内部链路（实际上并不存在）。一旦控制器注意到了链路，它就会根据这个受到污染的拓扑信息来重新计算最短路径。这样所有与虚假链路有连接的路线都被攻击者进行了污染。但是，OpenFlow与传统的以太网交换机不同，它并不会修改数据包的源MAC地址。因此为了规避可能的异常检测，我们必须在重放LLDP和普通数据包的时保留源MAC地址。</p><h2 id="防御策略"><a href="#防御策略" class="headerlink" title="防御策略"></a>防御策略</h2><h3 id="1-静态防御策略"><a href="#1-静态防御策略" class="headerlink" title="1. 静态防御策略"></a>1. 静态防御策略</h3><p>静态防御策略是预先手动配置/管理主机位置和链路信息（比如，将主机标识符（比如MAC地址）分配给一个特定的交换机端口），然后每当有新的改变时（new addition or removal）手动验证和修改。显然，静态防御策略并不是一个很好的选择，因为手动的去管理是特别繁琐的，容易出错，并且在实践中也不好扩展。特别地，它并不适用于动态的并且有可扩展性的需求的SDN网络。</p><h3 id="2-动态防御策略TopoGuard"><a href="#2-动态防御策略TopoGuard" class="headerlink" title="2. 动态防御策略TopoGuard"></a>2. 动态防御策略TopoGuard</h3><h4 id="2-1-主机位置劫持攻击的动态防御策略"><a href="#2-1-主机位置劫持攻击的动态防御策略" class="headerlink" title="2.1 主机位置劫持攻击的动态防御策略"></a>2.1 主机位置劫持攻击的动态防御策略</h4><p>主机位置劫持攻击的问题主要在于，当主机位置更新的时候，OpenFlow控制器缺乏了对主机标识符的验证。</p><h5 id="2-1-1-主机实体认证"><a href="#2-1-1-主机实体认证" class="headerlink" title="2.1.1 主机实体认证"></a>2.1.1 主机实体认证</h5><p>这是一个密码学的加密解决方案：添加额外的公钥来验证主机。当一个主机需要改变它的位置的时候，它就把新的位置信息通过私钥加密到数据包中没使用的部分（比如VLAN ID or ToS）。</p><p>这个方案理论上确实是可行的，可以解决恶意主机的profile伪造，因为攻击者无法获取目标主机的私钥。但是在现实上，这种方案需要增加额外的存储开销来保存OpenFlow控制器的公钥，以及用于处理每个Packet-In数据包的计算开销。并且，所有主机的密钥管理和动态添加/修改也会带来额外的开销和成本。此外，这种方法需要在每个主机上修改实现，实际部署上非常的繁琐和困难。</p><h5 id="2-1-2-主机迁移合法性的验证"><a href="#2-1-2-主机迁移合法性的验证" class="headerlink" title="2.1.2 主机迁移合法性的验证"></a>2.1.2 主机迁移合法性的验证</h5><blockquote><p>主机迁移完成的条件：</p></blockquote><ul><li>主机迁移的前置条件是OpenFlow控制器必须接收到一个Port_Down信号在主机迁移完成之前</li><li>主机迁移的后置条件是主机在完成迁移之后，对先前位置的主机实体的访问是不可达的。</li></ul><p>因此，基于上述两种情况，我们可以通过检查前置条件和后置条件来验证主机迁移的合法性。若有一个条件不满足，那么可能原主机位置被劫持，与控制器进行通信的主机是攻击者伪造的主机，这样就会被检测到。这个方法也增加了额外的开销，但是比较上面基于公私钥的实体认证相比，显然此方法更加轻量级。</p><p>在面向SDN的车载边缘计算中我们也可以利用这种模型，来对抗主机位置劫持的攻击。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222850617.png" alt="image-20211224222850617"></p><h4 id="2-2-链路伪造攻击的动态防御策略"><a href="#2-2-链路伪造攻击的动态防御策略" class="headerlink" title="2.2 链路伪造攻击的动态防御策略"></a>2.2 链路伪造攻击的动态防御策略</h4><blockquote><p>链路伪造的攻击主要在两个方面：</p></blockquote><ul><li><p>在OpenFlow网络的链路发现过程中，LLDP包的完整性/来源可能遭到破坏</p></li><li><p>受损主机参与LLDP传播路径</p><h5 id="2-2-1-LLDP数据包的身份验证"><a href="#2-2-1-LLDP数据包的身份验证" class="headerlink" title="2.2.1 LLDP数据包的身份验证"></a>2.2.1 LLDP数据包的身份验证</h5><p>解决这个问题的一个方案是在LLDP数据包中添加额外的身份验证器TLVs。比如，我们可以在LLDP数据包中添加一个有控制器签名的TLV，并在接收到LLDP数据包时检查签名。签名TLV是通过LLDP数据包中的DPID和端口号都计算的。这样，攻击者很难操纵LLDP数据包。然而这种方法，无法抵抗基于LLDP重放/隧道的方式的链路伪造攻击。</p><h5 id="2-2-2-交换机端口属性的验证"><a href="#2-2-2-交换机端口属性的验证" class="headerlink" title="2.2.2 交换机端口属性的验证"></a>2.2.2 交换机端口属性的验证</h5><p>如果OpenFlow链路发现过程中没有主机参与到LLDP的传播，那么就可以判断没有攻击者进行链路伪造。因此可以检查是否有主机驻留在LLDP的链路传播中从而检测是否有攻击者参与。</p><p>我们可以增加一些额外的逻辑来跟踪来自不同交换机端口的流量，已决定哪个设备连接到哪个端口。如果 OpenFlow 控制器从特定的交换机端口检测到主机生成的流量（例如DNS），则我们将该端口的设备类型设置为 HOST。否则，当从这些端口接收到 LLDP 数据包时，我们将这些交换机端口指定为交换机。在 OpenFlow 网络中，这两个类型是相互排斥的，因为 LLDP 只能在交换机内部链路端口和连接到OpenFlow控制器的端口上传输。</p><p>这种方法的一个假设是：受损的主机不是一个实际的交换机，因此将生成常规的主机生成的流量（如ARP，DNS）。这假设也确实是合理的，在实践中大多数情况下也成立。虽然攻击者也可以禁用受损主机或者虚拟机中的所有主机生成流量，但它这样多少页破坏了主机的正常网络活动功能，无异于暴露自己，使得正常机器用户注意到。</p></li></ul><h2 id="TopoGuard"><a href="#TopoGuard" class="headerlink" title="TopoGuard"></a>TopoGuard</h2><p>TopoGuard的基本思想是通过修复上一节所提到的安全漏洞来确保控制器的安全。</p><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>下图展示了TopoGuard防御系统的体系结构。The Topology Update Checker在探测到拓扑更新后会去验证主机迁移的合法性，LLDP数据包的完整性和来源以及交换机端口属性。具体来说，Port Manager监视 OpenFlow 消息，以跟踪存储在Port Property（端口属性）中的交换机端口动态。然后，Port Property将用于推理拓扑更新的可信性。Host Prober（主机探测）用来测试在OpenFlow网络中特点位置的主机的活动性，并且判断主机迁移的合法性。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222838902.png" alt="image-20211224222838902"></p><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h3><h4 id="端口属性管理"><a href="#端口属性管理" class="headerlink" title="端口属性管理"></a>端口属性管理</h4><p>为了推断拓扑更新的有效性，给OpenFlow控制器中每个交换机端口增加了额外属性。包括：</p><p>设备类型（Device Type）、主机列表（HOST List）和标识（SHUT_DOWN_FLAG）。</p><ol><li><p>设备类型</p><p>设备类型指的是一个特定交换机端口连接到的设备类型。该值可以是任意值ANY，交换机SWITCH，主机HOST。初始值是ANY，它将根据后续流量切换到SWITCH或者HOST。当端口管理器从具有设备类型为ANY的交换机端口接收LLDP数据包时，它会将其类型更改为SWITCH。同样，若接收到任何 first-hop 主机流量时，交换机端口的设备类型被设置为HOST。相反，当接收到端口状态信息中指示的Port_Down信号时，HOST和交换机端口值被设置为ANY。如果端口管理器检测到HOST端口的LLDP包或者交换机端口的first-hop主机流量包，则会引发攻击警报并通知拓扑更新检查器以防止相关拓扑更新。这种防御方法的认为LLDP数据包仅被设计为通过数据平面上的交换机内部链路端口。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222829755.png" alt="image-20211224222829755"></p></li></ol><ul><li><p>设备类型被判定为HOST说明交换机端口所连接到的设备类型是一个主机，而当端口管理器检测到主机端口发送的是LLDP数据包，那么可以认定发生了链路伪造的攻击。</p></li><li><p>设备类型被判定为SWITCH说明交换机端口所连接到的设备类型是一个交换机，而当端口管理器检测到主机端口发送的是主机流量数据包，那么就可以认为在链路发现的过程中有主机的参与，即是发生了攻击。</p></li></ul><ol start="2"><li><p>主机列表</p><p>端口属性管理的一个挑战是<strong>如何确定端口的设备类型为HOST。</strong>尽管上述中我们认为若接收到任何first-hop 主机流量时，交换机端口的设备类型被设置为HOST。但是在实际上，发现不同的OpenFlow交换机可能会为特定的主机流发出多个包内消息的副本，即<strong>OpenFlow控制器将从交换机内部链路端口接收主机流量。</strong></p><p>为了解决这个问题，在每个交换机端口的端口属性中维护<strong>主机列表</strong>，其中包含主机实体（MAC地址形式）。当接收到Packet-In消息时，端口管理器<strong>在现有端口属性的主机列表中定位主机实体。如果没有找到，则将流量视为first-hop流量，并将源MAC地址记录在入口交换机端口的端口属性的主机列表中。</strong></p></li><li><p>SHUT_DOWN_FLAG</p><p>主机列表的另一个作用是验证主机迁移的可信度。主机迁移的前置条件是控制器在主机迁移完成之前接收到一个Port_Down信号。此时一旦检测到该<strong>端口关闭</strong>，我们将为交换机端口的主机列表中的主机<strong>设置SHUT_DOWN_FLAG</strong>。当端口管理器从该端口接收到相关的主机流量时，可以禁用SHUT_DOWN_FLAG。此外，我们还可以验证主机列表中的SHUT_DOWN_FLAG，以验证主机迁移。</p></li></ol><h4 id="主机探测"><a href="#主机探测" class="headerlink" title="主机探测"></a>主机探测</h4><p>我们还可以利用主机探测器（Host Prober）来验证主机迁移的后置条件，即主机迁移完成后在前一个位置无法访问主机。</p><p>主机探测器向主机的前一个位置发出一个主机探测数据包，例如：IMCPEcho请求，并且设置一个合理的timeout（1s）等待响应。为了确保响应的成功交付，主机探测器还安装了一个流规则，以将 ICMP 响应引导回 OpenFlow 控制器。</p><h4 id="拓扑更新验证"><a href="#拓扑更新验证" class="headerlink" title="拓扑更新验证"></a>拓扑更新验证</h4><p>拓扑更新检查器将验证拓扑更新的正确性，包括主机迁移和新的链路发现。</p><ul><li><p><input disabled="" type="checkbox">  检测到主机迁移</p><p>检查器将引用<strong>端口属性</strong>来检查该<strong>前置条件</strong>，并指示<strong>主机探测</strong>程序验证该<strong>后置条件</strong>。</p></li><li><p><input disabled="" type="checkbox">  验证链路发现</p><p>第一个任务是确保 LLDP 的完整性/来源。为此，我们在一个LLDP 数据包中放置一个签名 TLV，这是一个 DPID 和端口号的加密哈希值。一旦发现一个新链路，拓扑更新检查器就会对已签名的哈希值 TLV 执行额外的验证逻辑。然后，拓扑更新检查器检测主机是否位于 LLDP 传播的路径上。通过检查新链路的交换机端口的设备类型来完成。因此，HOST 端口中涉及的任何内部链接更新都将被拒绝，并触发攻击警报。</p></li></ul><h2 id="传统网络的具体攻击方式"><a href="#传统网络的具体攻击方式" class="headerlink" title="传统网络的具体攻击方式"></a>传统网络的具体攻击方式</h2><h3 id="主机位置劫持"><a href="#主机位置劫持" class="headerlink" title="主机位置劫持"></a>主机位置劫持</h3><p>一个臭名昭著的主机位置劫持攻击是以太网网络中的 <strong>ARP 缓存毒化攻击</strong>。即攻击者发送伪造的 ARP 消息，以将目标主机的 IP 地址与恶意主机 的 MAC 地址关联起来。通过这样做，对手可以劫持目标主机的实体，这通常是一个网关。但是，ARP 缓存中毒攻击与主机位 置劫持攻击有几个不同，如下表所示。首先，ARP 高速缓存中 毒的攻击范围仅限于一个广播域，即对手必须与其目标保持在 同一广播域内。相比之下，对手可以在 OpenFlow 网络的任何位置发起主机位置劫持攻击。第二，除了 ARP 应答数据包外，主 机位置劫持攻击还可以利用几乎各种数据包，如 ICMPEcho、UDP 和 TCP，来篡夺目标主机的位置。在这一点上，主机位置劫持攻击可以隐藏在正常流量中，以避开 NIDS（网络入侵检测）。同样从防御的角度来看，传统的 ARP 缓存中毒缓解策略， 如静态 ARP 条目，可能不适合直接应用于 SDN 网络，因为其静态配置破坏了 OpenFlow 网络的动态处理能力。例如，跟踪各种 OpenFlow 访问点之间的主机迁移。为了抵御主机位置劫持攻击以及跟踪网络动态，在本文中，我们利用 OpenFlow 的特定功能来动态验证主机迁移。</p><p><img src="/../../img/markdown_img/TopoGuard.assets/image-20211224222820222.png" alt="image-20211224222820222"></p><h3 id="链路伪造"><a href="#链路伪造" class="headerlink" title="链路伪造"></a>链路伪造</h3><p>在传统网络中，类似于链路伪造攻击的攻击是 <strong>STP 破坏</strong>（即 BPDU 伪造），即对手用最小的桥 ID 伪造 BPDUs，以抢占生成树的根。在伪造根之后，对手有可能精心策划拒绝服务或中间攻击。然而，STP 破坏攻击只会扰乱STP 的运行，而不是向网络拓扑中注入一个假的链路，以毒害整个网络操作。</p>]]></content>
      
      
      <categories>
          
          <category> SDN软件定义网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mininet的环境安装</title>
      <link href="/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/SDN/"/>
      <url>/2021/12/24/SDN%20%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%94%BB%E5%87%BB/SDN/</url>
      
        <content type="html"><![CDATA[<h1 id="Mininet"><a href="#Mininet" class="headerlink" title="Mininet"></a>Mininet</h1><h3 id="安装Mininet"><a href="#安装Mininet" class="headerlink" title="安装Mininet"></a>安装Mininet</h3><p><a href="http://mininet.org/download/#option-2-native-installation-from-source">http://mininet.org/download/#option-2-native-installation-from-source</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> git://github.com/mininet/mininet</span><br><span class="line">sudo mininet/util/install.sh -n3v<span class="comment">#-a基本不会成功</span></span><br><span class="line">sudo install.sh -h <span class="comment">#安装OpenFlow Wireshark分解器</span></span><br></pre></td></tr></table></figure><h3 id="Mininet命令"><a href="#Mininet命令" class="headerlink" title="Mininet命令"></a>Mininet命令</h3><h4 id="网络建构启动参数"><a href="#网络建构启动参数" class="headerlink" title="网络建构启动参数"></a>网络建构启动参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--topo自定义拓扑结构（最常用）</span><br><span class="line">--custom加载脚本拓扑</span><br><span class="line">--switch自定义要使用的交换机</span><br><span class="line">--controller自定义要使用的控制器</span><br><span class="line">--mac自动配置设备的MAC地址</span><br></pre></td></tr></table></figure><h5 id="–topo"><a href="#–topo" class="headerlink" title="–topo"></a>–topo</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --topo=single,3<span class="comment">#单一拓扑：交换机只有一个，下挂一个或多个主机</span></span><br><span class="line">sudo mn --topo=linear,4<span class="comment">#线性拓扑：交换机连接为线性排列，每个交换机所连接的主机数目只有一个</span></span><br><span class="line">sudo mn --topo=tree,depth=2,fanout=2<span class="comment">#树形拓扑：交换机连接成树形，depth为深度，叶子结点为主机，fanout为广度，即一个交换机下有多少个设备</span></span><br><span class="line">sudo mn --custom file.py --topo mytopo<span class="comment">#file.py最好替换成绝对路径 mytopo为file.py中的类名</span></span><br><span class="line">sudo mn --protocol=openflow13<span class="comment">#最小化拓扑，一个交换机，两个主机</span></span><br></pre></td></tr></table></figure><h5 id="–swicth"><a href="#–swicth" class="headerlink" title="–swicth"></a>–swicth</h5><p>默认使用OpenVSwitch交换机</p><h5 id="–controller"><a href="#–controller" class="headerlink" title="–controller"></a>–controller</h5><p>定义要使用的控制器，如果没有则使用mininet中默认的控制器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --controller=remote,--ip=[controller IP],--port=[port]<span class="comment">#remote表示远程控制器</span></span><br></pre></td></tr></table></figure><h5 id="–mac"><a href="#–mac" class="headerlink" title="–mac"></a>–mac</h5><p>自动设置设备的MAC地址，设置交换机的MAC、主机MAC及IP地址从小到大排序</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --topo=tree,depth=2,fanout=2,--mac<span class="comment">#直接在正常命令后面添加--mac即可</span></span><br></pre></td></tr></table></figure><h5 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --switch ovsk,protocols=OpenFlow13 --controller=remote,ip=192.168.31.139,port=6653 --topo=tree,depth=2,fanout=3</span><br><span class="line"><span class="comment">#交换机为Open vSwitch Kernel Mode，支持的协议为OpenFlow1.3，控制器为远程控制器，远程控制器的ip地址为192.168.31.139，端口为6653，拓扑为树形拓扑，深度为2，广度为3</span></span><br></pre></td></tr></table></figure><h4 id="内部交互命令"><a href="#内部交互命令" class="headerlink" title="内部交互命令"></a>内部交互命令</h4><h5 id="设备查看："><a href="#设备查看：" class="headerlink" title="设备查看："></a>设备查看：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump查看节点信息</span><br><span class="line">net查看链路信息</span><br><span class="line">nodes查看总共的节点</span><br><span class="line">links查看链路是否连通（不代表能ping通）</span><br><span class="line">intfs   查看网络接口信息</span><br><span class="line">pingpair只验证前两个主机的连通性</span><br><span class="line">pingall验证所有主机间的通信</span><br></pre></td></tr></table></figure><h5 id="设备操作："><a href="#设备操作：" class="headerlink" title="设备操作："></a>设备操作：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperf两节点间进行iperftcp带宽测试</span><br><span class="line">iperfudp两节点间进行iperfudp带宽测试</span><br><span class="line">link禁用或开启节点间链路</span><br><span class="line">dpctl所有交换机上的流表</span><br><span class="line">xterm进入某个节点终端</span><br><span class="line">py执行python表达式</span><br></pre></td></tr></table></figure><h6 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf h1 h2</span><br></pre></td></tr></table></figure><h6 id="iperfudp"><a href="#iperfudp" class="headerlink" title="iperfudp"></a>iperfudp</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iperfudp bw h1 h2</span><br></pre></td></tr></table></figure><h6 id="link"><a href="#link" class="headerlink" title="link"></a>link</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">link h1 s1 up<span class="comment">#禁用链路</span></span><br><span class="line">link h1 s1 down<span class="comment">#开启链路</span></span><br></pre></td></tr></table></figure><h6 id="dpctl"><a href="#dpctl" class="headerlink" title="dpctl"></a>dpctl</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpctl dump-flows</span><br><span class="line">dpctl dump-flows -O Openflow13  <span class="comment">#如果指定了使用openflow1.3协议则应这样输入</span></span><br></pre></td></tr></table></figure><h6 id="xterm"><a href="#xterm" class="headerlink" title="xterm"></a>xterm</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xterm h1</span><br></pre></td></tr></table></figure><h6 id="py"><a href="#py" class="headerlink" title="py"></a>py</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">py <span class="built_in">help</span>(s1)</span><br><span class="line">py dir(s1)</span><br><span class="line">添加主机的命令：<span class="comment">#原拓扑中为（h1，s1）（h2，s1）</span></span><br><span class="line">py net.addHost(<span class="string">&quot;h3&quot;</span>)<span class="comment">#添加h3主机</span></span><br><span class="line">py net.addLink(s1,net.get(<span class="string">&quot;h3&quot;</span>))<span class="comment">#添加s1与h3之间的链路</span></span><br><span class="line">py s1.attach(<span class="string">&quot;s1-eth3&quot;</span>)<span class="comment">#添加s1的eth3的接口</span></span><br><span class="line">py net.get(<span class="string">&quot;h3&quot;</span>).cmd(<span class="string">&quot;ifconfig h3-eth0 10.3&quot;</span>)  <span class="comment">#给h3添加ip地址（10.0.0.3）</span></span><br><span class="line">之后其他主机就可以ping通h3</span><br></pre></td></tr></table></figure><h4 id="外部运行参数"><a href="#外部运行参数" class="headerlink" title="外部运行参数"></a>外部运行参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c  清除配置</span><br><span class="line">-h  帮助</span><br></pre></td></tr></table></figure><h1 id="RYU"><a href="#RYU" class="headerlink" title="RYU"></a>RYU</h1><h3 id="安装RYU"><a href="#安装RYU" class="headerlink" title="安装RYU"></a>安装RYU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip python-dev build-essential</span><br><span class="line">sudo pip install --upgrade pip</span><br><span class="line">sudo apt-get install python-eventlet</span><br><span class="line">sudo apt-get install python-routes</span><br><span class="line">sudo apt-get install python-webob</span><br><span class="line">sudo apt-get install python-paramiko</span><br><span class="line">sudo pip install ryu</span><br></pre></td></tr></table></figure><h3 id="测试RYU"><a href="#测试RYU" class="headerlink" title="测试RYU"></a>测试RYU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ryu-manager</span><br><span class="line"><span class="comment">#如果出现 DistributionNotFound: webob&gt;=1.2 类似问题则输入sudo pip install --upgrade webob 即可，缺少什么就将“webob”替换成什么</span></span><br></pre></td></tr></table></figure><h3 id="启动RYU"><a href="#启动RYU" class="headerlink" title="启动RYU"></a>启动RYU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ryu-manager simple_switch_13.py  <span class="comment">#适用于OpenFlow 1.3协议</span></span><br></pre></td></tr></table></figure><h1 id="验证OpenFlow-1-3"><a href="#验证OpenFlow-1-3" class="headerlink" title="验证OpenFlow 1.3"></a>验证OpenFlow 1.3</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mn --switch ovs,protocols=OpenFlow13 --controller=remote,ip=192.168.31.139,port=6633  <span class="comment">#Mininet连接支持OpenFlow1.3的控制器</span></span><br><span class="line">sudo ovs-ofctl dump-flows -O openflow13 s1  <span class="comment">#查看交换机S1的流表</span></span><br></pre></td></tr></table></figure><p>也可用Wireshark对any端口进行抓包，可以捕捉到OpenFlow 1.3协议（需要筛选）</p>]]></content>
      
      
      <categories>
          
          <category> SDN软件定义网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 缓存穿透击穿与雪崩</title>
      <link href="/2021/12/17/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9/"/>
      <url>/2021/12/17/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<p>在生产环境中，会因为很多的原因造成访问请求绕过了缓存，都需要访问数据库持久层，虽然对Redis缓存服务器不会造成影响，但是数据库的负载就会增大，使缓存的作用降低</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p><strong>缓存穿透</strong>是指查询一个<strong>数据库一定不存在的数据</strong>。</p><p>正常的使用缓存流程大致是：数据查询先到缓存中查找key，发现key不存在或者已经过期，再对数据库进行查询，并把查询到的对象，数据存到缓存中。但是如果数据库为空，则不放进缓存。</p><p>缓存穿透：一个数据缓存中不存在，导致请求的数据走数据库，就会使得后端存储负载加大，然而数据库中也不存在。这种情况下如果有攻击者故意多次请求一个不存在的主键id（比如负数id），而这个负数id在数据库根本就没有，就有可能搞垮整个数据库，甚至使整个服务瘫痪。</p><p>造成缓存穿透的基本原因有两个。</p><ul><li>自身业务代码或者数据出现问题（例如：set 和 get 的key不一致）</li><li>一些恶意攻击、爬虫等造成大量空命中（爬取线上商城商品数据，超大循环递增商品的ID）</li></ul><h1 id="缓存穿透解决方案"><a href="#缓存穿透解决方案" class="headerlink" title="缓存穿透解决方案"></a>缓存穿透解决方案</h1><h2 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h2><p>缓存空对象是指：在持久层没有命中的情况下，仍然将数据进行缓存。把key的value设置为null，并设置过期时间。</p><h4 id="缓存空对象带来的问题"><a href="#缓存空对象带来的问题" class="headerlink" title="缓存空对象带来的问题"></a>缓存空对象带来的问题</h4><ol><li>缓存空对象设置key的value为空，但是仍然是占用了内存空间的，对空值做缓存，缓存中还需要去保存这个空值的key，消耗内存空间。因此我们要对这种空值设置一个过期时间，让一定时间过后自动过期。</li><li>缓存空对象可能带来缓存和数据库的数据有一段时间窗口内的不一致，可能会对业务造成影响。比如设置过期时间为1分钟，如果此时数据库又添加了这个数据，那么这段时间就会出现缓存和数据库的数据不一致。此时，可以利用消息系统或者其他方式清除缓存中的空对象。</li></ol><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><blockquote><p>布隆过滤器参照知乎[@YoungChen][<a href="https://zhuanlan.zhihu.com/p/43263751]%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E8%AE%B2%E5%BE%97%E9%9D%9E%E5%B8%B8%E6%B8%85%E6%A5%9A">https://zhuanlan.zhihu.com/p/43263751]的文章，讲得非常清楚</a></p></blockquote><p>布隆过滤器（Bloom Filter）本质是其实是一种概率型数据结构。它可以高效的查询和插入，但是不能删除。可以<strong>用来判断某个数一定不存在或者可能存在</strong>。</p><p>跟传统的list、set、map相比，因为布隆过滤器本质存的是二进制比特位，且不存key，所以它占用的空间更小。跟HashMap相比，HashMap可以根据特定的key查询到对应的value值，并且判断key是否存在的时间复杂度也很低O(1)。但是，HashMap既需要存key，还需要存value值，存储容量比较高，并且考虑到HashMap的负载因子，HashMap一般情况下会有空间的浪费的。数据一旦过高，用HashMap占用的空间可就太高的。</p><p>布隆过滤器的虽然占用的空间小，但是它不确定的判断某个key一定存在，只能说概率。</p><ul><li>实现原理</li></ul><p>布隆过滤器就是一个bit向量或者说bit数组。</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122091819486.png" alt="image-20211122091819486"></p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122091912029.png" alt="image-20211122091912029"></p><p>我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122092135911.png" alt="image-20211122092135911"></p><p>4这个bit位被“baidu”和“tencent”两都置1，因为4这个bit位是被覆盖了的。那么我们现在想查询一个值是否存在，假设这个值通过哈希函数映射到了1，5，7三个bit位上。发现5这个bit位上的值是0，那么就说明这个值一定是不存在的。如果它存在，则它的映射到的所有bit位都必须为1。</p><p>现在我们要查询”baidu”是否存在。通过哈希函数我们得到三个bit位1,4,7。我们发现这三个bit上全都是1，尽管如此，我们仍然不能说”baidu”这个值必然是存在的，因为不要忘记了4这个bit位，”tencent”也存为1过。那么或许有个数，它根本就没进来存过，却意外的被其他的key一起把这个数的bit位全置为1了，所以布隆过滤器不能认定一个key一定存在。</p><ul><li>哈希函数的个数选择和布隆过滤器的长度选择</li></ul><p>如果哈希函数的个数选择太少了，bit位的覆盖率就会变高，误报率就会变高。</p><p>如果哈希函数的个数选择太多了，每个bit位置1的速度就会加快，并且每次的哈希函数计算就是一个消耗资源的行为，布隆过滤器的效率就会降低。</p><p>如果布隆过滤器的长度设置太小了，那么每个bit位置1的速度也会加快，误报率同样会增加。</p><p>如果布隆过滤器的长度设置太大了，那么就意味着更多的空间。</p><p>对于哈希函数的个数和布隆过滤器的长度选择有一个公式：</p><p>m：布隆过滤器的长度    k：哈希函数的个数    n：插入元素的个数    p：误报率</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122093555700.png" alt="image-20211122093555700"></p><h2 id="Redis缓存穿透的布隆过滤器的解决方案"><a href="#Redis缓存穿透的布隆过滤器的解决方案" class="headerlink" title="Redis缓存穿透的布隆过滤器的解决方案"></a>Redis缓存穿透的布隆过滤器的解决方案</h2><p>根据上述布隆过滤器的描述，那么我们可以很好的将Redis的缓存穿透和布隆过滤器联系起来。</p><p>一个请求先去Redis缓存中去请求数据，缓存中并不存在，接着我们让这个请求进入布隆过滤器，去判断这个值是否存在，如果存在则再让这个请求进入到数据库中去查询。</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122095540985.png" alt="image-20211122095540985"></p><p>布隆过滤器的特性就是占用的空间相对较小，并且查询速度相比数据库也比较快，能支撑的QPS更高，可以很好的保护数据库。</p><p>分布式环境下，数据放到内存中来处理， 属于local cache 问题；如果想要保持一致性，可以通过数据变更时，群发MQ消息的方式让应用服务器实例更新。这个方案在数据变更频次很低而访接口QPS极高时，可以尝试。否则，当有实例 bloom filter数据未更新时， 在未更新这个间隔内，用户请求路由到不同实例，就会出现一下能查到，一下查不到奇怪现象。 如果数据变更频次很低时，也可以考虑把bloom fliter 数据写到配置中心里，让配置中心把数据推送到应用实例上。</p><h2 id="两种解决方案的对比"><a href="#两种解决方案的对比" class="headerlink" title="两种解决方案的对比"></a>两种解决方案的对比</h2><table><thead><tr><th>解决缓存穿透</th><th>适用场景</th><th>维护成本</th></tr></thead><tbody><tr><td>缓存空对象</td><td>数据命中不高<br />数据变更频次高</td><td>代码维护简单<br />需要过多的缓存空间来存key和null值<br />数据不一致</td></tr><tr><td>布隆过滤器</td><td>数据命中不高<br />数据变更频次低</td><td>代码维护复杂<br />缓存空间占用少</td></tr></tbody></table><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿是指一个热点key，并发量特别的大，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就击穿缓存，直接请求走数据库。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>设置热点数据过期时间</p><p>让过期时间更加均匀一点或者永不过期，这样就解决了热点key过期后的问题。当然这也会带来一些空间的问题。</p></li><li><p>加互斥锁</p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此需要等待。这种方式将高并发的压力转到分布式锁上，因此对分布式锁的考验很大。这样就会导致高并发场景下的性能降低。</p></li></ul><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是指：缓存不可用Redis宕机或者说大批缓存集体失效，大量的请求同时达到数据库，造成数据库系统雪崩。</p><p>产生雪崩的原因之一，比如马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="/../../img/markdown_img/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%B8%8E%E9%9B%AA%E5%B4%A9.assets/image-20211122100233282.png" alt="image-20211122100233282"></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>针对缓存不可用这种情况可以提高缓存层的可用性，比如设计成分布式，Redis集群，配置哨兵模式和cluster实现。</li><li>服务降级（限流降级）：关闭一些服务，保证主要的服务可用。</li><li>数据预热：在正式部署之前，先把可能的数据先预访问一遍，这样部分可能大量访问的数据就会加载到缓存中，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 持久化及优化方式</title>
      <link href="/2021/12/17/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/12/17/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>因为Redis是内存数据库，一旦宕机，数据就会丢失，所以需要一种持久化的操作，将内存中的数据写到磁盘上保存。Redis本身提供了两种数据持久化方式：RDB和AOF。这两种方式各有其优点和缺点。</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>Redis默认的持久化方案就是RDB。RDB就是把数据以快照的形式保存到磁盘上。快照就类似于VMware上虚拟机快照的意思，把当前时刻状态记录下来。</p><p>RDB持久化是指在指定的时间间隔内，将内存中的数据集快照写入磁盘中。这样方式是将内存中的数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。</p><h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>save命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB持久化完成。这样对于内存比较大的服务器，会造成较长时间的阻塞，所以不太建议使用。</p><p>具体流程如下：</p><p><img src="/../../img/markdown_img/Redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211121091823127.png" alt="image-20211121091823127"></p><p>执行完成后如果存在旧的RDB文件，就会把旧的RDB文件替换成新的RDB文件。客户端数据太大的时候，这种方式显然不可取。</p><h3 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h3><p>bgsave命令Redis会在后台异步进行快照操作，同时Redis还可以响应客户端的请求。</p><p>具体操作是Redis主进程会执行fork操作创建一个子进程，然后RDB持久化过程由子进程负责，完成后自动结束。这样，尽管也会阻塞，但是阻塞只发生在fork阶段，基本上Redis内部所有的RDB操作都是bgsave命令。</p><p>具体流程如下：</p><p><img src="/../../img/markdown_img/Redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20211121092857471.png" alt="image-20211121092857471"></p><h3 id="配置文件自动触发"><a href="#配置文件自动触发" class="headerlink" title="配置文件自动触发"></a>配置文件自动触发</h3><p>自动触发模式是需要我们在配置文件redis.conf中完成的。</p><p>配置save，这里的save 3600 1的意思是：如果3600秒内，至少有1个key值变化，就进行持久化。</p><p>在redis.conf配置文件中有配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># You can set these explicitly by uncommenting the three following lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># save 3600 1</span></span><br><span class="line"><span class="comment"># save 300 100</span></span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes<span class="comment"># 默认yes 当启用RDB且最后一次bgsave失败了，Redis是否停止接收数据</span></span><br><span class="line">rdbcompression yes<span class="comment"># 默认yes，存到磁盘的快照，可以设置是否进行压缩存储</span></span><br><span class="line">rdbchecksum yes<span class="comment"># 默认yes，存储快照后让redis进行数据校验，这样做会增加大约10%性能消耗</span></span><br><span class="line">dbfilename dump.rdb<span class="comment"># 快照文件名</span></span><br><span class="line">dir ./<span class="comment"># 快照文件存放路径</span></span><br></pre></td></tr></table></figure><h3 id="save与bgsave的比较"><a href="#save与bgsave的比较" class="headerlink" title="save与bgsave的比较"></a>save与bgsave的比较</h3><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞</td><td>是</td><td>是（仅在fork期间阻塞）</td></tr><tr><td>复杂度</td><td>O（n）</td><td>O（n）</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>fork，消耗额外内存</td></tr></tbody></table><p>除了上述三种方式，以下情况也会生成RDB文件：</p><ul><li>主从的全量复制时，主机会生成RDB文件。</li><li>Redis中的debug reload提供debug级别的重启，不清空内存的一种重启，这种方式也会触发RDB文件的生成。</li><li>执行shutdown时，会触发RDB文件的生成。</li><li>执行flushall命令，也会生成dump.rdb文件，但此时里面是空的。</li></ul><h2 id="RDB的优点和缺点"><a href="#RDB的优点和缺点" class="headerlink" title="RDB的优点和缺点"></a>RDB的优点和缺点</h2><p>优点</p><ul><li>RDB文件是全量备份，适合用于进行备份和数据恢复</li><li>生成RDB文件的时候，Redis主进程会fork( )一个子进程来处理所有保存的工作，主进程不需要进行任何磁盘IO操作</li><li>RDB在加载RDB恢复数据比AOF方式快</li></ul><p>缺点</p><ul><li>RDB是全量备份比较耗时，存储的是内存数据的二进制序列化形式，存储上非常紧凑。写RDB文件还是会消耗大量IO性能。</li><li>当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有主进程的内存数据，父进程如果在此时进行数据的修改，子进程并不知情，所有在持久化期间修改的数据不会被保存，如果此时宕机，就有可能丢失数据。即并不支持数据持久化的实时性。</li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>RDB的全量备份有些耗时，所以提出了另外一种持久化方式AOF。此外，AOF还可以解决数据持久化的实时性。</p><p>默认关闭AOF模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><h2 id="持久化原理"><a href="#持久化原理" class="headerlink" title="持久化原理"></a>持久化原理</h2><p>AOF的持久化方式工作机制很简单，Redis将收到的每一个写命令都通过write函数追加到aof文件中。</p><p>随着aof文件越来越大，需要定期对aof文件进行重写，达到压缩的目的。</p><h2 id="文件重写原理"><a href="#文件重写原理" class="headerlink" title="文件重写原理"></a>文件重写原理</h2><ol><li><p>AOF的方式每次写命令都追加到aof文件中，这样aof文件会变得越来越大。为了压缩aof的持久化文件，Redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时fork出一条新进程来将文件重写。</p></li><li><p>重写后的aof文件为什么可以变小</p><p>a). 进程内已经超时的数据不再写入文件。</p><p>b). 旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a111、set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</p><p>c). 多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢 出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。</p></li></ol><p>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据内容用命令的方式重写一个新的aof文件。</p><p>重写后的aof文件更小，可以被Redis更快的加载。</p><h3 id="触发方式-1"><a href="#触发方式-1" class="headerlink" title="触发方式"></a>触发方式</h3><h4 id="bgrewriteaof"><a href="#bgrewriteaof" class="headerlink" title="bgrewriteaof"></a>bgrewriteaof</h4><p>通过Redis的命令bgrewriteaof手动触发</p><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p><p>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。</p><p>auto-aof-rewrite-percentage：代表当前AOF文件空间 （aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb<span class="comment"># 表示运行AOF重写时文件最小体积，默认为64MB。</span></span><br></pre></td></tr></table></figure><p>自动触发时机 = aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（aof_current_size - aof_base_size）/ aof_base_size&gt;=auto-aof-rewritepercentage</p><p>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</p><h2 id="触发方式-2"><a href="#触发方式-2" class="headerlink" title="触发方式"></a>触发方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If unsure, use &quot;everysec&quot;.</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure><ul><li><p>always Redis的每条写命令都写入到系统aof_buffer缓冲区，然后fsync同步到磁盘。每次发送数据变更会被立即记录到磁盘，<strong>性能较差，IO开销比较大</strong>。但是数据完整性比较好。</p></li><li><p>everysec 过程与always相同，每秒记录一次，如果一秒内宕机，则会有数据丢失。</p></li><li><p>no 从不记录。</p></li></ul><h2 id="AOF的优点和缺点"><a href="#AOF的优点和缺点" class="headerlink" title="AOF的优点和缺点"></a>AOF的优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>AOF可以更好的保存数据不丢失，一般AOF每隔一秒，通过一个后台线程执行一次fsync操作，最多丢失1s的数据。</li><li>AOF日志文件过大的时候，出现后台重写操作，不会影响客户端的读写。</li><li>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如如果不小心flushall清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令删除，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</li><li>AOF开启后，支持的写QPS（每秒查询率）会比RDB支持的写QPS低，因为AOP一般会配置成每秒fsync一次日志文件，每秒一次fsync，性能也还是很高的</li></ul><h1 id="RDB和AOF比较"><a href="#RDB和AOF比较" class="headerlink" title="RDB和AOF比较"></a>RDB和AOF比较</h1><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>没有实时持久化</td><td>根据策略不同决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table><h1 id="Redis启动数据加载的流程"><a href="#Redis启动数据加载的流程" class="headerlink" title="Redis启动数据加载的流程"></a>Redis启动数据加载的流程</h1><ol><li>AOF持久化开启并且存在AOF文件，优先加载AOF文件。</li><li>AOF持久化关闭或者AOF文件不存在，加载RDB文件。</li><li>AOF/RDB加载成功后，Redis启动成功。</li><li>AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</li></ol><h1 id="Redis持久化的优化方式"><a href="#Redis持久化的优化方式" class="headerlink" title="Redis持久化的优化方式"></a>Redis持久化的优化方式</h1><p>可以看到不管是RDB的快照，还是AOP的重写，都需要fork一个进程，这会对Redis造成阻塞。因此为了不影响Redis主进程的响应，我们需要尽可能的降低阻塞。即是<strong>减少fork操作的阻塞。</strong></p><ol><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例的最大可用内存maxmemory，fork耗时跟内存量成正比。</li><li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败。vm.overcommit_memory=1。默认值为0，会使Linux在内存分配时，发现不够内存不足时，不会进行分配，进而造成fork阻塞。</li><li>降低fork频率。放宽AOF自动触发时机，避免不必要的全量复制。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity+Jwt整合</title>
      <link href="/2021/12/17/SpringSecurity/SpringSecurity+Jwt%E6%95%B4%E5%90%88/"/>
      <url>/2021/12/17/SpringSecurity/SpringSecurity+Jwt%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="常见的认证机制"><a href="#常见的认证机制" class="headerlink" title="常见的认证机制"></a>常见的认证机制</h3><h4 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h4><p>　HTTP Basic Auth简单点说就是每次请求API时都提供用户的username和password。简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth。</p><h4 id="Cookie-Auth"><a href="#Cookie-Auth" class="headerlink" title="Cookie Auth"></a>Cookie Auth</h4><p>​    Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。     </p><p><img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image64.png"></p><h4 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h4><p>　OAuth（开放授权,Open Authorization）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。如网站通过微信、微博登录等，主要用于第三方登录。</p><p>　OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。</p><p>下面是OAuth2.0的流程：</p><p> <img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image65.png"></p><p>　这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。</p><p>缺点：过重。</p><h4 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h4><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li><p>客户端使用用户名跟密码请求登录</p></li><li><p>服务端收到请求，去验证用户名与密码</p></li><li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p></li><li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里</p></li><li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p></li><li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p></li></ol><p> <img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image66.png"></p><p>比第一种方式更安全，比第二种方式更节约服务器资源，比第三种方式更加轻量。</p><p>具体，Token Auth的优点（Token机制相对于Cookie机制又有什么好处呢？）：</p><ol><li><p>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</p></li><li><p>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</p></li><li><p>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</p></li><li><p>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</p></li><li><p>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 10等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p></li><li><p>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</p></li><li><p>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多.</p></li><li><p>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</p></li><li><p>基于标准化：你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</p></li></ol><h2 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h2><h4 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h4><p>　JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。</p><p>官网：  <a href="https://jwt.io/">https://jwt.io/</a></p><p>标准：  <a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a></p><p>JWT令牌的优点：</p><ol><li><p>jwt基于json，非常方便解析。</p></li><li><p>可以在令牌中自定义丰富的内容，易扩展。</p></li><li><p>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</p></li><li><p>资源服务使用JWT可不依赖认证服务即可完成授权。</p></li></ol><p>缺点：</p><ol><li>JWT令牌较长，占存储空间比较大。</li></ol><h4 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h4><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p><h5 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h5><p>头部用于描述关于该JWT的最基本的信息，例如其类型（即JWT）以及签名所用的算法（如HMAC SHA256或RSA）等。这也可以被表示成一个JSON对象。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>typ</code>：是类型。</p></li><li><p><code>alg</code>：签名的算法，这里使用的算法是HS256算法</p></li></ul><p>我们对头部的json字符串进行BASE64编码（网上有很多在线编码的网站），编码后的字符串如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  </span><br></pre></td></tr></table></figure><p>　<code>Base64</code>是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。JDK 中提供了非常方便的 <code>BASE64Encoder </code>和 <code>BASE64Decoder</code>，用它们可以非常方便的完成基于 BASE64 的编码和解码。</p><h5 id="负载-Payload"><a href="#负载-Payload" class="headerlink" title="负载(Payload)"></a>负载(Payload)</h5><p>第二部分是负载，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：</p><ul><li>标准中注册的声明（建议但不强制使用）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iss: jwt签发者</span><br><span class="line">sub: jwt所面向的用户</span><br><span class="line">aud: 接收jwt的一方</span><br><span class="line">exp: jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">nbf: 定义在什么时间之前，该jwt都是不可用的.</span><br><span class="line">iat: jwt的签发时间</span><br><span class="line">jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</span><br></pre></td></tr></table></figure><ul><li>公共的声明</li></ul><p>　公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><ul><li>私有的声明</li></ul><p>　私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>　这个指的就是自定义的claim。比如下面那个举例中的name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>sub</code>是标准的声明，<code>name</code>是自定义的声明（公共的或私有的）</p><p>然后将其进行base64编码，得到Jwt的第二部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbWVzIiwiYWRtaW4iOnRydWV9  </span><br></pre></td></tr></table></figure><p>提示：声明中不要放一些敏感信息。</p><h5 id="签证、签名（signature）"><a href="#签证、签名（signature）" class="headerlink" title="签证、签名（signature）"></a>签证、签名（signature）</h5><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ol><li><p>header (base64后的)</p></li><li><p>payload (base64后的)</p></li><li><p>secret（盐，一定要保密）</p></li></ol><p>　这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI</span><br></pre></td></tr></table></figure><p>将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR9cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.8HI-Lod0ncfVDnbKIPJJqLH998duF9DSDGkx3gRPNVI  </span><br></pre></td></tr></table></figure><p>注意：<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以自我签发<code>jwt</code>了。</p><h3 id="JJWT简介"><a href="#JJWT简介" class="headerlink" title="JJWT简介"></a>JJWT简介</h3><h4 id="什么是JJWT"><a href="#什么是JJWT" class="headerlink" title="什么是JJWT"></a>什么是JJWT</h4><p>　JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。</p><p>规范官网：<a href="https://jwt.io/">https://jwt.io/</a></p><h2 id="SpringSecurity整合JWT"><a href="#SpringSecurity整合JWT" class="headerlink" title="SpringSecurity整合JWT"></a>SpringSecurity整合JWT</h2><p>SpringSecurity整合JWT最终达到的效果：</p><p>当用户首次登录的时候，输入用户名和密码走正常的登录逻辑，到数据库中根据用户名找到用户的密码信息，然后比对密码是否匹配。若匹配，先将这个用户存入Security的安全上下文holder中，然后利用<strong>JWT工具类</strong>生成一个token，返回给客户端。</p><p>接下来，用户每次请求，都需要在请求头header中携带一个token，这个token首先会进入我们<strong>自定义的Jwt登录认证过滤器</strong>，从请求头中获取token，利用<strong>Jwt工具类</strong>解析token，如果能获取到用户名，则用户认证成功，执行下一个过滤器。否则用<strong>自定义的拒绝访问类</strong>返回权限不足，或者直接用<strong>自定义的认证失败类</strong>返回token失效或者请先登录。</p><h3 id="Application-properties配置"><a href="#Application-properties配置" class="headerlink" title="Application.properties配置"></a>Application.properties配置</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">springsecurityforjwt</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="comment"># Jwt盐</span></span><br><span class="line"><span class="meta">jwt.secret</span>=<span class="string">******</span></span><br><span class="line"><span class="comment"># 请求头的key value为token</span></span><br><span class="line"><span class="meta">jwt.tokenHeader</span>=<span class="string">Authorization</span></span><br><span class="line"><span class="comment"># 过期时间7天</span></span><br><span class="line"><span class="meta">jwt.expiration</span>=<span class="string">604800</span></span><br><span class="line"><span class="comment"># token的头部</span></span><br><span class="line"><span class="meta">jwt.tokenHead</span>=<span class="string">Bearer</span></span><br><span class="line"><span class="comment"># 配置freemarker视图的位置</span></span><br><span class="line"><span class="meta">spring.freemarker.template-loader-path</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="comment"># 配置freemarker后缀</span></span><br><span class="line"><span class="meta">spring.freemarker.suffix</span>=<span class="string">.ftl</span></span><br><span class="line"><span class="meta">spring.freemarker.charset</span>=<span class="string">utf-8</span></span><br></pre></td></tr></table></figure><h3 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zc.springsecurityforjwt.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_USERNAME=<span class="string">&quot;sub&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLAIM_KEY_CREATED=<span class="string">&quot;created&quot;</span>;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHead;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expiration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTokenHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tokenHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expiration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims claims</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateToken</span><span class="params">(Map&lt;String,Object&gt; claims)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户信息生成token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从token中获取负载</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> claims</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Claims <span class="title">getClaimsFromToken</span><span class="params">(String token)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Claims claims = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secret)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;JWT格式验证失败:&#123;&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从token中获取登录用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsernameFromToken</span><span class="params">(String token)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String username;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            username = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> expiration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">generateExpirationDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(System.currentTimeMillis()+expiration*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证token是否还有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     *客户端传入的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDetails 从数据库中查询出来的用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateToken</span><span class="params">(String token, UserDetails userDetails)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String username = getUsernameFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断token是否已经失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTokenExpired</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date expiredDate = getExpiredDateFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> expiredDate.before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从token中获取过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getExpiredDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClaimsFromToken(token).getExpiration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当原来的token没过期时是可以刷新的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldToken 带tokenHead的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">refreshHeadToken</span><span class="params">(String oldToken)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(oldToken))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = oldToken.substring(tokenHead.length());</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//token校验不通过</span></span><br><span class="line">        Claims claims = getClaimsFromToken(token);</span><br><span class="line">        <span class="keyword">if</span>(claims==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果token已经过期，不支持刷新</span></span><br><span class="line">        <span class="keyword">if</span>(isTokenExpired(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            claims.put(CLAIM_KEY_CREATED, <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">return</span> generateToken(claims);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jwt登录认证过滤器JwtAuthenticationFilter"><a href="#Jwt登录认证过滤器JwtAuthenticationFilter" class="headerlink" title="Jwt登录认证过滤器JwtAuthenticationFilter"></a>Jwt登录认证过滤器JwtAuthenticationFilter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHead;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String authHeader=request.getHeader(tokenHeader);</span><br><span class="line">        System.out.println(authHeader);</span><br><span class="line">        <span class="comment">//存在token</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>!=authHeader&amp;&amp;authHeader.startsWith(tokenHead))</span><br><span class="line">        &#123;</span><br><span class="line">            String authToken=authHeader.substring(tokenHead.length());</span><br><span class="line">            System.out.println(authToken);</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(authToken);</span><br><span class="line">            System.out.println(<span class="string">&quot;token中解析到的用户名为：&quot;</span>+username);</span><br><span class="line">            <span class="comment">//token存在但是未登录</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span>!=username&amp;&amp;<span class="keyword">null</span>==SecurityContextHolder.getContext().getAuthentication())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//登录</span></span><br><span class="line">                User user = userService.findUserByUsername(username);</span><br><span class="line">                System.out.println(user);</span><br><span class="line">                <span class="comment">//判断token是否有效</span></span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken,user))</span><br><span class="line">                &#123;</span><br><span class="line">                    UsernamePasswordAuthenticationToken authenticationToken=</span><br><span class="line">                            <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    authenticationToken.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝方法异常RestfulAccessDeniedHandler"><a href="#拒绝方法异常RestfulAccessDeniedHandler" class="headerlink" title="拒绝方法异常RestfulAccessDeniedHandler"></a>拒绝方法异常RestfulAccessDeniedHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean error = RespBean.error(<span class="string">&quot;权限不足，联系管理员!&quot;</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));</span><br><span class="line">        error.setCode(<span class="number">403</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="认证失败异常RestfulAuthorizationEntryPoint"><a href="#认证失败异常RestfulAuthorizationEntryPoint" class="headerlink" title="认证失败异常RestfulAuthorizationEntryPoint"></a>认证失败异常RestfulAuthorizationEntryPoint</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当未登录或者token失效时访问接口自定义的返回结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAuthorizationEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean bean = RespBean.error(<span class="string">&quot;请先登录!&quot;</span>);</span><br><span class="line">        bean.setCode(<span class="number">401</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(bean));</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringSecurity安全配置类"><a href="#SpringSecurity安全配置类" class="headerlink" title="SpringSecurity安全配置类"></a>SpringSecurity安全配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationFilter jwtAuthenticationFilter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestfulAccessDeniedHandler restfulAccessDeniedHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestfulAuthorizationEntryPoint restfulAuthorizationEntryPoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/toLogin&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/static/**&quot;</span>,<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/static/**&quot;</span>,<span class="string">&quot;wabjars/**&quot;</span>,<span class="string">&quot;swagger-resources/**&quot;</span>,<span class="string">&quot;/v2/api-doc/**&quot;</span>).permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//开启跨域访问</span></span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//使用jwt，禁用csrf保护</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//关闭session存储</span></span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .headers().cacheControl();</span><br><span class="line">            <span class="comment">//配置自定义过滤器 添加jwt登录授权过滤器</span></span><br><span class="line">            <span class="comment">//在过滤器UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line">            http.addFilterBefore(jwtAuthenticationFilter,UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">            <span class="comment">//添加自定义未授权未登录结果返回</span></span><br><span class="line">            http.exceptionHandling()</span><br><span class="line">                    .accessDeniedHandler(restfulAccessDeniedHandler)</span><br><span class="line">                    .authenticationEntryPoint(restfulAuthorizationEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtTokenUtil <span class="title">tokenUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenUtil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">login</span><span class="params">(User user, HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.login(user,request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserInfo</span><span class="params">(Principal principal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==principal)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String username = principal.getName();</span><br><span class="line">        User user = userService.findUserByUsername(username);</span><br><span class="line">        user.setPassword(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service实现类"><a href="#Service实现类" class="headerlink" title="Service实现类"></a>Service实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserByUsername&quot;</span>);</span><br><span class="line">        User user = userMapper.findUserByUsername(username);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">login</span><span class="params">(User user, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//登录</span></span><br><span class="line">        User userDetails = userMapper.findUserByUsername(user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">&quot;登录用户为：&quot;</span>+user);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==userDetails||passwordEncoder.matches(user.getPassword(),userDetails.getPassword()))</span><br><span class="line">            <span class="keyword">return</span> RespBean.error(<span class="string">&quot;用户名或者密码不正确&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!userDetails.isEnabled())</span><br><span class="line">            <span class="keyword">return</span> RespBean.error(<span class="string">&quot;账户被禁止使用，请联系管理员&quot;</span>);</span><br><span class="line">        <span class="comment">//更新security登录用户对象</span></span><br><span class="line">        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken=</span><br><span class="line">                <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails,<span class="keyword">null</span>,userDetails.getAuthorities());</span><br><span class="line">        String token=jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">        map.put(<span class="string">&quot;tokenHead&quot;</span>,jwtTokenUtil.getTokenHead());</span><br><span class="line">        <span class="keyword">return</span> RespBean.success(<span class="string">&quot;登录成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Postman测试"><a href="#Postman测试" class="headerlink" title="Postman测试"></a>Postman测试</h3><p>用户首次进行访问登录接口，携带username和password以post方式进行提交。服务器端返回一个token。</p><p>因为后端采用的PostMapping所以注意提交方式。</p><p><img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image-20211202195719521.png" alt="image-20211202195719521"></p><p>用户访问后端其他接口，需要在请求头中加上token。</p><p>因为后端采用的GetMapping所以注意提交方式。</p><p><img src="/../../img/markdown_img/SpringSecurity+Jwt%E6%95%B4%E5%90%88.assets/image-20211202200021002.png" alt="image-20211202200021002"></p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 主从哨兵脑裂</title>
      <link href="/2021/12/16/redis/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/16/redis/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><p>读和写以及备份操作都是在一台Redis服务器上进行的，那么随着项目访问量的增加，对Redis服务器的操作也越加频繁，虽然Redis读写速度都很快，但是一定程度上也会造成一定的延时，那么为了解决访问量大的问题（大概有80%的请求都是读请求），通常会采取的一种方式是主从架构Master/Slave，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机Slave 节点。</p><p>主从复制之后，<strong>主服务器用来处理写请求，而从服务器只能用于读，不能写</strong>。最简单一主二从的方式，也可以采用一主多从的或者级联结构，Redis主从复制又可以分为全量复制和增量复制。</p><p>主从复制一主多从：</p><ul><li><p>这样的问题就是，如果Master服务器宕机了，那么两个从服务器便没有了主人一样，这时候我们只能去重新启动master，或者说在剩下的从服务器中选一个作为主服务器，然后进行将剩下的从服务器手动的连接到新master，这样就显得并不智能。显然，这非常的麻烦，大型的项目从服务器可能会有很多。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121200823820.png" alt="image-20211121200823820"></p></li></ul><p>主从复制链路形式：</p><ul><li>这种模式也有上述的问题，Master6379宕机之后，Slave6380并不会摇身一变成为matser，它仍然是一个salve。</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121194755383.png" alt="image-20211121194755383"></p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。</p><ul><li>从服务器连接主服务器，发送sync命令；</li><li>主服务器接收到sync命令，开始执行bgsave命令生成rdb文件，并使用缓冲区记录此后执行的所有写命令</li><li>主服务器bgsave命令执行完成后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照</li><li>主服务器快照发送完毕后开始向服务器发送缓冲区中的写命令</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令</li></ul><p>至此，从服务器数据初始化的所有操作完成，从服务器此时可以接收来自用户的读请求，但是不能写。</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>Redis<strong>增量复制</strong>是指<strong>Slave初始化后开始正常工作时，主服务器发生的写操作同步到从服务器的过程。</strong></p><p>增量复制的过程主要是<strong>主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行写命令</strong>。</p><h1 id="主从复制模拟"><a href="#主从复制模拟" class="headerlink" title="主从复制模拟"></a>主从复制模拟</h1><p>这里用3个不同的端口，生成3个redis服务器，并且准备用6379端口设置为主机，6380和6381设置为从机。</p><p>主从复制，配置从节点不配置主节点</p><h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><ol><li>拷贝redis.conf文件</li></ol><p>这里拷贝3份配置文件redis.conf，1一个主，2个从</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121190849226.png" alt="image-20211121190849226"></p><ol start="2"><li><p>修改配置文件</p><ul><li>redis.conf中的端口号</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185306902.png" alt="image-20211121185306902"></p><ul><li>daemonize 设置为yes</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185315718.png" alt="image-20211121185315718"></p><ul><li>进程id pid</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185322334.png" alt="image-20211121185322334"></p><ul><li>日志</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185331341.png" alt="image-20211121185331341"></p><ul><li>dump.rdb</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185345459.png" alt="image-20211121185345459"></p><ul><li>如果redis设置了密码，那么需要在从机上设置主机的密码</li></ul><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121185439977.png" alt="image-20211121185439977"></p></li><li><p>分别启动三个端口的redis-server和redis-cli</p></li><li><p>将端口6380、6381设置为6379的从机</p><ul><li><p><code>slave ip port</code>设置为Ip+port主机的从机</p></li><li><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191420316.png"></p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191440436-16374932859391.png" alt="image-20211121191440436"></p></li><li><p><code>info replication</code>查看当6380和6381服务器的状态</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191544255.png" alt="image-20211121191544255"></p></li><li><p>6379主机查看服务器状态</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121191650650.png" alt="image-20211121191650650"></p></li></ul></li></ol><p>我们上述的配置是通过命令配置的，如果在配置文件中进行配置，那么则是永久的配置。</p><p>配置文件中进行的配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置主服务器IP 端口</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment"># redis设置了密码的话 还需要配置主服务器的密码</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure><p>这种命令配置的主从，当主机关闭后，重启，它仍然会是两个从机的主机，从机依旧可以直接获取到主机写的信息！如果我们将主机关闭后，让从机比如6380成为。但是，当从机关闭，重启，这个从机就不再是之前它master的slave了，现在重启后，它自己就是一个master，跟之前的master就没关系了。</p><p>如果Master宕机了，如果要让slave中的一个成为master，在哨兵模式没有设置的情况下，执行命令<code>slaveof no one</code>，那么这个结点就成为了master，然后其他的slave就可以再手动连接到新手动设置的master了。</p><h3 id="链路形式"><a href="#链路形式" class="headerlink" title="链路形式"></a>链路形式</h3><p>这里将6379作为master，然后6380连接到6381上。</p><p>现在将6379master断掉，然后在6381上info replication，发现它并不会成为master。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121195727429.png" alt="image-20211121195727429"></p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121195757090.png" alt="image-20211121195757090"></p><p>主从模式没办法对master进行自动的更新。因此引入了哨兵模式Sentinel。</p><p>从master到slave的复制是异步的，所以可能有部分数据还没复制到slave，master宕机，由此数据就部分丢失了，这就是<strong>Redis异步复制导致的数据丢失问题。</strong></p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>上面的模式，如果Master宕机了那么就类似群龙无首一样，多个slave中没有一个站出来自动充当master，如果我们手动选择就太繁琐了，引入的哨兵模式就可以解决这种问题。</p><h3 id="哨兵模式的作用"><a href="#哨兵模式的作用" class="headerlink" title="哨兵模式的作用"></a>哨兵模式的作用</h3><ol><li><strong>监控(Monitoring):</strong> 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</li><li><strong>提醒(Notification):</strong> 当被监控的某个Redis节点出现问题时， 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>主节点故障转移(Automatic failover)<strong>：当</strong>一个Master不能正常工作</strong>时，哨兵(sentinel) 会开始<strong>一次自动故障迁移操作</strong>。从节点晋升到主节点并维护后续正确的主从关系；</li></ol><h3 id="哨兵进程的工作方式"><a href="#哨兵进程的工作方式" class="headerlink" title="哨兵进程的工作方式"></a>哨兵进程的工作方式</h3><p>Sentinel（哨兵）是Redis的高可用性解决方案：由一个或者多个哨兵实例组成的哨兵系统来监视多个服务器的运行状态。</p><p>当一个master主服务器宕机的时候，如果有一个哨兵检测到这个主机处于下线状态，这时候这个主机被认为是<strong>主观下线</strong>（SDOWN），然后当一定数量的哨兵都检测到这个主服务器下线时，这个主机被认为<strong>客观下线</strong>（ODOWN），并在确定主服务器进入<strong>客观下线</strong>的状态之后，哨兵自动投票选举从服务器中的一个成为主服务器，剩下的所有从服务器都会自动的连接到这个新选取出来的主服务器。</p><ol><li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。</li><li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态。</li><li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）。</li><li>在一般情况下， 每个Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li><li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li></ol><h3 id="哨兵模式模拟"><a href="#哨兵模式模拟" class="headerlink" title="哨兵模式模拟"></a>哨兵模式模拟</h3><h4 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h4><p>新建一个哨兵模式配置文件<code>sentinel.conf</code>，这里设置同意主节点真的挂掉的哨兵数量为1。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 同意主节点真的挂掉的哨兵数量</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6381 1</span><br></pre></td></tr></table></figure><h4 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h4><p><code>redis-sentinel sentinel.conf</code>启动哨兵</p><p>第一次启动哨兵：Next failover delay: I will not start a failover before Sun Nov 21 20:50:55 2021</p><p>这是因为在redis主从服务器中设置了密码，但是哨兵配置文件中并没有配置密码，所有没有成功启动哨兵模式。</p><p>重新配置如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 同意主节点真的挂掉的哨兵数量</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6381 1</span><br><span class="line">sentinel auth-pass myredis password <span class="comment"># 密码配置</span></span><br></pre></td></tr></table></figure><p>重新启动哨兵模式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]<span class="comment"># redis-sentinel myredisconfig/sentinel.conf</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.176 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.176 <span class="comment"># Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=8175, just started</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.176 <span class="comment"># Configuration loaded</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.177 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">8175:X 21 Nov 2021 21:26:49.177 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.6 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 8175</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">          `-._        _.-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span></span><br><span class="line"></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.177 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># Sentinel ID is 16cbd6e88092909d2f92476c149045138facc8f1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># +monitor master myredis 127.0.0.1 6381 quorum 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.180 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:26:49.181 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动成功，可以看到6381端口下有两个slave：</p><p>+slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381；</p><p>+slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381；</p><p>现在我们将主节点6381断掉，验证哨兵模式是否会重新选举主服务器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8175:X 21 Nov 2021 21:26:49.177 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># Sentinel ID is 16cbd6e88092909d2f92476c149045138facc8f1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.179 <span class="comment"># +monitor master myredis 127.0.0.1 6381 quorum 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:26:49.180 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:26:49.181 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +sdown master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +odown master myredis 127.0.0.1 6381 #quorum 1/1</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +new-epoch 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.868 <span class="comment"># +try-failover master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.869 <span class="comment"># +vote-for-leader 16cbd6e88092909d2f92476c149045138facc8f1 1</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.869 <span class="comment"># +elected-leader master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.869 <span class="comment"># +failover-state-select-slave master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.931 <span class="comment"># +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:55.931 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:55.991 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:56.291 <span class="comment"># +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:56.291 <span class="comment"># +failover-state-reconf-slaves master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:56.345 * +slave-reconf-sent slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.273 * +slave-reconf-inprog slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.273 * +slave-reconf-done slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 <span class="comment"># +failover-end master myredis 127.0.0.1 6381</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 <span class="comment"># +switch-master myredis 127.0.0.1 6381 127.0.0.1 6380</span></span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6380</span><br><span class="line">8175:X 21 Nov 2021 21:27:57.329 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6380</span><br><span class="line">8175:X 21 Nov 2021 21:28:27.369 <span class="comment"># +sdown slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6380</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这里+表示进入，-表示退出</span><br><span class="line">+sdown就表示实例进入主观下线状态</span><br><span class="line"></span><br><span class="line">-sdown表示实例退出主观下线状态</span><br><span class="line"></span><br><span class="line">+odown表示实例进入客观下线状态</span><br><span class="line"></span><br><span class="line">-odown表示实例退出客观下线状态</span><br><span class="line"></span><br><span class="line">+swtich-master表示主服务器地址发生变化</span><br></pre></td></tr></table></figure><p>可以看到，确实是重新选举了一个master：+switch-master myredis 127.0.0.1 6381 127.0.0.1 6380；</p><p>现在6380成为了一个master，然后我们去查看6380的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line">Error: Server closed the connection</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment"># 角色从slave变为master</span></span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6379,state=online,offset=5126,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4f3894e2484b0ed7c7cf3ddb62805a4cd865e726</span><br><span class="line">master_replid2:c2a5af21553f6f3996fdfd68742d9a667960d9e5</span><br><span class="line">master_repl_offset:5126</span><br><span class="line">second_repl_offset:2408</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:5126</span><br></pre></td></tr></table></figure><p>可以看到现在6380的角色成为了master。</p><p>查看6379的信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line">Error: Server closed the connection</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6380<span class="comment"># 主节点从6381变为了6380</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:5390</span><br><span class="line">slave_repl_offset:5390</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:4f3894e2484b0ed7c7cf3ddb62805a4cd865e726</span><br><span class="line">master_replid2:c2a5af21553f6f3996fdfd68742d9a667960d9e5</span><br><span class="line">master_repl_offset:5390</span><br><span class="line">second_repl_offset:2408</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:5376</span><br></pre></td></tr></table></figure><h3 id="哨兵配置文件"><a href="#哨兵配置文件" class="headerlink" title="哨兵配置文件"></a>哨兵配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">  sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line"> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h3><p>当只有一个哨兵的时候，如果这个哨兵一不小心崩掉了，那么我们的主从模式就没有哨兵了，就无法完成自动选举主节点的功能了。所以我们可以给哨兵也做一个集群。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211121214930557.png" alt="image-20211121214930557"></p><p>根据端口不同配置多份哨兵的配置文件，然后启动redis-master，redis-slaves，哨兵。</p><h1 id="异步数据丢失"><a href="#异步数据丢失" class="headerlink" title="异步数据丢失"></a>异步数据丢失</h1><p>因为Redis从master到slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，由此数据就部分丢失了，这就是<strong>Redis异步复制导致的数据丢失问题。</strong></p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211123224114132.png" alt="image-20211123224114132"></p><h1 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h1><p>Redis的一个master因为网络的波动，与其他slave失去了连接，但是master实际上还是在正常的运行。哨兵们就认为这个master挂掉了，于是哨兵就会选举出一个新的master。这个时候集群里就有两个master了，这就是<strong>脑裂。</strong></p><p>尽管这个时候某个slave已经被选举成为了master，但是可能客户端client还没来得及从旧的master切换到新的master，仍在继续写数据，就可能造成这仍向旧master写的部分数据丢失。</p><p>然后当原本的master携带数据重新连接回来的时候，哨兵让原master执行slaveof命令，和新master进行全量复制，当从服务器收到master的快照文件后丢弃所有旧数据，原master数据被清空，重新向新master复制数据。</p><p><img src="/../../img/markdown_img/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.assets/image-20211123224138254.png" alt="image-20211123224138254"></p><h1 id="脑裂以及异步数据丢失解决方案"><a href="#脑裂以及异步数据丢失解决方案" class="headerlink" title="脑裂以及异步数据丢失解决方案"></a>脑裂以及异步数据丢失解决方案</h1><p>Redis提供以下配置：</p><ul><li><p>min-slaves-to-write M</p><p>配置了master能进行数据同步的最少slave数量。</p></li><li><p>min-slaves-max-lag N</p><p>配置了master，slave进行数据复制时，slave给master发送ACK消息的最大延迟。</p></li></ul><p>我们可以把min-slaves-to-write和min-slaves-max-lag结合起来使用，分别设置一定阈值。</p><p>比如这里配置后要求：一个master至少要有M个slave，并且slave和master进行数据复制时的ACK消息不能超过N秒，否则，master就不能再接收client的请求。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity过滤器原理</title>
      <link href="/2021/01/23/SpringSecurity/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2021/01/23/SpringSecurity/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringSecurity原理"><a href="#SpringSecurity原理" class="headerlink" title="SpringSecurity原理"></a>SpringSecurity原理</h1><h2 id="主要过滤器链"><a href="#主要过滤器链" class="headerlink" title="主要过滤器链"></a>主要过滤器链</h2><p>SpringSecurity的功能主要是由一系列的过滤器链相互配合完成的。验证一个过滤器之后放行到下一个过滤器链，然后到最后。</p><p><img src="/../../img/markdown_img/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.assets/image-20211202145237010.png" alt="image-20211202145237010"></p><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p><img src="/../../img/markdown_img/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.assets/d359fe34bc7860c11a1b6e50bfd0e086.png" alt="img"></p><h3 id="过滤器作用"><a href="#过滤器作用" class="headerlink" title="过滤器作用"></a>过滤器作用</h3><ol><li><p>SecurityContextPersistenceFilter：会在每次请求处理之前从配置好的SecurityContextRepository中获取SecurityContext安全上下文信息，然后加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓库”中，然后将SecurityContextHolder中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</p></li><li><p>DefaultLoginPageGeneratingFilter：如果没有配置自定义登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p></li><li><p>BasicAuthenticationFilter：检测和处理http basic认证。</p></li><li><p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自/login的表单action。从表单中获取用户名和密码时，默认使用的表单name属性值为username和password，这俩个值也可以通过usernameParameter和passwordParameter在配置中自定义。</p><p>这个过滤器在表单提交登录请求之时会起作用。那么假设现在采用SpringSecurity整合Jwt，那么我需要配置一个Jwt登录认证类（继承BasicAuthenticationFilter或者继承OncePerRequestFilter都可以，因为BasicAuthenticationFilter继承了OncePerRequestFilter），重写过滤器方法。Jwt的token认证登录是需要在<strong>在采用用户名密码登录认证之前</strong>，所以在配置Jwt登录认证类的时候需要在UsernamePasswordAuthenticationFilter之前添加过滤器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置自定义过滤器 添加jwt登录授权过滤器</span></span><br><span class="line"><span class="comment">//在过滤器UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line">http.addFilterBefore(jwtAuthenticationFilter,UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure></li><li><p>RequestCacheAwareFilter：用来处理请求的缓存。</p></li><li><p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。</p></li><li><p>AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在则为其提供一个匿名Authentication。</p></li><li><p>SessionManagementFilter：管理Session的过滤器</p></li><li><p>ExceptionTranslationFilter：捕获来自过滤器链的所有异常，并进行处理。但是只处理两类异常：AccessDeniedException和AuthenticationException 异常，其他的异常会继续抛出。</p><p>如果捕获到的AuthenticationException，那么将会使用其对应的AuthenticationEntryPoint的commence()方法处理。在处理之前，ExceptionTranslationFilter先使用RequestCache将当前的HTTPServletRequest的信息保存起来，方便用户登录成功后可以跳转到之前的页面。</p><p>可以自定义AuthenticationException的处理方法。需要实现AuthenticationEntryPoint接口，然后重写commence()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当未登录或者token失效时访问接口自定义的返回结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAuthorizationEntryPoint</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean bean = RespBean.error(<span class="string">&quot;请先登录!&quot;</span>);</span><br><span class="line">        bean.setCode(<span class="number">401</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(bean));</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果捕获的AuthenticationDeniedException，那么将会根据当前访问的用户是否已经登录认证做不同的处理，如果未登录，则会使用关联的AuthenticationEntryPoint的commence()方法进行处理，否则将使用关联的AccessDeniedHandler的handle()方法进行处理。</p><p>可以进行自定义AuthenticationDeniedException的处理方法。需要实现AccessDeniedHandler接口，然后重写handle()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        RespBean error = RespBean.error(<span class="string">&quot;权限不足，联系管理员!&quot;</span>);</span><br><span class="line">        writer.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));</span><br><span class="line">        error.setCode(<span class="number">403</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FilterSecurityInterceptor：可以看做过滤器链的出口</p></li><li><p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p></li></ol><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>SecurityContext对象是安全上下文信息，包括当前使用系统的用户的信息。每个用户都会有它的安全上下文对象，所以把每一个用户的SecurityContext保存到SecurityContextHolder中。</p><p>SecurityContextHolder存储SecurityContext的方式根据应用场景不同也有区别：</p><p>（1）单机系统，即应用从开启到关闭的整个生命周期只有一个用户在使用。由于整个应用只需要保存一个SecurityContext（安全上下文即可）</p><p>（2）多用户系统，比如典型的Web系统，整个生命周期可能同时有多个用户在使用。这时候应用需要保存多个SecurityContext（安全上下文），需要利用ThreadLocal进行保存，每个线程都可以利用ThreadLocal获取其自己的SecurityContext，及安全上下文。ThreadLocal内部会用数组来存储多个对象的。原理是，ThreadLocal会为每个线程开辟一个存储区域，来存储相应的对象。</p><p>Authentication：用户信息的表示</p><p>在SecurityContextHolder中存储了当前与系统交互的用户的信息。Spring Security使用一个Authentication 对象来表示这些信息。</p><p>Authentication 主要包含了：</p><ul><li>用户权限集合</li><li>用户证书（密码）</li><li>细节（Details）</li><li>Principal（就是这个用户的账户信息）</li></ul><p>在自定义登录认证过滤器的时候，记得需要把用户的信息（Authentication ）保存到SecurityContextHolder中，以便后续用户的正常使用。比如我在做和Jwt认证的整合的时候，继承OncePerRequestFilter，重写doFilterInternal方法，认证完token之后，就需要把用户的信息存入安全上下文Holder中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UsernamePasswordAuthenticationToken authenticationToken</span><br><span class="line">    =<span class="keyword">new</span> UsernamePasswordAuthenticationToken(user,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">authenticationToken.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource()</span><br><span class="line">                               .buildDetails(request));</span><br><span class="line"></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br></pre></td></tr></table></figure><p>关于SecurityContextHolder大概就这样，有一些关于SecurityContextHolder具体的源码的细节可以参考一篇博客：</p><p><a href="https://www.cnblogs.com/longfurcat/p/9417912.html">https://www.cnblogs.com/longfurcat/p/9417912.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
